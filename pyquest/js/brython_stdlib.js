__BRYTHON__.use_VFS = true;
var scripts = {"$timestamp": 1756070177670, "array": [".js", "(function($B){\n\nvar _b_ = $B.builtins\n\nvar typecodes = {\n    'b': Int8Array,    // signed char, 1 byte\n    'B': Uint8Array,   // unsigned char, 1\n    'u': Uint32Array,  // Py_UNICODE Unicode character, 2 (deprecated)\n    'h': Int16Array,   // signed short, 2\n    'H': Uint16Array,  // unsigned short, 2\n    'i': Int16Array,   //  signed int, 2\n    'I': Uint16Array,  // unsigned int, 2\n    'l': Int32Array,   // signed long, 4\n    'L': Uint32Array,  // unsigned long, 4\n    'q': null,         // signed long, 8 (not implemented)\n    'Q': null,         // unsigned long, 8 (not implemented)\n    'f': Float32Array, // float, 4\n    'd': Float64Array  // double float, 8\n}\n\nvar array = $B.make_class(\"array\",\n    function(){\n        var missing = {},\n            $ = $B.args(\"array\", 2, {typecode: null, initializer: null},\n                [\"typecode\", \"initializer\"], arguments, {initializer: missing},\n                null, null),\n            typecode = $.typecode,\n            initializer = $.initializer\n        if(! typecodes.hasOwnProperty(typecode)){\n            throw _b_.ValueError.$factory(\"bad typecode (must be b, \" +\n                \"B, u, h, H, i, I, l, L, q, Q, f or d)\")\n        }\n        if(typecodes[typecode] === null){\n            console.log(\"array factory, $\", $, typecode)\n            throw _b_.NotImplementedError.$factory(\"type code \" +\n                typecode + \" is not implemented\")\n        }\n        var res = {\n            __class__: array,\n            typecode: typecode,\n            obj: null\n        }\n        if(initializer !== missing){\n            if(Array.isArray(initializer)){\n                array.fromlist(res, initializer)\n            }else if($B.$isinstance(initializer, _b_.bytes)){\n                array.frombytes(res, initializer)\n            }else{\n                array.extend(res, initializer)\n            }\n        }\n        return res\n    }\n)\n\narray.$buffer_protocol = true\narray.$match_sequence_pattern = true // for Pattern Matching (PEP 634)\n\narray.__getitem__ = function(self, key){\n    if(self.obj){\n        if(self.obj[key] !== undefined){\n            return self.obj[key]\n        }else if($B.$isinstance(key, _b_.slice)){\n            var t = self.obj.slice(key.start, key.stop)\n            return {\n                __class__: array,\n                typecode: self.typecode,\n                obj: t\n            }\n        }\n    }\n    throw _b_.IndexError.$factory(\"array index out of range\")\n}\n\nvar array_iterator = $B.make_iterator_class(\"array_iterator\")\narray.__iter__ = function(self){\n    return array_iterator.$factory(self.obj === null ? [] : self.obj)\n}\n\narray.__len__ = function(self){\n    return self.obj === null ? 0 : self.obj.length\n}\n\narray.__mul__ = function(self, nb){\n    if(typeof nb == \"number\" || $B.$isinstance(nb, _b_.int)){\n        var t = [],\n            copy = self.obj.slice()\n        for(var i = 0; i < nb; i++){\n            t = t.concat(copy)\n        }\n        return {\n            __class__: array,\n            typecode: self.typecode,\n            obj: t\n        }\n    }\n    throw _b_.ValueError.$factory(\"cannot multiply array by \" +\n        $B.class_name(nb))\n}\n\narray.__setitem__ = function(_self, index, value){\n    if(_self.obj[index] === undefined){\n        throw _b_.IndexError.$factory(\"array index out of range\")\n    }\n    _self.obj[index] = value\n}\n\narray.__str__ = function(self){\n    $B.args(\"__str__\", 1, {self: null},\n        [\"self\"], arguments, {}, null, null)\n    var res = \"array('\" + self.typecode + \"'\"\n    if(self.obj !== null){\n        res += \", [\" + self.obj + \"]\"\n    }\n    return res + \")\"\n}\n\nfunction normalize_index(self, i){\n    // return an index i between 0 and self.obj.length - 1\n    if(i < 0){\n        i = self.obj.length + i\n    }\n    if(i < 0){i = 0}\n    else if(i > self.obj.length - 1){\n        i = self.obj.length\n    }\n    return i\n}\n\narray.append = function(self, value){\n    $B.args(\"append\", 2, {self: null, value: null},\n        [\"self\", \"value\"], arguments, {}, null, null)\n    var pos = self.obj === null ? 0 : self.obj.length\n    return array.insert(self, pos, value)\n}\n\narray.count = function(self, x){\n    $B.args(\"count\", 2, {self: null, x: null},\n        [\"self\", \"x\"], arguments, {}, null, null)\n    if(self.obj === null){\n        return 0\n    }\n    return self.obj.filter(function(item){return item == x}).length\n}\n\narray.extend = function(self, iterable){\n    $B.args(\"extend\", 2, {self: null, iterable: null},\n        [\"self\", \"iterable\"], arguments, {}, null, null)\n    if(iterable.__class__ === array){\n        if(iterable.typecode !== self.typecode){\n            throw _b_.TypeError.$factory(\"can only extend with array \" +\n                \"of same kind\")\n        }\n        if(iterable.obj === null){return _b_.None}\n        // create new object with length = sum of lengths\n        var newobj = new typecodes[self.typecode](self.obj.length +\n            iterable.obj.length)\n        // copy self.obj\n        newobj.set(self.obj)\n        // copy iterable.obj\n        newobj.set(iterable.obj, self.obj.length)\n        self.obj = newobj\n    }else{\n        var it = _b_.iter(iterable)\n        while(true){\n            try{\n                var item = _b_.next(it)\n                array.append(self, item)\n            }catch(err){\n                if(err.__class__ !== _b_.StopIteration){\n                    throw err\n                }\n                break\n            }\n        }\n    }\n    return _b_.None\n}\n\narray.frombytes = function(self, s){\n    $B.args(\"frombytes\", 2, {self: null, s: null},\n        [\"self\", \"s\"], arguments, {}, null, null)\n    if(! $B.$isinstance(s, _b_.bytes)){\n        throw _b_.TypeError.$factory(\"a bytes-like object is required, \" +\n            \"not '\" + $B.class_name(s) + \"'\")\n    }\n    self.obj = new typecodes[self.typecode](s.source)\n    return _b_.None\n}\n\narray.fromlist = function(self, list){\n    $B.args(\"fromlist\", 2, {self: null, list: null},\n        [\"self\", \"list\"], arguments, {}, null, null)\n    var it = _b_.iter(list)\n    while(true){\n        try{\n            var item = _b_.next(it)\n            try{\n                array.append(self, item)\n            }catch(err){\n                console.log(err)\n                return _b_.None\n            }\n        }catch(err){\n            if(err.__class__ === _b_.StopIteration){\n                return _b_.None\n            }\n            throw err\n        }\n    }\n}\n\narray.fromstring = array.frombytes\n\narray.index = function(self, x){\n    $B.args(\"index\", 2, {self: null, x: null},\n        [\"self\", \"x\"], arguments, {}, null, null)\n    var res = self.obj.findIndex(function(item){return x == item})\n    if(res == -1){\n        throw _b_.ValueError.$factory(\"array.index(x): x not in array\")\n    }\n    return res\n}\n\narray.insert = function(self, i, value){\n    $B.args(\"insert\", 3, {self: null, i: null, value: null},\n        [\"self\", \"i\", \"value\"], arguments, {}, null, null)\n    if(self.obj === null){\n        self.obj = [value]\n    }else{\n        self.obj.splice(i, 0, value)\n    }\n    return _b_.None\n}\n\narray.itemsize = function(self){\n    return typecodes[self.typecode].BYTES_PER_ELEMENT\n}\n\narray.pop = function(self, i){\n    var $ = $B.args(\"count\", 2, {self: null, i: null},\n        [\"self\", \"i\"], arguments, {i: -1}, null, null)\n    i = $.i\n    if(self.obj === null){\n        throw _b_.IndexError.$factory(\"pop from empty array\")\n    }else if(self.obj.length == 1){\n        var res = self.obj[0]\n        self.obj = null\n        return res\n    }\n    i = normalize_index(self, i)\n    // store value to return\n    var res = self.obj[i]\n    // create new array, size = previous size - 1\n    var newobj = new typecodes[self.typecode](self.obj.length - 1)\n    // fill new array with values until i excluded\n    newobj.set(self.obj.slice(0, i))\n    // fill with values after i\n    newobj.set(self.obj.slice(i + 1), i)\n    // set self.obj to new array\n    self.obj = newobj\n    // return stored value\n    return res\n}\n\narray.remove = function(self, x){\n    $B.args(\"remove\", 2, {self: null, x: null},\n        [\"self\", \"x\"], arguments, {}, null, null)\n    var res = self.obj.findIndex(function(item){return x == item})\n    if(res == -1){\n        throw _b_.ValueError.$factory(\"array.remove(x): x not in array\")\n    }\n    array.pop(self, res)\n    return _b_.None\n}\n\narray.reverse = function(self){\n    $B.args(\"reverse\", 1, {self: null},\n        [\"self\"], arguments, {}, null, null)\n    if(self.obj === null){return _b_.None}\n    self.obj.reverse()\n    return _b_.None\n}\n\narray.tobytes = function(self){\n    $B.args(\"tobytes\", 1, {self: null},\n        [\"self\"], arguments, {}, null, null)\n    var items = Array.prototype.slice.call(self.obj),\n        res = []\n    items.forEach(function(item){\n        while(item > 256){\n            res.push(item % 256)\n            item = Math.floor(item / 256)\n        }\n        res.push(item)\n    })\n    return _b_.bytes.$factory(res)\n}\n\narray.tolist = function(self){\n    $B.args(\"tolist\", 1, {self: null},\n        [\"self\"], arguments, {}, null, null)\n    if(self.obj === null){\n        return $B.$list([])\n    }\n    return $B.$list(Array.prototype.slice.call(self.obj))\n}\n\narray.tostring = array.tobytes\n\narray.typecode = function(self){\n    return self.typecode\n}\n\n$B.set_func_names(array, \"array\")\n\nvar module = {\n    array: array,\n    typecodes: Object.keys(typecodes).join('')\n}\n\n$B.addToImported('array', module)\n\n})(__BRYTHON__)\n"], "builtins": [".js", "(function(){\n    var obj = {},\n        builtin_names = ['ArithmeticError', 'AssertionError',\n            'AttributeError', 'BaseException', 'BaseExceptionGroup',\n            'BlockingIOError', 'BrokenPipeError', 'BufferError',\n            'BytesWarning', 'ChildProcessError', 'ConnectionAbortedError',\n            'ConnectionError', 'ConnectionRefusedError',\n            'ConnectionResetError', 'DeprecationWarning', 'EOFError',\n            'Ellipsis', 'EncodingWarning', 'EnvironmentError', 'Exception',\n            'ExceptionGroup', 'False', 'FileExistsError', 'FileNotFoundError',\n            'FloatingPointError', 'FutureWarning', 'GeneratorExit', 'IOError',\n            'ImportError', 'ImportWarning', 'IndentationError', 'IndexError',\n            'InterruptedError', 'IsADirectoryError', 'KeyError',\n            'KeyboardInterrupt', 'LookupError', 'MemoryError',\n            'ModuleNotFoundError', 'NameError', 'None', 'NotADirectoryError',\n            'NotImplemented', 'NotImplementedError', 'OSError',\n            'OverflowError', 'PendingDeprecationWarning', 'PermissionError',\n            'ProcessLookupError', 'RecursionError', 'ReferenceError',\n            'ResourceWarning', 'RuntimeError', 'RuntimeWarning',\n            'StopAsyncIteration', 'StopIteration', 'SyntaxError',\n            'SyntaxWarning', 'SystemError', 'SystemExit', 'TabError',\n            'TimeoutError', 'True', 'TypeError', 'UnboundLocalError',\n            'UnicodeDecodeError', 'UnicodeEncodeError', 'UnicodeError',\n            'UnicodeTranslateError', 'UnicodeWarning', 'UserWarning',\n            'ValueError', 'Warning', 'WindowsError', 'ZeroDivisionError',\n            '_', '__build_class__', '__debug__', '__import__',\n            'abs', 'aiter', 'all', 'anext', 'any', 'ascii', 'bin', 'bool',\n            'breakpoint', 'bytearray', 'bytes', 'callable', 'chr',\n            'classmethod', 'compile', 'complex', 'delattr', 'dict', 'dir',\n            'divmod', 'enumerate', 'eval', 'exec', 'exit', 'filter', 'float',\n            'format', 'frozenset', 'getattr', 'globals', 'hasattr', 'hash',\n            'help', 'hex', 'id', 'input', 'int', 'isinstance', 'issubclass',\n            'iter', 'len', 'list', 'locals', 'map', 'max', 'memoryview',\n            'min', 'next', 'object', 'oct', 'open', 'ord', 'pow', 'print',\n            'property', 'quit', 'range', 'repr', 'reversed', 'round', 'set',\n            'setattr', 'slice', 'sorted', 'staticmethod', 'str', 'sum',\n            'super', 'tuple', 'type', 'vars', 'zip']\n    for(var key of builtin_names){\n        if(__BRYTHON__.builtins[key] !== undefined){\n            obj[key] = __BRYTHON__.builtins[key]\n        }\n    }\n    obj.__doc__ = 'builtins module'\n    obj.__build_class__ = ''\n    obj.copyright = 'CPython copyright'\n    obj.credits = 'CPython builtins credits'\n    obj.license = 'CPython license'\n\n    $B.addToImported('builtins', obj)\n})()\n"], "dis": [".js", "(function($B){\n\nvar _b_ = $B.builtins,\n    dict = $B.builtins.dict\n\nvar mod = {\n    dis:function(src){\n        $B.$py_module_path['__main__'] = $B.brython_path\n        return __BRYTHON__.py2js(src,'__main__','__main__',\n            $B.builtins_scope).to_js()\n    },\n    COMPILER_FLAG_NAMES: $B.builtins.dict.$factory(),\n    Positions: function(){\n        return _b_.None\n    }\n}\n\n// COMPILER_FLAGS is defined in brython_builtins.js\nfor(var key in $B.COMPILER_FLAGS){\n    mod[key] = $B.COMPILER_FLAGS[key]\n    _b_.dict.$setitem(mod.COMPILER_FLAG_NAMES, mod[key], key)\n}\n\n$B.addToImported('dis', mod)\n\n})(__BRYTHON__)"], "encoding_cp932": [".js", "const cps = {\"0\": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, 65377, 65378, 65379, 65380, 65381, 65382, 65383, 65384, 65385, 65386, 65387, 65388, 65389, 65390, 65391, 65392, 65393, 65394, 65395, 65396, 65397, 65398, 65399, 65400, 65401, 65402, 65403, 65404, 65405, 65406, 65407, 65408, 65409, 65410, 65411, 65412, 65413, 65414, 65415, 65416, 65417, 65418, 65419, 65420, 65421, 65422, 65423, 65424, 65425, 65426, 65427, 65428, 65429, 65430, 65431, 65432, 65433, 65434, 65435, 65436, 65437, 65438, 65439, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null], \"33088\": [12288, 12289, 12290, 65292, 65294, 12539, 65306, 65307, 65311, 65281, 12443, 12444, 180, 65344, 168, 65342, 65507, 65343, 12541, 12542, 12445, 12446, 12291, 20189, 12293, 12294, 12295, 12540, 8213, 8208, 65295, 65340, 65374, 8741, 65372, 8230, 8229, 8216, 8217, 8220, 8221, 65288, 65289, 12308, 12309, 65339, 65341, 65371, 65373, 12296, 12297, 12298, 12299, 12300, 12301, 12302, 12303, 12304, 12305, 65291, 65293, 177, 215], \"33152\": [247, 65309, 8800, 65308, 65310, 8806, 8807, 8734, 8756, 9794, 9792, 176, 8242, 8243, 8451, 65509, 65284, 65504, 65505, 65285, 65283, 65286, 65290, 65312, 167, 9734, 9733, 9675, 9679, 9678, 9671, 9670, 9633, 9632, 9651, 9650, 9661, 9660, 8251, 12306, 8594, 8592, 8593, 8595, 12307], \"33208\": [8712, 8715, 8838, 8839, 8834, 8835, 8746, 8745], \"33224\": [8743, 8744, 65506, 8658, 8660, 8704, 8707], \"33242\": [8736, 8869, 8978, 8706, 8711, 8801, 8786, 8810, 8811, 8730, 8765, 8733, 8757, 8747, 8748], \"33264\": [8491, 8240, 9839, 9837, 9834, 8224, 8225, 182], \"33276\": [9711], \"33359\": [65296, 65297, 65298, 65299, 65300, 65301, 65302, 65303, 65304, 65305], \"33376\": [65313, 65314, 65315, 65316, 65317, 65318, 65319, 65320, 65321, 65322, 65323, 65324, 65325, 65326, 65327, 65328, 65329, 65330, 65331, 65332, 65333, 65334, 65335, 65336, 65337, 65338], \"33409\": [65345, 65346, 65347, 65348, 65349, 65350, 65351, 65352, 65353, 65354, 65355, 65356, 65357, 65358, 65359, 65360, 65361, 65362, 65363, 65364, 65365, 65366, 65367, 65368, 65369, 65370], \"33439\": [12353, 12354, 12355, 12356, 12357, 12358, 12359, 12360, 12361, 12362, 12363, 12364, 12365, 12366, 12367, 12368, 12369, 12370, 12371, 12372, 12373, 12374, 12375, 12376, 12377, 12378, 12379, 12380, 12381, 12382, 12383, 12384, 12385, 12386, 12387, 12388, 12389, 12390, 12391, 12392, 12393, 12394, 12395, 12396, 12397, 12398, 12399, 12400, 12401, 12402, 12403, 12404, 12405, 12406, 12407, 12408, 12409, 12410, 12411, 12412, 12413, 12414, 12415, 12416, 12417, 12418, 12419, 12420, 12421, 12422, 12423, 12424, 12425, 12426, 12427, 12428, 12429, 12430, 12431, 12432, 12433, 12434, 12435], \"33600\": [12449, 12450, 12451, 12452, 12453, 12454, 12455, 12456, 12457, 12458, 12459, 12460, 12461, 12462, 12463, 12464, 12465, 12466, 12467, 12468, 12469, 12470, 12471, 12472, 12473, 12474, 12475, 12476, 12477, 12478, 12479, 12480, 12481, 12482, 12483, 12484, 12485, 12486, 12487, 12488, 12489, 12490, 12491, 12492, 12493, 12494, 12495, 12496, 12497, 12498, 12499, 12500, 12501, 12502, 12503, 12504, 12505, 12506, 12507, 12508, 12509, 12510, 12511], \"33664\": [12512, 12513, 12514, 12515, 12516, 12517, 12518, 12519, 12520, 12521, 12522, 12523, 12524, 12525, 12526, 12527, 12528, 12529, 12530, 12531, 12532, 12533, 12534], \"33695\": [913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937], \"33727\": [945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 963, 964, 965, 966, 967, 968, 969], \"33856\": [1040, 1041, 1042, 1043, 1044, 1045, 1025, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071], \"33904\": [1072, 1073, 1074, 1075, 1076, 1077, 1105, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085], \"33920\": [1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103], \"33951\": [9472, 9474, 9484, 9488, 9496, 9492, 9500, 9516, 9508, 9524, 9532, 9473, 9475, 9487, 9491, 9499, 9495, 9507, 9523, 9515, 9531, 9547, 9504, 9519, 9512, 9527, 9535, 9501, 9520, 9509, 9528, 9538], \"34624\": [9312, 9313, 9314, 9315, 9316, 9317, 9318, 9319, 9320, 9321, 9322, 9323, 9324, 9325, 9326, 9327, 9328, 9329, 9330, 9331, 8544, 8545, 8546, 8547, 8548, 8549, 8550, 8551, 8552, 8553], \"34655\": [13129, 13076, 13090, 13133, 13080, 13095, 13059, 13110, 13137, 13143, 13069, 13094, 13091, 13099, 13130, 13115, 13212, 13213, 13214, 13198, 13199, 13252, 13217], \"34686\": [13179], \"34688\": [12317, 12319, 8470, 13261, 8481, 12964, 12965, 12966, 12967, 12968, 12849, 12850, 12857, 13182, 13181, 13180, 8786, 8801, 8747, 8750, 8721, 8730, 8869, 8736, 8735, 8895, 8757, 8745, 8746], \"34975\": [20124, 21782, 23043, 38463, 21696, 24859, 25384, 23030, 36898, 33909, 33564, 31312, 24746, 25569, 28197, 26093, 33894, 33446, 39925, 26771, 22311, 26017, 25201, 23451, 22992, 34427, 39156, 32098, 32190, 39822, 25110, 31903, 34999, 23433, 24245, 25353, 26263, 26696, 38343, 38797, 26447, 20197, 20234, 20301, 20381, 20553, 22258, 22839, 22996, 23041, 23561, 24799, 24847, 24944, 26131, 26885, 28858, 30031, 30064, 31227, 32173, 32239, 32963, 33806, 34915, 35586, 36949, 36986, 21307, 20117, 20133, 22495, 32946, 37057, 30959, 19968, 22769, 28322, 36920, 31282, 33576, 33419, 39983, 20801, 21360, 21693, 21729, 22240, 23035, 24341, 39154, 28139, 32996, 34093], \"35136\": [38498, 38512, 38560, 38907, 21515, 21491, 23431, 28879, 32701, 36802, 38632, 21359, 40284, 31418, 19985, 30867, 33276, 28198, 22040, 21764, 27421, 34074, 39995, 23013, 21417, 28006, 29916, 38287, 22082, 20113, 36939, 38642, 33615, 39180, 21473, 21942, 23344, 24433, 26144, 26355, 26628, 27704, 27891, 27945, 29787, 30408, 31310, 38964, 33521, 34907, 35424, 37613, 28082, 30123, 30410, 39365, 24742, 35585, 36234, 38322, 27022, 21421, 20870], \"35200\": [22290, 22576, 22852, 23476, 24310, 24616, 25513, 25588, 27839, 28436, 28814, 28948, 29017, 29141, 29503, 32257, 33398, 33489, 34199, 36960, 37467, 40219, 22633, 26044, 27738, 29989, 20985, 22830, 22885, 24448, 24540, 25276, 26106, 27178, 27431, 27572, 29579, 32705, 35158, 40236, 40206, 40644, 23713, 27798, 33659, 20740, 23627, 25014, 33222, 26742, 29281, 20057, 20474, 21368, 24681, 28201, 31311, 38899, 19979, 21270, 20206, 20309, 20285, 20385, 20339, 21152, 21487, 22025, 22799, 23233, 23478, 23521, 31185, 26247, 26524, 26550, 27468, 27827, 28779, 29634, 31117, 31166, 31292, 31623, 33457, 33499, 33540, 33655, 33775, 33747, 34662, 35506, 22057, 36008, 36838, 36942, 38686, 34442, 20420, 23784, 25105, 29273, 30011, 33253, 33469, 34558, 36032, 38597, 39187, 39381, 20171, 20250, 35299, 22238, 22602, 22730, 24315, 24555, 24618, 24724, 24674, 25040, 25106, 25296, 25913], \"35392\": [39745, 26214, 26800, 28023, 28784, 30028, 30342, 32117, 33445, 34809, 38283, 38542, 35997, 20977, 21182, 22806, 21683, 23475, 23830, 24936, 27010, 28079, 30861, 33995, 34903, 35442, 37799, 39608, 28012, 39336, 34521, 22435, 26623, 34510, 37390, 21123, 22151, 21508, 24275, 25313, 25785, 26684, 26680, 27579, 29554, 30906, 31339, 35226, 35282, 36203, 36611, 37101, 38307, 38548, 38761, 23398, 23731, 27005, 38989, 38990, 25499, 31520, 27179], \"35456\": [27263, 26806, 39949, 28511, 21106, 21917, 24688, 25324, 27963, 28167, 28369, 33883, 35088, 36676, 19988, 39993, 21494, 26907, 27194, 38788, 26666, 20828, 31427, 33970, 37340, 37772, 22107, 40232, 26658, 33541, 33841, 31909, 21000, 33477, 29926, 20094, 20355, 20896, 23506, 21002, 21208, 21223, 24059, 21914, 22570, 23014, 23436, 23448, 23515, 24178, 24185, 24739, 24863, 24931, 25022, 25563, 25954, 26577, 26707, 26874, 27454, 27475, 27735, 28450, 28567, 28485, 29872, 29976, 30435, 30475, 31487, 31649, 31777, 32233, 32566, 32752, 32925, 33382, 33694, 35251, 35532, 36011, 36996, 37969, 38291, 38289, 38306, 38501, 38867, 39208, 33304, 20024, 21547, 23736, 24012, 29609, 30284, 30524, 23721, 32747, 36107, 38593, 38929, 38996, 39000, 20225, 20238, 21361, 21916, 22120, 22522, 22855, 23305, 23492, 23696, 24076, 24190, 24524, 25582, 26426, 26071, 26082, 26399, 26827, 26820], \"35648\": [27231, 24112, 27589, 27671, 27773, 30079, 31048, 23395, 31232, 32000, 24509, 35215, 35352, 36020, 36215, 36556, 36637, 39138, 39438, 39740, 20096, 20605, 20736, 22931, 23452, 25135, 25216, 25836, 27450, 29344, 30097, 31047, 32681, 34811, 35516, 35696, 25516, 33738, 38816, 21513, 21507, 21931, 26708, 27224, 35440, 30759, 26485, 40653, 21364, 23458, 33050, 34384, 36870, 19992, 20037, 20167, 20241, 21450, 21560, 23470, 24339, 24613, 25937], \"35712\": [26429, 27714, 27762, 27875, 28792, 29699, 31350, 31406, 31496, 32026, 31998, 32102, 26087, 29275, 21435, 23621, 24040, 25298, 25312, 25369, 28192, 34394, 35377, 36317, 37624, 28417, 31142, 39770, 20136, 20139, 20140, 20379, 20384, 20689, 20807, 31478, 20849, 20982, 21332, 21281, 21375, 21483, 21932, 22659, 23777, 24375, 24394, 24623, 24656, 24685, 25375, 25945, 27211, 27841, 29378, 29421, 30703, 33016, 33029, 33288, 34126, 37111, 37857, 38911, 39255, 39514, 20208, 20957, 23597, 26241, 26989, 23616, 26354, 26997, 29577, 26704, 31873, 20677, 21220, 22343, 24062, 37670, 26020, 27427, 27453, 29748, 31105, 31165, 31563, 32202, 33465, 33740, 34943, 35167, 35641, 36817, 37329, 21535, 37504, 20061, 20534, 21477, 21306, 29399, 29590, 30697, 33510, 36527, 39366, 39368, 39378, 20855, 24858, 34398, 21936, 31354, 20598, 23507, 36935, 38533, 20018, 27355, 37351, 23633, 23624], \"35904\": [25496, 31391, 27795, 38772, 36705, 31402, 29066, 38536, 31874, 26647, 32368, 26705, 37740, 21234, 21531, 34219, 35347, 32676, 36557, 37089, 21350, 34952, 31041, 20418, 20670, 21009, 20804, 21843, 22317, 29674, 22411, 22865, 24418, 24452, 24693, 24950, 24935, 25001, 25522, 25658, 25964, 26223, 26690, 28179, 30054, 31293, 31995, 32076, 32153, 32331, 32619, 33550, 33610, 34509, 35336, 35427, 35686, 36605, 38938, 40335, 33464, 36814, 39912], \"35968\": [21127, 25119, 25731, 28608, 38553, 26689, 20625, 27424, 27770, 28500, 31348, 32080, 34880, 35363, 26376, 20214, 20537, 20518, 20581, 20860, 21048, 21091, 21927, 22287, 22533, 23244, 24314, 25010, 25080, 25331, 25458, 26908, 27177, 29309, 29356, 29486, 30740, 30831, 32121, 30476, 32937, 35211, 35609, 36066, 36562, 36963, 37749, 38522, 38997, 39443, 40568, 20803, 21407, 21427, 24187, 24358, 28187, 28304, 29572, 29694, 32067, 33335, 35328, 35578, 38480, 20046, 20491, 21476, 21628, 22266, 22993, 23396, 24049, 24235, 24359, 25144, 25925, 26543, 28246, 29392, 31946, 34996, 32929, 32993, 33776, 34382, 35463, 36328, 37431, 38599, 39015, 40723, 20116, 20114, 20237, 21320, 21577, 21566, 23087, 24460, 24481, 24735, 26791, 27278, 29786, 30849, 35486, 35492, 35703, 37264, 20062, 39881, 20132, 20348, 20399, 20505, 20502, 20809, 20844, 21151, 21177, 21246, 21402, 21475, 21521], \"36160\": [21518, 21897, 22353, 22434, 22909, 23380, 23389, 23439, 24037, 24039, 24055, 24184, 24195, 24218, 24247, 24344, 24658, 24908, 25239, 25304, 25511, 25915, 26114, 26179, 26356, 26477, 26657, 26775, 27083, 27743, 27946, 28009, 28207, 28317, 30002, 30343, 30828, 31295, 31968, 32005, 32024, 32094, 32177, 32789, 32771, 32943, 32945, 33108, 33167, 33322, 33618, 34892, 34913, 35611, 36002, 36092, 37066, 37237, 37489, 30783, 37628, 38308, 38477], \"36224\": [38917, 39321, 39640, 40251, 21083, 21163, 21495, 21512, 22741, 25335, 28640, 35946, 36703, 40633, 20811, 21051, 21578, 22269, 31296, 37239, 40288, 40658, 29508, 28425, 33136, 29969, 24573, 24794, 39592, 29403, 36796, 27492, 38915, 20170, 22256, 22372, 22718, 23130, 24680, 25031, 26127, 26118, 26681, 26801, 28151, 30165, 32058, 33390, 39746, 20123, 20304, 21449, 21766, 23919, 24038, 24046, 26619, 27801, 29811, 30722, 35408, 37782, 35039, 22352, 24231, 25387, 20661, 20652, 20877, 26368, 21705, 22622, 22971, 23472, 24425, 25165, 25505, 26685, 27507, 28168, 28797, 37319, 29312, 30741, 30758, 31085, 25998, 32048, 33756, 35009, 36617, 38555, 21092, 22312, 26448, 32618, 36001, 20916, 22338, 38442, 22586, 27018, 32948, 21682, 23822, 22524, 30869, 40442, 20316, 21066, 21643, 25662, 26152, 26388, 26613, 31364, 31574, 32034, 37679, 26716, 39853, 31545, 21273, 20874, 21047], \"36416\": [23519, 25334, 25774, 25830, 26413, 27578, 34217, 38609, 30352, 39894, 25420, 37638, 39851, 30399, 26194, 19977, 20632, 21442, 23665, 24808, 25746, 25955, 26719, 29158, 29642, 29987, 31639, 32386, 34453, 35715, 36059, 37240, 39184, 26028, 26283, 27531, 20181, 20180, 20282, 20351, 21050, 21496, 21490, 21987, 22235, 22763, 22987, 22985, 23039, 23376, 23629, 24066, 24107, 24535, 24605, 25351, 25903, 23388, 26031, 26045, 26088, 26525, 27490], \"36480\": [27515, 27663, 29509, 31049, 31169, 31992, 32025, 32043, 32930, 33026, 33267, 35222, 35422, 35433, 35430, 35468, 35566, 36039, 36060, 38604, 39164, 27503, 20107, 20284, 20365, 20816, 23383, 23546, 24904, 25345, 26178, 27425, 28363, 27835, 29246, 29885, 30164, 30913, 31034, 32780, 32819, 33258, 33940, 36766, 27728, 40575, 24335, 35672, 40235, 31482, 36600, 23437, 38635, 19971, 21489, 22519, 22833, 23241, 23460, 24713, 28287, 28422, 30142, 36074, 23455, 34048, 31712, 20594, 26612, 33437, 23649, 34122, 32286, 33294, 20889, 23556, 25448, 36198, 26012, 29038, 31038, 32023, 32773, 35613, 36554, 36974, 34503, 37034, 20511, 21242, 23610, 26451, 28796, 29237, 37196, 37320, 37675, 33509, 23490, 24369, 24825, 20027, 21462, 23432, 25163, 26417, 27530, 29417, 29664, 31278, 33131, 36259, 37202, 39318, 20754, 21463, 21610, 23551, 25480, 27193, 32172, 38656, 22234, 21454, 21608], \"36672\": [23447, 23601, 24030, 20462, 24833, 25342, 27954, 31168, 31179, 32066, 32333, 32722, 33261, 33311, 33936, 34886, 35186, 35728, 36468, 36655, 36913, 37195, 37228, 38598, 37276, 20160, 20303, 20805, 21313, 24467, 25102, 26580, 27713, 28171, 29539, 32294, 37325, 37507, 21460, 22809, 23487, 28113, 31069, 32302, 31899, 22654, 29087, 20986, 34899, 36848, 20426, 23803, 26149, 30636, 31459, 33308, 39423, 20934, 24490, 26092, 26991, 27529, 28147], \"36736\": [28310, 28516, 30462, 32020, 24033, 36981, 37255, 38918, 20966, 21021, 25152, 26257, 26329, 28186, 24246, 32210, 32626, 26360, 34223, 34295, 35576, 21161, 21465, 22899, 24207, 24464, 24661, 37604, 38500, 20663, 20767, 21213, 21280, 21319, 21484, 21736, 21830, 21809, 22039, 22888, 22974, 23100, 23477, 23558, 23567, 23569, 23578, 24196, 24202, 24288, 24432, 25215, 25220, 25307, 25484, 25463, 26119, 26124, 26157, 26230, 26494, 26786, 27167, 27189, 27836, 28040, 28169, 28248, 28988, 28966, 29031, 30151, 30465, 30813, 30977, 31077, 31216, 31456, 31505, 31911, 32057, 32918, 33750, 33931, 34121, 34909, 35059, 35359, 35388, 35412, 35443, 35937, 36062, 37284, 37478, 37758, 37912, 38556, 38808, 19978, 19976, 19998, 20055, 20887, 21104, 22478, 22580, 22732, 23330, 24120, 24773, 25854, 26465, 26454, 27972, 29366, 30067, 31331, 33976, 35698, 37304, 37664, 22065, 22516, 39166], \"36928\": [25325, 26893, 27542, 29165, 32340, 32887, 33394, 35302, 39135, 34645, 36785, 23611, 20280, 20449, 20405, 21767, 23072, 23517, 23529, 24515, 24910, 25391, 26032, 26187, 26862, 27035, 28024, 28145, 30003, 30137, 30495, 31070, 31206, 32051, 33251, 33455, 34218, 35242, 35386, 36523, 36763, 36914, 37341, 38663, 20154, 20161, 20995, 22645, 22764, 23563, 29978, 23613, 33102, 35338, 36805, 38499, 38765, 31525, 35535, 38920, 37218, 22259, 21416], \"36992\": [36887, 21561, 22402, 24101, 25512, 27700, 28810, 30561, 31883, 32736, 34928, 36930, 37204, 37648, 37656, 38543, 29790, 39620, 23815, 23913, 25968, 26530, 36264, 38619, 25454, 26441, 26905, 33733, 38935, 38592, 35070, 28548, 25722, 23544, 19990, 28716, 30045, 26159, 20932, 21046, 21218, 22995, 24449, 24615, 25104, 25919, 25972, 26143, 26228, 26866, 26646, 27491, 28165, 29298, 29983, 30427, 31934, 32854, 22768, 35069, 35199, 35488, 35475, 35531, 36893, 37266, 38738, 38745, 25993, 31246, 33030, 38587, 24109, 24796, 25114, 26021, 26132, 26512, 30707, 31309, 31821, 32318, 33034, 36012, 36196, 36321, 36447, 30889, 20999, 25305, 25509, 25666, 25240, 35373, 31363, 31680, 35500, 38634, 32118, 33292, 34633, 20185, 20808, 21315, 21344, 23459, 23554, 23574, 24029, 25126, 25159, 25776, 26643, 26676, 27849, 27973, 27927, 26579, 28508, 29006, 29053, 26059, 31359, 31661, 32218], \"37184\": [32330, 32680, 33146, 33307, 33337, 34214, 35438, 36046, 36341, 36984, 36983, 37549, 37521, 38275, 39854, 21069, 21892, 28472, 28982, 20840, 31109, 32341, 33203, 31950, 22092, 22609, 23720, 25514, 26366, 26365, 26970, 29401, 30095, 30094, 30990, 31062, 31199, 31895, 32032, 32068, 34311, 35380, 38459, 36961, 40736, 20711, 21109, 21452, 21474, 20489, 21930, 22766, 22863, 29245, 23435, 23652, 21277, 24803, 24819, 25436, 25475, 25407, 25531], \"37248\": [25805, 26089, 26361, 24035, 27085, 27133, 28437, 29157, 20105, 30185, 30456, 31379, 31967, 32207, 32156, 32865, 33609, 33624, 33900, 33980, 34299, 35013, 36208, 36865, 36973, 37783, 38684, 39442, 20687, 22679, 24974, 33235, 34101, 36104, 36896, 20419, 20596, 21063, 21363, 24687, 25417, 26463, 28204, 36275, 36895, 20439, 23646, 36042, 26063, 32154, 21330, 34966, 20854, 25539, 23384, 23403, 23562, 25613, 26449, 36956, 20182, 22810, 22826, 27760, 35409, 21822, 22549, 22949, 24816, 25171, 26561, 33333, 26965, 38464, 39364, 39464, 20307, 22534, 23550, 32784, 23729, 24111, 24453, 24608, 24907, 25140, 26367, 27888, 28382, 32974, 33151, 33492, 34955, 36024, 36864, 36910, 38538, 40667, 39899, 20195, 21488, 22823, 31532, 37261, 38988, 40441, 28381, 28711, 21331, 21828, 23429, 25176, 25246, 25299, 27810, 28655, 29730, 35351, 37944, 28609, 35582, 33592, 20967, 34552, 21482], \"37440\": [21481, 20294, 36948, 36784, 22890, 33073, 24061, 31466, 36799, 26842, 35895, 29432, 40008, 27197, 35504, 20025, 21336, 22022, 22374, 25285, 25506, 26086, 27470, 28129, 28251, 28845, 30701, 31471, 31658, 32187, 32829, 32966, 34507, 35477, 37723, 22243, 22727, 24382, 26029, 26262, 27264, 27573, 30007, 35527, 20516, 30693, 22320, 24347, 24677, 26234, 27744, 30196, 31258, 32622, 33268, 34584, 36933, 39347, 31689, 30044, 31481, 31569, 33988], \"37504\": [36880, 31209, 31378, 33590, 23265, 30528, 20013, 20210, 23449, 24544, 25277, 26172, 26609, 27880, 34411, 34935, 35387, 37198, 37619, 39376, 27159, 28710, 29482, 33511, 33879, 36015, 19969, 20806, 20939, 21899, 23541, 24086, 24115, 24193, 24340, 24373, 24427, 24500, 25074, 25361, 26274, 26397, 28526, 29266, 30010, 30522, 32884, 33081, 33144, 34678, 35519, 35548, 36229, 36339, 37530, 38263, 38914, 40165, 21189, 25431, 30452, 26389, 27784, 29645, 36035, 37806, 38515, 27941, 22684, 26894, 27084, 36861, 37786, 30171, 36890, 22618, 26626, 25524, 27131, 20291, 28460, 26584, 36795, 34086, 32180, 37716, 26943, 28528, 22378, 22775, 23340, 32044, 29226, 21514, 37347, 40372, 20141, 20302, 20572, 20597, 21059, 35998, 21576, 22564, 23450, 24093, 24213, 24237, 24311, 24351, 24716, 25269, 25402, 25552, 26799, 27712, 30855, 31118, 31243, 32224, 33351, 35330, 35558, 36420, 36883], \"37696\": [37048, 37165, 37336, 40718, 27877, 25688, 25826, 25973, 28404, 30340, 31515, 36969, 37841, 28346, 21746, 24505, 25764, 36685, 36845, 37444, 20856, 22635, 22825, 23637, 24215, 28155, 32399, 29980, 36028, 36578, 39003, 28857, 20253, 27583, 28593, 30000, 38651, 20814, 21520, 22581, 22615, 22956, 23648, 24466, 26007, 26460, 28193, 30331, 33759, 36077, 36884, 37117, 37709, 30757, 30778, 21162, 24230, 22303, 22900, 24594, 20498, 20826, 20908], \"37760\": [20941, 20992, 21776, 22612, 22616, 22871, 23445, 23798, 23947, 24764, 25237, 25645, 26481, 26691, 26812, 26847, 30423, 28120, 28271, 28059, 28783, 29128, 24403, 30168, 31095, 31561, 31572, 31570, 31958, 32113, 21040, 33891, 34153, 34276, 35342, 35588, 35910, 36367, 36867, 36879, 37913, 38518, 38957, 39472, 38360, 20685, 21205, 21516, 22530, 23566, 24999, 25758, 27934, 30643, 31461, 33012, 33796, 36947, 37509, 23776, 40199, 21311, 24471, 24499, 28060, 29305, 30563, 31167, 31716, 27602, 29420, 35501, 26627, 27233, 20984, 31361, 26932, 23626, 40182, 33515, 23493, 37193, 28702, 22136, 23663, 24775, 25958, 27788, 35930, 36929, 38931, 21585, 26311, 37389, 22856, 37027, 20869, 20045, 20970, 34201, 35598, 28760, 25466, 37707, 26978, 39348, 32260, 30071, 21335, 26976, 36575, 38627, 27741, 20108, 23612, 24336, 36841, 21250, 36049, 32905, 34425, 24319, 26085, 20083, 20837], \"37952\": [22914, 23615, 38894, 20219, 22922, 24525, 35469, 28641, 31152, 31074, 23527, 33905, 29483, 29105, 24180, 24565, 25467, 25754, 29123, 31896, 20035, 24316, 20043, 22492, 22178, 24745, 28611, 32013, 33021, 33075, 33215, 36786, 35223, 34468, 24052, 25226, 25773, 35207, 26487, 27874, 27966, 29750, 30772, 23110, 32629, 33453, 39340, 20467, 24259, 25309, 25490, 25943, 26479, 30403, 29260, 32972, 32954, 36649, 37197, 20493, 22521, 23186, 26757], \"38016\": [26995, 29028, 29437, 36023, 22770, 36064, 38506, 36889, 34687, 31204, 30695, 33833, 20271, 21093, 21338, 25293, 26575, 27850, 30333, 31636, 31893, 33334, 34180, 36843, 26333, 28448, 29190, 32283, 33707, 39361, 40614, 20989, 31665, 30834, 31672, 32903, 31560, 27368, 24161, 32908, 30033, 30048, 20843, 37474, 28300, 30330, 37271, 39658, 20240, 32624, 25244, 31567, 38309, 40169, 22138, 22617, 34532, 38588, 20276, 21028, 21322, 21453, 21467, 24070, 25644, 26001, 26495, 27710, 27726, 29256, 29359, 29677, 30036, 32321, 33324, 34281, 36009, 31684, 37318, 29033, 38930, 39151, 25405, 26217, 30058, 30436, 30928, 34115, 34542, 21290, 21329, 21542, 22915, 24199, 24444, 24754, 25161, 25209, 25259, 26000, 27604, 27852, 30130, 30382, 30865, 31192, 32203, 32631, 32933, 34987, 35513, 36027, 36991, 38750, 39131, 27147, 31800, 20633, 23614, 24494, 26503, 27608, 29749, 30473, 32654], \"38208\": [40763, 26570, 31255, 21305, 30091, 39661, 24422, 33181, 33777, 32920, 24380, 24517, 30050, 31558, 36924, 26727, 23019, 23195, 32016, 30334, 35628, 20469, 24426, 27161, 27703, 28418, 29922, 31080, 34920, 35413, 35961, 24287, 25551, 30149, 31186, 33495, 37672, 37618, 33948, 34541, 39981, 21697, 24428, 25996, 27996, 28693, 36007, 36051, 38971, 25935, 29942, 19981, 20184, 22496, 22827, 23142, 23500, 20904, 24067, 24220, 24598, 25206, 25975], \"38272\": [26023, 26222, 28014, 29238, 31526, 33104, 33178, 33433, 35676, 36000, 36070, 36212, 38428, 38468, 20398, 25771, 27494, 33310, 33889, 34154, 37096, 23553, 26963, 39080, 33914, 34135, 20239, 21103, 24489, 24133, 26381, 31119, 33145, 35079, 35206, 28149, 24343, 25173, 27832, 20175, 29289, 39826, 20998, 21563, 22132, 22707, 24996, 25198, 28954, 22894, 31881, 31966, 32027, 38640, 25991, 32862, 19993, 20341, 20853, 22592, 24163, 24179, 24330, 26564, 20006, 34109, 38281, 38491, 31859, 38913, 20731, 22721, 30294, 30887, 21029, 30629, 34065, 31622, 20559, 22793, 29255, 31687, 32232, 36794, 36820, 36941, 20415, 21193, 23081, 24321, 38829, 20445, 33303, 37610, 22275, 25429, 27497, 29995, 35036, 36628, 31298, 21215, 22675, 24917, 25098, 26286, 27597, 31807, 33769, 20515, 20472, 21253, 21574, 22577, 22857, 23453, 23792, 23791, 23849, 24214, 25265, 25447, 25918, 26041, 26379], \"38464\": [27861, 27873, 28921, 30770, 32299, 32990, 33459, 33804, 34028, 34562, 35090, 35370, 35914, 37030, 37586, 39165, 40179, 40300, 20047, 20129, 20621, 21078, 22346, 22952, 24125, 24536, 24537, 25151, 26292, 26395, 26576, 26834, 20882, 32033, 32938, 33192, 35584, 35980, 36031, 37502, 38450, 21536, 38956, 21271, 20693, 21340, 22696, 25778, 26420, 29287, 30566, 31302, 37350, 21187, 27809, 27526, 22528, 24140, 22868, 26412, 32763, 20961, 30406], \"38528\": [25705, 30952, 39764, 40635, 22475, 22969, 26151, 26522, 27598, 21737, 27097, 24149, 33180, 26517, 39850, 26622, 40018, 26717, 20134, 20451, 21448, 25273, 26411, 27819, 36804, 20397, 32365, 40639, 19975, 24930, 28288, 28459, 34067, 21619, 26410, 39749, 24051, 31637, 23724, 23494, 34588, 28234, 34001, 31252, 33032, 22937, 31885, 27665, 30496, 21209, 22818, 28961, 29279, 30683, 38695, 40289, 26891, 23167, 23064, 20901, 21517, 21629, 26126, 30431, 36855, 37528, 40180, 23018, 29277, 28357, 20813, 26825, 32191, 32236, 38754, 40634, 25720, 27169, 33538, 22916, 23391, 27611, 29467, 30450, 32178, 32791, 33945, 20786, 26408, 40665, 30446, 26466, 21247, 39173, 23588, 25147, 31870, 36016, 21839, 24758, 32011, 38272, 21249, 20063, 20918, 22812, 29242, 32822, 37326, 24357, 30690, 21380, 24441, 32004, 34220, 35379, 36493, 38742, 26611, 34222, 37971, 24841, 24840, 27833, 30290], \"38720\": [35565, 36664, 21807, 20305, 20778, 21191, 21451, 23461, 24189, 24736, 24962, 25558, 26377, 26586, 28263, 28044, 29494, 29495, 30001, 31056, 35029, 35480, 36938, 37009, 37109, 38596, 34701, 22805, 20104, 20313, 19982, 35465, 36671, 38928, 20653, 24188, 22934, 23481, 24248, 25562, 25594, 25793, 26332, 26954, 27096, 27915, 28342, 29076, 29992, 31407, 32650, 32768, 33865, 33993, 35201, 35617, 36362, 36965, 38525, 39178, 24958, 25233, 27442], \"38784\": [27779, 28020, 32716, 32764, 28096, 32645, 34746, 35064, 26469, 33713, 38972, 38647, 27931, 32097, 33853, 37226, 20081, 21365, 23888, 27396, 28651, 34253, 34349, 35239, 21033, 21519, 23653, 26446, 26792, 29702, 29827, 30178, 35023, 35041, 37324, 38626, 38520, 24459, 29575, 31435, 33870, 25504, 30053, 21129, 27969, 28316, 29705, 30041, 30827, 31890, 38534, 31452, 40845, 20406, 24942, 26053, 34396, 20102, 20142, 20698, 20001, 20940, 23534, 26009, 26753, 28092, 29471, 30274, 30637, 31260, 31975, 33391, 35538, 36988, 37327, 38517, 38936, 21147, 32209, 20523, 21400, 26519, 28107, 29136, 29747, 33256, 36650, 38563, 40023, 40607, 29792, 22593, 28057, 32047, 39006, 20196, 20278, 20363, 20919, 21169, 23994, 24604, 29618, 31036, 33491, 37428, 38583, 38646, 38666, 40599, 40802, 26278, 27508, 21015, 21155, 28872, 35010, 24265, 24651, 24976, 28451, 29001, 31806, 32244, 32879], \"38976\": [34030, 36899, 37676, 21570, 39791, 27347, 28809, 36034, 36335, 38706, 21172, 23105, 24266, 24324, 26391, 27004, 27028, 28010, 28431, 29282, 29436, 31725, 32769, 32894, 34635, 37070, 20845, 40595, 31108, 32907, 37682, 35542, 20525, 21644, 35441, 27498, 36036, 33031, 24785, 26528, 40434, 20121, 20120, 39952, 35435, 34241, 34152, 26880, 28286, 30871, 33109], \"39071\": [24332, 19984, 19989, 20010, 20017, 20022, 20028, 20031, 20034, 20054, 20056, 20098, 20101, 35947, 20106, 33298, 24333, 20110, 20126, 20127, 20128, 20130, 20144, 20147, 20150, 20174, 20173, 20164, 20166, 20162, 20183, 20190, 20205, 20191, 20215, 20233, 20314, 20272, 20315, 20317, 20311, 20295, 20342, 20360, 20367, 20376, 20347, 20329, 20336, 20369, 20335, 20358, 20374, 20760, 20436, 20447, 20430, 20440, 20443, 20433, 20442, 20432, 20452, 20453, 20506, 20520, 20500, 20522, 20517, 20485, 20252, 20470, 20513, 20521, 20524, 20478, 20463, 20497, 20486, 20547, 20551, 26371, 20565, 20560, 20552, 20570, 20566, 20588, 20600, 20608, 20634, 20613, 20660, 20658], \"39232\": [20681, 20682, 20659, 20674, 20694, 20702, 20709, 20717, 20707, 20718, 20729, 20725, 20745, 20737, 20738, 20758, 20757, 20756, 20762, 20769, 20794, 20791, 20796, 20795, 20799, 20800, 20818, 20812, 20820, 20834, 31480, 20841, 20842, 20846, 20864, 20866, 22232, 20876, 20873, 20879, 20881, 20883, 20885, 20886, 20900, 20902, 20898, 20905, 20906, 20907, 20915, 20913, 20914, 20912, 20917, 20925, 20933, 20937, 20955, 20960, 34389, 20969, 20973], \"39296\": [20976, 20981, 20990, 20996, 21003, 21012, 21006, 21031, 21034, 21038, 21043, 21049, 21071, 21060, 21067, 21068, 21086, 21076, 21098, 21108, 21097, 21107, 21119, 21117, 21133, 21140, 21138, 21105, 21128, 21137, 36776, 36775, 21164, 21165, 21180, 21173, 21185, 21197, 21207, 21214, 21219, 21222, 39149, 21216, 21235, 21237, 21240, 21241, 21254, 21256, 30008, 21261, 21264, 21263, 21269, 21274, 21283, 21295, 21297, 21299, 21304, 21312, 21318, 21317, 19991, 21321, 21325, 20950, 21342, 21353, 21358, 22808, 21371, 21367, 21378, 21398, 21408, 21414, 21413, 21422, 21424, 21430, 21443, 31762, 38617, 21471, 26364, 29166, 21486, 21480, 21485, 21498, 21505, 21565, 21568, 21548, 21549, 21564, 21550, 21558, 21545, 21533, 21582, 21647, 21621, 21646, 21599, 21617, 21623, 21616, 21650, 21627, 21632, 21622, 21636, 21648, 21638, 21703, 21666, 21688, 21669, 21676, 21700, 21704, 21672], \"39488\": [21675, 21698, 21668, 21694, 21692, 21720, 21733, 21734, 21775, 21780, 21757, 21742, 21741, 21754, 21730, 21817, 21824, 21859, 21836, 21806, 21852, 21829, 21846, 21847, 21816, 21811, 21853, 21913, 21888, 21679, 21898, 21919, 21883, 21886, 21912, 21918, 21934, 21884, 21891, 21929, 21895, 21928, 21978, 21957, 21983, 21956, 21980, 21988, 21972, 22036, 22007, 22038, 22014, 22013, 22043, 22009, 22094, 22096, 29151, 22068, 22070, 22066, 22072], \"39552\": [22123, 22116, 22063, 22124, 22122, 22150, 22144, 22154, 22176, 22164, 22159, 22181, 22190, 22198, 22196, 22210, 22204, 22209, 22211, 22208, 22216, 22222, 22225, 22227, 22231, 22254, 22265, 22272, 22271, 22276, 22281, 22280, 22283, 22285, 22291, 22296, 22294, 21959, 22300, 22310, 22327, 22328, 22350, 22331, 22336, 22351, 22377, 22464, 22408, 22369, 22399, 22409, 22419, 22432, 22451, 22436, 22442, 22448, 22467, 22470, 22484, 22482, 22483, 22538, 22486, 22499, 22539, 22553, 22557, 22642, 22561, 22626, 22603, 22640, 27584, 22610, 22589, 22649, 22661, 22713, 22687, 22699, 22714, 22750, 22715, 22712, 22702, 22725, 22739, 22737, 22743, 22745, 22744, 22757, 22748, 22756, 22751, 22767, 22778, 22777, 22779, 22780, 22781, 22786, 22794, 22800, 22811, 26790, 22821, 22828, 22829, 22834, 22840, 22846, 31442, 22869, 22864, 22862, 22874, 22872, 22882, 22880, 22887, 22892, 22889], \"39744\": [22904, 22913, 22941, 20318, 20395, 22947, 22962, 22982, 23016, 23004, 22925, 23001, 23002, 23077, 23071, 23057, 23068, 23049, 23066, 23104, 23148, 23113, 23093, 23094, 23138, 23146, 23194, 23228, 23230, 23243, 23234, 23229, 23267, 23255, 23270, 23273, 23254, 23290, 23291, 23308, 23307, 23318, 23346, 23248, 23338, 23350, 23358, 23363, 23365, 23360, 23377, 23381, 23386, 23387, 23397, 23401, 23408, 23411, 23413, 23416, 25992, 23418, 23424], \"39808\": [23427, 23462, 23480, 23491, 23495, 23497, 23508, 23504, 23524, 23526, 23522, 23518, 23525, 23531, 23536, 23542, 23539, 23557, 23559, 23560, 23565, 23571, 23584, 23586, 23592, 23608, 23609, 23617, 23622, 23630, 23635, 23632, 23631, 23409, 23660, 23662, 20066, 23670, 23673, 23692, 23697, 23700, 22939, 23723, 23739, 23734, 23740, 23735, 23749, 23742, 23751, 23769, 23785, 23805, 23802, 23789, 23948, 23786, 23819, 23829, 23831, 23900, 23839, 23835, 23825, 23828, 23842, 23834, 23833, 23832, 23884, 23890, 23886, 23883, 23916, 23923, 23926, 23943, 23940, 23938, 23970, 23965, 23980, 23982, 23997, 23952, 23991, 23996, 24009, 24013, 24019, 24018, 24022, 24027, 24043, 24050, 24053, 24075, 24090, 24089, 24081, 24091, 24118, 24119, 24132, 24131, 24128, 24142, 24151, 24148, 24159, 24162, 24164, 24135, 24181, 24182, 24186, 40636, 24191, 24224, 24257, 24258, 24264, 24272, 24271], \"40000\": [24278, 24291, 24285, 24282, 24283, 24290, 24289, 24296, 24297, 24300, 24305, 24307, 24304, 24308, 24312, 24318, 24323, 24329, 24413, 24412, 24331, 24337, 24342, 24361, 24365, 24376, 24385, 24392, 24396, 24398, 24367, 24401, 24406, 24407, 24409, 24417, 24429, 24435, 24439, 24451, 24450, 24447, 24458, 24456, 24465, 24455, 24478, 24473, 24472, 24480, 24488, 24493, 24508, 24534, 24571, 24548, 24568, 24561, 24541, 24755, 24575, 24609, 24672], \"40064\": [24601, 24592, 24617, 24590, 24625, 24603, 24597, 24619, 24614, 24591, 24634, 24666, 24641, 24682, 24695, 24671, 24650, 24646, 24653, 24675, 24643, 24676, 24642, 24684, 24683, 24665, 24705, 24717, 24807, 24707, 24730, 24708, 24731, 24726, 24727, 24722, 24743, 24715, 24801, 24760, 24800, 24787, 24756, 24560, 24765, 24774, 24757, 24792, 24909, 24853, 24838, 24822, 24823, 24832, 24820, 24826, 24835, 24865, 24827, 24817, 24845, 24846, 24903, 24894, 24872, 24871, 24906, 24895, 24892, 24876, 24884, 24893, 24898, 24900, 24947, 24951, 24920, 24921, 24922, 24939, 24948, 24943, 24933, 24945, 24927, 24925, 24915, 24949, 24985, 24982, 24967, 25004, 24980, 24986, 24970, 24977, 25003, 25006, 25036, 25034, 25033, 25079, 25032, 25027, 25030, 25018, 25035, 32633, 25037, 25062, 25059, 25078, 25082, 25076, 25087, 25085, 25084, 25086, 25088, 25096, 25097, 25101, 25100, 25108, 25115], \"40256\": [25118, 25121, 25130, 25134, 25136, 25138, 25139, 25153, 25166, 25182, 25187, 25179, 25184, 25192, 25212, 25218, 25225, 25214, 25234, 25235, 25238, 25300, 25219, 25236, 25303, 25297, 25275, 25295, 25343, 25286, 25812, 25288, 25308, 25292, 25290, 25282, 25287, 25243, 25289, 25356, 25326, 25329, 25383, 25346, 25352, 25327, 25333, 25424, 25406, 25421, 25628, 25423, 25494, 25486, 25472, 25515, 25462, 25507, 25487, 25481, 25503, 25525, 25451], \"40320\": [25449, 25534, 25577, 25536, 25542, 25571, 25545, 25554, 25590, 25540, 25622, 25652, 25606, 25619, 25638, 25654, 25885, 25623, 25640, 25615, 25703, 25711, 25718, 25678, 25898, 25749, 25747, 25765, 25769, 25736, 25788, 25818, 25810, 25797, 25799, 25787, 25816, 25794, 25841, 25831, 33289, 25824, 25825, 25260, 25827, 25839, 25900, 25846, 25844, 25842, 25850, 25856, 25853, 25880, 25884, 25861, 25892, 25891, 25899, 25908, 25909, 25911, 25910, 25912, 30027, 25928, 25942, 25941, 25933, 25944, 25950, 25949, 25970, 25976, 25986, 25987, 35722, 26011, 26015, 26027, 26039, 26051, 26054, 26049, 26052, 26060, 26066, 26075, 26073, 26080, 26081, 26097, 26482, 26122, 26115, 26107, 26483, 26165, 26166, 26164, 26140, 26191, 26180, 26185, 26177, 26206, 26205, 26212, 26215, 26216, 26207, 26210, 26224, 26243, 26248, 26254, 26249, 26244, 26264, 26269, 26305, 26297, 26313, 26302, 26300], \"40512\": [26308, 26296, 26326, 26330, 26336, 26175, 26342, 26345, 26352, 26357, 26359, 26383, 26390, 26398, 26406, 26407, 38712, 26414, 26431, 26422, 26433, 26424, 26423, 26438, 26462, 26464, 26457, 26467, 26468, 26505, 26480, 26537, 26492, 26474, 26508, 26507, 26534, 26529, 26501, 26551, 26607, 26548, 26604, 26547, 26601, 26552, 26596, 26590, 26589, 26594, 26606, 26553, 26574, 26566, 26599, 27292, 26654, 26694, 26665, 26688, 26701, 26674, 26702], \"40576\": [26803, 26667, 26713, 26723, 26743, 26751, 26783, 26767, 26797, 26772, 26781, 26779, 26755, 27310, 26809, 26740, 26805, 26784, 26810, 26895, 26765, 26750, 26881, 26826, 26888, 26840, 26914, 26918, 26849, 26892, 26829, 26836, 26855, 26837, 26934, 26898, 26884, 26839, 26851, 26917, 26873, 26848, 26863, 26920, 26922, 26906, 26915, 26913, 26822, 27001, 26999, 26972, 27000, 26987, 26964, 27006, 26990, 26937, 26996, 26941, 26969, 26928, 26977, 26974, 26973, 27009, 26986, 27058, 27054, 27088, 27071, 27073, 27091, 27070, 27086, 23528, 27082, 27101, 27067, 27075, 27047, 27182, 27025, 27040, 27036, 27029, 27060, 27102, 27112, 27138, 27163, 27135, 27402, 27129, 27122, 27111, 27141, 27057, 27166, 27117, 27156, 27115, 27146, 27154, 27329, 27171, 27155, 27204, 27148, 27250, 27190, 27256, 27207, 27234, 27225, 27238, 27208, 27192, 27170, 27280, 27277, 27296, 27268, 27298, 27299], \"40768\": [27287, 34327, 27323, 27331, 27330, 27320, 27315, 27308, 27358, 27345, 27359, 27306, 27354, 27370, 27387, 27397, 34326, 27386, 27410, 27414, 39729, 27423, 27448, 27447, 30428, 27449, 39150, 27463, 27459, 27465, 27472, 27481, 27476, 27483, 27487, 27489, 27512, 27513, 27519, 27520, 27524, 27523, 27533, 27544, 27541, 27550, 27556, 27562, 27563, 27567, 27570, 27569, 27571, 27575, 27580, 27590, 27595, 27603, 27615, 27628, 27627, 27635, 27631], \"40832\": [40638, 27656, 27667, 27668, 27675, 27684, 27683, 27742, 27733, 27746, 27754, 27778, 27789, 27802, 27777, 27803, 27774, 27752, 27763, 27794, 27792, 27844, 27889, 27859, 27837, 27863, 27845, 27869, 27822, 27825, 27838, 27834, 27867, 27887, 27865, 27882, 27935, 34893, 27958, 27947, 27965, 27960, 27929, 27957, 27955, 27922, 27916, 28003, 28051, 28004, 27994, 28025, 27993, 28046, 28053, 28644, 28037, 28153, 28181, 28170, 28085, 28103, 28134, 28088, 28102, 28140, 28126, 28108, 28136, 28114, 28101, 28154, 28121, 28132, 28117, 28138, 28142, 28205, 28270, 28206, 28185, 28274, 28255, 28222, 28195, 28267, 28203, 28278, 28237, 28191, 28227, 28218, 28238, 28196, 28415, 28189, 28216, 28290, 28330, 28312, 28361, 28343, 28371, 28349, 28335, 28356, 28338, 28372, 28373, 28303, 28325, 28354, 28319, 28481, 28433, 28748, 28396, 28408, 28414, 28479, 28402, 28465, 28399, 28466, 28364], \"57408\": [28478, 28435, 28407, 28550, 28538, 28536, 28545, 28544, 28527, 28507, 28659, 28525, 28546, 28540, 28504, 28558, 28561, 28610, 28518, 28595, 28579, 28577, 28580, 28601, 28614, 28586, 28639, 28629, 28652, 28628, 28632, 28657, 28654, 28635, 28681, 28683, 28666, 28689, 28673, 28687, 28670, 28699, 28698, 28532, 28701, 28696, 28703, 28720, 28734, 28722, 28753, 28771, 28825, 28818, 28847, 28913, 28844, 28856, 28851, 28846, 28895, 28875, 28893], \"57472\": [28889, 28937, 28925, 28956, 28953, 29029, 29013, 29064, 29030, 29026, 29004, 29014, 29036, 29071, 29179, 29060, 29077, 29096, 29100, 29143, 29113, 29118, 29138, 29129, 29140, 29134, 29152, 29164, 29159, 29173, 29180, 29177, 29183, 29197, 29200, 29211, 29224, 29229, 29228, 29232, 29234, 29243, 29244, 29247, 29248, 29254, 29259, 29272, 29300, 29310, 29314, 29313, 29319, 29330, 29334, 29346, 29351, 29369, 29362, 29379, 29382, 29380, 29390, 29394, 29410, 29408, 29409, 29433, 29431, 20495, 29463, 29450, 29468, 29462, 29469, 29492, 29487, 29481, 29477, 29502, 29518, 29519, 40664, 29527, 29546, 29544, 29552, 29560, 29557, 29563, 29562, 29640, 29619, 29646, 29627, 29632, 29669, 29678, 29662, 29858, 29701, 29807, 29733, 29688, 29746, 29754, 29781, 29759, 29791, 29785, 29761, 29788, 29801, 29808, 29795, 29802, 29814, 29822, 29835, 29854, 29863, 29898, 29903, 29908, 29681], \"57664\": [29920, 29923, 29927, 29929, 29934, 29938, 29936, 29937, 29944, 29943, 29956, 29955, 29957, 29964, 29966, 29965, 29973, 29971, 29982, 29990, 29996, 30012, 30020, 30029, 30026, 30025, 30043, 30022, 30042, 30057, 30052, 30055, 30059, 30061, 30072, 30070, 30086, 30087, 30068, 30090, 30089, 30082, 30100, 30106, 30109, 30117, 30115, 30146, 30131, 30147, 30133, 30141, 30136, 30140, 30129, 30157, 30154, 30162, 30169, 30179, 30174, 30206, 30207], \"57728\": [30204, 30209, 30192, 30202, 30194, 30195, 30219, 30221, 30217, 30239, 30247, 30240, 30241, 30242, 30244, 30260, 30256, 30267, 30279, 30280, 30278, 30300, 30296, 30305, 30306, 30312, 30313, 30314, 30311, 30316, 30320, 30322, 30326, 30328, 30332, 30336, 30339, 30344, 30347, 30350, 30358, 30355, 30361, 30362, 30384, 30388, 30392, 30393, 30394, 30402, 30413, 30422, 30418, 30430, 30433, 30437, 30439, 30442, 34351, 30459, 30472, 30471, 30468, 30505, 30500, 30494, 30501, 30502, 30491, 30519, 30520, 30535, 30554, 30568, 30571, 30555, 30565, 30591, 30590, 30585, 30606, 30603, 30609, 30624, 30622, 30640, 30646, 30649, 30655, 30652, 30653, 30651, 30663, 30669, 30679, 30682, 30684, 30691, 30702, 30716, 30732, 30738, 31014, 30752, 31018, 30789, 30862, 30836, 30854, 30844, 30874, 30860, 30883, 30901, 30890, 30895, 30929, 30918, 30923, 30932, 30910, 30908, 30917, 30922, 30956], \"57920\": [30951, 30938, 30973, 30964, 30983, 30994, 30993, 31001, 31020, 31019, 31040, 31072, 31063, 31071, 31066, 31061, 31059, 31098, 31103, 31114, 31133, 31143, 40779, 31146, 31150, 31155, 31161, 31162, 31177, 31189, 31207, 31212, 31201, 31203, 31240, 31245, 31256, 31257, 31264, 31263, 31104, 31281, 31291, 31294, 31287, 31299, 31319, 31305, 31329, 31330, 31337, 40861, 31344, 31353, 31357, 31368, 31383, 31381, 31384, 31382, 31401, 31432, 31408], \"57984\": [31414, 31429, 31428, 31423, 36995, 31431, 31434, 31437, 31439, 31445, 31443, 31449, 31450, 31453, 31457, 31458, 31462, 31469, 31472, 31490, 31503, 31498, 31494, 31539, 31512, 31513, 31518, 31541, 31528, 31542, 31568, 31610, 31492, 31565, 31499, 31564, 31557, 31605, 31589, 31604, 31591, 31600, 31601, 31596, 31598, 31645, 31640, 31647, 31629, 31644, 31642, 31627, 31634, 31631, 31581, 31641, 31691, 31681, 31692, 31695, 31668, 31686, 31709, 31721, 31761, 31764, 31718, 31717, 31840, 31744, 31751, 31763, 31731, 31735, 31767, 31757, 31734, 31779, 31783, 31786, 31775, 31799, 31787, 31805, 31820, 31811, 31828, 31823, 31808, 31824, 31832, 31839, 31844, 31830, 31845, 31852, 31861, 31875, 31888, 31908, 31917, 31906, 31915, 31905, 31912, 31923, 31922, 31921, 31918, 31929, 31933, 31936, 31941, 31938, 31960, 31954, 31964, 31970, 39739, 31983, 31986, 31988, 31990, 31994, 32006], \"58176\": [32002, 32028, 32021, 32010, 32069, 32075, 32046, 32050, 32063, 32053, 32070, 32115, 32086, 32078, 32114, 32104, 32110, 32079, 32099, 32147, 32137, 32091, 32143, 32125, 32155, 32186, 32174, 32163, 32181, 32199, 32189, 32171, 32317, 32162, 32175, 32220, 32184, 32159, 32176, 32216, 32221, 32228, 32222, 32251, 32242, 32225, 32261, 32266, 32291, 32289, 32274, 32305, 32287, 32265, 32267, 32290, 32326, 32358, 32315, 32309, 32313, 32323, 32311], \"58240\": [32306, 32314, 32359, 32349, 32342, 32350, 32345, 32346, 32377, 32362, 32361, 32380, 32379, 32387, 32213, 32381, 36782, 32383, 32392, 32393, 32396, 32402, 32400, 32403, 32404, 32406, 32398, 32411, 32412, 32568, 32570, 32581, 32588, 32589, 32590, 32592, 32593, 32597, 32596, 32600, 32607, 32608, 32616, 32617, 32615, 32632, 32642, 32646, 32643, 32648, 32647, 32652, 32660, 32670, 32669, 32666, 32675, 32687, 32690, 32697, 32686, 32694, 32696, 35697, 32709, 32710, 32714, 32725, 32724, 32737, 32742, 32745, 32755, 32761, 39132, 32774, 32772, 32779, 32786, 32792, 32793, 32796, 32801, 32808, 32831, 32827, 32842, 32838, 32850, 32856, 32858, 32863, 32866, 32872, 32883, 32882, 32880, 32886, 32889, 32893, 32895, 32900, 32902, 32901, 32923, 32915, 32922, 32941, 20880, 32940, 32987, 32997, 32985, 32989, 32964, 32986, 32982, 33033, 33007, 33009, 33051, 33065, 33059, 33071, 33099], \"58432\": [38539, 33094, 33086, 33107, 33105, 33020, 33137, 33134, 33125, 33126, 33140, 33155, 33160, 33162, 33152, 33154, 33184, 33173, 33188, 33187, 33119, 33171, 33193, 33200, 33205, 33214, 33208, 33213, 33216, 33218, 33210, 33225, 33229, 33233, 33241, 33240, 33224, 33242, 33247, 33248, 33255, 33274, 33275, 33278, 33281, 33282, 33285, 33287, 33290, 33293, 33296, 33302, 33321, 33323, 33336, 33331, 33344, 33369, 33368, 33373, 33370, 33375, 33380], \"58496\": [33378, 33384, 33386, 33387, 33326, 33393, 33399, 33400, 33406, 33421, 33426, 33451, 33439, 33467, 33452, 33505, 33507, 33503, 33490, 33524, 33523, 33530, 33683, 33539, 33531, 33529, 33502, 33542, 33500, 33545, 33497, 33589, 33588, 33558, 33586, 33585, 33600, 33593, 33616, 33605, 33583, 33579, 33559, 33560, 33669, 33690, 33706, 33695, 33698, 33686, 33571, 33678, 33671, 33674, 33660, 33717, 33651, 33653, 33696, 33673, 33704, 33780, 33811, 33771, 33742, 33789, 33795, 33752, 33803, 33729, 33783, 33799, 33760, 33778, 33805, 33826, 33824, 33725, 33848, 34054, 33787, 33901, 33834, 33852, 34138, 33924, 33911, 33899, 33965, 33902, 33922, 33897, 33862, 33836, 33903, 33913, 33845, 33994, 33890, 33977, 33983, 33951, 34009, 33997, 33979, 34010, 34000, 33985, 33990, 34006, 33953, 34081, 34047, 34036, 34071, 34072, 34092, 34079, 34069, 34068, 34044, 34112, 34147, 34136, 34120], \"58688\": [34113, 34306, 34123, 34133, 34176, 34212, 34184, 34193, 34186, 34216, 34157, 34196, 34203, 34282, 34183, 34204, 34167, 34174, 34192, 34249, 34234, 34255, 34233, 34256, 34261, 34269, 34277, 34268, 34297, 34314, 34323, 34315, 34302, 34298, 34310, 34338, 34330, 34352, 34367, 34381, 20053, 34388, 34399, 34407, 34417, 34451, 34467, 34473, 34474, 34443, 34444, 34486, 34479, 34500, 34502, 34480, 34505, 34851, 34475, 34516, 34526, 34537, 34540], \"58752\": [34527, 34523, 34543, 34578, 34566, 34568, 34560, 34563, 34555, 34577, 34569, 34573, 34553, 34570, 34612, 34623, 34615, 34619, 34597, 34601, 34586, 34656, 34655, 34680, 34636, 34638, 34676, 34647, 34664, 34670, 34649, 34643, 34659, 34666, 34821, 34722, 34719, 34690, 34735, 34763, 34749, 34752, 34768, 38614, 34731, 34756, 34739, 34759, 34758, 34747, 34799, 34802, 34784, 34831, 34829, 34814, 34806, 34807, 34830, 34770, 34833, 34838, 34837, 34850, 34849, 34865, 34870, 34873, 34855, 34875, 34884, 34882, 34898, 34905, 34910, 34914, 34923, 34945, 34942, 34974, 34933, 34941, 34997, 34930, 34946, 34967, 34962, 34990, 34969, 34978, 34957, 34980, 34992, 35007, 34993, 35011, 35012, 35028, 35032, 35033, 35037, 35065, 35074, 35068, 35060, 35048, 35058, 35076, 35084, 35082, 35091, 35139, 35102, 35109, 35114, 35115, 35137, 35140, 35131, 35126, 35128, 35148, 35101, 35168, 35166], \"58944\": [35174, 35172, 35181, 35178, 35183, 35188, 35191, 35198, 35203, 35208, 35210, 35219, 35224, 35233, 35241, 35238, 35244, 35247, 35250, 35258, 35261, 35263, 35264, 35290, 35292, 35293, 35303, 35316, 35320, 35331, 35350, 35344, 35340, 35355, 35357, 35365, 35382, 35393, 35419, 35410, 35398, 35400, 35452, 35437, 35436, 35426, 35461, 35458, 35460, 35496, 35489, 35473, 35493, 35494, 35482, 35491, 35524, 35533, 35522, 35546, 35563, 35571, 35559], \"59008\": [35556, 35569, 35604, 35552, 35554, 35575, 35550, 35547, 35596, 35591, 35610, 35553, 35606, 35600, 35607, 35616, 35635, 38827, 35622, 35627, 35646, 35624, 35649, 35660, 35663, 35662, 35657, 35670, 35675, 35674, 35691, 35679, 35692, 35695, 35700, 35709, 35712, 35724, 35726, 35730, 35731, 35734, 35737, 35738, 35898, 35905, 35903, 35912, 35916, 35918, 35920, 35925, 35938, 35948, 35960, 35962, 35970, 35977, 35973, 35978, 35981, 35982, 35988, 35964, 35992, 25117, 36013, 36010, 36029, 36018, 36019, 36014, 36022, 36040, 36033, 36068, 36067, 36058, 36093, 36090, 36091, 36100, 36101, 36106, 36103, 36111, 36109, 36112, 40782, 36115, 36045, 36116, 36118, 36199, 36205, 36209, 36211, 36225, 36249, 36290, 36286, 36282, 36303, 36314, 36310, 36300, 36315, 36299, 36330, 36331, 36319, 36323, 36348, 36360, 36361, 36351, 36381, 36382, 36368, 36383, 36418, 36405, 36400, 36404, 36426], \"59200\": [36423, 36425, 36428, 36432, 36424, 36441, 36452, 36448, 36394, 36451, 36437, 36470, 36466, 36476, 36481, 36487, 36485, 36484, 36491, 36490, 36499, 36497, 36500, 36505, 36522, 36513, 36524, 36528, 36550, 36529, 36542, 36549, 36552, 36555, 36571, 36579, 36604, 36603, 36587, 36606, 36618, 36613, 36629, 36626, 36633, 36627, 36636, 36639, 36635, 36620, 36646, 36659, 36667, 36665, 36677, 36674, 36670, 36684, 36681, 36678, 36686, 36695, 36700], \"59264\": [36706, 36707, 36708, 36764, 36767, 36771, 36781, 36783, 36791, 36826, 36837, 36834, 36842, 36847, 36999, 36852, 36869, 36857, 36858, 36881, 36885, 36897, 36877, 36894, 36886, 36875, 36903, 36918, 36917, 36921, 36856, 36943, 36944, 36945, 36946, 36878, 36937, 36926, 36950, 36952, 36958, 36968, 36975, 36982, 38568, 36978, 36994, 36989, 36993, 36992, 37002, 37001, 37007, 37032, 37039, 37041, 37045, 37090, 37092, 25160, 37083, 37122, 37138, 37145, 37170, 37168, 37194, 37206, 37208, 37219, 37221, 37225, 37235, 37234, 37259, 37257, 37250, 37282, 37291, 37295, 37290, 37301, 37300, 37306, 37312, 37313, 37321, 37323, 37328, 37334, 37343, 37345, 37339, 37372, 37365, 37366, 37406, 37375, 37396, 37420, 37397, 37393, 37470, 37463, 37445, 37449, 37476, 37448, 37525, 37439, 37451, 37456, 37532, 37526, 37523, 37531, 37466, 37583, 37561, 37559, 37609, 37647, 37626, 37700, 37678], \"59456\": [37657, 37666, 37658, 37667, 37690, 37685, 37691, 37724, 37728, 37756, 37742, 37718, 37808, 37804, 37805, 37780, 37817, 37846, 37847, 37864, 37861, 37848, 37827, 37853, 37840, 37832, 37860, 37914, 37908, 37907, 37891, 37895, 37904, 37942, 37931, 37941, 37921, 37946, 37953, 37970, 37956, 37979, 37984, 37986, 37982, 37994, 37417, 38000, 38005, 38007, 38013, 37978, 38012, 38014, 38017, 38015, 38274, 38279, 38282, 38292, 38294, 38296, 38297], \"59520\": [38304, 38312, 38311, 38317, 38332, 38331, 38329, 38334, 38346, 28662, 38339, 38349, 38348, 38357, 38356, 38358, 38364, 38369, 38373, 38370, 38433, 38440, 38446, 38447, 38466, 38476, 38479, 38475, 38519, 38492, 38494, 38493, 38495, 38502, 38514, 38508, 38541, 38552, 38549, 38551, 38570, 38567, 38577, 38578, 38576, 38580, 38582, 38584, 38585, 38606, 38603, 38601, 38605, 35149, 38620, 38669, 38613, 38649, 38660, 38662, 38664, 38675, 38670, 38673, 38671, 38678, 38681, 38692, 38698, 38704, 38713, 38717, 38718, 38724, 38726, 38728, 38722, 38729, 38748, 38752, 38756, 38758, 38760, 21202, 38763, 38769, 38777, 38789, 38780, 38785, 38778, 38790, 38795, 38799, 38800, 38812, 38824, 38822, 38819, 38835, 38836, 38851, 38854, 38856, 38859, 38876, 38893, 40783, 38898, 31455, 38902, 38901, 38927, 38924, 38968, 38948, 38945, 38967, 38973, 38982, 38991, 38987, 39019, 39023, 39024], \"59712\": [39025, 39028, 39027, 39082, 39087, 39089, 39094, 39108, 39107, 39110, 39145, 39147, 39171, 39177, 39186, 39188, 39192, 39201, 39197, 39198, 39204, 39200, 39212, 39214, 39229, 39230, 39234, 39241, 39237, 39248, 39243, 39249, 39250, 39244, 39253, 39319, 39320, 39333, 39341, 39342, 39356, 39391, 39387, 39389, 39384, 39377, 39405, 39406, 39409, 39410, 39419, 39416, 39425, 39439, 39429, 39394, 39449, 39467, 39479, 39493, 39490, 39488, 39491], \"59776\": [39486, 39509, 39501, 39515, 39511, 39519, 39522, 39525, 39524, 39529, 39531, 39530, 39597, 39600, 39612, 39616, 39631, 39633, 39635, 39636, 39646, 39647, 39650, 39651, 39654, 39663, 39659, 39662, 39668, 39665, 39671, 39675, 39686, 39704, 39706, 39711, 39714, 39715, 39717, 39719, 39720, 39721, 39722, 39726, 39727, 39730, 39748, 39747, 39759, 39757, 39758, 39761, 39768, 39796, 39827, 39811, 39825, 39830, 39831, 39839, 39840, 39848, 39860, 39872, 39882, 39865, 39878, 39887, 39889, 39890, 39907, 39906, 39908, 39892, 39905, 39994, 39922, 39921, 39920, 39957, 39956, 39945, 39955, 39948, 39942, 39944, 39954, 39946, 39940, 39982, 39963, 39973, 39972, 39969, 39984, 40007, 39986, 40006, 39998, 40026, 40032, 40039, 40054, 40056, 40167, 40172, 40176, 40201, 40200, 40171, 40195, 40198, 40234, 40230, 40367, 40227, 40223, 40260, 40213, 40210, 40257, 40255, 40254, 40262, 40264], \"59968\": [40285, 40286, 40292, 40273, 40272, 40281, 40306, 40329, 40327, 40363, 40303, 40314, 40346, 40356, 40361, 40370, 40388, 40385, 40379, 40376, 40378, 40390, 40399, 40386, 40409, 40403, 40440, 40422, 40429, 40431, 40445, 40474, 40475, 40478, 40565, 40569, 40573, 40577, 40584, 40587, 40588, 40594, 40597, 40593, 40605, 40613, 40617, 40632, 40618, 40621, 38753, 40652, 40654, 40655, 40656, 40660, 40668, 40670, 40669, 40672, 40677, 40680, 40687], \"60032\": [40692, 40694, 40695, 40697, 40699, 40700, 40701, 40711, 40712, 30391, 40725, 40737, 40748, 40766, 40778, 40786, 40788, 40803, 40799, 40800, 40801, 40806, 40807, 40812, 40810, 40823, 40818, 40822, 40853, 40860, 40864, 22575, 27079, 36953, 29796, 20956, 29081], \"60736\": [32394, 35100, 37704, 37512, 34012, 20425, 28859, 26161, 26824, 37625, 26363, 24389, 20008, 20193, 20220, 20224, 20227, 20281, 20310, 20370, 20362, 20378, 20372, 20429, 20544, 20514, 20479, 20510, 20550, 20592, 20546, 20628, 20724, 20696, 20810, 20836, 20893, 20926, 20972, 21013, 21148, 21158, 21184, 21211, 21248, 21255, 21284, 21362, 21395, 21426, 21469, 64014, 21660, 21642, 21673, 21759, 21894, 22361, 22373, 22444, 22472, 22471, 64015], \"60800\": [64016, 22686, 22706, 22795, 22867, 22875, 22877, 22883, 22948, 22970, 23382, 23488, 29999, 23512, 23532, 23582, 23718, 23738, 23797, 23847, 23891, 64017, 23874, 23917, 23992, 23993, 24016, 24353, 24372, 24423, 24503, 24542, 24669, 24709, 24714, 24798, 24789, 24864, 24818, 24849, 24887, 24880, 24984, 25107, 25254, 25589, 25696, 25757, 25806, 25934, 26112, 26133, 26171, 26121, 26158, 26142, 26148, 26213, 26199, 26201, 64018, 26227, 26265, 26272, 26290, 26303, 26362, 26382, 63785, 26470, 26555, 26706, 26560, 26625, 26692, 26831, 64019, 26984, 64020, 27032, 27106, 27184, 27243, 27206, 27251, 27262, 27362, 27364, 27606, 27711, 27740, 27782, 27759, 27866, 27908, 28039, 28015, 28054, 28076, 28111, 28152, 28146, 28156, 28217, 28252, 28199, 28220, 28351, 28552, 28597, 28661, 28677, 28679, 28712, 28805, 28843, 28943, 28932, 29020, 28998, 28999, 64021, 29121, 29182, 29361], \"60992\": [29374, 29476, 64022, 29559, 29629, 29641, 29654, 29667, 29650, 29703, 29685, 29734, 29738, 29737, 29742, 29794, 29833, 29855, 29953, 30063, 30338, 30364, 30366, 30363, 30374, 64023, 30534, 21167, 30753, 30798, 30820, 30842, 31024, 64024, 64025, 64026, 31124, 64027, 31131, 31441, 31463, 64028, 31467, 31646, 64029, 32072, 32092, 32183, 32160, 32214, 32338, 32583, 32673, 64030, 33537, 33634, 33663, 33735, 33782, 33864, 33972, 34131, 34137], \"61056\": [34155, 64031, 34224, 64032, 64033, 34823, 35061, 35346, 35383, 35449, 35495, 35518, 35551, 64034, 35574, 35667, 35711, 36080, 36084, 36114, 36214, 64035, 36559, 64036, 64037, 36967, 37086, 64038, 37141, 37159, 37338, 37335, 37342, 37357, 37358, 37348, 37349, 37382, 37392, 37386, 37434, 37440, 37436, 37454, 37465, 37457, 37433, 37479, 37543, 37495, 37496, 37607, 37591, 37593, 37584, 64039, 37589, 37600, 37587, 37669, 37665, 37627, 64040, 37662, 37631, 37661, 37634, 37744, 37719, 37796, 37830, 37854, 37880, 37937, 37957, 37960, 38290, 63964, 64041, 38557, 38575, 38707, 38715, 38723, 38733, 38735, 38737, 38741, 38999, 39013, 64042, 64043, 39207, 64044, 39326, 39502, 39641, 39644, 39797, 39794, 39823, 39857, 39867, 39936, 40304, 40299, 64045, 40473, 40657], \"61167\": [8560, 8561, 8562, 8563, 8564, 8565, 8566, 8567, 8568, 8569, 65506, 65508, 65287, 65282], \"64064\": [8560, 8561, 8562, 8563, 8564, 8565, 8566, 8567, 8568, 8569, 8544, 8545, 8546, 8547, 8548, 8549, 8550, 8551, 8552, 8553, 65506, 65508, 65287, 65282, 12849, 8470, 8481, 8757, 32394, 35100, 37704, 37512, 34012, 20425, 28859, 26161, 26824, 37625, 26363, 24389, 20008, 20193, 20220, 20224, 20227, 20281, 20310, 20370, 20362, 20378, 20372, 20429, 20544, 20514, 20479, 20510, 20550, 20592, 20546, 20628, 20724, 20696, 20810], \"64128\": [20836, 20893, 20926, 20972, 21013, 21148, 21158, 21184, 21211, 21248, 21255, 21284, 21362, 21395, 21426, 21469, 64014, 21660, 21642, 21673, 21759, 21894, 22361, 22373, 22444, 22472, 22471, 64015, 64016, 22686, 22706, 22795, 22867, 22875, 22877, 22883, 22948, 22970, 23382, 23488, 29999, 23512, 23532, 23582, 23718, 23738, 23797, 23847, 23891, 64017, 23874, 23917, 23992, 23993, 24016, 24353, 24372, 24423, 24503, 24542, 24669, 24709, 24714, 24798, 24789, 24864, 24818, 24849, 24887, 24880, 24984, 25107, 25254, 25589, 25696, 25757, 25806, 25934, 26112, 26133, 26171, 26121, 26158, 26142, 26148, 26213, 26199, 26201, 64018, 26227, 26265, 26272, 26290, 26303, 26362, 26382, 63785, 26470, 26555, 26706, 26560, 26625, 26692, 26831, 64019, 26984, 64020, 27032, 27106, 27184, 27243, 27206, 27251, 27262, 27362, 27364, 27606, 27711, 27740, 27782, 27759, 27866, 27908, 28039, 28015], \"64320\": [28054, 28076, 28111, 28152, 28146, 28156, 28217, 28252, 28199, 28220, 28351, 28552, 28597, 28661, 28677, 28679, 28712, 28805, 28843, 28943, 28932, 29020, 28998, 28999, 64021, 29121, 29182, 29361, 29374, 29476, 64022, 29559, 29629, 29641, 29654, 29667, 29650, 29703, 29685, 29734, 29738, 29737, 29742, 29794, 29833, 29855, 29953, 30063, 30338, 30364, 30366, 30363, 30374, 64023, 30534, 21167, 30753, 30798, 30820, 30842, 31024, 64024, 64025], \"64384\": [64026, 31124, 64027, 31131, 31441, 31463, 64028, 31467, 31646, 64029, 32072, 32092, 32183, 32160, 32214, 32338, 32583, 32673, 64030, 33537, 33634, 33663, 33735, 33782, 33864, 33972, 34131, 34137, 34155, 64031, 34224, 64032, 64033, 34823, 35061, 35346, 35383, 35449, 35495, 35518, 35551, 64034, 35574, 35667, 35711, 36080, 36084, 36114, 36214, 64035, 36559, 64036, 64037, 36967, 37086, 64038, 37141, 37159, 37338, 37335, 37342, 37357, 37358, 37348, 37349, 37382, 37392, 37386, 37434, 37440, 37436, 37454, 37465, 37457, 37433, 37479, 37543, 37495, 37496, 37607, 37591, 37593, 37584, 64039, 37589, 37600, 37587, 37669, 37665, 37627, 64040, 37662, 37631, 37661, 37634, 37744, 37719, 37796, 37830, 37854, 37880, 37937, 37957, 37960, 38290, 63964, 64041, 38557, 38575, 38707, 38715, 38723, 38733, 38735, 38737, 38741, 38999, 39013, 64042, 64043, 39207, 64044, 39326, 39502, 39641], \"64576\": [39644, 39797, 39794, 39823, 39857, 39867, 39936, 40304, 40299, 64045, 40473, 40657]}\nvar decoding_table = [],\n    encoding_table = []\nfor(let cp in cps){\n    cp = parseInt(cp)\n    for(let i = 0, len = cps[cp].length; i < len; i++){\n        let key = cp + i,\n            value = cps[cp][i]\n        decoding_table[key] = value\n        encoding_table[value] = key\n    }\n}\nvar module = {encoding_table, decoding_table}\n__BRYTHON__.addToImported(\"encoding_cp932\", module)\n"], "hashlib": [".js", "(function($B){\n\nvar _b_ = $B.builtins\n\nvar block_size = {\n    md5: 64,\n    sha1: 64,\n    sha224: 64,\n    sha256: 64,\n    sha384: 128,\n    sha512: 128\n}\n\nvar $mod = {\n\n    __getattr__ : function(attr){\n        if(attr == 'new'){\n            return hash.$factory\n        }\n        throw $B.attr_error(attr, $mod)\n    },\n    md5: function(obj){return hash.$factory('md5', obj)},\n    sha1: function(obj){return hash.$factory('sha1', obj)},\n    sha224: function(obj){return hash.$factory('sha224', obj)},\n    sha256: function(obj){return hash.$factory('sha256', obj)},\n    sha384: function(obj){return hash.$factory('sha384', obj)},\n    sha512: function(obj){return hash.$factory('sha512', obj)},\n\n    algorithms_guaranteed: ['md5', 'sha1', 'sha224', 'sha256', 'sha384', 'sha512'],\n    algorithms_available:  ['md5', 'sha1', 'sha224', 'sha256', 'sha384', 'sha512']\n}\n\n//todo: eventually move this function to a \"utility\" file or use ajax module?\nfunction $get_CryptoJS_lib(alg){\n    if($B.VFS !== undefined && $B.VFS.hashlib){\n        // use file in brython_stdlib.js\n        var lib = $B.VFS[\"crypto_js.rollups.\" + alg]\n        if (lib === undefined){\n            throw _b_.ImportError.$factory(\"can't import hashlib.\" + alg)\n        }\n        var res = lib[1]\n        try{\n            eval(res + \"; $B.CryptoJS = CryptoJS;\")\n            return\n        }catch(err){\n            throw Error(\"JS Eval Error\",\n                \"Cannot eval CryptoJS algorithm '\" + alg + \"' : error:\" + err)\n        }\n    }\n\n    var module = {__name__: 'CryptoJS', $is_package: false}\n    var res = $B.$download_module(module, $B.brython_path + 'libs/crypto_js/rollups/' + alg + '.js');\n\n    try{\n        eval(res + \"; $B.CryptoJS = CryptoJS;\")\n    }catch(err){\n        throw Error(\"JS Eval Error\",\n            \"Cannot eval CryptoJS algorithm '\" + alg + \"' : error:\" + err)\n    }\n}\n\nfunction bytes2WordArray(obj){\n    // Transform a bytes object into an instance of class WordArray\n    // defined in CryptoJS\n    if(!$B.$isinstance(obj, _b_.bytes)){\n        throw _b_.TypeError(\"expected bytes, got \" + $B.class_name(obj))\n    }\n\n    var words = []\n    for(var i = 0; i < obj.source.length; i += 4){\n        var word = obj.source.slice(i, i + 4)\n        while(word.length < 4){word.push(0)}\n        var w = word[3] + (word[2] << 8) + (word[1] << 16) + (word[0] << 24)\n        words.push(w)\n    }\n    return {words: words, sigBytes: obj.source.length}\n}\n\nvar hash = {\n    __class__: _b_.type,\n    __mro__: [_b_.object],\n    __qualname__: 'hash',\n    __name__: 'hash'\n}\n\nhash.update = function(self, msg){\n    self.hash.update(bytes2WordArray(msg))\n}\n\nhash.copy = function(self){\n    return self.hash.clone()\n}\n\nhash.digest = function(self){\n    var obj = self.hash.clone().finalize().toString(),\n        res = []\n    for(var i = 0; i < obj.length; i += 2){\n        res.push(parseInt(obj.substr(i, 2), 16))\n    }\n    return _b_.bytes.$factory(res)\n}\n\nhash.hexdigest = function(self) {\n    return self.hash.clone().finalize().toString()\n}\n\nhash.$factory = function(alg, obj) {\n    var res = {\n        __class__: hash\n    }\n\n    switch(alg) {\n      case 'md5':\n      case 'sha1':\n      case 'sha224':\n      case 'sha256':\n      case 'sha384':\n      case 'sha512':\n        var ALG = alg.toUpperCase()\n        if($B.Crypto === undefined ||\n            $B.CryptoJS.algo[ALG] === undefined){$get_CryptoJS_lib(alg)}\n\n        res.hash = $B.CryptoJS.algo[ALG].create()\n        if(obj !== undefined){\n            res.hash.update(bytes2WordArray(obj))\n        }\n        break\n      default:\n        throw $B.builtins.AttributeError.$factory('Invalid hash algorithm: ' + alg)\n    }\n    res.digest_size = res.hash._hash.sigBytes\n    res.block_size = block_size[alg]\n    return res\n}\n\n$B.addToImported('hashlib', $mod)\n\n})(__BRYTHON__)\n"], "html_parser": [".js", "(function($B){\n\n_b_ = $B.builtins\n\nvar ELEMENT_NODE = 1,\n    TEXT_NODE = 3,\n    COMMENT_NODE =    8,\n    DOCUMENT_TYPE_NODE =    10\n\nvar HTMLNode = $B.make_class(\"HTMLNode\",\n    function(){\n        return {\n            __class__: HTMLNode,\n            nodeType: TEXT_NODE,\n            text: \"\"\n        }\n    }\n)\n\nHTMLNode.__str__ = function(self){\n    return self.text\n}\n\n$B.set_func_names(HTMLNode, \"_html_parser\")\n\nfunction* tokenize(src){\n    var node = HTMLNode.$factory(),\n        pos = 0,\n        tag = \"\",\n        type = \"text\"\n    while(pos < src.length){\n        var char = src[pos]\n        switch(type){\n            case \"text\":\n                if(char == \"<\"){\n                    // starts a tag if immediately followed by a letter or by /\n                    var tag_mo = /^(\\/?)[a-zA-Z]+/.exec(src.substr(pos + 1))\n                    if(tag_mo){\n                        yield node\n                        node = HTMLNode.$factory()\n                        type = \"tag\"\n                        node.tagName = \"\"\n                        node.nodeType = ELEMENT_NODE\n                        node.closing = tag_mo[1] != \"\"\n                        node.attrs = []\n                    }else{\n                        // doctype declaration\n                        var decl_mo = /^<!doctype\\s+(.*?)>/i.exec(src.substr(pos))\n                        if(decl_mo){\n                            yield node\n                            node = HTMLNode.$factory()\n                            node.text = decl_mo[0]\n                            node.doctype = decl_mo[1]\n                            node.nodeType = DOCUMENT_TYPE_NODE\n                            yield node\n                            node = HTMLNode.$factory()\n                            type = \"text\"\n                            pos += decl_mo[0].length\n                            break\n                        }else{\n                            // comment\n                            var comment_mo = /^\\<!(.*?)>/.exec(src.substr(pos))\n                            if(comment_mo){\n                                yield node\n                                node = HTMLNode.$factory()\n                                node.text = comment_mo[0]\n                                node.comment = comment_mo[1]\n                                node.nodeType = COMMENT_NODE\n                                yield node\n                                node = HTMLNode.$factory()\n                                type = \"text\"\n                                pos += comment_mo[0].length\n                                break\n                            }\n                        }\n                    }\n                }\n                pos++\n                node.text += char\n                break\n            case \"tag\":\n                if(char.search(/[_a-zA-Z]/) > -1){\n                    var mo = /\\w+/.exec(src.substr(pos))\n                    if(mo !== null){\n                        pos += mo[0].length\n                        if(node.tagName == \"\"){\n                            node.tagName = mo[0].toUpperCase()\n                        }\n                        node.text += mo[0]\n                    }else{\n                        pos++\n                    }\n                }else if(char == \">\"){\n                    node.text += char\n                    yield node\n                    node = HTMLNode.$factory()\n                    type = \"text\"\n                    pos++\n                }else if(char == \"=\"){\n                    node.text += char\n                    pos++\n                }else if(char == \"'\" || char == '\"'){\n                    var i = pos + 1,\n                        found_string_end = false\n                    while(i < src.length){\n                        if(src[i] == char){\n                            var nb_escape = 0\n                            while(src[i - 1 - nb_escape] == '/'){\n                                nb_escape++\n                            }\n                            if(nb_escape % 2 == 0){\n                                node.text += src.substr(pos, i + 1 - pos)\n                                pos = i + 1\n                                found_string_end = true\n                                break\n                            }else{\n                                i++\n                            }\n                        }else if(src[i] == '>'){\n                            break\n                        }else{\n                            i++\n                        }\n                    }\n                    if(! found_string_end){\n                        // unterminated string: ignore\n                        pos++\n                    }\n                }else{\n                    node.text += char\n                    pos++\n                }\n                break\n            default:\n                pos++\n        }\n    }\n    yield node\n}\nvar module = {\n    ELEMENT_NODE: 1,\n    TEXT_NODE: 3,\n    COMMENT_NODE:    8,\n    DOCUMENT_TYPE_NODE:    10,\n    tokenize: tokenize\n}\n\n$B.addToImported('html_parser', module)\n\n})(__BRYTHON__)\n"], "marshal": [".js", "(function($B){\n\nvar _b_ = $B.builtins\n\nvar module = {\n    loads: function(){\n        var $ = $B.args('loads', 1, {obj:null}, ['obj'], arguments, {},\n            null, null)\n        return $B.structuredclone2pyobj(JSON.parse($.obj))\n    },\n    load: function(){\n        var $ = $B.args('load', 1, {file:null}, ['file'], arguments, {},\n            null, null)\n        var content = $B.$call($B.$getattr($.file, \"read\"))()\n        return $module.loads(_b_.bytes.decode(content, \"latin-1\"));\n    },\n    dump: function(){\n        var $ = $B.args('dump', 2, {value:null, file: null},\n            ['value', 'file'], arguments, {}, null, null)\n        var s = JSON.stringify($B.pyobj2structuredclone($.value))\n        $B.$getattr($.file, \"write\")(_b_.str.encode(s, 'latin-1'))\n        var flush = $B.$getattr($.file, \"flush\", null)\n        if(flush !== null){\n            $B.$call(flush)()\n        }\n        return _b_.None\n    },\n    dumps: function(){\n        var $ = $B.args('dumps', 1, {obj:null}, ['obj'], arguments, {},\n            null, null)\n        return JSON.stringify($B.pyobj2structuredclone($.obj))\n    }\n}\n\n$B.addToImported('marshal', module)\n\n})(__BRYTHON__)\n"], "math": [".js", "(function($B){\n\nvar _b_ = $B.builtins\n\nconst INF = $B.fast_float(Number.POSITIVE_INFINITY),\n      NINF = $B.fast_float(Number.NEGATIVE_INFINITY),\n      ZERO = $B.fast_float(0),\n      NAN = $B.fast_float(Number.NaN)\n\nvar float_check = function(x) {\n    // Returns a Javascript number\n    if(x.__class__ === $B.long_int){\n        var res = parseInt(x.value)\n        if(! isFinite(res)){\n            throw _b_.OverflowError.$factory('int too big for float')\n        }\n        return res\n    }else if(x.__class__ === _b_.float){\n        return x.value\n    }\n    try{\n        return _b_.float.$factory(x).value\n    }catch(err){\n        throw _b_.TypeError.$factory('must be real number, not ' +\n            $B.class_name(x))\n    }\n}\n\nfunction check_int(x){\n    if(! $B.$isinstance(x, _b_.int)){\n        throw _b_.TypeError.$factory(\"'\" + $B.class_name(x) +\n            \"' object cannot be interpreted as an integer\")\n    }\n}\n\nfunction check_int_or_round_float(x){\n    return ($B.$isinstance(x, _b_.float) && Number.isInteger(x.value)) ||\n            $B.$isinstance(x, _b_.int)\n}\n\nvar isWholeNumber = function(x){return (x * 10) % 10 == 0}\n\nvar isOdd = function(x) {return isWholeNumber(x) && 2 * Math.floor(x / 2) != x}\n\nvar isNegZero = function(x) {return x === 0 && Math.atan2(x,x) < 0}\n\nfunction overflow(){\n    throw _b_.OverflowError.$factory(\"math range error\")\n}\n\nfunction value_error(){\n    throw _b_.ValueError.$factory(\"math range error\")\n}\n\nvar EPSILON = Math.pow(2, -52),\n    MAX_VALUE = (2 - EPSILON) * Math.pow(2, 1023),\n    MIN_VALUE = Math.pow(2, -1022),\n    Py_HUGE_VAL = Number.POSITIVE_INFINITY,\n    logpi = 1.144729885849400174143427351353058711647,\n    sqrtpi = 1.772453850905516027298167483341145182798\n\nfunction nextUp(x){\n    if(x !== x){ // NaN\n        return x\n    }\n    if(_b_.float.$funcs.isinf(x)){\n        if(_b_.float.$funcs.isninf(x)){\n            return -MAX_VALUE\n        }\n        return _mod.inf\n    }\n    if($B.$isinstance(x, $B.long_int)){\n        x = Number(x.value)\n    }else if($B.$isinstance(x, _b_.float)){\n        x = x.value\n    }\n\n    if(x == +MAX_VALUE){\n        return +1 / 0\n    }\n    if(typeof x == \"number\"){\n        var y = x * (x < 0 ? 1 - EPSILON / 2 : 1 + EPSILON)\n        if(y == x){\n            y = MIN_VALUE * EPSILON > 0 ? x + MIN_VALUE * EPSILON : x + MIN_VALUE\n        }\n        if(y === +1 / 0){\n            y = +MAX_VALUE\n        }\n        var b = x + (y - x) / 2\n        if(x < b && b < y){\n            y = b;\n        }\n        var c = (y + x) / 2\n        if(x < c && c < y){\n            y = c;\n        }\n        return y === 0 ? -0 : y\n    }else{\n        var factor = $B.rich_comp('__lt__', x, 0) ? 1 - EPSILON / 2 :\n                                                   1 + EPSILON\n        var y = $B.rich_op(\"__mul__\", x , factor)\n        if(y == x){\n            y = MIN_VALUE * EPSILON > 0 ?\n                    $B.rich_op('__add__', x, MIN_VALUE * EPSILON) :\n                    $B.rich_op('__add__', x, MIN_VALUE)\n        }\n        if(y === +1 / 0){\n            y = +MAX_VALUE\n        }\n        var y_minus_x = $B.rich_op('__sub__', y, x)\n        var z = $B.rich_op('__truediv__', y_minus_x, 2) // (y - x) / 2\n\n        var b = $B.rich_op('__add__', x, z)\n        if($B.rich_comp('__lt__', x, b) && $B.rich_comp('__lt__', b, y)){\n            y = b;\n        }\n        var c = $B.rich_op('__truediv__', $B.rich_op('__add__', y, x), 2)\n        if($B.rich_comp('__lt__', x, c) && $B.rich_comp('__lt__', c, y)){\n            y = c;\n        }\n        return y === 0 ? -0 : y\n    }\n}\n\nfunction gcd2(a, b){\n    // GCD of 2 factors\n    if($B.rich_comp(\"__gt__\", b, a)){\n        var temp = a\n        a = b\n        b = temp\n    }\n    while(true){\n        if(b == 0){\n            return a\n        }\n        a = $B.rich_op(\"__mod__\", a, b)\n        if(a == 0){\n            return b\n        }\n        b = $B.rich_op(\"__mod__\", b, a)\n    }\n}\n\nconst LANCZOS_N = 13,\n      lanczos_g = 6.024680040776729583740234375,\n      lanczos_g_minus_half = 5.524680040776729583740234375,\n      lanczos_num_coeffs = [\n    23531376880.410759688572007674451636754734846804940,\n    42919803642.649098768957899047001988850926355848959,\n    35711959237.355668049440185451547166705960488635843,\n    17921034426.037209699919755754458931112671403265390,\n    6039542586.3520280050642916443072979210699388420708,\n    1439720407.3117216736632230727949123939715485786772,\n    248874557.86205415651146038641322942321632125127801,\n    31426415.585400194380614231628318205362874684987640,\n    2876370.6289353724412254090516208496135991145378768,\n    186056.26539522349504029498971604569928220784236328,\n    8071.6720023658162106380029022722506138218516325024,\n    210.82427775157934587250973392071336271166969580291,\n    2.5066282746310002701649081771338373386264310793408\n    ],\n    /* denominator is x*(x+1)*...*(x+LANCZOS_N-2) */\n    lanczos_den_coeffs = [\n    0.0, 39916800.0, 120543840.0, 150917976.0, 105258076.0, 45995730.0,\n    13339535.0, 2637558.0, 357423.0, 32670.0, 1925.0, 66.0, 1.0],\n    /* gamma values for small positive integers, 1 though NGAMMA_INTEGRAL */\n    NGAMMA_INTEGRAL = 23,\n    gamma_integral = [\n    1.0, 1.0, 2.0, 6.0, 24.0, 120.0, 720.0, 5040.0, 40320.0, 362880.0,\n    3628800.0, 39916800.0, 479001600.0, 6227020800.0, 87178291200.0,\n    1307674368000.0, 20922789888000.0, 355687428096000.0,\n    6402373705728000.0, 121645100408832000.0, 2432902008176640000.0,\n    51090942171709440000.0, 1124000727777607680000.0]\n\n/* Lanczos' sum L_g(x), for positive x */\nfunction lanczos_sum(x){\n    var num = 0.0,\n        den = 0.0,\n        i\n    /* evaluate the rational function lanczos_sum(x).  For large\n       x, the obvious algorithm risks overflow, so we instead\n       rescale the denominator and numerator of the rational\n       function by x**(1-LANCZOS_N) and treat this as a\n       rational function in 1/x.  This also reduces the error for\n       larger x values.  The choice of cutoff point (5.0 below) is\n       somewhat arbitrary; in tests, smaller cutoff values than\n       this resulted in lower accuracy. */\n    if (x < 5.0) {\n        for (i = LANCZOS_N; --i >= 0; ) {\n            num = num * x + lanczos_num_coeffs[i];\n            den = den * x + lanczos_den_coeffs[i];\n        }\n    }else{\n        for (i = 0; i < LANCZOS_N; i++) {\n            num = num / x + lanczos_num_coeffs[i];\n            den = den / x + lanczos_den_coeffs[i];\n        }\n    }\n    return num/den;\n}\n\nfunction m_sinpi(x){\n    // x is float\n    // returns a float\n    var r,\n        y = fmod(fabs(x), 2.0), // float\n        n = _b_.round($B.fast_float(2.0 * y.value)) // int\n    switch(n){\n        case 0:\n            r = sin(pi.value * y.value);\n            break;\n        case 1:\n            r = cos(pi.value * (y.value - 0.5));\n            break;\n        case 2:\n            /* N.B. -sin(pi*(y-1.0)) is *not* equivalent: it would give\n               -0.0 instead of 0.0 when y == 1.0. */\n            r = sin(pi.value * (1.0 - y.value));\n            break;\n        case 3:\n            r = _b_.float.__neg__(cos(pi.value *(y.value - 1.5)))\n            break;\n        case 4:\n            r = sin(pi.value * (y.value - 2.0));\n            break;\n        }\n    return $B.fast_float(copysign(1.0, x).value * r.value);\n}\n\n/*\n   lgamma:  natural log of the absolute value of the Gamma function.\n   For large arguments, Lanczos' formula works extremely well here.\n*/\nfunction m_lgamma(x){\n    var r,\n        absx\n\n    /* special cases */\n    if(! isfinite(x)){\n        if(isnan(x)){\n            return x;  /* lgamma(nan) = nan */\n        }else{\n            return $B.fast_float(Number.POSITIVE_INFINITY); /* lgamma(+-inf) = +inf */\n        }\n    }\n\n    /* integer arguments */\n    var x1 = float_check(x)\n    if(Number.isInteger(x1) && x1 <= 2.0){\n        if(x1 <= 0.0){\n            value_error()\n        }else{\n            return $B.fast_float(0.0); /* lgamma(1) = lgamma(2) = 0.0 */\n        }\n    }\n\n    absx = fabs(x)\n    /* tiny arguments: lgamma(x) ~ -log(fabs(x)) for small x */\n    if (absx.value < 1e-20){\n        return  $B.fast_float(-log(absx).value);\n    }\n    /* Lanczos' formula.  We could save a fraction of a ulp in accuracy by\n       having a second set of numerator coefficients for lanczos_sum that\n       absorbed the exp(-lanczos_g) term, and throwing out the lanczos_g\n       subtraction below; it's probably not worth it. */\n    var lsum = $B.fast_float(lanczos_sum(absx.value))\n    r = log(lsum).value - lanczos_g;\n    r += (absx.value - 0.5) *\n        (log($B.fast_float(absx.value + lanczos_g - 0.5)).value - 1)\n    if (x1 < 0.0){\n        /* Use reflection formula to get value for negative x. */\n        r = logpi - log(fabs(m_sinpi(absx))).value - log(absx).value - r\n    }\n    r = $B.fast_float(r)\n    if(isinf(r)){\n        overflow()\n    }\n    return r;\n}\n\nfunction acos(x){\n    $B.check_nb_args('acos', 1, arguments)\n    $B.check_no_kw('acos', x)\n    if(_mod.isinf(x)){\n        throw _b_.ValueError.$factory(\"math domain error\")\n    }else if(_mod.isnan(x)){\n        return _mod.nan\n    }else{\n        x = float_check(x)\n        if(x > 1 || x < -1){\n            throw _b_.ValueError.$factory(\"math domain error\")\n        }\n        return _b_.float.$factory(Math.acos(x))\n    }\n}\n\nfunction acosh(x){\n    $B.check_nb_args('acosh', 1, arguments)\n    $B.check_no_kw('acosh', x)\n\n    if(_b_.float.$funcs.isinf(x)){\n        if(_b_.float.$funcs.isninf(x)){\n            throw _b_.ValueError.$factory(\"math domain error\")\n        }\n        return _mod.inf\n    }else if(_mod.isnan(x)){\n        return _mod.nan\n    }\n    var y = float_check(x)\n    if(y <= 0){\n        throw _b_.ValueError.$factory(\"math domain error\")\n    }\n    if(y > Math.pow(2, 28)){ // issue 1590\n        return _b_.float.$factory(_mod.log(y).value + _mod.log(2).value)\n    }\n    return _b_.float.$factory(Math.log(y + Math.sqrt(y * y - 1)))\n}\n\nfunction asin(x){\n    $B.check_nb_args('asin', 1, arguments)\n    $B.check_no_kw('asin', x)\n    if(_mod.isinf(x)){\n        throw _b_.ValueError.$factory(\"math domain error\")\n    }else if(_mod.isnan(x)){\n        return _mod.nan\n    }else{\n        x = float_check(x)\n        if(x > 1 || x < -1){\n            throw _b_.ValueError.$factory(\"math domain error\")\n        }\n        return _b_.float.$factory(Math.asin(x))\n    }\n}\n\nfunction asinh(x){\n    $B.check_nb_args('asinh', 1, arguments)\n    $B.check_no_kw('asinh', x)\n\n    var y = float_check(x)\n    if(_b_.float.$funcs.isninf(x)){\n        return NINF\n    }else if(_b_.float.$funcs.isinf(x)){\n        return INF\n    }\n    if(y == 0 && 1 / y === -Infinity){\n        return $B.fast_float(-0.0)\n    }\n    return _b_.float.$factory(Math.asinh(y))\n}\n\nfunction atan(x){\n    $B.check_nb_args('atan', 1, arguments)\n    $B.check_no_kw('atan', x)\n\n    if(_b_.float.$funcs.isninf(x)){return _b_.float.$factory(-Math.PI / 2)}\n    if(_b_.float.$funcs.isinf(x)){return _b_.float.$factory(Math.PI / 2)}\n    return _b_.float.$factory(Math.atan(float_check(x)))\n}\n\nfunction atan2(x, y){\n    $B.check_nb_args('atan2', 2, arguments)\n    $B.check_no_kw('atan2', x, y)\n\n    return _b_.float.$factory(Math.atan2(float_check(x), float_check(y)))\n}\n\nfunction atanh(x){\n    $B.check_nb_args('atanh', 1, arguments)\n    $B.check_no_kw('atanh', x)\n    if(_b_.float.$funcs.isinf(x)){\n        throw _b_.ValueError.$factory(\"math domain error\")\n    }\n    var y = float_check(x)\n    if(y == 0){\n        return 0\n    }else if(y <= -1 || y >= 1){\n        throw _b_.ValueError.$factory(\"math domain error\")\n    }\n    return _b_.float.$factory(0.5 * Math.log((1 / y + 1)/(1 / y - 1)));\n}\n\nfunction cbrt(x){\n    // Cubic root\n    $B.check_nb_args('cbrt ', 1, arguments)\n    $B.check_no_kw('cbrt ', x)\n\n    var y = float_check(x)\n    if(_b_.float.$funcs.isninf(x)){\n        return NINF\n    }else if(_b_.float.$funcs.isinf(x)){\n        return INF\n    }\n    var _r = $B.fast_float(Math.cbrt(y))\n    if(_b_.float.$funcs.isinf(_r)){\n        throw _b_.OverflowError.$factory(\"math range error\")\n    }\n    return _r\n}\n\nfunction ceil(x){\n    $B.check_nb_args('ceil', 1, arguments)\n    $B.check_no_kw('ceil', x)\n\n    var res\n\n    if($B.$isinstance(x, _b_.float)){\n        if(_b_.float.$funcs.isinf(x)){\n            throw _b_.OverflowError.$factory(\n                \"cannot convert float infinity to integer\")\n        }else if(_mod.isnan(x)){\n            throw _b_.OverflowError.$factory(\n                \"cannot convert float NaN to integer\")\n        }\n    }\n\n    var klass = x.__class__ || $B.get_class(x)\n\n    try{\n        // Use attribute of the object's class, not of the object\n        // itself (special method)\n        return $B.$call($B.$getattr(klass, '__ceil__'))(x)\n    }catch(err){\n        if(! $B.is_exc(err, [_b_.AttributeError])){\n            throw err\n        }\n    }\n\n    try{\n        x = $B.$call($B.$getattr(klass, '__float__'))(x)\n    }catch(err){\n        if(! $B.is_exc(err, [_b_.AttributeError])){\n            throw err\n        }else{\n            throw _b_.TypeError.$factory(\"must be real number, not \" +\n               $B.class_name(x))\n        }\n    }\n    return _mod.ceil(x)\n}\n\nconst ULLONG_MAX = 2n ** 64n - 1n,\n      LONG_MAX = 2147483647,\n      LONG_MIN = -2147483647,\n      LLONG_MAX = 9223372036854775807n,\n      LLONG_MIN = -9223372036854775807n,\n      p2_64 = 2n ** 64n\n\nconst reduced_factorial_odd_part = [\n    0x0000000000000001n, 0x0000000000000001n, 0x0000000000000001n, 0x0000000000000003n,\n    0x0000000000000003n, 0x000000000000000fn, 0x000000000000002dn, 0x000000000000013bn,\n    0x000000000000013bn, 0x0000000000000b13n, 0x000000000000375fn, 0x0000000000026115n,\n    0x000000000007233fn, 0x00000000005cca33n, 0x0000000002898765n, 0x00000000260eeeebn,\n    0x00000000260eeeebn, 0x0000000286fddd9bn, 0x00000016beecca73n, 0x000001b02b930689n,\n    0x00000870d9df20adn, 0x0000b141df4dae31n, 0x00079dd498567c1bn, 0x00af2e19afc5266dn,\n    0x020d8a4d0f4f7347n, 0x335281867ec241efn, 0x9b3093d46fdd5923n, 0x5e1f9767cc5866b1n,\n    0x92dd23d6966aced7n, 0xa30d0f4f0a196e5bn, 0x8dc3e5a1977d7755n, 0x2ab8ce915831734bn,\n    0x2ab8ce915831734bn, 0x81d2a0bc5e5fdcabn, 0x9efcac82445da75bn, 0xbc8b95cf58cde171n,\n    0xa0e8444a1f3cecf9n, 0x4191deb683ce3ffdn, 0xddd3878bc84ebfc7n, 0xcb39a64b83ff3751n,\n    0xf8203f7993fc1495n, 0xbd2a2a78b35f4bddn, 0x84757be6b6d13921n, 0x3fbbcfc0b524988bn,\n    0xbd11ed47c8928df9n, 0x3c26b59e41c2f4c5n, 0x677a5137e883fdb3n, 0xff74e943b03b93ddn,\n    0xfe5ebbcb10b2bb97n, 0xb021f1de3235e7e7n, 0x33509eb2e743a58fn, 0x390f9da41279fb7dn,\n    0xe5cb0154f031c559n, 0x93074695ba4ddb6dn, 0x81c471caa636247fn, 0xe1347289b5a1d749n,\n    0x286f21c3f76ce2ffn, 0x00be84a2173e8ac7n, 0x1595065ca215b88bn, 0xf95877595b018809n,\n    0x9c2efe3c5516f887n, 0x373294604679382bn, 0xaf1ff7a888adcd35n, 0x18ddf279a2c5800bn,\n    0x18ddf279a2c5800bn, 0x505a90e2542582cbn, 0x5bacad2cd8d5dc2bn, 0xfe3152bcbff89f41n,\n    0xe1467e88bf829351n, 0xb8001adb9e31b4d5n, 0x2803ac06a0cbb91fn, 0x1904b5d698805799n,\n    0xe12a648b5c831461n, 0x3516abbd6160cfa9n, 0xac46d25f12fe036dn, 0x78bfa1da906b00efn,\n    0xf6390338b7f111bdn, 0x0f25f80f538255d9n, 0x4ec8ca55b8db140fn, 0x4ff670740b9b30a1n,\n    0x8fd032443a07f325n, 0x80dfe7965c83eeb5n, 0xa3dc1714d1213afdn, 0x205b7bbfcdc62007n,\n    0xa78126bbe140a093n, 0x9de1dc61ca7550cfn, 0x84f0046d01b492c5n, 0x2d91810b945de0f3n,\n    0xf5408b7f6008aa71n, 0x43707f4863034149n, 0xdac65fb9679279d5n, 0xc48406e7d1114eb7n,\n    0xa7dc9ed3c88e1271n, 0xfb25b2efdb9cb30dn, 0x1bebda0951c4df63n, 0x5c85e975580ee5bdn,\n    0x1591bc60082cb137n, 0x2c38606318ef25d7n, 0x76ca72f7c5c63e27n, 0xf04a75d17baa0915n,\n    0x77458175139ae30dn, 0x0e6c1330bc1b9421n, 0xdf87d2b5797e8293n, 0xefa5c703e1e68925n,\n    0x2b6b1b3278b4f6e1n, 0xceee27b382394249n, 0xd74e3829f5dab91dn, 0xfdb17989c26b5f1fn,\n    0xc1b7d18781530845n, 0x7b4436b2105a8561n, 0x7ba7c0418372a7d7n, 0x9dbc5c67feb6c639n,\n    0x502686d7f6ff6b8fn, 0x6101855406be7a1fn, 0x9956afb5806930e7n, 0xe1f0ee88af40f7c5n,\n    0x984b057bda5c1151n, 0x9a49819acc13ea05n, 0x8ef0dead0896ef27n, 0x71f7826efe292b21n,\n    0xad80a480e46986efn, 0x01cdc0ebf5e0c6f7n, 0x6e06f839968f68dbn, 0xdd5943ab56e76139n,\n    0xcdcf31bf8604c5e7n, 0x7e2b4a847054a1cbn, 0x0ca75697a4d3d0f5n, 0x4703f53ac514a98bn,\n];\n\nconst inverted_factorial_odd_part = [\n    0x0000000000000001n, 0x0000000000000001n, 0x0000000000000001n, 0xaaaaaaaaaaaaaaabn,\n    0xaaaaaaaaaaaaaaabn, 0xeeeeeeeeeeeeeeefn, 0x4fa4fa4fa4fa4fa5n, 0x2ff2ff2ff2ff2ff3n,\n    0x2ff2ff2ff2ff2ff3n, 0x938cc70553e3771bn, 0xb71c27cddd93e49fn, 0xb38e3229fcdee63dn,\n    0xe684bb63544a4cbfn, 0xc2f684917ca340fbn, 0xf747c9cba417526dn, 0xbb26eb51d7bd49c3n,\n    0xbb26eb51d7bd49c3n, 0xb0a7efb985294093n, 0xbe4b8c69f259eabbn, 0x6854d17ed6dc4fb9n,\n    0xe1aa904c915f4325n, 0x3b8206df131cead1n, 0x79c6009fea76fe13n, 0xd8c5d381633cd365n,\n    0x4841f12b21144677n, 0x4a91ff68200b0d0fn, 0x8f9513a58c4f9e8bn, 0x2b3e690621a42251n,\n    0x4f520f00e03c04e7n, 0x2edf84ee600211d3n, 0xadcaa2764aaacdfdn, 0x161f4f9033f4fe63n,\n    0x161f4f9033f4fe63n, 0xbada2932ea4d3e03n, 0xcec189f3efaa30d3n, 0xf7475bb68330bf91n,\n    0x37eb7bf7d5b01549n, 0x46b35660a4e91555n, 0xa567c12d81f151f7n, 0x4c724007bb2071b1n,\n    0x0f4a0cce58a016bdn, 0xfa21068e66106475n, 0x244ab72b5a318ae1n, 0x366ce67e080d0f23n,\n    0xd666fdae5dd2a449n, 0xd740ddd0acc06a0dn, 0xb050bbbb28e6f97bn, 0x70b003fe890a5c75n,\n    0xd03aabff83037427n, 0x13ec4ca72c783bd7n, 0x90282c06afdbd96fn, 0x4414ddb9db4a95d5n,\n    0xa2c68735ae6832e9n, 0xbf72d71455676665n, 0xa8469fab6b759b7fn, 0xc1e55b56e606caf9n,\n    0x40455630fc4a1cffn, 0x0120a7b0046d16f7n, 0xa7c3553b08faef23n, 0x9f0bfd1b08d48639n,\n    0xa433ffce9a304d37n, 0xa22ad1d53915c683n, 0xcb6cbc723ba5dd1dn, 0x547fb1b8ab9d0ba3n,\n    0x547fb1b8ab9d0ba3n, 0x8f15a826498852e3n, 0x32e1a03f38880283n, 0x3de4cce63283f0c1n,\n    0x5dfe6667e4da95b1n, 0xfda6eeeef479e47dn, 0xf14de991cc7882dfn, 0xe68db79247630ca9n,\n    0xa7d6db8207ee8fa1n, 0x255e1f0fcf034499n, 0xc9a8990e43dd7e65n, 0x3279b6f289702e0fn,\n    0xe7b5905d9b71b195n, 0x03025ba41ff0da69n, 0xb7df3d6d3be55aefn, 0xf89b212ebff2b361n,\n    0xfe856d095996f0adn, 0xd6e533e9fdf20f9dn, 0xf8c0e84a63da3255n, 0xa677876cd91b4db7n,\n    0x07ed4f97780d7d9bn, 0x90a8705f258db62fn, 0xa41bbb2be31b1c0dn, 0x6ec28690b038383bn,\n    0xdb860c3bb2edd691n, 0x0838286838a980f9n, 0x558417a74b36f77dn, 0x71779afc3646ef07n,\n    0x743cda377ccb6e91n, 0x7fdf9f3fe89153c5n, 0xdc97d25df49b9a4bn, 0x76321a778eb37d95n,\n    0x7cbb5e27da3bd487n, 0x9cff4ade1a009de7n, 0x70eb166d05c15197n, 0xdcf0460b71d5fe3dn,\n    0x5ac1ee5260b6a3c5n, 0xc922dedfdd78efe1n, 0xe5d381dc3b8eeb9bn, 0xd57e5347bafc6aadn,\n    0x86939040983acd21n, 0x395b9d69740a4ff9n, 0x1467299c8e43d135n, 0x5fe440fcad975cdfn,\n    0xcaa9a39794a6ca8dn, 0xf61dbd640868dea1n, 0xac09d98d74843be7n, 0x2b103b9e1a6b4809n,\n    0x2ab92d16960f536fn, 0x6653323d5e3681dfn, 0xefd48c1c0624e2d7n, 0xa496fefe04816f0dn,\n    0x1754a7b07bbdd7b1n, 0x23353c829a3852cdn, 0xbf831261abd59097n, 0x57a8e656df0618e1n,\n    0x16e9206c3100680fn, 0xadad4c6ee921dac7n, 0x635f2b3860265353n, 0xdd6d0059f44b3d09n,\n    0xac4dd6b894447dd7n, 0x42ea183eeaa87be3n, 0x15612d1550ee5b5dn, 0x226fa19d656cb623n,\n]\n\nconst factorial_trailing_zeros = [\n     0,  0,  1,  1,  3,  3,  4,  4,  7,  7,  8,  8, 10, 10, 11, 11,  //  0-15\n    15, 15, 16, 16, 18, 18, 19, 19, 22, 22, 23, 23, 25, 25, 26, 26,  // 16-31\n    31, 31, 32, 32, 34, 34, 35, 35, 38, 38, 39, 39, 41, 41, 42, 42,  // 32-47\n    46, 46, 47, 47, 49, 49, 50, 50, 53, 53, 54, 54, 56, 56, 57, 57,  // 48-63\n    63, 63, 64, 64, 66, 66, 67, 67, 70, 70, 71, 71, 73, 73, 74, 74,  // 64-79\n    78, 78, 79, 79, 81, 81, 82, 82, 85, 85, 86, 86, 88, 88, 89, 89,  // 80-95\n    94, 94, 95, 95, 97, 97, 98, 98, 101, 101, 102, 102, 104, 104, 105, 105,  // 96-111\n    109, 109, 110, 110, 112, 112, 113, 113, 116, 116, 117, 117, 119, 119, 120, 120,  // 112-127\n].map(BigInt)\n\nconst NULL = undefined\n\n/* Calculate C(n, k) for n in the 63-bit range. */\n\nfunction perm_comb_small(n, k, iscomb){\n    if(k == 0){\n        return 1n\n    }\n\n    /* For small enough n and k the result fits in the 64-bit range and can\n     * be calculated without allocating intermediate PyLong objects. */\n    if(iscomb){\n        /* Maps k to the maximal n so that 2*k-1 <= n <= 127 and C(n, k)\n         * fits into a uint64_t.  Exclude k = 1, because the second fast\n         * path is faster for this case.*/\n        var fast_comb_limits1 = [\n            0, 0, 127, 127, 127, 127, 127, 127,  // 0-7\n            127, 127, 127, 127, 127, 127, 127, 127,  // 8-15\n            116, 105, 97, 91, 86, 82, 78, 76,  // 16-23\n            74, 72, 71, 70, 69, 68, 68, 67,  // 24-31\n            67, 67, 67  // 32-34\n        ];\n        if(k < fast_comb_limits1.length && n <= fast_comb_limits1[k]){\n            /*\n                comb(n, k) fits into a uint64_t. We compute it as\n                    comb_odd_part << shift\n                where 2**shift is the largest power of two dividing comb(n, k)\n                and comb_odd_part is comb(n, k) >> shift. comb_odd_part can be\n                calculated efficiently via arithmetic modulo 2**64, using three\n                lookups and two uint64_t multiplications.\n            */\n            var comb_odd_part = reduced_factorial_odd_part[n]\n                                   * inverted_factorial_odd_part[k]\n                                   * inverted_factorial_odd_part[n - k];\n            comb_odd_part %= p2_64\n            var shift = factorial_trailing_zeros[n]\n                      - factorial_trailing_zeros[k]\n                      - factorial_trailing_zeros[n - k];\n            return comb_odd_part << shift;\n        }\n\n        /* Maps k to the maximal n so that 2*k-1 <= n <= 127 and C(n, k)*k\n         * fits into a long long (which is at least 64 bit).  Only contains\n         * items larger than in fast_comb_limits1. */\n        var fast_comb_limits2 = [\n            0, ULLONG_MAX, 4294967296, 3329022, 102570, 13467, 3612, 1449,  // 0-7\n            746, 453, 308, 227, 178, 147  // 8-13\n        ];\n        if (k < fast_comb_limits2.length && n <= fast_comb_limits2[k]) {\n            /* C(n, k) = C(n, k-1) * (n-k+1) / k */\n            var result = n,\n                i = 1n;\n            while(i < k){\n                result *= --n;\n                result /= ++i;\n            }\n            return result;\n        }\n    }else{\n        /* Maps k to the maximal n so that k <= n and P(n, k)\n         * fits into a long long (which is at least 64 bit). */\n        var fast_perm_limits = [\n            0, ULLONG_MAX, 4294967296, 2642246, 65537, 7133, 1627, 568,  // 0-7\n            259, 142, 88, 61, 45, 36, 30, 26,  // 8-15\n            24, 22, 21, 20, 20  // 16-20\n        ];\n        if (k < fast_perm_limits.length && n <= fast_perm_limits[k]) {\n            if(n <= 127){\n                /* P(n, k) fits into a uint64_t. */\n                var perm_odd_part = reduced_factorial_odd_part[n]\n                                       * inverted_factorial_odd_part[n - k];\n                perm_odd_part %= p2_64\n                var shift = factorial_trailing_zeros[n]\n                          - factorial_trailing_zeros[n - k];\n                var res = perm_odd_part << shift\n\n                return res;\n            }\n\n            /* P(n, k) = P(n, k-1) * (n-k+1) */\n            var result = n;\n            for (var i = 1; i < k; i++) {\n                result *= --n;\n            }\n            return result\n        }\n    }\n\n    /* For larger n use recursive formulas:\n     *\n     *   P(n, k) = P(n, j) * P(n-j, k-j)\n     *   C(n, k) = C(n, j) * C(n-j, k-j) // C(k, j)\n     */\n    var j = k / 2n;\n    var a = perm_comb_small(n, j, iscomb);\n    var b = perm_comb_small(n - j, k - j, iscomb);\n    a = a * b;\n    if(iscomb){\n        b = perm_comb_small(k, j, 1);\n        a = a / b;\n    }\n    return a;\n}\n\n/* Calculate P(n, k) or C(n, k) using recursive formulas.\n * It is more efficient than sequential multiplication thanks to\n * Karatsuba multiplication.\n */\nfunction perm_comb(n, k, iscomb){\n    if(k == 0){\n        return 1;\n    }\n    if(k == 1){\n        return n;\n    }\n\n    /* P(n, k) = P(n, j) * P(n-j, k-j) */\n    /* C(n, k) = C(n, j) * C(n-j, k-j) // C(k, j) */\n    var j = k / 2n\n    var a = perm_comb(n, j, iscomb);\n    //var t = j\n    //n = n - t;\n    var b = perm_comb(n - j, k - j, iscomb);\n    a = a * b;\n    if(iscomb){\n        b = perm_comb_small(k, j, 1);\n        a = a / b;\n    }\n    return a;\n}\n\nfunction comb(n, k){\n    var $ = $B.args('comb', 2, {n: null, k: null}, ['n', 'k'],\n            arguments, {}, null, null),\n        n = $.n,\n        k = $.k\n\n    var result = NULL,\n        temp,\n        overflow, cmp;\n\n    // accept integers or objects with __index__\n    n = $B.PyNumber_Index(n)\n    k = $B.PyNumber_Index(k)\n\n    n = _b_.int.$to_bigint(n);\n    k = _b_.int.$to_bigint(k);\n\n    if(n < 0){\n        throw _b_.ValueError.$factory(\n                        \"n must be a non-negative integer\");\n    }\n    if(k < 0){\n        throw _b_.ValueError.$factory(\n                        \"k must be a non-negative integer\");\n    }\n\n    overflow = n > LLONG_MAX || n < LLONG_MIN\n    if(! overflow){\n        overflow = k > LLONG_MAX || k < LLONG_MIN\n        if (overflow || k > n) {\n            result = 0n;\n        }else{\n            if(n - k < k){\n                k = n - k\n            }\n            if (k > 1) {\n                result = perm_comb_small(n, k, 1);\n            }\n        }\n        /* For k == 1 just return the original n in perm_comb(). */\n    }else{\n        /* k = min(k, n - k) */\n        temp = n - k\n        if(temp < 0) {\n            result = 0n;\n        }\n        if (temp < k) {\n            k = temp\n        }\n\n        overflow = k > LLONG_MAX || k < LLONG_MIN\n        if (overflow) {\n            throw _b_.OverflowError.$factory(\n                         \"min(n - k, k) must not exceed \" +\n                         LLONG_MAX);\n        }\n    }\n    if(result === undefined){\n        result = perm_comb(n, k, 1);\n    }\n\n    return _b_.int.$int_or_long(result)\n}\n\n\nfunction copysign(x, y){\n    $B.check_nb_args_no_kw('copysign', 2, arguments)\n\n    var x1 = Math.abs(float_check(x))\n    var y1 = float_check(y)\n    var sign = Math.sign(y1)\n    sign = (sign == 1 || Object.is(sign, +0)) ? 1 : - 1\n    return _b_.float.$factory(x1 * sign)\n}\n\nfunction cos(x){\n    $B.check_nb_args('cos ', 1, arguments)\n    $B.check_no_kw('cos ', x)\n    return _b_.float.$factory(Math.cos(float_check(x)))\n}\n\nfunction cosh(x){\n    $B.check_nb_args('cosh', 1, arguments)\n    $B.check_no_kw('cosh', x)\n\n    if(_b_.float.$funcs.isinf(x)){return INF}\n    var y = float_check(x)\n    if(Math.cosh !== undefined){return _b_.float.$factory(Math.cosh(y))}\n    return _b_.float.$factory((Math.pow(Math.E, y) +\n        Math.pow(Math.E, -y)) / 2)\n}\n\nfunction degrees(x){\n    $B.check_nb_args('degrees', 1, arguments)\n    $B.check_no_kw('degrees', x)\n    return _b_.float.$factory(float_check(x) * 180 / Math.PI)\n}\n\nfunction dist(p, q){\n    $B.check_nb_args_no_kw('dist', 2, arguments)\n\n    function test(x){\n        if(typeof x === \"number\"){\n            return x\n        }else if(x.__class__ === _b_.float){\n            return x.value\n        }\n        var y = $B.$getattr(x, '__float__', null)\n        if(y === null){\n            throw _b_.TypeError.$factory('not a float')\n        }\n        return $B.$call(y)().value\n    }\n\n    // build list of differences (as floats) between coordinates of p and q\n    var diffs = [],\n        diff\n\n    if(Array.isArray(p) && Array.isArray(q)){\n        // simple case : p and q are lists of tuples\n        if(p.length != q.length){\n            throw _b_.ValueError.$factory(\"both points must have \" +\n                \"the same number of dimensions\")\n        }\n        p = p.map(test)\n        q = q.map(test)\n        for(var i = 0, len = p.length; i < len; i++){\n            var next_p = p[i],\n                next_q = q[i]\n            var diff = Math.abs(next_p - next_q)\n            diffs.push(diff)\n        }\n    }else{\n        var itp = _b_.iter(p),\n            itq = _b_.iter(q),\n            res = 0\n\n        while(true){\n            try{\n                var next_p = _b_.next(itp)\n            }catch(err){\n                if(err.__class__ === _b_.StopIteration){\n                    // check that the other iterator is also exhausted\n                    try{\n                        var next_q = _b_.next(itq)\n                        throw _b_.ValueError.$factory(\"both points must have \" +\n                            \"the same number of dimensions\")\n                    }catch(err){\n                        if(err.__class__ === _b_.StopIteration){\n                            break\n                        }\n                        throw err\n                    }\n                }\n                throw err\n            }\n            next_p = test(next_p)\n            try{\n                var next_q = _b_.next(itq)\n            }catch(err){\n                if(err.__class__ === _b_.StopIteration){\n                    throw _b_.ValueError.$factory(\"both points must have \" +\n                        \"the same number of dimensions\")\n                }\n                throw err\n            }\n            next_q = test(next_q)\n            diff = Math.abs(next_p - next_q)\n            diffs.push(diff)\n        }\n    }\n    for(var diff of diffs){\n        if(! isFinite(diff) && ! isNaN(diff)){\n            return _mod.inf\n        }\n    }\n    for(var diff of diffs){\n        if(isNaN(diff)){\n            return _mod.nan\n        }\n    }\n\n    var res = 0,\n        scale = 1,\n        max_diff = Math.max(...diffs),\n        min_diff = Math.min(...diffs)\n        max_value = Math.sqrt(Number.MAX_VALUE) / p.length,\n        min_value = Math.sqrt(Number.MIN_VALUE) * p.length\n    if(max_diff > max_value){\n        var nb = 0\n        while(max_diff > max_value){\n            scale *= 2\n            max_diff /= 2\n            nb++\n        }\n        for(var diff of diffs){\n            diff = diff / scale\n            res += diff * diff\n        }\n        return $B.fast_float(scale * Math.sqrt(res))\n    }else if(min_diff !== 0 && min_diff < min_value){\n        while(min_diff < min_value){\n            scale *= 2\n            min_diff *= 2\n        }\n        for(var diff of diffs){\n            diff = diff * scale\n            res += diff * diff\n        }\n        return $B.fast_float(Math.sqrt(res) / scale)\n    }else{\n        for(var diff of diffs){\n            res += Math.pow(diff, 2)\n        }\n        return $B.fast_float(Math.sqrt(res))\n    }\n}\n\nconst e = _b_.float.$factory(Math.E)\n\nconst ERF_SERIES_CUTOFF = 1.5,\n      ERF_SERIES_TERMS = 25,\n      ERFC_CONTFRAC_CUTOFF = 30.0,\n      ERFC_CONTFRAC_TERMS = 50\n\n/*\n   Error function, via power series.\n   Given a finite float x, return an approximation to erf(x).\n   Converges reasonably fast for small x.\n*/\n\nfunction m_erf_series(x){\n    var x2, acc, fk, result\n    var i\n\n    x2 = x * x\n    acc = 0.0\n    fk = ERF_SERIES_TERMS + 0.5\n    for(i = 0; i < ERF_SERIES_TERMS; i++){\n        acc = 2.0 + x2 * acc / fk\n        fk -= 1.0\n    }\n    result = acc * x * exp(-x2).value / sqrtpi\n    return result\n}\n\nfunction m_erfc_contfrac(x){\n    var x2, a, da, p, p_last, q, q_last, b, result;\n    var i\n\n    if(x >= ERFC_CONTFRAC_CUTOFF){\n        return 0.0\n    }\n\n    x2 = x * x\n    a = 0.0\n    da = 0.5\n    p = 1.0\n    p_last = 0.0\n    q = da + x2\n    q_last = 1.0\n    for(i = 0; i < ERFC_CONTFRAC_TERMS; i++){\n        var temp\n        a += da\n        da += 2.0\n        b = da + x2\n        temp = p; p = b * p - a * p_last; p_last = temp\n        temp = q; q = b * q - a * q_last; q_last = temp\n    }\n    result = p / q * x * exp(-x2).value / sqrtpi\n    return result\n}\n\n\nfunction erf(x){\n    var absx,\n        cf\n    var x1 = float_check(x)\n    if(isNaN(x1)){\n        return x\n    }\n    absx = fabs(x)\n    if(absx.value < ERF_SERIES_CUTOFF){\n        return $B.fast_float(m_erf_series(x1))\n    }else{\n        cf = m_erfc_contfrac(absx.value)\n        return $B.fast_float(x1 > 0.0 ? 1.0 - cf : cf - 1.0)\n    }\n}\n\nfunction erfc(x){\n\n    // inspired from\n    // http://stackoverflow.com/questions/457408/is-there-an-easily-available-implementation-of-erf-for-python\n    var y = float_check(x)\n    var t = 1.0 / (1.0 + 0.5 * Math.abs(y))\n    var ans = 1 - t * Math.exp( -y * y - 1.26551223 +\n                 t * ( 1.00002368 +\n                 t * ( 0.37409196 +\n                 t * ( 0.09678418 +\n                 t * (-0.18628806 +\n                 t * ( 0.27886807 +\n                 t * (-1.13520398 +\n                 t * ( 1.48851587 +\n                 t * (-0.82215223 +\n                 t * 0.17087277)))))))))\n    if(y >= 0.0){return 1 - ans}\n    return 1 + ans\n}\n\nfunction erfc(x){\n    $B.check_nb_args_no_kw('erfc', 1, arguments)\n    var absx, cf;\n\n    var x1 = float_check(x)\n    if(isNaN(x1)){\n        return x\n    }\n    absx = fabs(x);\n    if(absx.value < ERF_SERIES_CUTOFF){\n        return $B.fast_float(1.0 - m_erf_series(x1))\n    }else{\n        cf = m_erfc_contfrac(absx.value)\n        return $B.fast_float(x1 > 0.0 ? cf : 2.0 - cf)\n    }\n}\n\nfunction exp(x){\n    $B.check_nb_args('exp', 1, arguments)\n    $B.check_no_kw('exp', x)\n\n     if(_b_.float.$funcs.isninf(x)){\n         return _b_.float.$factory(0)\n     }\n     if(_b_.float.$funcs.isinf(x)){\n         return INF\n     }\n     var _r = Math.exp(float_check(x))\n     if(! isNaN(_r) && ! isFinite(_r)){\n         throw _b_.OverflowError.$factory(\"math range error\")\n     }\n     return _b_.float.$factory(_r)\n}\n\nfunction exp2(x){\n    return pow(2, x)\n}\n\nfunction expm1(x){\n    $B.check_nb_args('expm1', 1, arguments)\n    $B.check_no_kw('expm1', x)\n\n     if(_b_.float.$funcs.isninf(x)){\n         return $B.fast_float(-1)\n     }else if(_b_.float.$funcs.isinf(x)){\n         return INF\n     }\n     var _r = Math.expm1(float_check(x))\n     if((! isNaN(_r)) && ! isFinite(_r)){\n         overflow()\n     }\n     return $B.fast_float(_r)\n}\n\nfunction fabs(x){\n    $B.check_nb_args_no_kw('fabs', 1, arguments)\n    return _b_.float.$funcs.fabs(float_check(x)) // located in py_float.js\n}\n\n// factorial implementation, adapted from CPython's mathmodule.c\n\nconst SmallFactorials = [\n    1n, 1n, 2n, 6n, 24n, 120n, 720n, 5040n, 40320n,\n    362880n, 3628800n, 39916800n, 479001600n,\n    6227020800n, 87178291200n, 1307674368000n,\n    20922789888000n, 355687428096000n, 6402373705728000n,\n    121645100408832000n, 2432902008176640000n\n    ]\n\nconst SIZEOF_LONG = 4\n\nfunction _Py_bit_length(x){\n    const BIT_LENGTH_TABLE = [\n        0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4,\n        5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5\n    ]\n    var msb = 0;\n    while(x >= 32n){\n        msb += 6;\n        x >>= 6n;\n    }\n    msb += BIT_LENGTH_TABLE[parseInt(x)];\n    return msb\n}\nfunction count_set_bits(n){\n    var count = 0n;\n    while(n != 0){\n        ++count;\n        n &= n - 1n; /* clear least significant bit */\n    }\n    return count;\n}\n\nfunction factorial_partial_product(start, stop, max_bits){\n    var midpoint,\n        num_operands,\n        left,\n        right,\n        result\n\n    /* If the return value will fit an unsigned long, then we can\n     * multiply in a tight, fast loop where each multiply is O(1).\n     * Compute an upper bound on the number of bits required to store\n     * the answer.\n     *\n     * Storing some integer z requires floor(lg(z))+1 bits, which is\n     * conveniently the value returned by bit_length(z).  The\n     * product x*y will require at most\n     * bit_length(x) + bit_length(y) bits to store, based\n     * on the idea that lg product = lg x + lg y.\n     *\n     * We know that stop - 2 is the largest number to be multiplied.  From\n     * there, we have: bit_length(answer) <= num_operands *\n     * bit_length(stop - 2)\n     */\n\n    num_operands = (stop - start) / 2n;\n    max_bits = BigInt(max_bits)\n    /* The \"num_operands <= 8 * SIZEOF_LONG\" check guards against the\n     * unlikely case of an overflow in num_operands * max_bits. */\n    if(num_operands <= 8 * SIZEOF_LONG &&\n        num_operands * max_bits <= 8 * SIZEOF_LONG) {\n        var j,\n            total;\n        for (total = start, j = start + 2n; j < stop; j += 2n){\n            total *= j;\n        }\n        return total\n    }\n\n    /* find midpoint of range(start, stop), rounded up to next odd number. */\n    midpoint = (start + num_operands) | 1n;\n    left = factorial_partial_product(start, midpoint,\n                                     _Py_bit_length(midpoint - 2n));\n    right = factorial_partial_product(midpoint, stop, max_bits);\n    result = left * right\n    return result;\n}\n\n\nfunction factorial_odd_part(n){\n    var i,\n        v, lower, upper,\n        partial, tmp, inner, outer;\n\n    inner = 1n\n    outer = inner;\n    upper = 3n;\n    for (i = BigInt(_Py_bit_length(n)) - 2n; i >= 0; i--) {\n        v = n >> i;\n        if (v <= 2){\n            continue\n        }\n        lower = upper;\n        /* (v + 1) | 1 = least odd integer strictly larger than n / 2**i */\n        upper = (v + 1n) | 1n;\n        /* Here inner is the product of all odd integers j in the range (0,\n           n/2**(i+1)].  The factorial_partial_product call below gives the\n           product of all odd integers j in the range (n/2**(i+1), n/2**i]. */\n        partial = factorial_partial_product(lower, upper,\n                                            _Py_bit_length(upper-2n));\n        /* inner *= partial */\n        tmp = inner * partial\n        inner = tmp;\n        /* Now inner is the product of all odd integers j in the range (0,\n           n/2**i], giving the inner product in the formula above. */\n\n        /* outer *= inner; */\n        tmp = outer * inner\n        outer = tmp;\n    }\n    return outer;\n}\n\nfunction factorial(arg){\n    var x,\n        two_valuation,\n        overflow,\n        result,\n        odd_part;\n    // Check that arg can be converted to an integer, and transform it to\n    // a bigint\n    x = _b_.int.$to_bigint($B.PyNumber_Index(arg))\n    overflow = x > LONG_MAX || x < LONG_MIN\n    if(x > LONG_MAX) {\n        throw _b_.OverflowError.$factory(\n                     \"factorial() argument should not exceed \" +\n                     LONG_MAX)\n    }else if(x < 0) {\n        throw _b_.ValueError.$factory(\n                        \"factorial() not defined for negative values\");\n    }\n\n    /* use lookup table if x is small */\n    if (x < SmallFactorials.length){\n        return _b_.int.$int_or_long(SmallFactorials[x]);\n    }\n    /* else express in the form odd_part * 2**two_valuation, and compute as\n       odd_part << two_valuation. */\n    odd_part = factorial_odd_part(x);\n    two_valuation = x - count_set_bits(x);\n    return _b_.int.$int_or_long(odd_part << two_valuation);\n}\n\nfunction floor(x){\n    $B.check_nb_args_no_kw('floor', 1, arguments)\n\n    if(typeof x == \"number\" || x.__class__ === _b_.float){\n        return Math.floor(float_check(x))\n    }\n    var klass = $B.get_class(x)\n    try{\n        return $B.$call($B.$getattr(klass, \"__floor__\"))(x)\n    }catch(err){\n        if($B.is_exc(err, [_b_.AttributeError])){\n            try{\n                var float = $B.$call($B.$getattr(klass, \"__float__\"))(x)\n                return floor(float)\n            }catch(err){\n                if($B.is_exc(err, [_b_.AttributeError])){\n                    throw _b_.TypeError.$factory(\"no __float__\")\n                }\n                throw err\n            }\n        }\n    }\n}\n\nvar _fma = (function () {\n    // copied from \n    // https://gist.github.com/Yaffle/fb47de4c18b63147699e0b621f1031f7\n\n  \n  var SPLIT = Math.pow(2, 27) + 1;\n  var MIN_VALUE = Math.pow(2, -1022);\n  var EPSILON = Math.pow(2, -52);\n  // (1022 + 52) / 3 < C <= (1022 - 53 - 53 + 4) / 2 - ?\n  var C = 416;\n  var A = Math.pow(2, +C);\n  var B = Math.pow(2, -C);\n\n  var multiply = function (a, b) {\n    var at = SPLIT * a;\n    var ahi = at - (at - a);\n    var alo = a - ahi;\n    var bt = SPLIT * b;\n    var bhi = bt - (bt - b);\n    var blo = b - bhi;\n    var p = a * b;\n    var e = ((ahi * bhi - p) + ahi * blo + alo * bhi) + alo * blo;\n    return {\n      p: p,\n      e: e\n    };\n  };\n\n  var add = function (a, b) {\n    var s = a + b;\n    var v = s - a;\n    var e = (a - (s - v)) + (b - v);\n    return {\n      s: s,\n      e: e\n    };\n  };\n\n  var adjust = function (x, y) {\n    return x !== 0 && y !== 0 && SPLIT * x - (SPLIT * x - x) === x ? x * (1 + (x < 0 ? -1 : +1) * (y < 0 ? -1 : +1) * EPSILON) : x;\n  };\n\n  var fma = function (x, y, z) {\n    x = Number(x);\n    y = Number(y);\n    z = Number(z);\n\n    if (x === 0 || x !== x || x === +1 / 0 || x === -1 / 0 ||\n        y === 0 || y !== y || y === +1 / 0 || y === -1 / 0) {\n      return x * y + z;\n    }\n    if (z === 0) {\n      return x * y;\n    }\n    if (z !== z || z === +1 / 0 || z === -1 / 0) {\n      return z;\n    }\n\n    var scale = 1;\n    while (Math.abs(x) > A) {\n      scale *= A;\n      x *= B;\n    }\n    while (Math.abs(y) > A) {\n      scale *= A;\n      y *= B;\n    }\n    if (scale === 1 / 0) {\n      return x * y * scale;\n    }\n    while (Math.abs(x) < B) {\n      scale *= B;\n      x *= A;\n    }\n    while (Math.abs(y) < B) {\n      scale *= B;\n      y *= A;\n    }\n    if (scale === 0) {\n      return z;\n    }\n\n    var xs = x;\n    var ys = y;\n    var zs = z / scale;\n\n    if (Math.abs(zs) > Math.abs(xs * ys) * 4 / EPSILON) {\n      return z;\n    }\n    if (Math.abs(zs) < Math.abs(xs * ys) * EPSILON / 4 * EPSILON / 4) {\n      zs = (z < 0 ? -1 : +1) * MIN_VALUE;\n    }\n\n    var xy = multiply(xs, ys);\n    var s = add(xy.p, zs);\n    var u = add(xy.e, s.e);\n    var i = add(s.s, u.s);\n\n    var f = i.s + adjust(i.e, u.e);\n    if (f === 0) {\n      return f;\n    }\n\n    var fs = f * scale;\n    if (Math.abs(fs) > MIN_VALUE) {\n      return fs;\n    }\n\n    // It is possible that there was extra rounding for a denormalized value.\n    return fs + adjust(f - fs / scale, i.e) * scale;\n  };\n\n  return fma\n\n}());\n\nfunction fma(x, y, z){\n    var $ = $B.args('fma', 3, {x: null, y: null, z: null}, ['x', 'y', 'z'],\n            arguments, {}, null, null),\n        x = float_check($.x),\n        y = float_check($.y),\n        z = float_check($.z)\n\n    var res =_fma(x, y, z)\n    if(isFinite(res)){\n        return $B.fast_float(res)\n    }\n    if(isNaN(res)){\n        if (!isNaN(x) && !isNaN(y) && !isNaN(z)) {\n            /* NaN result from non-NaN inputs. */\n            throw _b_.ValueError.$factory(\"invalid operation in fma\");\n        }\n    }else if(isFinite(x) && isFinite(y) && isFinite(z)) {\n        /* Infinite result from finite inputs. */\n        throw _b_.OverflowError.$factory(\"overflow in fma\");\n    }\n\n    return $B.fast_float(res)\n}\n\nfunction fmod(x, y){\n    $B.check_nb_args_no_kw('fmod', 2, arguments)\n    if($B.$isinstance(x, _b_.float)){\n        if(_b_.float.$funcs.isinf(x)){\n            throw _b_.ValueError.$factory('math domain error')\n        }\n    }\n    y = float_check(y)\n    if(y == 0){\n        throw _b_.ValueError.$factory('math domain error')\n    }\n    return _b_.float.$factory(float_check(x) % float_check(y))\n}\n\nfunction frexp(x){\n    $B.check_nb_args_no_kw('frexp', 1, arguments)\n\n    var _l = _b_.float.$funcs.frexp(x)\n    return _b_.tuple.$factory([_b_.float.$factory(_l[0]), _l[1]])\n}\n\nfunction fsum(x){\n    $B.check_nb_args_no_kw('fsum', 1, arguments)\n\n    /* Translation into Javascript of the function msum in an Active\n       State Cookbook recipe : https://code.activestate.com/recipes/393090/\n       by Raymond Hettinger\n    */\n    var partials = [],\n        res = new Number(),\n        _it = _b_.iter(x)\n    while(true){\n        try{\n            var x = _b_.next(_it),\n                i = 0\n            x = float_check(x)\n            for(var j = 0, len = partials.length; j < len; j++){\n                var y = float_check(partials[j])\n                if(Math.abs(x) < Math.abs(y)){\n                    var z = x\n                    x = y\n                    y = z\n                }\n                var hi = x + y,\n                    lo = y - (hi - x)\n                if(lo){\n                    partials[i] = lo\n                    i++\n                }\n                x = hi\n            }\n            partials = partials.slice(0, i).concat([x])\n        }catch(err){\n            if($B.$isinstance(err, _b_.StopIteration)){break}\n            throw err\n        }\n    }\n    var res = 0\n    for(var i = 0; i < partials.length; i++){\n        res += partials[i]\n    }\n    return $B.fast_float(res)\n}\n\nfunction gamma(x){\n    $B.check_nb_args('gamma', 1, arguments)\n    $B.check_no_kw('gamma', x)\n    var x_as_number = x,\n        r,\n        y,\n        z,\n        sqrtpow\n\n    /* special cases */\n    if($B.$isinstance(x, _b_.float)){\n        x_as_number = x.value\n    }else if(! $B.$isinstance(x, _b_.int)){\n        throw _b_.TypeError.$factory(\"must be real number, not \" +\n            $B.class_name(x))\n    }\n    if(x_as_number === Number.POSITIVE_INFINITY || isNaN(x_as_number)){\n        return x\n    }else if(x_as_number === Number.NEGATIVE_INFINITY || x_as_number == 0){\n        throw _b_.ValueError.$factory(\"math domain error\")\n    }\n\n    /* integer arguments */\n    if(Number.isInteger(x_as_number)){\n        if($B.rich_comp('__lt__', x, 0.0)){\n            throw _b_.ValueError.$factory(\"math domain error\")\n        }\n        if($B.rich_comp('__le__', x, NGAMMA_INTEGRAL)){\n            return $B.fast_float(gamma_integral[x_as_number - 1])\n        }\n    }\n    var absx = fabs(x)\n\n    /* tiny arguments:  tgamma(x) ~ 1/x for x near 0 */\n    if(absx.value < 1e-20){\n        r = 1.0 / x_as_number\n        if(r === Infinity || r === -Infinity){\n            overflow()\n        }\n        return $B.fast_float(r)\n    }\n\n    /* large arguments: assuming IEEE 754 doubles, tgamma(x) overflows for\n       x > 200, and underflows to +-0.0 for x < -200, not a negative\n       integer. */\n    if(absx.value > 200.0){\n        if(x_as_number < 0.0){\n            return $B.fast_float(0.0 / m_sinpi(x).value);\n        }else{\n            overflow()\n        }\n    }\n\n    y = absx.value + lanczos_g_minus_half;\n    /* compute error in sum */\n    if (absx.value > lanczos_g_minus_half) {\n        /* note: the correction can be foiled by an optimizing\n           compiler that (incorrectly) thinks that an expression like\n           a + b - a - b can be optimized to 0.0.  This shouldn't\n           happen in a standards-conforming compiler. */\n        var q = y - absx.value;\n        z = q - lanczos_g_minus_half;\n    }else{\n        var q = y - lanczos_g_minus_half;\n        z = q - absx.value;\n    }\n    z = z * lanczos_g / y;\n    if (x_as_number < 0.0) {\n        r = -pi.value / m_sinpi(absx).value /\n                absx.value * _mod.exp(y).value /\n                lanczos_sum(absx.value);\n        r -= z * r;\n        if(absx.value < 140.0){\n            r /= pow(y, absx.value - 0.5).value;\n        }else{\n            sqrtpow = pow(y, absx.value / 2.0 - 0.25);\n            r /= sqrtpow.value;\n            r /= sqrtpow.value;\n        }\n    }else{\n        r = lanczos_sum(absx.value) / exp(y).value;\n        r += z * r;\n        if(absx.value < 140.0){\n            r *= pow(y, absx.value - 0.5).value;\n        }else{\n            sqrtpow = pow(y, absx.value / 2.0 - 0.25);\n            r *= sqrtpow.value;\n            r *= sqrtpow.value;\n        }\n    }\n    if(r === Number.POSITIVE_INFINITY){\n        overflow()\n    }\n    return $B.fast_float(r);\n}\n\n\n// GCD algorithm. Javascript adaptation of Python script at\n// https://gist.github.com/cmpute/baa545f0c2b6be8b628e9ded3c19f6c1\n// by Jacob Zhong\nfunction bit_length(x){\n    return x.toString(2).length\n}\n\n$B.nb_simple_gcd = 0\n\nfunction simple_gcd(a, b){\n    /* a fits into a long, so b must too */\n    $B.nb_simple_gcd++\n    var x = a >= 0 ? a : -a,\n        y = b >= 0 ? b : -b\n\n    /* usual Euclidean algorithm for longs */\n    while (y != 0) {\n        t = y;\n        y = x % y;\n        x = t;\n    }\n    return x\n}\n\nfunction lgcd(x, y){\n    var a, b, c, d\n    if(x < y){\n        return lgcd(y, x)\n    }\n    var shift = BigInt(Math.max(Math.floor(bit_length(x) / 64),\n                    Math.floor(bit_length(y) / 64))),\n        xbar = x >> (shift * 64n),\n        ybar = y >> (shift * 64n)\n    while(y > p2_64){\n        [a, b, c, d] = [1n, 0n, 0n, 1n]\n        while(ybar + c != 0 && ybar + d != 0){\n            q = (xbar + a) / (ybar + c)\n            p = (xbar + b) / (ybar + d)\n            if(q != p){\n                break\n            }\n            [a, c] = [c, a - q * c]\n            [b, d] = [d, b - q * d]\n            [xbar, ybar] = [ybar, xbar - q * ybar]\n        }\n        if(b == 0){\n            [x, y] = [y, x % y]\n        }else{\n            [x, y] = [a * x + b * y, c * x + d * y]\n        }\n    }\n    return simple_gcd(x, y)\n}\n\nfunction xgcd(x, y){\n    var xneg = x < 0 ? -1n : 1n,\n        yneg = y < 0 ? -1n : 1n,\n        last_r,\n        last_s,\n        last_t,\n        q, r, s, t;\n\n    [x, y] = [x >= 0 ? x : -x, y >= 0 ? y : -y];\n\n    // it's maintained that r = s * x + t * y, last_r = last_s * x + last_t * y\n    [last_r, r] = [x, y];\n    [last_s, s] = [1n, 0n];\n    [last_t, t] = [0n, 1n];\n\n    while(r > 0){\n        q = last_r / r;\n        [last_r, r] = [r, last_r - q * r];\n        [last_s, s] = [s, last_s - q * s];\n        [last_t, t] = [t, last_t - q * t];\n    }\n    return [last_r, last_s * xneg, last_t * yneg]\n}\n\nfunction lxgcd(x, y){\n    var g, cy, cx,\n        s, last_s,\n        t, last_t,\n        a, b, c, d\n    x = x >= 0 ? x : -x\n    y = y >= 0 ? y : -y\n\n    if(x < y){\n        [g, cy, cx] = xgcd(y, x)\n        return [g, cx, cy]\n    }\n\n    var shift = BigInt(Math.max(Math.floor(bit_length(x) / 64),\n                Math.floor(bit_length(y) / 64))),\n        xbar = x >> (shift * 64n),\n        ybar = y >> (shift * 64n);\n\n    [last_s, s] = [1n, 0n];\n    [last_t, t] = [0n, 1n];\n\n    while(y > p2_64){\n        [a, b, c, d] = [1n, 0n, 0n, 1n]\n        while(ybar + c != 0 && ybar + d != 0){\n            q = (xbar + a) / (ybar + c)\n            p = (xbar + b) / (ybar + d)\n            if(q != p){\n                break\n            };\n            [a, c = c], [a - q * c];\n            [b, d = d], [b - q * d];\n            [xbar, ybar] = [ybar, xbar - q * ybar];\n        }\n        if(b == 0){\n            q = x / y;\n            [x, y] = [y, x % y];\n            [last_s, s] = [s, last_s - q * s];\n            [last_t, t] = [t, last_t - q * t];\n        }else{\n            [x, y] = [a * x + b * y, c * x + d * y];\n            [last_s, s] = [a * last_s + b * s, c * last_s + d * s];\n            [last_t, t] = [a * last_t + b * t, c * last_t + d * t];\n        }\n    }\n    // notice that here x, y could be negative\n    [g, cx, cy] = xgcd(x, y)\n\n    return [g, cx * last_s + cy * s, cx * last_t + cy * t]\n}\n\nfunction gcd(x, y){\n    var $ = $B.args(\"gcd\", 0, {}, [], arguments, {}, 'args', null)\n    var args = $.args.map($B.PyNumber_Index)\n    if(args.length == 0){\n        return 0\n    }else if(args.length == 1){\n        return _b_.abs(args[0])\n    }\n    x = _b_.int.$to_bigint(args[0])\n    y = _b_.int.$to_bigint(args[1])\n    var res = lxgcd(x, y)[0],\n        i = 2\n    while(i < args.length){\n        res = lxgcd(res, _b_.int.$to_bigint(args[i]))[0]\n        i++\n    }\n    return _b_.int.$int_or_long(res)\n}\n\n\nfunction hypot(x, y){\n    var $ = $B.args(\"hypot\", 0, {}, [],\n                arguments, {}, \"args\", null)\n    var args = []\n    for(var arg of $.args){\n        try{\n            args.push(float_check(arg))\n        }catch(err){\n            if($B.is_exc(err, [_b_.ValueError])){\n                throw _b_.TypeError.$factory('must be real number, not ' +\n                    $B.class_name(arg))\n            }\n            throw err\n        }\n    }\n    return $B.fast_float(Math.hypot(...args))\n}\n\nvar inf = INF\n\nfunction isclose(){\n    var $ = $B.args(\"isclose\",\n                      4,\n                      {a: null, b: null, rel_tol: null, abs_tol: null},\n                      ['a', 'b', 'rel_tol', 'abs_tol'],\n                      arguments,\n                      {rel_tol: $B.fast_float(1e-09),\n                       abs_tol: $B.fast_float(0.0)},\n                      '*',\n                      null)\n    var a = float_check($.a),\n        b = float_check($.b),\n        rel_tol = float_check($.rel_tol),\n        abs_tol = float_check($.abs_tol)\n\n    if(rel_tol < 0.0 || abs_tol < 0.0){\n        throw _b_.ValueError.$factory('tolerances must be non-negative')\n    }\n\n    if(a == b){\n        return _b_.True\n    }\n    if(_b_.float.$funcs.isinf(a) || _b_.float.$funcs.isinf(b)){\n        return a === b\n    }\n    // isclose(a, b, rel_tol, abs_tol) is the same as\n    // abs_diff = abs(a - b)\n    // max_ab = max(abs(a), abs(b))\n    // abs_diff <= abs_tol or abs_diff / max_ab <= rel_tol\n    // This is more correct than in Python docs:\n    // \"abs(a-b) <= max(rel_tol * max(abs(a), abs(b)), abs_tol)\"\n    // because this fails for Decimal instances, which do not support\n    // multiplication by floats\n\n    var diff = b - a,\n        abs_diff = Math.abs(diff)\n    if(abs_diff <= abs_tol){\n        return true\n    }\n    var abs_a = Math.abs(a),\n        abs_b = Math.abs(b),\n        max_ab = Math.max(abs_a, abs_b)\n    return abs_diff / max_ab <= rel_tol\n}\n\nfunction isfinite(x){\n    $B.check_nb_args('isfinite', 1, arguments)\n    $B.check_no_kw('isfinite', x)\n    return isFinite(float_check(x))\n}\n\nfunction isinf(x){\n    $B.check_nb_args('isinf', 1, arguments)\n    $B.check_no_kw('isinf', x)\n    return _b_.float.$funcs.isinf(x)\n}\n\nfunction isnan(x){\n    $B.check_nb_args('isnan', 1, arguments)\n    $B.check_no_kw('isnan', x)\n    return isNaN(float_check(x))\n}\n\nfunction isqrt(x){\n    $B.check_nb_args_no_kw('isqrt', 1, arguments)\n\n    x = $B.PyNumber_Index(x)\n    if($B.rich_comp(\"__lt__\", x, 0)){\n        throw _b_.ValueError.$factory(\n            \"isqrt() argument must be nonnegative\")\n    }\n    if(typeof x == \"number\"){\n        return Math.floor(Math.sqrt(x))\n    }else{ // big integer\n        // adapted from code in mathmodule.c\n        var n = x.value,\n            bit_length = n.toString(2).length,\n            c = BigInt(Math.floor((bit_length - 1) / 2)),\n            c_bit_length = c.toString(2).length,\n            a = 1n,\n            d = 0n,\n            e\n\n        for(var s = BigInt(c_bit_length - 1); s >= 0; s--){\n            // Loop invariant: (a-1)**2 < (n >> 2*(c - d)) < (a+1)**2\n            e = d\n            d = c >> s\n            a = (a << d - e - 1n) + (n >> 2n*c - e - d + 1n) / a\n        }\n        return _b_.int.$int_or_long(a - (a * a > n ? 1n : 0n))\n    }\n}\n\nfunction lcm(){\n    var $ = $B.args(\"lcm\", 0, {}, [], arguments, {}, 'args', null),\n        product = 1\n\n    var args = $.args.map($B.PyNumber_Index)\n    if(args.length == 0){\n        return 1\n    }else if(args.length == 1){\n        return _b_.abs(args[0])\n    }\n    var a = _b_.abs(args[0]),\n        b,\n        product, gcd\n    for(var i = 0, len = args.length; i < len; i++){\n        b = _b_.abs(args[i])\n        if(b == 0){\n            return 0\n        }\n        gcd = gcd2(a, b)\n        product = $B.rich_op('__mul__', a, b)\n        a = $B.$getattr(product, \"__floordiv__\")(gcd)\n    }\n    return a\n}\n\nfunction ldexp(x, i){\n    $B.check_nb_args('ldexp', 2, arguments)\n    $B.check_no_kw('ldexp', x, i)\n    return _b_.float.$funcs.ldexp(x, i)   // in py_float.js\n}\n\nfunction lgamma(x){\n    $B.check_nb_args('lgamma', 1, arguments)\n    $B.check_no_kw('lgamma', x)\n\n    return m_lgamma(x)\n}\n\nfunction longint_mant_exp(long_int){\n    // Returns mantissa and exponent of a long integer\n    var value = long_int.value,\n        exp = value.toString(2).length,\n        exp1 = exp,\n        nb = 0n\n    // 2 ** exp is infinite if n > 1023\n    var nb = Math.floor(exp / 1023),\n        exp1 = BigInt(exp - 1023 * nb)\n    nb = BigInt(nb)\n    var reduced_value = long_int.value / 2n ** (nb * 1023n)\n    var mant = Number(reduced_value) / Number(2n ** exp1)\n    return [mant, exp]\n}\n\nvar log10_func = Math.log10 || (x => Math.log(x) / Math.log(10)),\n    log2_func = Math.log2 || (x => Math.log(x) / Math.log(2))\n\nfunction log(x, base){\n    var $ = $B.args(\"log\", 2, {x: null, base: null}, ['x', 'base'],\n        arguments, {base: _b_.None}, null, null),\n        x = $.x,\n        base = $.base\n    if(base == 10){\n        return log10(x)\n    }else if(base == 2){\n        return log2(x)\n    }\n    var log\n    if($B.$isinstance(x, $B.long_int)){\n        if(x.value <= 0){\n            throw _b_.ValueError.$factory('math domain error')\n        }\n        var mant_exp = longint_mant_exp(x)\n        log = Math.log(mant_exp[0]) + Math.log(2) * mant_exp[1]\n    }else if($B.$isinstance(x, _b_.int)){\n        x = _b_.int.$int_value(x)\n        if(x <= 0){\n            throw _b_.ValueError.$factory('math domain error')\n        }\n        log = Math.log(x)\n    }else{\n        var x1 = float_check(x)\n        if(x1 <= 0){\n            throw _b_.ValueError.$factory('math domain error')\n        }\n        log = Math.log(x1)\n    }\n    if(x1 <= 0){\n        throw _b_.ValueError.$factory(\"math domain error\")\n    }\n    if(base === _b_.None){\n        return $B.fast_float(log)\n    }\n    var denom = _mod.log(base).value\n    if(denom == 0){\n        throw _b_.ZeroDivisionError.$factory('float division by zero')\n    }\n    return $B.fast_float(log / denom)\n}\n\nfunction log1p(x){\n    $B.check_nb_args('log1p', 1, arguments)\n    $B.check_no_kw('log1p', x)\n    if($B.$isinstance(x, $B.long_int)){\n        if($B.long_int.bit_length(x) > 1024){\n            throw _b_.OverflowError.$factory(\n                \"int too large to convert to float\")\n        }\n        x = $B.long_int.$log2($B.fast_long_int(x.value + 1n))\n        return $B.fast_float(Number(x.value) * Math.LN2)\n    }\n    x = float_check(x)\n    if(x + 1 <= 0){\n        throw _b_.ValueError.$factory(\"math domain error\")\n    }\n    return $B.fast_float(Math.log1p(x))\n}\n\nfunction log2(x){\n    $B.check_nb_args('log2', 1, arguments)\n    $B.check_no_kw('log2', x)\n    var log2_func = Math.log2 || (x => Math.log(x) / Math.LN2)\n    if($B.$isinstance(x, $B.long_int)){\n        if(x.value <= 0){\n            throw _b_.ValueError.$factory('math domain error')\n        }\n        var mant_exp = longint_mant_exp(x)\n        return $B.fast_float(log2_func(mant_exp[0]) + mant_exp[1])\n    }\n    if(_b_.float.$funcs.isninf(x)){\n        throw _b_.ValueError.$factory('')\n    }\n    x = float_check(x)\n    if(x == 0){\n        throw _b_.ValueError.$factory(\"math domain error\")\n    }\n    if(isNaN(x)){\n        return _b_.float.$factory('nan')\n    }\n    if(x < 0.0){\n        throw _b_.ValueError.$factory('math domain error')\n    }\n    return $B.fast_float(log2_func(x))\n}\n\nfunction log10(x){\n    $B.check_nb_args('log10', 1, arguments)\n    $B.check_no_kw('log10', x)\n    if($B.$isinstance(x, $B.long_int)){\n        return $B.fast_float($B.long_int.$log10(x).value)\n    }\n    x = float_check(x)\n    if(x <= 0){\n        throw _b_.ValueError.$factory(\"math domain error\")\n    }\n    return $B.fast_float(Math.log10(x))\n}\n\nfunction modf(x){\n    $B.check_nb_args('modf', 1, arguments)\n    $B.check_no_kw('modf', x)\n\n    if(_b_.float.$funcs.isninf(x)){\n        return _b_.tuple.$factory([0.0, NINF])\n    }\n    if(_b_.float.$funcs.isinf(x)){\n        return _b_.tuple.$factory([0.0, INF])\n    }\n    var x1 = float_check(x)\n\n    if(isNaN(x1)){\n        return _b_.tuple.$factory([_b_.float.$factory('nan'),\n            _b_.float.$factory('nan')])\n    }\n\n    if(x1 > 0){\n       var i = _b_.float.$factory(x1 - Math.floor(x1))\n       return _b_.tuple.$factory([i, _b_.float.$factory(x1 - i.value)])\n    }\n\n    var x2 = Math.ceil(x1)\n    var i = _b_.float.$factory(x1 - x2)\n    return _b_.tuple.$factory([i, _b_.float.$factory(x2)])\n}\n\nvar nan = _b_.float.$factory('nan')\n\nfunction _nextafter(x, y){\n    // always returns a Javascript number\n    if($B.rich_comp('__lt__', y, x)){\n        var nu = nextUp($B.rich_op('__mul__', -1, x))\n        return -nu\n    }else if($B.rich_comp('__gt__', y, x)){\n        return nextUp(x)\n    }else{\n        var res = x !== x ? x : y\n        res = typeof res == 'number' ? res : res.value\n        return res\n    }\n}\n\nfunction make_float(x){\n    return typeof x == 'number' ? $B.fast_float(x) : x\n}\n\nfunction make_number(x){\n    return typeof x == 'number' ? x : x.value\n}\n\nfunction doubleToByteArray(number) {\n    // adapted from https://stackoverflow.com/questions/\n    // 25942516/double-to-byte-array-conversion-in-javascript\n    var buffer = new ArrayBuffer(8);         // JS numbers are 8 bytes long, or 64 bits\n    var longNum = new Float64Array(buffer);  // so equivalent to Float64\n\n    longNum[0] = number;\n\n    return Array.from(new Uint8Array(buffer)).reverse();  // reverse to get little endian\n}\n\nfunction byteArrayToDouble(bytearray) {\n    // adapted from https://stackoverflow.com/questions/\n    // 42699162/javascript-convert-array-of-4-bytes-into-a-float-value-from-modbustcp-read\n    // Create a buffer\n    var buf = new ArrayBuffer(8);\n    // Create a data view of it\n    var view = new DataView(buf);\n\n    // set bytes\n    bytearray.forEach(function (b, i) {\n        view.setUint8(i, b);\n    });\n\n    // Read the bits as a float\n    var num = view.getFloat64(0);\n    // Done\n    return num\n}\n\nfunction addSteps(array, steps){\n    // convert to BigInt, avoids issue when steps >= 2 ** 32\n    if(steps.__class__ == $B.long_int){\n        steps = steps.value\n    }else{\n        steps = BigInt(steps)\n    }\n    var positive = steps > 0n\n    if(steps < 0n){\n        steps = -steps\n    }\n    var x1 = steps >> 32n,\n        x2 = steps - x1 * 2n ** 32n\n    var buffer = new ArrayBuffer(8)\n    var longStep = new BigInt64Array(buffer)\n    longStep[0] = steps\n    var stepArray = Array.from(new Uint8Array(buffer)).reverse()\n    if(positive){\n        var carry = 0\n        for(var i = 7; i >= 0; i--){\n            array[i] += stepArray[i] + carry\n            if(array[i] > 255){\n                carry = 1\n                array[i] -= 256\n            }else{\n                carry = 0\n            }\n        }\n    }else{\n        var carry = 0\n        for(var i = 7; i >= 0; i--){\n            array[i] -= stepArray[i] - carry\n            if(array[i] < 0){\n                carry = -1\n                array[i] += 256\n            }else{\n                carry = 0\n            }\n        }\n    }\n}\n\nfunction nextafter(){\n    var $ = $B.args(\"nextafter\", 3, {x: null, y: null, steps: null},\n                ['x', 'y', 'steps'], arguments, {steps: _b_.None}, null, null),\n        x = $.x,\n        y = $.y,\n        steps = $.steps\n    if(! $B.$isinstance(x, [_b_.int, _b_.float])){\n        throw _b_.TypeError.$factory('must be a real number, not ' +\n            $B.class_name(x))\n    }\n    if(! $B.$isinstance(y, [_b_.int, _b_.float])){\n        throw _b_.TypeError.$factory('must be a real number, not ' +\n            $B.class_name(y))\n    }\n    if(isnan(x)){\n        return make_float(x)\n    }\n    if(isnan(y)){\n        return make_float(y)\n    }\n    if(steps === _b_.None){\n        return $B.fast_float(_nextafter(x, y))\n    }\n    steps = $B.PyNumber_Index(steps);\n    if(steps < 0) {\n        throw _b_.ValueError.$factory(\n                        \"steps must be a non-negative integer\");\n    }\n    if(steps == 0){\n        return make_float(x)\n    }\n    if(isnan(x)){\n        return make_float(x)\n    }\n    if(isnan(y)){\n        return make_float(y)\n    }\n    var x1 = make_number(x),\n        y1 = make_number(y)\n\n    if(y1 == x1){\n        return make_float(y)\n    }else if(y1 > x1){\n        var x_uint64 = doubleToByteArray(x1)\n        addSteps(x_uint64, steps)\n        var res = byteArrayToDouble(x_uint64)\n        return res >= y1 ? y : make_float(res)\n    }else{\n        var x_uint64 = doubleToByteArray(x1)\n        addSteps(x_uint64, -steps)\n        var res = byteArrayToDouble(x_uint64)\n        return res <= y1 ? y : make_float(res)\n    }\n}\n\nfunction perm(n, k){\n    var $ = $B.args(\"perm\", 2, {n: null, k: null}, ['n', 'k'],\n                    arguments, {k: _b_.None}, null, null),\n        n = $.n,\n        k = $.k\n\n    if(k === _b_.None){\n        check_int(n)\n        return _mod.factorial(n)\n    }\n    // raise TypeError if n or k is not an integer\n    n = $B.PyNumber_Index(n)\n    k = $B.PyNumber_Index(k)\n\n    // transform to Javascript BigInt\n    var n1 = _b_.int.$to_bigint(n),\n        k1 = _b_.int.$to_bigint(k);\n\n    if(k1 < 0){\n        throw _b_.ValueError.$factory(\"k must be a non-negative integer\")\n    }\n    if(n1 < 0){\n        throw _b_.ValueError.$factory(\"n must be a non-negative integer\")\n    }\n    if(k1 == 0){\n        return 1\n    }\n    if(k1 == 1){\n        return n\n    }\n    if(k1 == 2){\n        return _b_.int.$int_or_long(n1 * (n1 - 1n))\n    }\n    if(k1 > n1){\n        return 0\n    }\n    // Evaluates to n! / (n - k)!\n    var fn = _mod.factorial(n),\n        fn_k = _mod.factorial(n - k)\n    return $B.rich_op('__floordiv__', fn, fn_k)\n}\n\nconst pi = $B.fast_float(Math.PI)\n\nfunction pow(){\n    var $ = $B.args(\"pow\", 2, {base: null, exp: null}, ['base', 'exp'],\n                arguments, {}, null, null),\n        x = $.base,\n        y = $.exp\n\n    var x1 = float_check(x)\n    var y1 = float_check(y)\n\n    if(y1 == 0){\n        return _b_.float.$factory(1)\n    }\n    if(x1 == 0 && y1 < 0){\n        if(y1 === -Infinity){\n            return INF\n        }\n        throw _b_.ValueError.$factory('math domain error')\n    }\n    if(isFinite(x1) && x1 < 0 && isFinite(y1) && ! Number.isInteger(y1)){\n        throw _b_.ValueError.$factory('math domain error')\n    }\n\n    if(isNaN(y1)){\n        if(x1 == 1){return _b_.float.$factory(1)}\n        return NAN\n    }\n    if(x1 == 0){\n        return ZERO\n    }\n\n    if(_b_.float.$funcs.isninf(y)){\n        if(_b_.float.$funcs.isinf(x)){ // pow(INF, NINF) = 0.0\n            return ZERO\n        }else if(_b_.float.$funcs.isninf(x)){ // pow(NINF, NINF) = 0.0\n            return ZERO\n        }\n        if(x1 == 1 || x1 == -1){return _b_.float.$factory(1)}\n        if(x1 < 1 && x1 > -1){return INF}\n        return ZERO\n    }\n    if(_b_.float.$funcs.isinf(y)){\n        if(_b_.float.$funcs.isinf(x)){ // pow(INF, INF)\n            return INF\n        }\n        if(_b_.float.$funcs.isninf(x)){\n            return INF\n        }\n        if(x1 == 1 || x1 == -1){return _b_.float.$factory(1)}\n        if(x1 < 1 && x1 > -1){return ZERO}\n        return INF\n    }\n\n    if(isNaN(x1)){return _b_.float.$factory('nan')}\n    if(_b_.float.$funcs.isninf(x)){\n        if(y1 > 0 && isOdd(y1)){return NINF}\n        if(y1 > 0){return INF}  // this is even or a float\n        if(y1 < 0){return ZERO}\n        if(_b_.float.$float.isinf(y)){return INF}\n        return _b_.float.$factory(1)\n    }\n\n    if(_b_.float.$funcs.isinf(x)){\n        if(y1 > 0){return INF}\n        if(y1 < 0){return ZERO}\n        return _b_.float.$factory(1)\n    }\n\n    var r = Math.pow(x1, y1)\n    if(isNaN(r)){\n        return NAN\n    }\n    if(! isFinite(r)){\n        overflow()\n    }\n    return _b_.float.$factory(r)\n}\n\nfunction prod(){\n    var $ = $B.args(\"prod\", 1, {iterable:null, start:null},\n                    [\"iterable\", \"start\"], arguments, {start: 1}, \"*\",\n                    null),\n        iterable = $.iterable,\n        start = $.start\n    var res = start,\n        it = _b_.iter(iterable),\n        x\n    while(true){\n        try{\n            x = _b_.next(it)\n            if(x == 0){\n                return 0\n            }\n            res = $B.rich_op('__mul__', res, x)\n        }catch(err){\n            if(err.__class__ === _b_.StopIteration){\n                return res\n            }\n            throw err\n        }\n    }\n}\n\nfunction radians(x){\n    $B.check_nb_args('radians', 1, arguments)\n    $B.check_no_kw('radians', x)\n\n    return _b_.float.$factory(float_check(x) * Math.PI / 180)\n}\n\nfunction is_finite(x){\n    return typeof x == \"number\" ||\n               (x.__class__ === _b_.floar && isFinite(x.value)) ||\n               $B.$isinstance(x, _b_.int) ||\n               ($B.$isinstance(x, _b_.float) && isFinite(x.value))\n}\n\nfunction remainder(x, y){\n    $B.check_nb_args_no_kw('remainder', 2, arguments)\n    float_check(x) // might raise TypeError\n    /* Deal with most common case first. */\n    if(is_finite(x) && is_finite(y)){\n        var absx,\n            absy,\n            c,\n            m,\n            r;\n\n        if(float_check(y) == 0.0){\n            throw _b_.ValueError.$factory(\"math domain error\")\n        }\n\n        absx = fabs(x);\n        absy = fabs(y);\n        m = fmod(absx, absy);\n\n        c = absy.value - m.value\n        if(m.value < c){\n            r = m.value\n        }else if(m.value > c){\n            r = -c\n        }else{\n            r = m.value -\n                    2.0 * fmod($B.fast_float(0.5 * (absx.value - m.value)), absy).value;\n        }\n        return $B.fast_float(copysign(1.0, x).value * r);\n    }\n\n    /* Special values. */\n    if(float_check(y) == 0){\n        if(isnan(x)){\n            return x\n        }\n    }\n    if(isinf(x)){\n        if(isnan(y)){\n            return y\n        }\n        throw _b_.ValueError.$factory(\"math domain error\")\n    }\n    if(isnan(y)){\n        return y;\n    }\n    return x;\n}\n\nfunction sin(x){\n    $B.check_nb_args('sin ', 1, arguments)\n    $B.check_no_kw('sin ', x)\n    return _b_.float.$factory(Math.sin(float_check(x)))\n}\n\nfunction sinh(x) {\n    $B.check_nb_args('sinh', 1, arguments)\n    $B.check_no_kw('sinh', x)\n\n    var y = float_check(x)\n    if(Math.sinh !== undefined){\n        return _b_.float.$factory(Math.sinh(y))\n    }\n    return _b_.float.$factory(\n        (Math.pow(Math.E, y) - Math.pow(Math.E, -y)) / 2)\n}\n\nfunction sqrt(x){\n    $B.check_nb_args('sqrt ', 1, arguments)\n    $B.check_no_kw('sqrt ', x)\n\n    if(_b_.float.$funcs.isninf(x)){\n        value_error()\n    }else if(_b_.float.$funcs.isinf(x)){\n        return INF\n    }\n    var y = float_check(x)\n    if(y < 0){\n        value_error()\n    }\n    var _r = $B.fast_float(Math.sqrt(y))\n    if(_b_.float.$funcs.isinf(_r)){\n        overflow()\n    }\n    return _r\n}\n\n/*[clinic input]\nmath.sumprod\n\n    p: object\n    q: object\n    /\n\nReturn the sum of products of values from two iterables p and q.\n\nRoughly equivalent to:\n\n    sum(itertools.starmap(operator.mul, zip(p, q, strict=True)))\n\nFor float and mixed int/float inputs, the intermediate products\nand sums are computed with extended precision.\n[clinic start generated code]*/\n\nconst tl_zero = {hi: 0, lo: 0, tiny: 0}\n\nfunction _check_long_mult_overflow(a, b) {\n\n    /* From Python2's int_mul code:\n\n    Integer overflow checking for * is painful:  Python tried a couple ways, but\n    they didn't work on all platforms, or failed in endcases (a product of\n    -sys.maxint-1 has been a particular pain).\n\n    Here's another way:\n\n    The native long product x*y is either exactly right or *way* off, being\n    just the last n bits of the true product, where n is the number of bits\n    in a long (the delivered product is the true product plus i*2**n for\n    some integer i).\n\n    The native double product (double)x * (double)y is subject to three\n    rounding errors:  on a sizeof(long)==8 box, each cast to double can lose\n    info, and even on a sizeof(long)==4 box, the multiplication can lose info.\n    But, unlike the native long product, it's not in *range* trouble:  even\n    if sizeof(long)==32 (256-bit longs), the product easily fits in the\n    dynamic range of a double.  So the leading 50 (or so) bits of the double\n    product are correct.\n\n    We check these two ways against each other, and declare victory if they're\n    approximately the same.  Else, because the native long product is the only\n    one that can lose catastrophic amounts of information, it's the native long\n    product that must have overflowed.\n\n    */\n\n    /*\n\n    var longprod = (long)((unsigned long)a * b);\n    double doubleprod = (double)a * (double)b;\n    double doubled_longprod = (double)longprod;\n\n    if (doubled_longprod == doubleprod) {\n        return 0;\n    }\n\n    const double diff = doubled_longprod - doubleprod;\n    const double absdiff = diff >= 0.0 ? diff : -diff;\n    const double absprod = doubleprod >= 0.0 ? doubleprod : -doubleprod;\n\n    if (32.0 * absdiff <= absprod) {\n        return 0;\n    }\n\n    return 1;\n    */\n    return 0\n}\n\nfunction long_add_would_overflow(a, b){\n    return (a > 0n) ? (b > BigInt(LONG_MAX) - a) : (b < BigInt(LONG_MIN) - a);\n}\n\nfunction PyLong_CheckExact(n){\n    return typeof n == 'number' || n.__class__ === $B.long_int\n}\n\n/*\n   The default implementation of dl_mul() depends on the C math library\n   having an accurate fma() function as required by \u00a7 7.12.13.1 of the\n   C99 standard.\n\n   The UNRELIABLE_FMA option is provided as a slower but accurate\n   alternative for builds where the fma() function is found wanting.\n   The speed penalty may be modest (17% slower on an Apple M1 Max),\n   so don't hesitate to enable this build option.\n\n   The algorithms are from the T. J. Dekker paper:\n   A Floating-Point Technique for Extending the Available Precision\n   https://csclub.uwaterloo.ca/~pbarfuss/dekker1971.pdf\n*/\n\nfunction dl_split(x) {\n    // Dekker (5.5) and (5.6).\n    var t = x * 134217729.0;  // Veltkamp constant = 2.0 ** 27 + 1\n    var hi = t - (t - x);\n    var lo = x - hi;\n    return {hi, lo};\n}\n\nfunction dl_mul(x, y){\n    // Dekker (5.12) and mul12()\n    var xx = dl_split(x);\n    var yy = dl_split(y);\n    var p = xx.hi * yy.hi;\n    var q = xx.hi * yy.lo + xx.lo * yy.hi;\n    var z = p + q;\n    var zz = p - z + q + xx.lo * yy.lo;\n    return {hi: z, lo:  zz};\n}\n\nfunction dl_sum(a, b){\n    /* Algorithm 3.1 Error-free transformation of the sum */\n    var x = a + b;\n    var z = x - a;\n    var y = (a - (x - z)) + (b - z);\n    return {hi: x, lo: y};\n}\n\nfunction tl_fma(x, y, total){\n    /* Algorithm 5.10 with SumKVert for K=3 */\n    var pr = dl_mul(x, y);\n    var sm = dl_sum(total.hi, pr.hi);\n    var r1 = dl_sum(total.lo, pr.lo);\n    var r2 = dl_sum(r1.hi, sm.lo);\n    return {hi: sm.hi, lo: r2.hi, tiny: total.tiny + r1.lo + r2.lo}\n}\n\nfunction tl_to_d(total){\n    var last = dl_sum(total.lo, total.hi);\n    return total.tiny + last.lo + last.hi;\n}\n\nfunction sumprod(p, q){\n    var $ = $B.args('sumprod', 2, {p: null, q: null}, ['p', 'q'],\n            arguments, {}, null, null)\n    var p_i = NULL,\n        q_i = NULL,\n        term_i = NULL,\n        new_total = NULL;\n    var p_it, q_it, total;\n    var p_next, q_next;\n    var p_stopped = false, q_stopped = false;\n    var int_path_enabled = true,\n        int_total_in_use = false;\n    var flt_path_enabled = true,\n        flt_total_in_use = false;\n    var int_total = 0n;\n    var flt_total = tl_zero;\n\n    p_it = $B.make_js_iterator(p);\n    q_it = $B.make_js_iterator(q);\n    total = 0\n    p_next = p_it.next\n    q_next = q_it.next\n    while (1) {\n        var finished;\n        p_i = p_it.next()\n        if (p_i.done) {\n            p_stopped = true;\n        }else{\n            p_i = p_i.value\n        }\n        q_i = q_it.next()\n        if (q_i.done) {\n            q_stopped = true;\n        }else{\n            q_i = q_i.value\n        }\n        if (p_stopped != q_stopped) {\n            throw _b_.ValueError.$factory(\"Inputs are not the same length\");\n        }\n\n        finished = p_stopped & q_stopped;\n\n        if (int_path_enabled) {\n\n            if (! finished && PyLong_CheckExact(p_i) & PyLong_CheckExact(q_i)) {\n                var overflow;\n                var int_p, int_q, int_prod;\n\n                int_p = _b_.int.$to_bigint($B.PyNumber_Index(p_i))\n                overflow = int_p > LONG_MAX || int_p < LONG_MIN\n\n                if (overflow) {\n                    finalize_int_path()\n                }\n                int_q = _b_.int.$to_bigint($B.PyNumber_Index(q_i));\n                overflow = int_q > LONG_MAX || int_q < LONG_MIN\n                if (overflow) {\n                    finalize_int_path()\n                }\n                if (_check_long_mult_overflow(int_p, int_q)) {\n                    finalize_int_path()\n                }\n                int_prod = int_p * int_q;\n                if (long_add_would_overflow(int_total, int_prod)) {\n                    finalize_int_path()\n                }\n                if(int_path_enabled){\n                    int_total = int_total + int_prod;\n                    int_total_in_use = true;\n                    continue;\n                }\n            }\n\n            if(finished){\n                finalize_int_path()\n            }\n\n          function finalize_int_path(){\n            // We're finished, overflowed, or have a non-int\n            int_path_enabled = false;\n            if (int_total_in_use) {\n                term_i = _b_.int.$int_or_long(int_total);\n                new_total = $B.rich_op('__add__', total, term_i);\n                total = new_total\n                new_total = NULL;\n                int_total = 0;   // An ounce of prevention, ...\n                int_total_in_use = false;\n            }\n          }\n        }\n\n        if (flt_path_enabled) {\n\n            if (!finished) {\n                var flt_p, flt_q;\n                var p_type_float = p_i.__class__ === _b_.float;\n                var q_type_float = q_i.__class__ === _b_.float\n                if(p_type_float && q_type_float) {\n                    flt_p = p_i;\n                    flt_q = q_i;\n                }else if (p_type_float && (PyLong_CheckExact(q_i) ||\n                                           typeof q_i == 'boolean')){\n                    /* We care about float/int pairs and int/float pairs because\n                       they arise naturally in several use cases such as price\n                       times quantity, measurements with integer weights, or\n                       data selected by a vector of bools. */\n                    flt_p = p_i\n                    flt_q = _b_.int.$int_value(q_i)\n                }else if(q_type_float && (PyLong_CheckExact(p_i) ||\n                                          typeof p_i == 'boolean')) {\n                    flt_q = q_i\n                    flt_p = _b_.int.$int_value(p_i)\n                }else{\n                    finalize_flt_path()\n                }\n                if(flt_path_enabled){\n                    var new_flt_total = tl_fma(flt_p.value, flt_q.value, flt_total);\n                    if (isfinite(new_flt_total.hi)) {\n                        flt_total = new_flt_total;\n                        flt_total_in_use = true;\n                        continue;\n                    }\n                }\n            }\n            if(finished){\n                finalize_flt_path()\n            }\n\n          function finalize_flt_path(){\n            // We're finished, overflowed, have a non-float, or got a non-finite value\n            flt_path_enabled = false;\n            if(flt_total_in_use){\n                term_i = $B.fast_float(tl_to_d(flt_total));\n                if (term_i == NULL) {\n                    err_exit()\n                }\n                new_total = $B.rich_op('__add__', total, term_i);\n                total = new_total\n                new_total = NULL\n                flt_total = tl_zero;\n                flt_total_in_use = false;\n            }\n          }\n        }\n\n        if (finished) {\n            return total\n        }\n        term_i = $B.rich_op('__mul__', p_i, q_i);\n        new_total = $B.rich_op('__add__', total, term_i);\n        total = new_total\n        new_total = NULL;\n    }\n\n}\n\n\n\nfunction tan(x) {\n    $B.check_nb_args('tan', 1, arguments)\n    $B.check_no_kw('tan', x)\n\n    var y = float_check(x)\n    return _b_.float.$factory(Math.tan(y))\n}\n\nfunction tanh(x) {\n    $B.check_nb_args('tanh', 1, arguments)\n    $B.check_no_kw('tanh', x)\n\n    var y = float_check(x)\n    if(Math.tanh !== undefined){return _b_.float.$factory(Math.tanh(y))}\n    return _b_.float.$factory((Math.pow(Math.E, y) - Math.pow(Math.E, -y))/\n         (Math.pow(Math.E, y) + Math.pow(Math.E, -y)))\n}\n\nconst tau = $B.fast_float(2 * Math.PI)\n\nfunction trunc(x) {\n    $B.check_nb_args('trunc', 1, arguments)\n    $B.check_no_kw('trunc', x)\n\n   try{\n       return $B.$getattr(x, '__trunc__')()\n   }catch(err){\n   }\n   var x1 = float_check(x)\n   if(!isNaN(parseFloat(x1)) && isFinite(x1)){\n      if(Math.trunc !== undefined){\n          return _b_.int.$factory(Math.trunc(x1))\n      }\n      if(x1 > 0){\n          return _b_.int.$factory(Math.floor(x1))\n      }\n      return _b_.int.$factory(Math.ceil(x1))  // x1 < 0\n   }\n   throw _b_.ValueError.$factory(\n       'object is not a number and does not contain __trunc__')\n}\n\nfunction ulp(){\n    var $ = $B.args(\"ulp\", 1, {x: null}, ['x'], arguments, {}, null, null),\n        x = $.x\n    if($B.$isinstance(x, _b_.float)){\n        if(_b_.float.$funcs.isinf(x)){\n            return _mod.inf\n        }else if(_b_.float.$funcs.isnan(x)){\n            return _mod.nan\n        }\n    }\n    if(typeof x == \"number\"){\n        return x >= 0 ? $B.fast_float(nextUp(x) - x) :\n                       $B.fast_float(x - (-nextUp(-x)))\n    }else if($B.$isinstance(x, $B.long_int)){\n        x = Number(_b_.int.$to_bigint(x))\n        return x > 0 ? $B.fast_float(nextUp(x) - x) :\n                       $B.fast_float(x - (-nextUp(-x)))\n    }else{\n        if($B.rich_comp('__ge__', x, 0)){\n            return $B.rich_op('__sub__', $B.fast_float(nextUp(x.value)), x)\n        }else{\n            var neg_x = $B.$call($B.$getattr(x, \"__neg__\"))()\n            return $B.rich_op('__sub__', x,\n                $B.$call($B.$getattr($B.fast_float(nextUp(neg_x.value)), '__neg__'))())\n        }\n    }\n}\n\nvar _mod = {\n    acos,\n    acosh,\n    asin,\n    asinh,\n    atan,\n    atan2,\n    atanh,\n    cbrt,\n    ceil,\n    comb,\n    copysign,\n    cos,\n    cosh,\n    degrees,\n    dist,\n    e,\n    erf,\n    erfc,\n    exp,\n    exp2,\n    expm1,\n    fabs,\n    factorial,\n    floor,\n    fma,\n    fmod,\n    frexp,\n    fsum,\n    gamma,\n    gcd,\n    hypot,\n    inf,\n    isclose,\n    isfinite,\n    isinf,\n    isnan,\n    isqrt,\n    lcm,\n    ldexp,\n    lgamma,\n    log,\n    log1p,\n    log2,\n    log10,\n    modf,\n    nan,\n    nextafter,\n    perm,\n    pi,\n    pow,\n    prod,\n    radians,\n    remainder,\n    sin,\n    sinh,\n    sqrt,\n    sumprod,\n    tan,\n    tanh,\n    tau,\n    trunc,\n    ulp\n}\n\nfor(var $attr in _mod){\n    if(typeof _mod[$attr] === 'function'){\n        _mod[$attr].__class__ = $B.builtin_function_or_method\n    }\n}\n\n$B.addToImported('math', _mod)\n\n})(__BRYTHON__)\n"], "modulefinder": [".js", "(function($B){\n\nvar _b_=$B.builtins\nvar _mod = {}\n\n$ModuleFinderDict = {__class__:_b_.type,__name__:'ModuleFinder'}\n$ModuleFinderDict.__mro__ = [_b_.object]\n\n$ModuleFinderDict.run_script = function(self, pathname){\n    // pathname is the url of a Python script\n    var py_src = _b_.$open(pathname).read()\n    // transform into internal Brython tree structure\n    var root = $B.py2js(py_src)\n    // walk the tree to find occurences of imports\n    function walk(node){\n        var modules = []\n        var ctx = node.context\n        if(ctx && ctx.type=='node'){ctx = ctx.tree[0]}\n\n        if(ctx && ctx.type==\"import\"){\n            for(var i=0, _len_i = ctx.tree.length; i < _len_i;i++){\n                if(modules.indexOf(ctx.tree[i].name)==-1){\n                    modules.push(ctx.tree[i].name)\n                }\n            }\n        }else if(ctx && ctx.type==\"from\"){\n            if(modules.indexOf(ctx.module)==-1){\n                modules.push(ctx.module)\n            }\n        }\n\n        for(var i=0, _len_i = node.children.length; i < _len_i;i++){\n            mods = walk(node.children[i])\n            for(var j=0, _len_j = mods.length; j < _len_j;j++){\n                if(modules.indexOf(mods[j])==-1){modules.push(mods[j])}\n            }\n        }\n        return modules\n    }\n    self.modules = walk(root)\n}\n\n_mod.ModuleFinder = function(){return {__class__:$ModuleFinderDict}\n}\n_mod.ModuleFinder.$dict = $ModuleFinderDict\n_mod.ModuleFinder.__class__ = $B.$factory\n$ModuleFinderDict.$factory = _mod.ModuleFinder\n\n$B.addToImported('modulefinder', _mod)\n\n})(__BRYTHON__)\n"], "posix": [".js", "/*\nThis module provides access to operating system functionality that is\nstandardized by the C Standard and the POSIX standard (a thinly\ndisguised Unix interface).  Refer to the library manual and\ncorresponding Unix manual entries for more information on calls.\n*/\nvar $B = __BRYTHON__,\n    _b_ = $B.builtins\n\nfunction _randint(a, b){\n    return parseInt(Math.random() * (b - a + 1) + a)\n}\n\nvar stat_result = $B.make_class(\"stat_result\",\n    function(filename){\n        filename = _b_.str.$factory(filename)\n        if($B.file_cache && $B.file_cache.hasOwnProperty(filename)){\n            var f = $B.file_cache[filename],\n                res = {\n                    __class__: stat_result,\n                    st_atime: __BRYTHON__.timestamp,\n                    st_ctime: f.ctime,\n                    st_mtime: f.mtime,\n                    st_uid: -1,\n                    st_gid: -1,\n                    st_ino: -1,\n                    st_mode: 0,\n                    st_size: f.length\n                };\n                [\"mtime\", \"ctime\", \"atime_ns\", \"mtime_ns\", \"ctime_ns\"].\n                    forEach(function(item){\n                        res[\"st_\" + item] = res.st_atime\n                    });\n            return res\n        }else if($B.files && $B.files.hasOwnProperty(filename)){\n            var f = $B.files[filename],\n                res = {\n                    __class__: stat_result,\n                    st_atime: __BRYTHON__.timestamp,\n                    st_ctime: f.ctime,\n                    st_mtime: f.mtime,\n                    st_uid: -1,\n                    st_gid: -1,\n                    st_ino: -1,\n                    st_mode: 0,\n                    st_size: f.content.length\n                };\n            for(var item of [\"mtime\", \"ctime\", \"atime_ns\", \"mtime_ns\", \"ctime_ns\"]){\n                res[\"st_\" + item] = res.st_atime\n            }\n            return res\n\n        }else{\n            var res = {\n                __class__: stat_result,\n                st_atime: __BRYTHON__.timestamp,\n                st_uid: -1,\n                st_gid: -1,\n                st_ino: -1,\n                st_mode: filename.endsWith('/') ? 16895 : 33206,\n                st_size: 1 // fake\n            };\n            [\"mtime\", \"ctime\", \"atime_ns\", \"mtime_ns\", \"ctime_ns\"].\n                forEach(function(item){\n                    res[\"st_\" + item] = res.st_atime\n                });\n            return res\n        }\n    }\n)\n$B.set_func_names(stat_result, \"posix\")\n\nvar module = {\n    F_OK: 0,\n    O_APPEND: 8,\n    O_BINARY: 32768,\n    O_CREAT: 256,\n    O_EXCL: 1024,\n    O_NOINHERIT: 128,\n    O_RANDOM: 16,\n    O_RDONLY: 0,\n    O_RDWR: 2,\n    O_SEQUENTIAL: 32,\n    O_SHORT_LIVED: 4096,\n    O_TEMPORARY: 64,\n    O_TEXT: 16384,\n    O_TRUNC: 512,\n    O_WRONLY: 1,\n    P_DETACH: 4,\n    P_NOWAIT: 1,\n    P_NOWAITO: 3,\n    P_OVERLAY: 2,\n    P_WAIT: 0,\n    R_OK: 4,\n    TMP_MAX: 32767,\n    W_OK: 2,\n    X_OK: 1,\n    _have_functions: $B.$list(['MS_WINDOWS']),\n    environ: _b_.dict.$from_array(\n        [['PYTHONPATH', $B.brython_path],\n         ['PYTHONUSERBASE', ' ']]),\n    error: _b_.OSError,\n    fspath: function(path){\n        return path\n    },\n    getcwd: function(){\n        return $B.brython_path\n    },\n    getpid: function(){\n        return 0\n    },\n    lstat: function(filename){\n        return stat_result.$factory(filename)\n    },\n    open: function(path, flags){\n        throw _b_.NotImplementedError.$factory('os.open is not implemented')\n    },\n    remove: function(path) {\n        var $ = $B.args(\"remove\", 1, { path: null }, [\"path\"], arguments, {}, null, null)\n        console.log($)\n\n        var path = $.path\n        var found_file = false\n\n        if ($B.file_cache && $B.file_cache.hasOwnProperty(path)){\n            delete $B.file_cache[path]\n            found_file = true\n        }\n        if ($B.files && $B.files.hasOwnProperty(path)){\n            delete $B.files[path]\n            found_file = true\n        }\n\n        if(!found_file) {\n            throw _b_.FileNotFoundError.$factory(`No such file or directory: '${path}'`)\n        }\n\n        return _b_.None\n    },\n    stat: function(filename){\n        return stat_result.$factory(filename)\n    },\n    stat_result: function(filename){\n        return stat_result.$factory(filename)\n    },\n    urandom: function(n){\n        const randbytes = new Uint8Array(n);\n        crypto.getRandomValues(randbytes);\n        return _b_.bytes.$factory(Array.from(randbytes));\n    },\n    WTERMSIG: function(){\n        return 0\n    },\n    WNOHANG: function(){\n        return _b_.tuple.$factory([0, 0])\n    }\n};\n\n[\"WCOREDUMP\", \"WIFCONTINUED\", \"WIFSTOPPED\", \"WIFSIGNALED\", \"WIFEXITED\"].forEach(function(funcname){\n        module[funcname] = function(){return false}\n    });\n\n[\"WEXITSTATUS\", \"WSTOPSIG\", \"WTERMSIG\"].\n    forEach(function(funcname){\n        module[funcname] = function(){return _b_.None}\n    });\n\n[\"_exit\", \"_getdiskusage\", \"_getfileinformation\", \"_getfinalpathname\",\n    \"_getfullpathname\", \"_isdir\", \"abort\", \"access\", \"chdir\", \"chmod\",\n    \"close\", \"closerange\", \"device_encoding\", \"dup\", \"dup2\",\n    \"execv\", \"execve\", \"fsat\", \"fsync\", \"get_terminal_size\", \"getcwdb\",\n    \"getlogin\", \"getppid\", \"isatty\", \"kill\", \"link\", \"listdir\", \"lseek\",\n    \"mkdir\", \"pipe\", \"putenv\", \"read\", \"readlink\", \"rename\",\n    \"replace\", \"rmdir\", \"spawnv\", \"spawnve\", \"startfile\", \"stat_float_times\",\n    \"statvfs_result\", \"strerror\", \"symlink\", \"system\", \"terminal_size\",\n    \"times\", \"times_result\", \"umask\", \"uname_result\", \"unlink\", \"utime\",\n    \"waitpid\", \"write\"].forEach(function(funcname){\n        module[funcname] = function(){\n            throw _b_.NotImplementedError.$factory(\"posix.\" + funcname +\n                \" is not implemented\")\n        }\n    });\n\n$B.addToImported('posix', module)"], "pyexpat": [".js", "(function($B){\n\n$B.$import('xml_parser')\n\nvar model = $B.imported.xml_parser.models\nconsole.log('model', model)\n\nvar _b_ = $B.builtins\n\nconst XML_PARAM_ENTITY_PARSING_NEVER = 0,\n      XML_PARAM_ENTITY_PARSING_UNLESS_STANDALONE = 1,\n      XML_PARAM_ENTITY_PARSING_ALWAYS = 2\n\nconst FAIL = {}\n\nconst xml_entities = {\n    '&gt;': '>',\n    '&lt;': '<',\n    '&quot;': '\"',\n    '&apos;': \"'\",\n    '&amp;': '&'\n    }\n\nvar xmlparser = $B.make_class('xmlparser',\n    function(encoding, namespace_separator, intern){\n        return {\n            __class__: xmlparser,\n            __dict__: $B.empty_dict(),\n            encoding,\n            namespace_separator,\n            intern,\n            buffer_text: false,\n            _buffer: '',\n            _state: 'data',\n            _data_buffer: '',\n            _initialized: false,\n            _maybe_entity: null,\n            _element_stack: [],\n            _chunk_size: 2 << 14\n        }\n    }\n)\n\nxmlparser._handle_stack = function(self){\n    if(! (self._element instanceof ELEMENT)){\n        return\n    }\n    if(self._element.name === undefined){\n        console.log('name undefined', self._element)\n        alert()\n    }\n    if(self._element.is_end){\n        if(self._element_stack.length == 0){\n            raise_error(self, 'no opening tag for closing ' + self._element.name)\n        }else{\n            var expected = $B.last(self._element_stack)\n            if(expected !== self._element.name){\n                console.log('error handle stack, stack', self._element_stack, self._element)\n                raise_error(self, `tag mismatch, ` +\n                    `expected closing tag ${expected}, ` +\n                    `got: ${self._element.name}`)\n            }\n            self._element_stack.pop()\n            if(self._element_stack.length == 0){\n                flush_char_data(self)\n            }\n        }\n    }else if(! self._element.self_closing){\n        self._element_stack.push(self._element.name)\n    }\n}\n\nxmlparser.CharacterDataHandler = _b_.None\n\nxmlparser.CommentHandler = _b_.None\n\nxmlparser.EndElementHandler = _b_.None\n\nfunction check_entity(parser, pos){\n    var entity = parser._maybe_entity\n    var decimal = /&#(\\d+);$/.exec(entity)\n    if(decimal){\n        return _b_.chr(parseInt(decimal[1]))\n    }\n    var hexa = /&#x(\\d+);$/.exec(entity)\n    if(hexa){\n        return _b_.chr(parseInt(hexa[1], 16))\n    }\n    var xml_entity = xml_entities[entity]\n    if(xml_entity){\n        return xml_entity\n    }\n    raise_error_known_position(parser, `unknown entity: \"${entity}\"`, pos)\n}\n\nfunction flush_char_data(parser){\n    var buf = parser._data_buffer\n    if(buf.length > 0){\n        let handler = parser._handlers.CharacterDataHandler\n        if(handler !== _b_.None){\n            handler(buf)\n        }\n    }\n    parser._data_buffer = ''\n}\n\nfunction flush_final_char_data(parser){\n    var buf = parser._data_buffer\n    for(var i = 0; i < buf.length; i++){\n        if(! buf[i].match(/\\s/)){\n            var pos = parser._pos - buf.length + i - 1\n            console.log('rest', buf)\n            var msg = `junk after document element: line 1, column ${pos}`\n            raise_error(parser, msg)\n        }\n    }\n}\n\nconst encoding_re = /<\\?xml .*encoding\\s*=\\s*\"(.*?)\"/\n\nconst handler_names = [\n    'CharacterDataHandler',\n    'CommentHandler',\n    'StartElementHandler',\n    'EndElementHandler',\n    'XmlDeclHandler'\n    ]\n\nxmlparser.Parse = function(){\n    var $ = $B.args('Parse', 3,\n                {self: null, data: null, isfinal: null},\n                ['self', 'data', 'isfinal'], arguments,\n                {}, null, null),\n        self = $.self,\n        data = $.data,\n        isfinal = $.isfinal,\n        decoder,\n        array\n    if(self.finished){\n        throw Error('parsing finished')\n    }\n    if(_b_.isinstance(data, _b_.bytes)){\n        if(self.encoding === _b_.None){\n            // try getting encoding from prolog\n            decoder = new TextDecoder('iso-8859-1')\n            array = new Uint8Array(data.source.slice(0, 200))\n            var head = decoder.decode(array)\n            var mo = encoding_re.exec(head)\n            if(mo){\n                self.encoding = mo[1]\n            }else{\n                self.encoding = 'utf-8' // default\n            }\n        }\n        // decode bytes\n        decoder = new TextDecoder(self.encoding)\n        array = new Uint8Array(data.source)\n        data = decoder.decode(array)\n    }\n    if(! self._initialized){\n        if(data[0] != '<'){\n            throw Error(\"XML or text declaration not at start of entity\")\n        }\n        self._initialized = true\n    }\n    self._buffer = data\n    self._buffer_length = _b_.len(data)\n    self._pos = 0\n\n    var handlers = self._handlers = {}\n    for(var handler_name of handler_names){\n        let handler = $B.$getattr(self, handler_name)\n        if(handler !== _b_.None){\n            handlers[handler_name] = $B.$call(handler)\n        }else{\n            handlers[handler_name] = _b_.None\n        }\n    }\n\n    for(var token of xmlparser.xml_tokenizer(self)){\n        if(token instanceof ELEMENT){\n            if(! token.is_declaration && ! token.is_end){\n                if(handlers.StartElementHandler !== _b_.None){\n                    flush_char_data(self)\n                    handlers.StartElementHandler(token.name, token.attrs)\n                }\n                if(token.self_closing &&\n                            handlers.EndElementHandler !== _b_.None){\n                    handlers.EndElementHandler(token.name)\n                }\n            }else if(token.is_end &&\n                    handlers.EndElementHandler !== _b_.None){\n                flush_char_data(self)\n                handlers.EndElementHandler(token.name)\n            }\n        }else if(token instanceof DATA &&\n                handlers.CharacterDataHandler !== _b_.None){\n            handlers.CharacterDataHandler(token.value)\n        }else if(token instanceof COMMENT &&\n                handlers.CommentHandler !== _b_.None){\n            flush_char_data(self)\n            handlers.CommentHandler(token.value)\n        }\n    }\n    flush_final_char_data(self)\n    if(isfinal){\n        self.finished = true\n    }\n}\n\nxmlparser.ParseFile = function(){\n    var $ = $B.args('ParseFile', 2,\n                {self: null, file: null},\n                ['self', 'file'], arguments,\n                {}, null, null),\n        self = $.self,\n        file = $.file\n    var reader = $B.$call($B.$getattr(file, 'read'))\n    while(true){\n        var data = reader(self._chunk_size)\n        console.log('ParseFile, data', data)\n        if(_b_.len(data) == 0){\n            return xmlparser.Parse(self, data, true)\n        }else{\n            xmlparser.Parse(self, data, false)\n        }\n    }\n}\n\nxmlparser.SetBase = function(self, base){\n    self._base = base\n    return _b_.None\n}\n\nxmlparser.SetParamEntityParsing = function(self, peParsing){\n    self._peParsing = peParsing\n    return peParsing\n}\n\nxmlparser.StartElementHandler = _b_.None\n\nxmlparser.xml_tokenizer = function*(self){\n    // convert bytes to string\n    self._element = new $B.imported.xml_parser.DOCUMENT(self)\n    while(self._pos < self._buffer_length){\n        var char = self._buffer[self._pos]\n        self._element = self._element.feed(char)\n        if(self._element.closed){\n            yield self._element\n        }\n        self._pos++\n    }\n    console.log('element', self._element)\n    console.log('fini')\n    alert()\n}\n\n$B.set_func_names(xmlparser, 'expat')\n\nfunction raise_error_known_position(parser, message, pos){\n    message += ' at position ' + pos\n    var ix = pos\n    while(ix >= 0 && parser._buffer[ix] !== '\\n'){\n        ix--\n    }\n    message += '\\n' + parser._buffer.substring(ix, pos + 1)\n    message += '\\n' + ' '.repeat(pos - ix - 1) + '^'\n    throw error.$factory(message)\n}\n\nfunction raise_error(parser, message){\n    throw error.$factory(message)\n}\n\nfunction raise_error1(element, char){\n    var head = element\n    while(head.origin){\n        head = head.origin\n    }\n    console.log(head)\n    var cls = element.constructor.name,\n        message = cls + ' expected ' + element.expect +\n            ', got: ' + char\n    var pos = head.parser._pos\n    raise_error_known_position(head.parser, message, pos)\n}\n\nvar error = $B.make_class(\"error\",\n    function(message){\n        return {\n            __class__: error,\n            msg: message,\n            args: $B.fast_tuple([message]),\n            __cause__: _b_.None,\n            __context__: _b_.None,\n            __suppress_context__: false\n        }\n    })\nerror.__bases__ = [_b_.Exception, _b_.object]\nerror.__mro__ = [_b_.Exception, _b_.BaseException, _b_.object]\n\n$B.set_func_names(error, \"expat\")\n\nfunction expect_chars(element, char, stop){\n    var res\n    if(! element.hasOwnProperty('expected_chars')){\n        element.expected_chars = ''\n    }\n    if(is_char(char)){\n        element.expected_chars += char\n        if(stop){\n            var end_pos = element.expected_chars.length - stop.length\n            var tail = element.expected_chars.substr(end_pos)\n            if(tail == stop){\n                res = {value: element.expected_chars.substr(0, end_pos)}\n                delete element.expected_chars\n                return res\n            }\n        }\n    }else{\n        res = {value: element.expected_chars}\n        if(element.expected_pos == literal.length){\n            delete element.expected_pos\n            return {value: literal}\n        }\n    }\n    return {value: null}\n}\n\n\nfunction expect_name(element, char){\n    if(! element.hasOwnProperty('expected_name')){\n        if(is_id_start(char)){\n            element.expected_name = char\n        }else if(! is_whitespace(char)){\n            raise_error(element.parser, 'expected name start, got: ' + char)\n        }\n    }else if(is_id_continue(char)){\n        element.expected_name += char\n    }else if(is_whitespace(char)){\n        var res = {value: element.expected_name}\n        delete element.expected_name\n        return res\n    }else{\n        raise_error(element.parser, 'name expected id, got: ' + char)\n    }\n    return {}\n}\n\nfunction expect_literal(element, literal, char){\n    if(! element.hasOwnProperty('expected_pos')){\n        element.expected_pos = 0\n    }\n    if(literal[element.expected_pos] == char){\n        element.expected_pos++\n        if(element.expected_pos == literal.length){\n            delete element.expected_pos\n            return {value: literal}\n        }else{\n            return {value: null}\n        }\n    }\n    return FAIL\n}\n\nfunction get_parser(element){\n    while(element.origin){\n        element = element.origin\n    }\n    return element.parser\n}\n\nfunction get_pos(element){\n    while(element.origin){\n        element = element.origin\n    }\n    return element.parser._pos\n}\n\n/*\ndocument  ::=  prolog element Misc*\n\nprolog       ::=  XMLDecl? Misc* (doctypedecl Misc*)?\nXMLDecl      ::=  '<?xml' VersionInfo EncodingDecl? SDDecl? S? '?>'\nMisc         ::=  Comment | PI | S\nComment  ::=  '<!--' ((Char - '-') | ('-' (Char - '-')))* '-->'\nPI        ::=  '<?' PITarget (S (Char* - (Char* '?>' Char*)))? '?>'\ndoctypedecl    ::=  '<!DOCTYPE' S Name (S ExternalID)? S? ('[' intSubset ']' S?)? '>'\n*/\nfunction DOCUMENT(parser){\n    this.parser = parser\n    this.expect = 'prolog'\n    this.names = []\n}\n\nDOCUMENT.prototype.feed = function(char){\n    if(this.expect == 'prolog'){\n        this.expect = 'element'\n        return (new prolog(this)).feed(char)\n        if(char !== '<'){\n            raise_error(this.parser, 'expected <')\n        }\n        this.expect = 'name_start_or_special'\n    }else if(this.expect == 'name_start_or_special'){\n        if(char == '!'){\n            this.expect = 'comment_or_doctype'\n        }else if(char == '?'){\n            this.expect = 'xmldecl_or_pi'\n        }else if(is_id_start(char)){\n            this.expect = 'prolog'\n            return new ELEMENT(this).feed(char)\n        }else{\n            raise_error1(this, char)\n        }\n    }else if(this.expect == 'comment_or_doctype'){\n        if(char == '-'){\n            this.expect = 'comment'\n        }else if(char == 'D'){\n            this.expect = 'DOCTYPE'\n            return this.feed(char)\n        }else{\n            raise_error('expected comment or DOCTYPE, got: ' + char)\n        }\n    }else if(this.expect == 'DOCTYPE'){\n        var res = expect_literal(this, 'DOCTYPE', char)\n        if(res.value){\n            return new DOCTYPE(this.parser, this)\n        }\n    }else if(this.expect == 'xmldecl_or_pi'){\n        var res = expect_name(this, char)\n        if(res.value){\n            if(res.value == 'xml'){\n                this.expect = 'prolog'\n                return new XMLDECL(this.parser, this)\n            }else{\n                this.expect = 'prolog'\n                var pi = new PI(this.parser, this)\n                pi.name = res.value\n                pi.expect = 'content'\n                return pi\n            }\n        }\n        return this\n    }else if(this.expect == 'comment'){\n        if(char == '-'){\n            this.expect = 'prolog'\n            return new COMMENT(this.parser, this)\n        }else{\n            raise_error(this.parser, 'DOCUMENT, expected -, got: ' + char)\n        }\n    }else{\n        raise_error(this.parser, 'DOCUMENT, unhandled expect: ' + this.expect)\n    }\n    return this\n}\n\n/*\nprolog       ::=  XMLDecl? Misc* (doctypedecl Misc*)?\n*/\nfunction prolog(origin){\n    this.origin = origin\n    this.expect = 'XMLDecl?'\n}\n\nprolog.prototype.feed = function(char){\n    if(this.expect == 'XMLDecl?'){\n        return (new XMLDecl(this)).feed(char)\n    }\n    return this\n}\n\n/*\nXMLDecl      ::=  '<?xml' VersionInfo EncodingDecl? SDDecl? S? '?>'\n*/\nfunction XMLDecl(origin){\n    this.origin = origin\n    this.expect = '<?xml'\n}\n\nXMLDecl.prototype.feed = function(char){\n    if(this.expect == '<?xml'){\n        var res = expect_literal(this, '<?xml', char)\n        if(res.value){\n            console.log('found value', res.value)\n            this.expect = 'EncodingDecl?'\n            return new VersionInfo(this)\n        }\n    }else if(this.expect == 'EncodingDecl?'){\n        return new EncodingDecl(this)\n    }else{\n        raise_error1(this, 'unhandled expect: ' + this.expect)\n    }\n    return this\n}\n\n/*\nVersionInfo  ::=  S 'version' Eq (\"'\" VersionNum \"'\" | '\"' VersionNum '\"')\n*/\nfunction VersionInfo(origin){\n    this.origin = origin\n    this.expect = 'S'\n}\n\nVersionInfo.prototype.feed = function(char){\n    if(this.expect == 'S'){\n        this.expect = 'version'\n        return (new S(this)).feed(char)\n    }else if(this.expect == 'version'){\n        var res = expect_literal(this, 'version', char)\n        if(res.value){\n            this.expect = \"'\"\n            return new Eq(this)\n        }\n    }else if(this.expect == \"'\"){\n        var parser = get_parser(this),\n            save_pos = parser._pos\n        var res = expect_literal(this, \"'\", char)\n        console.log('res', res)\n        if(res === FAIL){\n            parser._pos = save_pos\n            this.expect = '\"'\n            return this.feed(parser._buffer[save_pos])\n        }else if(res.value){\n            this.quote = res.value\n            this.expect = 'VersionNum1'\n        }\n    }else if(this.expect == '\"'){\n        var res = expect_literal(this, '\"', char)\n        console.log('res', res)\n        if(res === FAIL){\n            raise_error1(this, char)\n        }else if(res.value){\n            this.quote = res.value\n            this.expect = 'VersionNum2'\n        }\n    }else if(this.expect == 'VersionNum1'){\n        var res = expect_chars(this, char, \"'\")\n        if(res.value){\n            console.log('VersionInfo complete')\n            return this.origin\n        }else if(res === FAIL){\n            raise_error1(this, char)\n        }\n    }else if(this.expect == 'VersionNum2'){\n        var res = expect_chars(this, char, '\"')\n        if(res.value){\n            console.log('VersionInfo complete')\n            return this.origin\n        }else if(res === FAIL){\n            raise_error1(this, char)\n        }\n    }else{\n        raise_error1(this, 'unhandled expect: ' + this.expect)\n    }\n    return this\n}\n\nfunction S(origin){\n    this.origin = origin\n}\n\nS.prototype.feed = function(char){\n    if(! is_whitespace(char)){\n        return this.origin.feed(char)\n    }\n    return this\n}\n\n/*\nEq           ::=  S? '=' S?\n*/\n\nfunction Eq(origin){\n    this.origin = origin\n    this.expect = 'S1'\n}\n\nEq.prototype.feed = function(char){\n    if(this.expect == 'S1'){\n        this.expect = '='\n        return (new S(this)).feed(char)\n    }else if(this.expect == '='){\n        var res = expect_literal(this, '=', char)\n        if(res){\n            this.expect = 'S2'\n        }\n    }else if(this.expect == 'S2'){\n        this.expect = 'end'\n        return (new S(this)).feed(char)\n    }else if(this.expect == 'end'){\n        return this.origin.feed(char)\n    }\n    return this\n}\n\nfunction Quote(origin){\n    this.origin = origin\n}\n\nQuote.prototype.feed = function(char){\n    if(char == '\"' || char == \"'\"){\n        this.quote = char\n    }else{\n        raise_error1(this, char)\n    }\n    return this\n}\n/*\ndoctypedecl    ::=  '<!DOCTYPE' S Name (S ExternalID)? S? ('[' intSubset ']' S?)? '>'\nintSubset      ::=  (markupdecl | DeclSep)*\nmarkupdecl     ::=  elementdecl | AttlistDecl | EntityDecl | NotationDecl\n                 |  PI | Comment\nDeclSep        ::=  PEReference | S\n*/\n\nfunction DOCTYPE(parser, origin){\n    this.parser = parser\n    this.origin = origin\n    this.expect = 'element_start'\n}\n\nDOCTYPE.prototype.feed = function(char){\n    console.log('DOCTYPE feed', this.expect, 'char', char)\n    if(this.expect == 'element_start'){\n        var res = expect_name(this, char)\n        if(res.value){\n            this.name = res.value\n            this.expect = 'external_id_or_[_or_>'\n        }\n    }else if(this.expect == 'external_id_or_[_or_>'){\n        if(char == '['){\n            this.expect = '>'\n            return new intSubset(this)\n        }else if(char == '>'){\n            this.expect == 'no_whitespace'\n        }else if(char == 'S' || char == 'P'){\n            this.expect = '[_or_>'\n            var res = new ExternalID(this)\n            return res.feed(char)\n        }else{\n            raise_error(this.parser, 'DOCTYPE expected SYSTEM, PUBLIC, [ or >, got: ' + char)\n        }\n    }else if(this.expect == '[_or_>'){\n        if(char == '['){\n            this.expect = '>'\n            return new intSubset(this)\n        }else if(char == '>'){\n            this.expect = 'no_whitespace'\n        }else if(! is_whitespace(char)){\n            raise_error(this.parser, 'DOCTYPE expected [ or >, got: ' + char)\n        }\n    }else if(this.expect == '>'){\n        if(! is_whitespace(char)){\n            if(char == '>'){\n                this.expect = 'no_whitespace'\n            }else{\n                raise_error(this.parser, 'DOCTYPE expected >, got: ' + char)\n            }\n        }\n    }else if(this.expect = 'no_whitespace'){\n        if(! is_whitespace(char)){\n            return this.origin.feed(char)\n        }\n    }\n    return this\n}\n\n/*\nXMLDecl      ::=  '<?xml' VersionInfo EncodingDecl? SDDecl? S? '?>'\nVersionInfo  ::=  S 'version' Eq (\"'\" VersionNum \"'\" | '\"' VersionNum '\"')\nEq           ::=  S? '=' S?\nVersionNum   ::=  '1.0'\nEncodingDecl  ::=  S 'encoding' Eq ('\"' EncName '\"' | \"'\" EncName \"'\" )\nEncName       ::=  [A-Za-z] ([A-Za-z0-9._] | '-')*\nSDDecl  ::=  S 'standalone' Eq\n             ((\"'\" ('yes' | 'no') \"'\") | ('\"' ('yes' | 'no') '\"'))\n*/\nfunction XMLDECL(parser, origin){\n    this.parser = parser\n    this.expect = 'version_info'\n    this.origin = origin\n}\n\nXMLDECL.prototype.feed = function(char){\n    switch(this.expect){\n        case 'version_info':\n            var res = expect_literal(this, 'version', char)\n            if(res.value){\n                this.expect = 'eq'\n                this.attr_name = 'version'\n            }\n            break\n        case 'eq':\n            if(char == '='){\n                this.expect = 'quote'\n            }else if(! is_whitespace(char)){\n                raise_error(this.parser, 'expect =, got: ' + char)\n            }\n            break\n        case 'quote':\n            if(is_quote(char)){\n                this.expect = char\n                this.quoted = ''\n            }else if(! is_whitespace(char)){\n                raise_error(this.parser, 'expected quote, got: ' + char)\n            }\n            break\n        case '\"':\n        case \"'\":\n            var res = expect_literal(this, this.expect, char)\n            if(res.value){\n                this[this.attr_name] = this.quoted\n                this.expect = 'encoding_or_sd_or_close'\n            }else{\n                this.quoted += char\n            }\n            break\n        case 'encoding_or_sd_or_close':\n            switch(char){\n                case 'e':\n                    if(! this.hasOwnProperty('encoding')){\n                        this.expect = 'encoding'\n                        return this.feed(char)\n                    }\n                    break\n                case 's':\n                    if(! this.hasOwnProperty('standalone')){\n                        this.expect = 'standalone'\n                        return this.feed(char)\n                    }\n                    break\n                case '?':\n                    this.expect = '>'\n                    break\n                default:\n                    if(! is_whitespace(char)){\n                        raise_error(this.parser,\n                            'expected encoding, standalone or ?, got: ' + char)\n                    }\n            }\n            break\n        case 'encoding':\n        case 'standalone':\n            var res = expect_literal(this, this.expect, char)\n            if(res.value){\n                this.attr_name = this.expect\n                this.expect = 'eq'\n            }\n            break\n        case '>':\n            if(char == '>'){\n                this.closed = true\n            }else if(! is_whitespace(char)){\n                if(this.closed){\n                    return this.origin.feed(char)\n                }\n                raise_error(this.parser, 'expected >, got: ' + char)\n            }\n            break\n        default:\n            raise_error(this.parser, 'unhandled case: ' + this.expect)\n    }\n    return this\n}\n\n/*\nPI        ::=  '<?' PITarget (S (Char* - (Char* '?>' Char*)))? '?>'\nPITarget  ::=  Name - (('X' | 'x') ('M' | 'm') ('L' | 'l'))\n*/\nfunction PI(parser, origin){\n    this.parser = parser\n    this.origin = origin\n    this.expect = 'pi_target'\n}\n\nPI.prototype.feed = function(char){\n    if(this.expect == 'pi_target'){\n        var res = expect_name(this, char)\n        if(res.value){\n            this.pi_target = res.value\n            this.expect = 'content'\n        }\n    }else if(this.expect == 'content'){\n        var res = expect_chars(this, char, '?>')\n        if(res.value){\n            this.content = res.value\n            this.closed = true\n            this.expect = 'no_whitespace'\n        }\n    }else if(this.expect == 'no_whitespace'){\n        if(! is_whitespace(char)){\n            return this.origin.feed(char)\n        }\n    }\n    return this\n}\n\nfunction CDATA(){\n    this.content = ''\n    this.expect = ']'\n    this.level = 1\n}\n\nCDATA.prototype.feed = function(char){\n    switch(this.expect){\n        case ']':\n            if(char == '>'){\n                throw Error('closed without closing ]')\n            }else if(char == '['){\n                this.level++\n            }else if(char == ']'){\n                if(this.level == 1){\n                    this.expect = '>'\n                }else{\n                    this.level--\n                }\n            }else{\n                this.content += char\n            }\n            break\n        case '>':\n            if(char != '>'){\n                console.log('-- error', this, 'char', char)\n                throw Error('expected \">\", got: ' + char)\n            }\n            this.closed = true\n            break\n    }\n    return this\n}\n\nfunction DTD(parser){\n    this.parser = parser\n    this.expect = 'name_start'\n    this.items = []\n}\n\nDTD.prototype.feed = function(char){\n    if(this.expect == 'name_start'){\n        if(is_id_start(char)){\n            this.name = char\n            this.expect = 'name_continue'\n        }else if(char == '-'){\n            this.expect = '-' // maybe comment start\n        }else if(char == '['){\n            return new CDATA()\n        }else{\n            throw Error('expected name, got ' + char)\n        }\n    }else if(this.expect == 'name_continue'){\n        if(is_id_continue(char)){\n            this.name += char\n        }else{\n            console.log('DD, name', this.name)\n            if(this.name == 'DOCTYPE'){\n                return new DOCTYPE(this.parser)\n            }else if(this.name == 'ENTITY'){\n                return new ENTITY(this.parser)\n            }\n            if(char == '>'){\n                this.closed = true\n            }else{\n                this.expect == 'any'\n            }\n        }\n    }else if(this.expect == '-'){\n        if(char == '-'){\n            // comment\n            this.is_comment = true\n        }else{\n            throw Error('expected -, got: ' + char)\n        }\n    }else{\n        if(char == '>'){\n            this.closed = true\n        }else{\n            this.items.push(char)\n        }\n    }\n    return this\n}\n\nDTD.prototype.toString = function(){\n    var res = `<!${this.name}`\n    if(this.items.length > 0){\n        res += ' '\n        var items = this.items.map(x => x.toString())\n        res += items.join(' ')\n    }\n    return res + '>'\n}\n\nfunction COMMENT(parser, origin){\n    this.parser = parser\n    this.origin = origin\n    this.value = ''\n    this.expect = '-->'\n}\n\nCOMMENT.prototype.feed = function(char){\n    if(this.expect == '-->'){\n        var res = expect_chars(this, char, '-->')\n        if(res.value){\n            this.content = res.value\n            this.expect = 'no_whitespace'\n        }\n    }else if(this.expect == 'no_whitespace'){\n        if(! is_whitespace(char)){\n            return this.origin.feed(char)\n        }\n    }\n    return this\n}\n\n/*\nelement       ::=  EmptyElemTag  | STag content ETag\nSTag          ::=  '<' Name (S Attribute)* S? '>'\nAttribute     ::=  Name Eq AttValue\nETag          ::=  '</' Name S? '>'\ncontent       ::=  CharData?\n                   ((element | Reference | CDSect | PI | Comment) CharData?)*\nEmptyElemTag  ::=  '<' Name (S Attribute)* S? '/>'\n*/\n\nfunction ELEMENT(origin) {\n    this.origin = origin\n    this.expect = '?_/_or_name_start'\n    this.attrs = $B.empty_dict()\n}\n\nELEMENT.prototype.add_attribute_name = function(attr_name){\n    if(_b_.dict.$contains(this.attrs, attr_name)){\n        throw Error(`duplicate attribute name: ${attr_name}`)\n    }\n    _b_.dict.$setitem(this.attrs, attr_name, _b_.None)\n}\n\nELEMENT.prototype.set_attribute_value = function(value){\n    _b_.dict.$setitem(this.attrs, this.attr_name, value)\n}\n\nELEMENT.prototype.feed = function(char){\n    console.log('ELEMENT feed, expects', this.expect, 'char', char)\n    if(this.expect == 'name_start'){\n        if(char == '?'){\n            if(this.is_declaration){\n                throw Error('already got ?')\n            }\n            this.is_declaration = true\n        }else if(char == '/'){\n            if(this.is_end){\n                throw Error('already got /')\n            }\n            this.is_end = true\n        }else if(is_id_start(char)){\n            this.name = char\n            this.expect = 'name_continue'\n        }\n    }else if(this.expect == 'name_continue'){\n        if(is_id_continue(char)){\n            this.name += char\n        }else{\n            // end of element name\n            if(this.is_declaration){\n                if(this.name == 'xml'){\n                    this.is_xml_header = true\n                }else{\n                    return new PROCESSING_INSTRUCTION(this.parser, this.name)\n                }\n            }\n            if(is_whitespace(char)){\n                this.expect = 'attr_name_start'\n            }else if(char == '>'){\n                this.closed = true\n            }else if(char == '/'){\n                this.self_closing = true\n                this.expect = '>'\n            }else{\n                throw Error('unexpected at end of element name: ' + char)\n            }\n        }\n    }else if(this.expect == 'attr_name_start'){\n        if(char == '/'){\n            this.self_closing = true\n        }else if(char == '>'){\n            this.expect = 'no_whitespace'\n        }else if(is_id_start(char)){\n            this.attr_name = char\n            this.expect = 'attr_name_continue'\n        }else if(char == '?' && this.is_declaration){\n            this.expect = '>'\n        }else if(! is_whitespace(char)){\n            throw Error('expected attribute name, got: ' + char)\n        }\n    }else if(this.expect == 'attr_name_continue'){\n        if(is_id_continue(char)){\n            this.attr_name += char\n        }else if(char == '='){\n            this.add_attribute_name(this.attr_name)\n            this.expect = 'attr_value_start'\n            this.attr_value = ''\n        }else if(is_whitespace(char)){\n            this.add_attribute_name(this.attr_name)\n            this.expect = '='\n        }else if(char == '>'){\n            this.add_attribute_name(this.attr_name)\n            this.closed = true\n        }else{\n            throw Error('unexpected character in attribute name: ' + char)\n        }\n    }else if(this.expect == '='){\n        if(char == '='){\n            this.expect = 'attr_value_start'\n        }else if(! is_whitespace(char)){\n            raise_error1(this, char)\n        }\n    }else if(this.expect == 'attr_value'){\n        if(char == '='){\n            this.expect = 'attr_value_start'\n            this.attr_value = ''\n        }else if(char == '>'){\n            this.closed = true\n        }else if(is_id_start(char)){\n            this.attr_name = char\n            this.expect = 'attr_name_continue'\n        }else if(! is_whitespace(char)){\n            throw Error('expected attribute value or name, got: ' + char)\n        }\n    }else if(this.expect == 'attr_value_start'){\n        if(char == '\"' || char == \"'\"){\n            this.expect = 'quote'\n            this.quote = char\n            this.attr_value = ''\n        }else if(! is_whitespace(char)){\n            throw Error('unexpect attribute value start: ' + char)\n        }\n    }else if(this.expect == \"quote\"){\n        if(char == this.quote){\n            this.set_attribute_value(this.attr_value)\n            this.expect = 'attr_name_start'\n        }else{\n            this.attr_value += char\n        }\n    }else if(this.expect == '>'){\n        if(char == '>'){\n            this.closed = true\n        }else{\n            throw Error('expected >, got: ' + char)\n        }\n    }else if(this.expect == 'attr_name'){\n        if(char instanceof Name){\n            if(_b_.dict.__contains__(this.attrs, char.value)){\n                throw Error('duplicate value ' + char.value)\n            }\n            _b_.dict.$setitem(this.attrs, char.value, _b_.None)\n            this.last_attr = char.value\n        }else if(char.value == '?' && this.is_declaration){\n            if(this.question_mark){\n                throw Error('already ?')\n            }\n            this.question_mark = true\n        }else if(char == END){\n            if(this.is_declaration && ! this.question_mark){\n                throw Error('missing ')\n            }\n        }else if(char instanceof Punctuation && char.value == '/'){\n            this.no_end = true\n            this.expect = END\n        }else{\n            throw Error('expected attribute name, got ' + char)\n        }\n    }else if(this.expect == 'attr_value'){\n        _b_.dict.$setitem(this.attrs, this.last_attr, char)\n        this.expect = 'attr_name'\n    }else if(this.expect == END){\n        // after \"/\"\n        if(char != END){\n            throw Error('nothing after /')\n        }\n    }else if(this.expect == 'no_whitespace'){\n        if(! is_whitespace(char)){\n            return this.origin.feed(char)\n        }\n    }else{\n        raise_error1(this, char)\n    }\n    return this\n}\n\nELEMENT.prototype.toString = function() {\n    var res = `<`\n    res += this.is_end ? '/' : ''\n    res += this.name\n    if(this.attrs.length > 0){\n        res += ' '\n    }\n    var attrs = []\n    for(var item of _b_.dict.$iter_items(this.attrs)){\n        console.log('item', item)\n        attrs.push(`${item.key}: ${item.value.toString()}`)\n    }\n    res += attrs.join(' ')\n    if(this.no_end){\n        res += '/'\n    }\n    return res + '>'\n}\n\n/*\nEntityDecl        ::=  GEDecl | PEDecl\nPEDecl            ::=  '<!ENTITY' S '%' S Name S PEDef S? '>'\nPEDef             ::=  EntityValue | ExternalID\n*/\nfunction ENTITY(parser){\n    this.parser = parser\n}\n\nENTITY.prototype.feed = function(char){\n    if(! is_whitespace(char)){\n        if(is_id_start(char)){\n            return new GEDecl(this.parser, char)\n        }else if(char == \"%\"){\n            return new PEDecl(this.parser)\n        }\n        throw Error('unexpected after ENTITY: ' + char)\n    }\n}\n\n/*\nGEDecl            ::=  '<!ENTITY' S Name S EntityDef S? '>'\nEntityDef         ::=  EntityValue | (ExternalID NDataDecl?)\nExternalID        ::=  'SYSTEM' S SystemLiteral\n                    |  'PUBLIC' S PubidLiteral S SystemLiteral\nNDataDecl         ::=  S 'NDATA' S Name\nEntityValue    ::=  '\"' ([^%&\"] | PEReference | Reference)* '\"'\n                 |  \"'\" ([^%&'] | PEReference | Reference)* \"'\"\n\n*/\nfunction GEDecl(parser, char){\n    this.parser = parser\n    this.expect = 'name_continue'\n    this.name = char\n    this.state = 'name'\n}\n\nGEDecl.prototype.feed = function(char){\n    switch(this.expect){\n        case 'name_start':\n            if(is_id_start(char)){\n                if(this.state == 'NDATA'){\n                    this.ndata_name = char\n                }\n                this.expect = 'name_continue'\n            }else if(! is_whitespace(char)){\n                throw Error('GEDecl expected name start, got: ' + char)\n            }\n            break\n        case 'name_continue':\n            if(is_id_continue(char)){\n                if(this.state == 'name'){\n                    this.name += char\n                }else if(this.state == 'NDATA'){\n                    this.ndata_name += char\n                }\n            }else if(is_whitespace(char)){\n                if(this.state == 'NDATA'){\n                    this.expect = '>'\n                }else{\n                    this.expect = 'entity_def'\n                }\n            }else if(char == '>' && this.state == 'NDATA'){\n                this.closed = true\n            }else{\n                throw Error('GEDecl expected name, got: ' + char)\n            }\n            break\n        case 'entity_def':\n            if(is_quote(char)){\n                this.quoted = ''\n                this.state = this.expect\n                this.expect = char\n            }else if(char == 'S' || char == 'P'){\n                this.expect = char == 'S' ? 'SYSTEM' : 'PUBLIC'\n                this.expect_pos = 1\n                this.external_id = this.expect\n            }else if(! is_whitespace(char)){\n                throw Error('GEDCL expect quote, SYSTEM or PUBLIC, got: ' + char)\n            }\n            break\n        case 'SYSTEM':\n        case 'PUBLIC':\n            if(char == this.expect[this.expect_pos]){\n                this.expect_pos++\n                if(this.expect_pos == this.expect.length){\n                    this.expect = this.expect == 'SYSTEM' ? 'system_literal' :\n                                                            'pubid_literal'\n                }\n            }else{\n                throw Error(`GEDecl expected ${this.expect}, got: ${char}`)\n            }\n            break\n        case 'NDATA':\n            if(char == this.expect[this.expect_pos]){\n                this.expect_pos++\n                if(this.expect_pos == this.expect.length){\n                    this.expect = 'name_start'\n                    this.ndata_name = ''\n                    this.state = 'NDATA'\n                }\n            }else{\n                throw Error(`GEDecl expected ${this.expect}, got: ${char}`)\n            }\n            break\n        case '\"':\n        case \"'\":\n            if(this.state == 'entity_def'){\n                if(char == this.expect){\n                    this.entity_def = this.quoted\n                    this.expect = '>'\n                }else{\n                    this.quoted += char\n                }\n            }else if(this.state == 'system_literal'){\n                if(char == this.expect){\n                    this.system_literal = this.quoted\n                    this.expect = 'n_data_decl_or_close'\n                }else{\n                    this.quoted += char\n                }\n            }\n            break\n        case 'system_literal':\n            if(is_quote(char)){\n                this.expect = char\n                this.state = 'system_literal'\n                this.quoted = ''\n            }else if(! is_whitespace(char)){\n                throw Error('GEDecl expected SystemLiteral, got: ' + char)\n            }\n            break\n        case '>':\n            if(! is_whitespace(char)){\n                if(char == '>'){\n                    this.closed = true\n                }else{\n                    throw Error('GEDecl expected >, got: ' + char)\n                }\n            }\n            break\n        case 'n_data_decl_or_close':\n            if(char == '>'){\n                this.closed = true\n            }else if(char == 'N'){\n                this.expect = 'NDATA'\n                this.expect_pos = 1\n            }else if(! is_whitespace(char)){\n                throw Error('GEDecl expected NDATA or >, got: ' + char)\n            }\n            break\n        default:\n            console.log(this.parser._buffer.substr(0, this.parser._pos))\n            throw Error('pas fini...')\n    }\n    return this\n}\n\n/*\nExternalID        ::=  'SYSTEM' S SystemLiteral\n                    |  'PUBLIC' S PubidLiteral S SystemLiteral\n*/\nfunction ExternalID(origin){\n    this.origin = origin\n    this.expect = 'first'\n}\n\nExternalID.prototype.feed = function(char){\n    if(this.expect == 'first'){\n        if(! is_whitespace(char)){\n            if(char == 'S'){\n                this.expect = 'SYSTEM'\n                return this.feed(char)\n            }else if(char == 'P'){\n                this.expect = 'PUBLIC'\n                return this.feed(char)\n            }else{\n                raise_error(this, 'ExternalID expected SYSTME or PUBLIC, got: ' + char)\n            }\n        }\n    }else if(this.expect == 'SYSTEM' || this.expect == 'PUBLIC'){\n        var res = expect_literal(this, this.expect, char)\n        if(res.value){\n            this.type = this.expect\n            if(this.type == 'SYSTEM'){\n                this.expect = '[_or_>'\n                return new SystemLiteral(this)\n            }else{\n                this.expect = 'system_after_pubid'\n                return new PubidLiteral(this)\n            }\n        }\n    }else if(this.expect == 'system_after_pubid'){\n        if(! is_whitespace(char)){\n            this.expect = '[_or_>'\n            return (new SystemLiteral(this)).feed(char)\n        }\n    }else if(this.expect == '[_or_>'){\n        if(char == '['){\n            this.expect = '>'\n            return new intSubset(this)\n        }else if(char == '>'){\n            return this.origin.feed(char)\n        }else{\n            raise_error1(this, char)\n        }\n    }else if(this.expect == '>'){\n        if(char == '>'){\n            this.expect = 'no_whitespace'\n        }else if(! is_whitespace(char)){\n            raise_error1(this, char)\n        }\n    }else if(this.expect == 'no_whitespace'){\n        if(! is_whitespace(char)){\n            console.log('return to origin', this.origin, 'char', char)\n            return this.origin.feed(char)\n        }\n    }\n    return this\n}\n\n/*\nPubidLiteral   ::=  '\"' PubidChar* '\"' | \"'\" (PubidChar - \"'\")* \"'\"\nPubidChar      ::=  #x20 | #xD | #xA | [a-zA-Z0-9]\n                 |  [-'()+,./:=?;!*#@$_%]\n*/\nfunction PubidLiteral(origin){\n    this.origin = origin\n    this.expect = 'quote'\n}\n\n\nfunction is_pubid_char(char){\n    /*\n#x20 | #xD | #xA | [a-zA-Z0-9]\n                 |  [-'()+,./:=?;!*#@$_%]\n*/\n    return char.match(new RegExp(\"[a-zA-Z0-9-'()+,./:=?;!*#@$_%]\")) ||\n        ' \\n\\r'.includes(char)\n}\n\nPubidLiteral.prototype.feed = function(char){\n    if(this.expect == 'quote'){\n        if(is_quote(char)){\n            this.expect = char\n            this.content = ''\n        }else if(! is_whitespace(char)){\n            raise_error1(this, char)\n        }\n    }else if(this.expect == 'no_whitespace'){\n        if(! is_whitespace(char)){\n            return this.origin.feed(char)\n        }\n    }else{\n        if(char == this.expect){\n            this.expect = 'no_whitespace'\n        }else if(is_pubid_char(char)){\n            this.content += char\n        }else{\n            console.log('PubidLiteral expects', this.expect, 'char', char)\n            console.log(is_pubid_char(char))\n            raise_error1(this, char)\n        }\n    }\n    return this\n}\n\nfunction SystemLiteral(origin){\n    this.origin = origin\n    this.expect = 'quote'\n}\n\nSystemLiteral.prototype.feed = function(char){\n    console.log('SystemLiteral expects', this.expect, 'char', char)\n    if(this.expect == 'quote'){\n        if(is_quote(char)){\n            this.expect = char\n            this.content = ''\n        }else if(! is_whitespace(char)){\n            raise_error1(this, char)\n        }\n    }else if(this.expect == 'no_whitespace'){\n        if(! is_whitespace(char)){\n            return this.origin.feed(char)\n        }\n    }else{\n        if(char == this.expect){\n            this.expect = 'no_whitespace'\n        }else{\n            this.content += char\n        }\n    }\n    return this\n}\n\nfunction PROCESSING_INSTRUCTION(parser, name){\n    this.parser = parser\n    this.name = name\n    this.expect = '?'\n    this.content = ''\n}\n\nPROCESSING_INSTRUCTION.prototype.feed = function(char){\n    // capture everything until the sequence ?>\n    if(this.expect == '?'){\n        if(char == '?'){\n            this.expect = '>'\n        }else{\n            this.content += char\n        }\n    }else if(this.expect == '>'){\n        if(char == '>'){\n            this.closed = true\n        }else{\n            this.content += '?' + char\n            this.expect = '-'\n        }\n    }\n    return this\n}\n\nfunction ATTR(name){\n  this.name = name\n}\n\nATTR.prototype.toString = function(){\n  var res = this.name\n  if(this.hasOwnProperty('value')){\n    res += '=' + this.value\n  }\n  return res\n}\n\nfunction DATA(value) {\n    this.value = value\n}\n\nDATA.prototype.toString = function() {\n    return `${this.value}`\n}\n\nvar START = 'START'\nvar END = 'END'\n\n\nfunction Name(value){\n    this.value = value\n}\n\nName.prototype.toString = function(){\n    return this.value\n}\n\nfunction Punctuation(value){\n    this.value = value\n}\n\nfunction String(quote, value){\n    this.quote = quote\n    this.value = value\n}\n\nString.prototype.toString = function(){\n    return this.quote + this.value + this.quote\n}\n\nconst punctuations = '!?/'\n\nfunction open(url){\n    var xhr = new XMLHttpRequest()\n    xhr.open('GET', url, false)\n    xhr.onreadystatechange = function(ev){\n        if(this.readyState == 4){\n            process(this.responseText)\n        }\n    }\n    xhr.send()\n}\n\nfunction create_parser(){\n    var $ = $B.args('ParserCreate', 3,\n                {encoding: null, namespace_separator: null, intern: null},\n                ['encoding', 'namespace_separator', 'intern'], arguments,\n                {encoding: _b_.None, namespace_separator: _b_.None, intern: _b_.None},\n                null, null),\n        encoding = $.encoding,\n        ns_sep = $.namespace_separator,\n        intern = $.intern\n    if(encoding !== _b_.None && ! _b_.isinstance(encoding, _b_.str)){\n        throw _b_.TypeError.$factory(\n            `ParserCreate() argument 'encoding' must be ` +\n            `str or None, not ${$B.class_name(encoding)}`)\n    }\n    if(ns_sep !== _b_.None){\n        if(! _b_.isinstance(ns_sep, _b_.str)){\n            throw _b_.TypeError.$factory(\n                `ParserCreate() argument 'namespace_separator' must be ` +\n                `str or None, not ${$B.class_name(ns_sep)}`)\n        }\n        if(ns_sep.length != 1){\n            throw _b_.ValueError.$factory(\"namespace_separator must be at \" +\n                \"most one character, omitted, or None\")\n        }\n    }\n    if(intern === _b_.None){\n        intern = $B.empty_dict()\n    }else if(! _b_.isinstance(intern, _b_.dict)){\n        throw _b_.TypeError.$factory('intern must be a dictionary')\n    }\n    return xmlparser.$factory(encoding, ns_sep, intern)\n}\n\nfunction display(text){\n    report.value += text + '\\n'\n}\n\nfunction process(src){\n    var indent = 0\n    for(var token of xml_tokenizer(src)){\n        if(indent > 50){\n            break\n        }\n        var head = ' '.repeat(indent)\n        if(token instanceof DATA){\n            display(head + ' ' + token.toString())\n        }else if(token instanceof ELEMENT){\n            if(token.is_end){\n                indent--\n            }\n            head = ' '.repeat(indent)\n            display(head + token.toString())\n            if(token.is_end || token.self_closing || token.is_declaration){\n                //\n            }else{\n                indent++\n            }\n        }else if(token instanceof DECLARATION){\n            display(head + token.toString())\n        }else{\n            console.log(head + 'token', token, token.toString())\n        }\n    }\n}\n\nfunction is_id_start(char){\n    return char.match(/\\p{L}/u) || char == \"_\"\n}\n\nfunction is_id_continue(char){\n    return char.match(/\\p{L}/u) || \"-_:\".includes(char) || char.match(/\\d/)\n}\n\nfunction is_whitespace(s){\n    for(let char of s){\n        if(! ' \\n\\r\\t'.includes(char)){\n            return false\n        }\n    }\n    return s.length > 0\n}\n\nfunction is_quote(char){\n    return char == '\"' || char == \"'\"\n}\n\nfunction is_char(char){\n    // #x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD] | [#x10000-#x10FFFF]\n    var cp = char.codePointAt(0)\n    return ([0x9, 0xa, 0xd].includes(cp)) ||\n            (0x20 <= cp && cp <= 0xd7ff) ||\n            (0xe000 <= cp && cp <= 0xfffd) ||\n            (0x10000 <= cp && cp <= 0x10ffff)\n}\n\nvar errors = 'errors'\n\n$B.addToImported('pyexpat',\n    {\n        create_parser,\n        ParserCreate: create_parser,\n        model,\n        error,\n        errors,\n        XML_PARAM_ENTITY_PARSING_NEVER,\n        XML_PARAM_ENTITY_PARSING_UNLESS_STANDALONE,\n        XML_PARAM_ENTITY_PARSING_ALWAYS\n    }\n)\n\n})(__BRYTHON__)"], "python_re": [".js", "// Regular expression\n(function($B){\n\nvar _debug = {value: 0}\n\nvar _b_ = $B.builtins\n\nvar MAXGROUPS = 2147483647,\n    MAXREPEAT = 2147483648\n\nvar word_gcs = ['Ll', 'Lu', 'Lm', 'Lt', 'Lo',\n                'Nd',\n                'Mc', 'Me', 'Mn',\n                'Pc']\n\nfunction is_word(cp){\n    if((cp >= 97 && cp <= 122) // a-z\n            || (cp >= 65 && cp <= 90) // A-Z\n        ){\n            return true\n    }\n    for(var word_gc of word_gcs){\n        if($B.in_unicode_category(word_gc, cp)){\n            return true\n        }\n    }\n    return false\n}\n\nvar ascii_word = {}\n\nfor(var cp = 0; cp <= 127; cp++){\n    if(is_word(cp)){\n        ascii_word[cp] = true\n    }\n}\n\nfunction is_ascii_word(cp){\n    return ascii_word[cp] !== undefined\n}\n\nfunction is_digit(cp){\n    if(cp >= 48 && cp <= 57){\n        return true\n    }\n    return $B.in_unicode_category('Nd', cp)\n}\n\nfunction is_ascii_digit(cp){\n    return cp <= 127 && is_digit(cp)\n}\n\nvar $error_2 = {\n    $name: \"error\",\n    $qualname: \"error\",\n    $is_class: true,\n    __module__: \"re\"\n}\n\nvar error = $B.make_class(\"error\",\n    function(message){\n        return {\n            __class__: error,\n            msg: message,\n            args: $B.fast_tuple([]),\n            __cause__: _b_.None,\n            __context__: _b_.None,\n            __suppress_context__: false\n        }\n    })\nerror.__bases__ = [_b_.Exception, _b_.object]\nerror.__mro__ = [_b_.Exception, _b_.BaseException, _b_.object]\n\nerror.__str__ = function(self){\n    var s = self.msg + ' at position ' + self.pos\n    if(self.lineno > 1){\n        s += ` (line ${self.lineno}, column ${self.colno})`\n    }\n    return s\n}\n\n$B.set_func_names(error, \"re\")\n\nfunction $last(t){\n    return t[t.length - 1]\n}\n\nfunction fail(message, pos, pattern){\n    var err = error.$factory(message)\n    err.msg = message\n    err.pos = pos\n    if(pattern){\n        err.pattern = pattern.py_obj // Python object passed to compile()\n        err.lineno = 1\n        var linestart = 0\n        for(var i = 0, len = pattern.string.length; i < pos; i++){\n            if(pattern.string[i] == '\\n'){\n                err.lineno++\n                linestart = i + 1\n            }\n        }\n        err.colno = pos - linestart + 1\n    }\n    throw err\n}\n\nfunction warn(klass, message, pos, text){\n    var frame = $B.frame_obj.frame,\n        file = frame[3].__file__,\n        src = $B.file_cache[file]\n    if(text === undefined){\n        var lineno = frame[1].$lineno\n        var lines = src.split('\\n'),\n            line = lines[lineno - 1]\n    }else{\n        if(Array.isArray(text)){\n            text = from_codepoint_list(text)\n        }\n        var lineno = 1,\n            line_start = 0\n        for(var i = 0; i < pos; i++){\n            if(text[i] == '\\n'){\n                lineno++\n                line_start = i + 1\n            }\n        }\n        var line_end = text.substr(line_start).search('\\n'),\n            line\n        if(line_end == -1){\n            line = text.substr(line_start)\n        }else{\n            line = text.substr(line_start, line_end)\n        }\n        var col_offset = pos - line_start\n    }\n    var warning = klass.$factory(message)\n    warning.pos = pos\n    warning.args[1] = [file, lineno, col_offset, lineno, col_offset,\n        line]\n    warning.filename = file\n    warning.lineno = warning.end_lineno = lineno\n    warning.offset = warning.end_offset = col_offset\n    warning.line = line\n    // module _warning is in builtin_modules.js\n    $B.imported._warnings.warn(warning)\n}\n\nfunction chr(i){\n    if(i < 0 || i > 1114111){\n        throw _b_.ValueError.$factory('Outside valid range')\n    }else if(i >= 0x10000 && i <= 0x10FFFF){\n        var code = (i - 0x10000)\n        return String.fromCodePoint(0xD800 | (code >> 10)) +\n            String.fromCodePoint(0xDC00 | (code & 0x3FF))\n    }else{\n        return String.fromCodePoint(i)\n    }\n}\n\nfunction ord(char){\n    return char.charCodeAt(0)\n}\n\nconst LETTERS = {\n    b: ord('b'),\n    N: ord('N'),\n    P: ord('P'),\n    u: ord('u'),\n    U: ord('U'),\n    x: ord('x')\n}\n\nconst PARENTH_OPEN = ord('('),\n      PARENTH_CLOSE = ord(')'),\n      BRACKET_OPEN = ord('['),\n      BRACKET_CLOSE = ord(']'),\n      BRACE_OPEN = ord('{'),\n      BRACE_CLOSE = ord('}'),\n      EQUAL = ord('='),\n      SUP = ord('>'),\n      INF = ord('<'),\n      MINUS = ord('-'),\n      PLUS = ord('+'),\n      OR = ord('|'),\n      DOT = ord('.'),\n      QUESTION_MARK = ord('?'),\n      EXCLAMATION_MARK = ord('!'),\n      COLON = ord(':'),\n      BACKSLASH = ord('\\\\'),\n      DOLLAR = ord('$'),\n      CARET = ord('^'),\n      LINEFEED = ord('\\n')\n\n// pattern tokenizer\n\nfunction is_ascii(name){\n    return /^[\\x00-\\x7F]*$/.test(name)\n}\n\nfunction open_unicode_db(){\n    if($B.unicodedb === undefined){\n        var xhr = new XMLHttpRequest\n        xhr.open(\"GET\",\n            $B.brython_path + \"unicode.txt?\" + (new Date()).getTime(), false)\n        xhr.onreadystatechange = function(){\n            if(this.readyState == 4){\n                if(this.status == 200){\n                    $B.unicodedb = this.responseText\n                }else{\n                    console.log(\n                        \"Warning - could not load unicode.txt\")\n                }\n            }\n        }\n        xhr.send()\n    }\n}\n\nfunction validate_named_char(description, pos){\n    // validate that \\N{<description>} is in the Unicode db\n    // Load unicode table if not already loaded\n    if(description.length == 0){\n        fail(\"missing character name\", pos)\n    }\n    open_unicode_db()\n    if($B.unicodedb !== undefined){\n        var re = new RegExp(\"^([0-9A-F]+);\" +\n            description.toUpperCase() + \";.*$\", \"m\")\n        search = re.exec($B.unicodedb)\n        if(search === null){\n            fail(`undefined character name '${description}'`, pos)\n        }\n        return parseInt(search[1], 16)\n    }else{\n        fail(\"could not load unicode.txt\", pos)\n    }\n}\n\nfunction validate_group_name(sname, pos, is_bytes){\n    // sname is an instance of StringObj\n    if(! _b_.str.isidentifier(sname.string)){\n        fail(`bad character in group name '${sname.string}'`, pos + 4)\n    }\n    if(is_bytes && ! is_ascii(sname.string)){\n        var s = _b_.bytes.decode(_b_.bytes.$factory(sname.codepoints),\n                                 'ascii', 'backslashreplace')\n        warn(_b_.DeprecationWarning,\n            `bad character in group name '${s}' at position ${pos + 4}`)\n    }\n    return true\n}\n\nfunction validate_group_num(so, pos){\n    var s = so.string\n    if(s.match(/^\\d+$/)){\n        return true\n    }\n    try{\n        var num = _b_.int.$factory(s)\n        warn(_b_.DeprecationWarning,\n            `bad character in group name '${s}' at position ${pos + 3}`,\n            pos + 3, s)\n        so.string = num + ''\n        return true\n    }catch(err){\n        return false\n    }\n}\n\nfunction validate_num_or_name(so, pos, is_bytes){\n    return validate_group_num(so, pos, is_bytes) ||\n               validate_group_name(so, pos - 1, is_bytes)\n}\n\nvar character_classes = {\n    in_charset: to_codepoint_list('dDsSwW'),\n    in_re: to_codepoint_list('AbBdDsSwWZ')\n}\n\nfunction escaped_char(args){\n    var cps = args.codepoints,\n        pos = args.pos,\n        in_charset = args.in_charset,\n        is_bytes = args.is_bytes // if pattern is bytes\n    var special = cps[pos + 1]\n    if(special === undefined){\n        fail('bad escape (end of pattern)', pos)\n    }\n    var key = in_charset ? 'in_charset' : 'in_re'\n    if(in_charset && special == LETTERS.b){\n        // Inside a character range, \\b represents the backspace character,\n        // for compatibility with Python\u2019s string literals.\n        return '\\b'\n    }\n    if(character_classes[key].indexOf(special) > -1){\n        return new CharacterClass(pos, special, 2)\n    }else if(special == LETTERS.N && ! is_bytes){\n        if(cps[pos + 2] != BRACE_OPEN){\n            fail('missing {', pos)\n        }\n        var i = pos + 3,\n            description = []\n        while(i < cps.length){\n            if(cps[i] == BRACE_CLOSE){\n                break\n            }\n            description.push(cps[i])\n            i++\n        }\n        if(description.length == 0){\n            fail(\"missing character name\", pos)\n        }\n        if(i == cps.length){\n            fail(\"missing }, unterminated name\", pos)\n        }\n        var cp = validate_named_char(from_codepoint_list(description), pos)\n        return {\n            type: 'N',\n            ord: cp,\n            char: chr(cp),\n            length: i - pos + 1\n        }\n    }else if(special == LETTERS.x){\n        // \\xhh = character with hex value hh\n        var rest = from_codepoint_list(cps.slice(pos + 2)),\n            mo = /^[0-9a-fA-F]{0,2}/.exec(rest),\n            hh = mo ? mo[0] : ''\n        if(mo && mo[0].length == 2){\n            var cp = parseInt(mo[0], 16)\n            return {\n                type: 'x',\n                ord: cp,\n                char: chr(cp),\n                length: 2 + mo[0].length\n            }\n        }\n        fail('incomplete escape \\\\x' + hh, pos)\n    }else if(special == LETTERS.u){\n        // \\uxxxx = character with 16-bit hex value xxxx\n        var rest = from_codepoint_list(cps.slice(pos + 2)),\n            mo = /^[0-9a-fA-F]{0,4}/.exec(rest),\n            xx = mo ? mo[0] : ''\n        if(mo && mo[0].length == 4){\n            var cp = parseInt(mo[0], 16)\n            return {\n                type: 'u',\n                ord: cp,\n                char: chr(cp),\n                length: 2 + mo[0].length\n            }\n        }\n        fail('incomplete escape \\\\u' + xx, pos)\n    }else if(special == LETTERS.U){\n        // \\Uxxxxxxxx = character with 32-bit hex value xxxxxxxx\n        var rest = from_codepoint_list(cps.slice(pos + 2)),\n            mo = /^[0-9a-fA-F]{0,8}/.exec(rest),\n            xx = mo ? mo[0] : ''\n        if(mo && mo[0].length == 8){\n            var cp = parseInt(mo[0], 16)\n            if(cp > 0x10FFFF){\n                fail(`bad escape \\\\U${mo[0]}`, pos)\n            }\n            return {\n                type: 'U',\n                ord: cp,\n                char: chr(cp),\n                length: 2 + mo[0].length\n            }\n        }\n        fail('incomplete escape \\\\U' + xx, pos)\n    }else{\n        // octal ?\n        // If the first digit of number is 0, or number is 3 octal digits\n        // long, it will not be interpreted as a group match, but as the\n        // character with octal value number\n        var rest = from_codepoint_list(cps.slice(pos + 1)),\n            mo = /^[0-7]{3}/.exec(rest)\n        if(in_charset){\n            try{\n                var res = $B.test_escape(rest, -1)\n                if(res){\n                    return {\n                        type: 'u',\n                        ord: res[0].codePointAt(0),\n                        char: res[0],\n                        length: res[1]\n                    }\n                }\n            }catch(err){\n                // ignore\n            }\n        }\n        if(mo == null){\n            mo = /^0[0-7]*/.exec(rest)\n        }\n        if(mo){\n            var octal_value = parseInt(mo[0], 8)\n            if(octal_value > 0o377){\n                fail(`octal escape value \\\\` +\n                    `${mo[0]} outside of range 0-0o377`, pos)\n            }\n            return {\n                type: 'o',\n                ord: octal_value,\n                char: chr(octal_value),\n                length: 1 + mo[0].length\n            }\n        }\n        var mo = /^\\d{1,2}/.exec(rest) // backref is at most 99\n        if(mo){\n            return {\n                type: 'backref',\n                value: parseInt(mo[0]),\n                length: 1 + mo[0].length\n            }\n        }\n        var trans = {a: chr(7), f: '\\f', n: '\\n', r: '\\r', t: '\\t', v: '\\v'},\n            res = trans[chr(special)]\n        if(res){\n            return ord(res)\n        }\n        if(chr(special).match(/[a-zA-Z]/)){\n            fail(\"bad escape \\\\\" + chr(special), pos)\n        }else{\n            return special\n        }\n    }\n}\n\nfunction check_character_range(t, positions){\n    // Check if last 2 items in t are a valid character range\n    var start = t[t.length - 2],\n        end = t[t.length - 1]\n    if(start instanceof CharacterClass || end instanceof CharacterClass){\n        fail(`bad character range ${start}-${end}`,\n            positions[positions.length - 2])\n    }else if(end < start){\n        fail(`bad character range ${start}-${end}`,\n            positions[positions.length - 2])\n    }\n    t.splice(t.length - 2, 2, {\n        type: 'character_range',\n        start: start,\n        end: end,\n        ord: [start.ord, end.ord]\n    })\n}\n\nfunction parse_character_set(text, pos, is_bytes){\n    // Parse character set starting at position \"pos\" in \"text\"\n    // pos is the position of the leading \"[\"\n    var start = pos,\n        result = {items: []},\n        positions = []\n    pos++\n    if(text[pos] == CARET){\n        result.neg = true\n        pos++\n    }else if(text[pos] == BRACKET_CLOSE){\n        // a leading ] is the character \"]\", not the set end\n        result.items.push(']')\n        positions.push(pos)\n        pos++\n    }else if(text[pos] == BRACKET_OPEN){\n        // send FutureWarning\n        warn(_b_.FutureWarning, \"Possible nested set\", pos, text)\n    }\n    var range = false\n    while(pos < text.length){\n        var cp = text[pos],\n            char = chr(cp)\n        if(char == ']'){\n            if(pos == start + 2 && result.neg){\n                // in \"[^]]\", the first ] is the character \"]\"\n                result.items.push(']')\n            }else{\n                return [result, pos]\n            }\n        }\n        if(char == '\\\\'){\n            var escape = escaped_char({\n                    codepoints: text,\n                    pos,\n                    in_charset: true,\n                    is_bytes\n                })\n            if(typeof escape == \"number\"){\n                var s = chr(escape)\n                escape = {\n                    ord: escape,\n                    length: 2,\n                    toString: function(){\n                        return s\n                    }\n                }\n            }\n            if(escape.type == \"num\"){\n                // [\\9] is invalid\n                fail(\"bad escape 1 \\\\\" +\n                    escape.value.toString()[0], pos)\n            }\n            result.items.push(escape)\n            positions.push(pos)\n            if(range){\n                check_character_range(result.items, positions)\n            }\n            range = false\n            pos += escape.length\n        }else if(char == '-'){\n            // Character range, or character \"-\"\n            if(pos == start + 1 ||\n                    (result.neg && pos == start + 2) ||\n                    pos == text.length - 2 || // [a-]\n                    range ||\n                    (result.items.length > 0 &&\n                    result.items[result.items.length - 1].type ==\n                        \"character_range\")){\n                result.items.push({\n                    ord: cp,\n                    char,\n                    toString: function(){\n                        return this.char\n                    }\n                })\n                if(text[pos + 1] == cp){\n                    warn(_b_.FutureWarning, \"Possible set difference\", pos, text)\n                }\n                pos++\n                if(range){\n                    check_character_range(result.items, positions)\n                }\n                range = false\n            }else{\n                range = true\n                if(text[pos + 1] == cp){\n                    warn(_b_.FutureWarning, \"Possible set difference\", pos, text)\n                }\n                pos++\n            }\n        }else{\n            positions.push(pos)\n            result.items.push({\n                ord: cp,\n                char,\n                toString: function(){\n                    return this.char\n                }\n            })\n            if(range){\n                check_character_range(result.items, positions)\n            }\n            range = false\n            // FutureWarning for consecutive \"&\", \"|\" or \"~\"\n            if(char == \"&\" && text[pos + 1] == cp){\n                warn(_b_.FutureWarning, \"Possible set intersection\", pos, text)\n            }else if(char == \"|\" && text[pos + 1] == cp){\n                warn(_b_.FutureWarning, \"Possible set union\", pos, text)\n            }else if(char == \"~\" && text[pos + 1] == cp){\n                warn(_b_.FutureWarning, \"Possible set symmetric difference\",\n                    pos, text)\n            }\n            pos++\n        }\n    }\n    fail(\"unterminated character set\", start)\n}\n\nfunction* tokenize(pattern, type, _verbose){\n    // pattern is a list of codepoints\n    var is_bytes = type == \"bytes\"\n    // verbose_stack is the stack of verbose state for each group in the regex\n    var verbose_stack = [_verbose],\n        verbose = _verbose,\n        parenth_pos\n    var pos = 0\n    while(pos < pattern.length){\n        var cp = pattern[pos],\n            char = String.fromCharCode(cp)\n        if(verbose){\n            // current group is in verbose mode\n            if(char == \"#\"){\n                // skip until next line feed\n                while(pos < pattern.length && pattern[pos] != 10){\n                    pos++\n                }\n                pos++\n                continue\n            }else{\n                while(pos < pattern.length &&\n                        [9, 10, 11, 12, 13, 32].indexOf(pattern[pos]) > -1){\n                    pos++\n                }\n            }\n            cp = pattern[pos]\n            if(cp === undefined){\n                break\n            }\n            char = String.fromCharCode(cp)\n            if(char == '#'){\n                continue\n            }\n        }\n        if(char == '('){\n            parenth_pos = pos\n            if(pattern[pos + 1] == QUESTION_MARK){\n                if(pattern[pos + 2] == LETTERS.P){\n                    if(pattern[pos + 3] == INF){\n                        var name = [],\n                            i = pos + 4\n                        while(i < pattern.length){\n                            if(pattern[i] == SUP){\n                                break\n                            }else if(pattern[i] == PARENTH_CLOSE){\n                                fail(\"missing >, unterminated name\", pos)\n                            }\n                            name.push(pattern[i])\n                            i++\n                        }\n                        var sname = StringObj.from_codepoints(name)\n                        validate_group_name(sname, pos, is_bytes)\n                        name = sname\n                        if(i == pattern.length){\n                            fail(\"missing >, unterminated name\", pos)\n                        }\n                        yield new Group(pos, {type: 'name_def', value: name})\n                        verbose_stack.push(verbose)\n                        pos = i + 1\n                        continue\n                    }else if(pattern[pos + 3] == EQUAL){\n                        var name = [],\n                            i = pos + 4\n                        while(i < pattern.length){\n                            if(pattern[i] == PARENTH_CLOSE){\n                                break\n                            }\n                            name.push(pattern[i])\n                            i++\n                        }\n                        name = StringObj.from_codepoints(name)\n                        validate_group_name(name, pos, is_bytes)\n                        if(i == pattern.length){\n                            fail(\"missing ), unterminated name\", pos)\n                        }\n                        yield new BackReference(pos, 'name', name.string)\n                        pos = i + 1\n                        continue\n                    }else if(pattern[pos + 3] === undefined){\n                        fail(\"unexpected end of pattern\", pos)\n                    }else{\n                        fail(\"unknown extension ?P\" + chr(pattern[pos + 3]), pos)\n                    }\n                }else if(pattern[pos + 2] == PARENTH_OPEN){\n                    var ref = [],\n                        i = pos + 3\n                    while(i < pattern.length){\n                        if(pattern[i] == PARENTH_CLOSE){\n                            break\n                        }\n                        ref.push(pattern[i])\n                        i++\n                    }\n                    var sref = StringObj.from_codepoints(ref)\n                    if(sref.string.match(/^\\d+$/)){\n                        ref = parseInt(sref.string)\n                    }else{\n                        validate_num_or_name(sref, pos, is_bytes)\n                        ref = sref.string\n                    }\n                    if(i == pattern.length){\n                        fail(\"missing ), unterminated name\", pos)\n                    }\n                    yield new ConditionalBackref(pos, ref)\n                    pos = i + 1\n                    continue\n                }else if(pattern[pos + 2] == EQUAL){\n                    // (?=...) : lookahead assertion\n                    yield new Group(pos, {type: 'lookahead_assertion'})\n                    verbose_stack.push(verbose)\n                    pos += 3\n                    continue\n                }else if(pattern[pos + 2] == EXCLAMATION_MARK){\n                    // (?!...) : negative lookahead assertion\n                    yield new Group(pos, {type: 'negative_lookahead_assertion'})\n                    verbose_stack.push(verbose)\n                    pos += 3\n                    continue\n                }else if(from_codepoint_list(pattern.slice(pos + 2, pos + 4)) == '<!'){\n                    // (?<!...) : negative lookbehind\n                    yield new Group(pos, {type: 'negative_lookbehind'})\n                    verbose_stack.push(verbose)\n                    pos += 4\n                    continue\n                }else if(from_codepoint_list(pattern.slice(pos + 2, pos + 4)) == '<='){\n                    // (?<=...) : positive lookbehind\n                    yield new Group(pos, {type: 'positive_lookbehind'})\n                    verbose_stack.push(verbose)\n                    pos += 4\n                    continue\n                }else if(pattern[pos + 2] == INF){\n                    pos += 3\n                    if(pos == pattern.length){\n                        fail(\"unexpected end of pattern\", pos)\n                    }\n                    fail(\"unknown extension ?<\" + _b_.chr(pattern[pos]), pos)\n                }else if(pattern[pos + 2] == COLON){\n                    yield new Group(pos, {non_capturing: true})\n                    verbose_stack.push(verbose)\n                    pos += 3\n                    continue\n                }else if(pattern[pos + 2] == SUP){\n                    yield new Group(pos, {atomic: true})\n                    verbose_stack.push(verbose)\n                    pos += 3\n                    continue\n                }else if(pattern[pos + 2] === undefined){\n                    fail(\"unexpected end of pattern\", pos)\n                }\n\n                var flags = to_codepoint_list('aiLmsux'),\n                    auL_flags = to_codepoint_list('auL'),\n                    flags_start = pos\n                if(pattern[pos + 2] == MINUS ||\n                        flags.indexOf(pattern[pos + 2]) > -1){\n                    if(pattern[pos + 2] == MINUS){\n                        var on_flags = [],\n                            has_off = true,\n                            off_flags = []\n                        pos += 3\n                    }else{\n                        var on_flags = [chr(pattern[pos + 2])],\n                            has_off = false,\n                            off_flags = [],\n                            auL = auL_flags.indexOf(pattern[pos + 2]) > -1 ?\n                                1 : 0,\n                            closed = false\n                        pos += 3\n                        while(pos < pattern.length){\n                            if(flags.indexOf(pattern[pos]) > -1){\n                                if(auL_flags.indexOf(pattern[pos]) > -1){\n                                    auL++\n                                    if(auL > 1){\n                                        fail(\"bad inline flags: flags 'a', 'u'\" +\n                                            \" and 'L' are incompatible\", pos)\n                                    }\n                                }\n                                on_flags.push(chr(pattern[pos]))\n                                pos++\n                            }else if(pattern[pos] == MINUS){\n                                has_off = true\n                                closed = true\n                                pos++\n                                break\n                            }else if(String.fromCharCode(pattern[pos]).\n                                    match(/[a-zA-Z]/)){\n                                fail(\"unknown flag\", pos)\n                            }else if(pattern[pos] == PARENTH_CLOSE){\n                                closed = true\n                                break\n                            }else if(pattern[pos] == COLON){\n                                yield new Group(pos, {name: \"Group\", type: \"flags\"})\n                                verbose_stack.push(verbose)\n                                closed = true\n                                break\n                            }else{\n                                fail(\"missing -, : or )\", pos)\n                            }\n                        }\n                        if(! closed){\n                            fail(\"missing -, : or )\", pos)\n                        }\n                    }\n                    if(has_off){\n                        while(pos < pattern.length){\n                            if(flags.indexOf(pattern[pos]) > -1){\n                                if(auL_flags.indexOf(pattern[pos]) > -1){\n                                    fail(\"bad inline flags: cannot turn off \" +\n                                        \"flags 'a', 'u' and 'L'\", pos)\n                                }\n                                if(on_flags.indexOf(chr(pattern[pos])) > -1){\n                                    fail(\"bad inline flags: flag turned on and off\", pos)\n                                }\n                                off_flags.push(chr(pattern[pos]))\n                                pos++\n                            }else if(pattern[pos] == COLON){\n                                yield new Group(pos, {name: \"Group\", type: \"flags\"})\n                                verbose_stack.push(verbose)\n                                break\n                            }else if(String.fromCharCode(pattern[pos]).\n                                    match(/[a-zA-Z]/)){\n                                fail(\"unknown flag\", pos)\n                            }else if(off_flags.length == 0){\n                                fail(\"missing flag\", pos)\n                            }else{\n                                fail(\"missing :\", pos)\n                            }\n                        }\n                        if(off_flags.length == 0){\n                            fail(\"missing flag\", pos)\n                        }\n                    }\n                    if(has_off && pattern[pos] != COLON){\n                        fail(\"missing :\", pos)\n                    }\n                    if(on_flags.length == 0 && off_flags.length == 0){\n                        fail(\"missing flag\", pos)\n                    }\n                    var set_flags = new SetFlags(flags_start,\n                        {on_flags, off_flags})\n\n                    yield set_flags\n                    // reset verbose\n                    if(on_flags.indexOf('x') > -1){\n                        verbose = true\n                        verbose_stack.push(verbose)\n                    }\n                    if(off_flags.indexOf('x') > -1){\n                        verbose = false\n                    }\n                    if(! closed){\n                        node = set_flags\n                    }\n                    pos++\n                }else if(pattern[pos + 2] == ord('#')){\n                    pos += 3\n                    while(pos < pattern.length){\n                        if(pattern[pos] == PARENTH_CLOSE){\n                            break\n                        }\n                        pos++\n                    }\n                    if(pos == pattern.length){\n                        fail(\"missing ), unterminated comment\", pos)\n                    }\n                    pos++\n                    continue\n                }else{\n                    fail(\"unknown extension ?\" + _b_.chr(pattern[pos + 2]),\n                        pos)\n                }\n            }else{\n                yield new Group(pos)\n                verbose_stack.push(verbose)\n                pos++\n            }\n        }else if(cp == PARENTH_CLOSE){\n            yield new GroupEnd(pos)\n            verbose_stack.pop()\n            verbose = $last(verbose_stack)\n            pos++\n        }else if(cp == BACKSLASH){\n            var escape = escaped_char({codepoints: pattern, pos, is_bytes})\n            if(escape instanceof CharacterClass){\n                yield escape\n                pos += escape.length\n            }else if(escape.char !== undefined){\n                yield new Char(pos, escape.ord)\n                pos += escape.length\n            }else if(escape.type == \"backref\"){\n                var len = escape.length\n                if(escape.value.length > 2){\n                    escape.value = escape.value.substr(0, 2)\n                    len = 2\n                }\n                yield new BackReference(pos, \"num\", escape.value)\n                pos += len\n            }else if(typeof escape == \"number\"){\n                // eg \"\\.\"\n                var esc = new Char(pos, escape)\n                esc.escaped = true\n                yield esc\n                pos += 2\n            }else{\n                yield new Char(pos, escape)\n                pos += escape.length\n            }\n        }else if(cp == BRACKET_OPEN){\n            // Set of characters\n            var set,\n                end_pos\n            [set, end_pos] = parse_character_set(pattern, pos, is_bytes)\n            yield new CharacterSet(pos, set)\n            pos = end_pos + 1\n        }else if('+?*'.indexOf(char) > -1){\n            yield new Repeater(pos, char)\n            pos++\n        }else if(cp == BRACE_OPEN){\n            var reps = /\\{(\\d*)((,)(\\d*))?\\}/.exec(\n                    from_codepoint_list(pattern.slice(pos)))\n            if(reps && reps[0] != '{}'){\n                if(reps[1] == \"\"){\n                    var limits = [0]\n                }else{\n                    var limits = [parseInt(reps[1])]\n                }\n                if(reps[4] !== undefined){\n                    if(reps[4] == \"\"){\n                        var max = Number.POSITIVE_INFINITY\n                    }else{\n                        var max = parseInt(reps[4])\n                    }\n                    limits.push(max)\n                }\n                yield new Repeater(pos, limits)\n                pos += reps[0].length\n            }else if(pattern[pos + 1] == BRACE_CLOSE){\n                // {} is the characters \"{\" and \"}\"\n                yield new Char(pos, BRACE_OPEN)\n                pos++\n            }else{\n                yield new Char(pos, BRACE_OPEN)\n                pos++\n            }\n        }else if(cp == OR){\n            yield new Or(pos)\n            pos++\n        }else if(cp == DOT){\n            yield new CharacterClass(pos, cp, 1)\n            pos++\n        }else if(cp == CARET){\n            yield new StringStart(pos)\n            pos++\n        }else if(cp == DOLLAR){\n            yield new StringEnd(pos)\n            pos++\n        }else{\n            yield new Char(pos, cp)\n            pos++\n        }\n    }\n}\n\nfunction transform_repl(data, pattern){\n    // data.repl is a StringObj instance\n    var repl = data.repl.string\n    repl = repl.replace(/\\\\n/g, '\\n')\n    repl = repl.replace(/\\\\r/g, '\\r')\n    repl = repl.replace(/\\\\t/g, '\\t')\n    repl = repl.replace(/\\\\b/g, '\\b')\n    repl = repl.replace(/\\\\v/g, '\\v')\n    repl = repl.replace(/\\\\f/g, '\\f')\n    repl = repl.replace(/\\\\a/g, '\\x07')\n    // detect backreferences\n    var pos = 0,\n        escaped = false,\n        br = false,\n        repl1 = \"\",\n        has_backref = false\n    while(pos < repl.length){\n        br = false\n        if(repl[pos] == \"\\\\\"){\n            escaped = ! escaped\n            if(escaped){\n                pos++\n                continue\n            }\n        }else if(escaped){\n            escaped = false\n            var mo = /^\\d+/.exec(repl.substr(pos))\n            if(mo){\n                var cps = to_codepoint_list(repl)\n                var escape = escaped_char({\n                        codepoints: cps,\n                        pos: pos - 1,\n                        is_bytes: cps.type == \"bytes\"\n                     })\n                if(escape.type == \"o\"){\n                    if(escape.ord > 0o377){\n                        fail(`octal escape value \\\\${mo[0]} ` +\n                            \" outside of range 0-0o377\", pos)\n                    }\n                    repl1 += escape.char\n                    pos += escape.length - 1\n                    continue\n                }else if(escape.type != \"backref\"){\n                    var group_num = mo[0].substr(0,\n                        Math.min(2, mo[0].length))\n                    fail(`invalid group reference ${group_num}`, pos)\n                }else{\n                    // only keep first 2 digits\n                    var group_num = mo[0].substr(0,\n                        Math.min(2, mo[0].length))\n                    // check that pattern has the specified group num\n                    if(pattern.groups === undefined){\n                        throw _b_.AttributeError.$factory(\"$groups\")\n                    }\n                    if(pattern.groups[group_num] === undefined){\n                        fail(`invalid group reference ${group_num}`,\n                            pos)\n                    }else{\n                        mo[0] = group_num\n                    }\n                }\n                if(! has_backref){\n                    var parts = [repl.substr(0, pos - 1),\n                            parseInt(mo[0])]\n                }else{\n                    parts.push(repl.substring(next_pos, pos - 1))\n                    parts.push(parseInt(mo[0]))\n                }\n                has_backref = true\n                var next_pos = pos + mo[0].length\n                br = true\n                pos += mo[0].length\n            }else if(repl[pos] == \"g\"){\n                pos++\n                if(repl[pos] != '<'){\n                    fail(\"missing <\", pos)\n                }\n                pos++\n                mo = /(.*?)>/.exec(repl.substr(pos))\n                if(mo){\n                    if(mo[1] == \"\"){\n                        pos += mo[0].length\n                        fail(\"missing group name\", pos - 1)\n                    }\n                    var group_name = mo[1]\n                    if(group_name == '0'){\n                        //  The backreference \\g<0> substitutes in the entire\n                        // substring matched by the RE.\n                    }else if(/^\\d+$/.exec(group_name)){\n                        if(pattern.groups[group_name] === undefined){\n                            fail(`invalid group reference ${group_name}`,\n                                pos)\n                        }\n                    }else{\n                        try{\n                            var group_num = _b_.int.$factory(group_name)\n                            if(group_num < 0){\n                                fail(`bad character in group name ` +\n                                    `'${group_name}' at position ${pos}`, pos)\n                            }\n                            warn(_b_.DeprecationWarning,\n                                `bad character in group name '${group_name}' ` +\n                                `at position ${pos}`)\n                            mo[1] = group_name = group_num + ''\n                        }catch(err){\n                            if(! _b_.str.isidentifier(group_name)){\n                                var cps = to_codepoint_list(group_name)\n                                if(! $B.is_XID_Start(cps[0])){\n                                    fail(\"bad character in group name '\" +\n                                        group_name + \"'\", pos)\n                                }else{\n                                    for(cp of cps.slice(1)){\n                                        if(! $B.is_XID_Continue(cp)){\n                                            fail(\"bad character in group name '\" +\n                                                group_name + \"'\", pos)\n                                        }\n                                    }\n                                }\n                            }else if(data.type == \"bytes\" && ! is_ascii(group_name)){\n                                var b = _b_.bytes.$factory(group_name, 'latin-1'),\n                                    s = _b_.bytes.decode(b, 'ascii', 'backslashreplace')\n                                warn(_b_.DeprecationWarning,\n                                    `bad character in group name '${s}'` +\n                                    ` at position ${pos}`)\n                            }\n                        }\n                        if(pattern.groups[group_name] === undefined){\n                            throw _b_.IndexError.$factory(\n                                `unknown group name '${group_name}'`,\n                                pos)\n                        }\n                    }\n                    if(! has_backref){\n                        var parts = [repl.substr(0, pos - 3),\n                                mo[1]]\n                    }else{\n                        parts.push(repl.substring(next_pos, pos - 3))\n                        parts.push(mo[1])\n                    }\n                    has_backref = true\n                    var next_pos = pos + mo[0].length\n                    br = true\n                    pos = next_pos\n                }else{\n                    if(repl.substr(pos).length > 0){\n                        fail(\"missing >, unterminated name\", pos)\n                    }else{\n                        fail(\"missing group name\", pos)\n                    }\n                }\n            }else{\n                if(/[a-zA-Z]/.exec(repl[pos])){\n                    fail(\"unknown escape\", pos)\n                }\n                pos += repl[pos]\n            }\n        }\n        if(! br){\n            repl1 += repl[pos]\n            pos ++\n        }\n    }\n    data.repl1 = repl1\n    if(has_backref){\n        parts.push(repl.substr(next_pos))\n        data.repl = function(bmo){\n            var mo = bmo.mo,\n                res = parts[0],\n                groups = mo.$groups,\n                s = mo.string,\n                group,\n                is_bytes = s.type == 'bytes'\n            for(var i = 1, len = parts.length; i < len; i += 2){\n                if(parts[i] == 0){\n                    var x = s.substring(mo.start, mo.end)\n                    if(is_bytes){\n                        x = _b_.bytes.decode(x, 'latin-1')\n                    }\n                    res += x\n                }else if(groups[parts[i]] === undefined){\n                    if(mo.node.$groups[parts[i]] !== undefined){\n                        // group is defined in the RE, but didn't contribute\n                        // to the match\n                        // groups[parts[i]] = ''\n                    }else{\n                        // group is not defined in the RE\n                        pos++\n                        group_num = parts[i].toString().substr(0, 2)\n                        fail(`invalid group reference ${group_num}`, pos)\n                    }\n                }else{\n                    group = groups[parts[i]]\n                    var x = s.substring(group.start, group.end)\n                    if(is_bytes){\n                        x = _b_.bytes.decode(x, 'latin-1')\n                    }\n                    res += x\n                }\n                res += parts[i + 1]\n            }\n            return res\n        }\n    }else{\n        data.repl = new StringObj(repl)\n    }\n    return data\n}\n\n\n\nvar Flag = $B.make_class(\"Flag\",\n    function(value){\n        return {\n            __class__: Flag,\n            value\n        }\n    }\n)\n\nFlag.__and__ = function(self, other){\n    if(other.__class__ === Flag){\n        return Flag.$factory(self.value & other.value)\n    }else if(typeof other == \"number\" || typeof other == \"boolean\"){\n        return Flag.$factory(self.value & other)\n    }\n    return _b_.NotImplemented\n}\n\nFlag.__index__ = function(self){\n    return self.value\n}\n\nFlag.__invert__ = function(self){\n    return Flag.$factory(~self.value)\n}\n\nFlag.__eq__ = function(self, other){\n    return self.value == other.value\n}\n\nFlag.__or__ = function(self, other){\n    if(other.__class__ === Flag){\n        return Flag.$factory(self.value | other.value)\n    }else if(typeof other == \"number\" || typeof other == \"boolean\"){\n        return Flag.$factory(self.value | other)\n    }\n    return _b_.NotImplemented\n}\n\nFlag.__rand__ = function(self, other){\n    if(typeof other == \"number\" || $B.$isinstance(other, _b_.int)){\n        if(other == 0){\n            return false // Flag.$factory(self.value)\n        }\n        return self.value & other\n    }\n    return _b_.NotImplemented\n}\n\nFlag.__ror__ = function(self, other){\n    if(typeof other == \"number\" || $B.$isinstance(other, _b_.int)){\n        if(other == 0){\n            return self.value\n        }\n        return self.value | other\n    }\n    return _b_.NotImplemented\n}\n\nFlag.__repr__ = Flag.__str__ = function(self){\n    if(self.value == 0){\n        return \"re.none\"\n    }\n    var inverted = self.value < 0\n\n    var t = [],\n        value = inverted ? ~self.value : self.value\n    for(var flag in inline_flags){\n        if(value & inline_flags[flag].value){\n            t.push('re.' + flag_names[flag])\n            value &= ~inline_flags[flag].value\n        }\n    }\n    if(value > 0){\n        t.push('0x' + value.toString(16))\n    }\n    var res = t.join('|')\n    if(inverted){\n        if(t.length > 1){\n            return '~(' + res + ')'\n        }else{\n            return '~' + res\n        }\n    }\n    return res\n}\n\nFlag.__xor__ = function(self, other){\n    return Flag.$factory(self.value ^ other.value)\n}\n\n$B.set_func_names(Flag, \"re\")\n\nvar no_flag = {}\n\nvar Scanner = $B.make_class(\"Scanner\",\n    function(pattern, string, pos, endpos){\n        var $ = $B.args('__init__', 4,\n                    {pattern: null, string: null, pos: null, endpos:null},\n                    ['pattern', 'string', 'pos', 'endpos'],\n                    arguments, {pos: 0, endpos: _b_.None}, null, null),\n            endpos = endpos === _b_.None ? $.string.length : endpos\n        return {\n            __class__: Scanner,\n            $string: $.string,\n            pattern: $.pattern,\n            pos: $.pos,\n            endpos\n        }\n    }\n)\n\nScanner.match = function(self){\n    return Pattern.match(self.pattern, self.$string)\n}\n\nScanner.search = function(self){\n    if(! self.$iterator){\n        self.$iterator = module.finditer(self.pattern, self.$string)\n    }\n    // return last match\n    var mo = _b_.None\n    for(mo of self.$iterator.js_gen){\n        // set mo\n    }\n    return mo\n}\n\nvar GroupIndex = $B.make_class(\"GroupIndex\",\n    function(self, _default){\n        var res = $B.empty_dict()\n        res.__class__ = GroupIndex\n        for(var key in self.$groups){\n            if(isNaN(parseInt(key))){\n                _b_.dict.$setitem(res, key, self.$groups[key].num)\n            }\n        }\n        return res\n    }\n)\nGroupIndex.__mro__ = [_b_.dict, _b_.object]\nGroupIndex.__setitem__ = function(){\n    throw _b_.TypeError.$factory(\"read only\")\n}\n\n$B.set_func_names(GroupIndex, \"re\")\n\nvar Pattern = $B.make_class(\"Pattern\",\n    function(pattern){\n        var nb_groups = 0\n        for(var key in pattern.groups){\n            if(isFinite(key)){\n                nb_groups++\n            }\n        }\n        return {\n            __class__: Pattern,\n            pattern: pattern.text,\n            groups: nb_groups,\n            flags: pattern.flags,\n            $groups: pattern.groups,\n            $pattern: pattern\n        }\n    }\n)\n\nPattern.__copy__ = function(self){\n    return self\n}\n\nPattern.__deepcopy__ = function(self){\n    return self\n}\n\nPattern.__eq__ = function(self, other){\n    if(other.$pattern && self.$pattern.type != other.$pattern.$type){\n        // warn(_b_.BytesWarning, \"cannot compare str and bytes pattern\", 1)\n    }\n    return self.pattern == other.pattern &&\n        self.flags.value == other.flags.value\n}\n\nPattern.__hash__ = function(self){\n    // best effort ;-)\n    return _b_.hash(self.pattern) + self.flags.value\n}\n\nPattern.__new__ = Pattern.$factory\n\nPattern.__reduce__ = function(self){\n    return Pattern.__reduce_ex__(self, 4)\n}\n\nPattern.__reduce_ex__ = function(self, protocol){\n    var res = _reconstructor,\n        state = [self.__class__].concat(self.__class__.__mro__)\n    var d = $B.empty_dict()\n    _b_.dict.$setitem(d, 'pattern', self.pattern)\n    _b_.dict.$setitem(d, 'flags', self.flags.value)\n    state.push(d)\n    return $B.fast_tuple([res, $B.fast_tuple(state)])\n}\n\nfunction _reconstructor(cls, base, state){\n    var pattern = _b_.dict.$getitem(state, 'pattern'),\n        flags = Flag.$factory(_b_.dict.$getitem(state, 'flags'))\n    return module.compile(pattern, flags)\n}\n\nPattern.__repr__ = Pattern.__str__ = function(self){\n    var text = self.$pattern.text,\n        s = text\n    if(self.$pattern.type == \"bytes\"){\n        s = _b_.str.$factory(_b_.str.encode(s, 'latin-1'))\n    }else{\n        s = _b_.repr(s)\n    }\n    s = s.substr(0, 200)\n    var res = `re.compile(${s}`,\n        flags = self.$pattern.flags\n    if(flags === no_flag){\n        return res + ')'\n    }\n    // mask UNICODE flag\n    if(flags.__class__ === Flag){\n        // copy flag, otherwise U.value would become 0\n        flags = Flag.$factory(flags.value)\n        flags.value &= ~U.value\n    }else if(typeof flags == \"number\"){\n        flags &= ~U.value\n    }\n    if(flags != 0 && flags.value != 0){\n        res += `, ${_b_.str.$factory(flags)}`\n    }\n    return res + ')'\n}\n\nPattern.findall = function(self){\n    var iter = Pattern.finditer.apply(null, arguments).js_gen,\n        res = []\n\n    while(true){\n        var next = iter.next()\n        if(next.done){\n            return $B.$list(res)\n        }\n        var bmo = next.value,\n            mo = bmo.mo,\n            groups = MatchObject.groups(bmo)\n\n        // replace None by the empty string\n        for(var i = 0, len = groups.length; i < len; i++){\n            groups[i] = groups[i] === _b_.None ? \"\" : groups[i]\n        }\n        if(groups.length > 0){\n            if(groups.length == 1){\n                res.push(groups[0])\n            }else{\n                res.push($B.fast_tuple(groups))\n            }\n        }else{\n            res.push(mo.string.substring(mo.start, mo.end))\n        }\n    }\n}\n\nPattern.finditer = function(self){\n    var $ = $B.args(\"finditer\", 4,\n            {self: null, string: null, pos: null, endpos: null},\n            'self string pos endpos'.split(' '), arguments,\n            {pos: 0, endpos: _b_.None}, null, null)\n    var data = prepare({string: $.string})\n    var endpos = $.endpos === _b_.None ? data.string.length : $.endpos\n    return $B.generator.$factory(iterator)(self.$pattern, data.string,\n            self.flags, $.string, $.pos, endpos)\n}\n\nPattern.fullmatch = function(self, string){\n    var $ = $B.args(\"match\", 4,\n                    {self: null, string: null, pos: null, endpos: null},\n                    [\"self\", \"string\", \"pos\", \"endpos\"], arguments,\n                    {pos: 0, endpos: _b_.None}, null, null)\n    if($.endpos === _b_.None){\n        $.endpos = $.string.length\n    }\n    var data = prepare({string: $.string})\n    if(self.$pattern.type != data.string.type){\n        throw _b_.TypeError.$factory(\"not the same type for pattern \" +\n            \"and string\")\n    }\n    var fullmatch_pattern = create_fullmatch_pattern($.self.$pattern)\n    var mo = match(fullmatch_pattern, data.string, $.pos, $.endpos)\n    if(mo && mo.end - mo.start == $.endpos - $.pos){\n        return MatchObject.$factory(mo)\n    }else{\n        return _b_.None\n    }\n}\n\nPattern.groupindex = {\n    __get__: function(self){\n        return GroupIndex.$factory(self)\n    }\n}\n\nPattern.match = function(self, string){\n    var $ = $B.args(\"match\", 4,\n                    {self: null, string: null, pos: null, endpos: null},\n                    [\"self\", \"string\", \"pos\", \"endpos\"], arguments,\n                    {pos: 0, endpos: _b_.None}, null, null)\n    if($.endpos === _b_.None){\n        $.endpos = $.string.length\n    }\n    var data = prepare({string: $.string})\n    if(self.$pattern.type != data.string.type){\n        throw _b_.TypeError.$factory(\"not the same type for pattern \" +\n            \"and string\")\n    }\n    var mo = match($.self.$pattern, data.string, $.pos,\n        $.endpos)\n    return mo ? MatchObject.$factory(mo) : _b_.None\n}\n\nPattern.scanner = function(self, string, pos, endpos){\n    return Scanner.$factory.apply(null, arguments) // self, string, pos, endpos)\n}\n\nPattern.search = function(self, string){\n    var $ = $B.args(\"match\", 4,\n                    {self: null, string: null, pos: null, endpos: null},\n                    [\"self\", \"string\", \"pos\", \"endpos\"], arguments,\n                    {pos: 0, endpos: _b_.None}, null, null)\n    var data = prepare({string: $.string})\n    if(self.$pattern.type != data.string.type){\n        throw _b_.TypeError.$factory(\"not the same type for pattern \" +\n            \"and string\")\n    }\n    if($.endpos === _b_.None){\n        $.endpos = data.string.length\n    }\n    var pos = $.pos\n    while(pos <= $.endpos){\n        var mo = match(self.$pattern, data.string, pos)\n        if(mo){\n            return MatchObject.$factory(mo)\n        }else{\n            pos++\n        }\n    }\n    return _b_.None\n}\n\nPattern.split = function(){\n    return module.split.apply(null, arguments)\n}\n\nPattern.sub = function(){\n    var $ = $B.args(\"match\", 4,\n                    {self: null, repl: null, string: null, count: null},\n                    \"self repl string count\".split(' '), arguments,\n                    {count: 0}, null, null)\n    var data = prepare({string: $.string})\n    if($.self.$pattern.type != data.string.type){\n        throw _b_.TypeError.$factory(\"not the same type for pattern \" +\n            \"and string\")\n    }\n\n    return module.sub($.self, $.repl, $.string, $.count)\n}\n\n$B.set_func_names(Pattern, \"re\")\n\nfunction Node(parent){\n    this.parent = parent\n    this.items = []\n}\n\nNode.prototype.add = function(item){\n    this.items.push(item)\n    item.parent = this\n}\n\nNode.prototype.fixed_length = function(){\n    // Return the sum of items lengths if fixed, else undefined\n    if(this.repeat){\n        return false\n    }\n    var len = 0\n    for(var item of this.items){\n        if(item.fixed_length === undefined){\n            console.log(\"pas de fixed length\", item)\n            alert()\n        }\n        var sublen = item.fixed_length()\n        if(sublen === false){\n            return false\n        }\n        len += sublen\n    }\n    return len\n}\n\nfunction get_top(node){\n    var top = node.parent\n    while(top.parent){\n        top = top.parent\n    }\n    return top\n}\n\nvar BackReference = function(pos, type, value){\n    // for \"\\number\"\n    this.name = \"BackReference\"\n    this.pos = pos\n    this.type = type // \"name\" or \"num\"\n    this.value = value\n    this.groups = []\n}\n\nBackReference.prototype.fixed_length = function(){\n    // Return length of referenced group if it is fixed, else undefined\n    if(this.repeat){\n        return undefined\n    }\n    var group = this.get_group()\n    if(group.fixed_length === undefined){\n        console.log(\"group\", group, \"no fixed length\")\n    }\n    return group === undefined ? false : group.fixed_length()\n}\n\nBackReference.prototype.get_group = function(){\n    var top = get_top(this)\n    return top.$groups[this.value]\n}\n\nBackReference.prototype.match = function(string, pos, endpos, groups){\n    this.repeat = this.repeat || {min: 1, max: 1}\n\n    var group = groups[this.value]\n    if(group === undefined){\n        if(this.repeat.min == 0){\n            return {\n                nb_min: 0,\n                nb_max: 0\n            }\n        }\n        return false\n    }\n\n    // Get the codepoints matched by the referenced group\n    group_cps = string.codepoints.slice(group.start, group.end)\n\n    // search (repetitions of) the matched group codepoints\n    var _pos = pos,\n        nb = 0,\n        group_len = group_cps.length,\n        flag,\n        cp\n    while(string.cp_at(_pos) !== undefined && nb < this.repeat.max){\n        flag = true\n        for(var i = 0; i < group_len; i++){\n            cp = string.cp_at(_pos + i)\n            if(cp != group_cps[i]){\n                flag = false\n                break\n            }\n        }\n        if(flag){\n            nb++\n            _pos += group_len\n        }else{\n            break\n        }\n    }\n    if(nb >= this.repeat.min){\n        // Returns the accepted minimum and maximum number of repeats\n        // and the length of each repeat\n        return {\n            nb_min: this.repeat.min,\n            nb_max: nb,\n            group_len\n        }\n    }\n    return false\n}\n\nBackReference.prototype.toString = function(){\n    return \"BackRef to group\" + this.value\n}\n\nvar Case = function(){\n    this.name = \"Case\"\n    this.items = []\n    this.groups = []\n    this.text = 'Case '\n}\n\nCase.prototype.add = function(item){\n    this.items.push(item)\n    item.parent = this\n}\n\nCase.prototype.fixed_length = function(){\n    var len\n    for(var item of this.items){\n        var fl = item.fixed_length()\n        if(fl === false){\n            return false\n        }else if(len === undefined){\n            len = fl\n        }else{\n            len += fl\n        }\n    }\n    return len\n}\n\nCase.prototype.toString = function(){\n    var res = 'Case '\n    res += this.items.map(x => x + '').join(' ')\n    return this.text = res\n}\n\nvar Choice = function(){\n    this.type = \"choice\"\n    this.items = []\n    this.groups = []\n}\n\nChoice.prototype.add = Node.prototype.add\n\nChoice.prototype.fixed_length = function(){\n    var len\n    for(var item of this.items){\n        var fl = item.fixed_length()\n        if(fl === false){\n            return false\n        }else if(len === undefined){\n            len = fl\n        }else if(len != fl){\n            return false\n        }\n     }\n     return len\n}\n\nChoice.prototype.toString = function(){\n    return 'Choice'\n}\n\nvar EmptyString = {\n        toString: function(){\n            return ''\n        },\n        match: function(string, pos, endpos){\n            return {nb_min: 0, nb_max: 0}\n        },\n        fixed_length: function(){\n            return 1\n        },\n        length: 0\n    },\n    Flags = function(flags){\n        this.flags = flags\n    },\n    GroupEnd = function(pos){\n        this.name = \"GroupEnd\"\n        this.pos = pos\n        this.text = ')'\n        this.toString = function(){\n            return '[end of group #' + this.group.num + ']'\n        }\n    },\n    Or = function(pos){\n        this.name = \"Or\"\n        this.pos = pos\n        this.text = '|'\n        this.toString = function(){\n            return '|'\n        }\n    },\n    Repeater = function(pos, op){\n        this.name = \"Repeater\"\n        this.pos = pos\n        this.op = op\n    }\n\nfunction cased_cps(cp, ignore_case, ascii){\n    // If cp is the codepoint of a cased Unicode character, return the list\n    // of the codepoints that match the character in a case-insensitive way\n\n    // ignore_case = this.flags && this.flags.value & IGNORECASE.value\n    // ascii = this.flags.value & ASCII.value\n    var cps,\n        char = $B.codepoint2jsstring(cp)\n    if(! ignore_case){\n        return [cp]\n    }\n    if(ascii){\n        // only test ASCII letters\n        ignore_case = ignore_case && (\n            (char >= 'a' && char <= 'z') ||\n            (char >= 'A' && char <= 'Z'))\n    }\n    if(ignore_case){\n        var char_up = char.toUpperCase(),\n            char_low = char.toLowerCase(),\n            cps = new Set([cp, $B.jsstring2codepoint(char_low),\n                $B.jsstring2codepoint(char_up)])\n        // special cases\n        if(char.toLowerCase() == \"k\"){\n            cps.add(0x212a) // Kelvin sign\n        }\n        if(cp == 0x212a){\n            cps.add(ord('k'))\n            cps.add(ord('K'))\n        }\n        if(char.toLowerCase() == \"s\"){\n            cps.add(0x017f) //  (Latin small letter long s)\n        }\n        if(cp == 0x017f){\n            cps.add(ord('s'))\n            cps.add(ord('S'))\n        }\n        if(char.toLowerCase() == 'i'){\n            cps.add(0x0130) //  (Latin capital letter I with dot above)\n            cps.add(0x0131) //  (Latin small letter dotless i)\n        }\n        if(cp == 0x0130 || cp == 0x0131){\n            cps.add(ord('i'))\n            cps.add(ord('I'))\n        }\n        return Array.from(cps)\n    }else{\n        cps = [cp]\n    }\n    return cps\n}\n\nvar Char = function(pos, cp, groups){\n    // character in a regular expression or in a character set\n    // pos : position of the character in the pattern string\n    // cp : the character's codepoint\n    // groups (optional) : the groups that contain the character\n    this.pos = pos\n    this.cp = cp\n    this.char = chr(this.cp)\n    this.text = this.char\n}\n\nChar.prototype.fixed_length = function(){\n    if(this.repeat){\n        return this.repeat.min\n    }\n    return this.char === EmptyString ? 0 : 1\n}\n\nChar.prototype.match = function(string, pos, endpos){\n    // Returns {pos1, pos2} such that \"this\" matches all the substrings\n    // string[pos:i] with pos1 <= i < pos2, or false if no match\n    this.repeat = this.repeat || {min: 1, max: 1}\n\n    var i = 0\n\n    // browse string codepoints until they don't match, or the number of\n    // matches is above the maximum allowed\n    if(this.flags){\n        if(this.flags.value & ASCII.value){\n            if(this.cp > 127){\n                return false\n            }\n        }\n        if(this.flags.value & IGNORECASE.value &&\n                (! this.is_bytes || this.cp <= 127)){\n            // Flag IGNORECASE set\n            // For bytes pattern, case insensitive matching only works\n            // for ASCII characters\n            var char_upper = this.char.toUpperCase(),\n                char_lower = this.char.toLowerCase(),\n                cp\n            while(i < this.repeat.max && pos + i < endpos){\n                cp = string.cp_at(pos + i)\n                var char = chr(cp)\n                if(char.toUpperCase() != char_upper &&\n                        char.toLowerCase() != char_lower){\n                   break\n                }\n                i++\n            }\n        }else{\n            while(pos + i < endpos &&\n                    string.cp_at(pos + i) == this.cp &&\n                    i < this.repeat.max){\n                i++\n            }\n        }\n    }else{\n        while(pos + i < endpos &&\n                string.cp_at(pos + i) == this.cp &&\n                i < this.repeat.max){\n            i++\n        }\n    }\n    var nb = i\n    if(nb >= this.repeat.min){\n        // Number of repeats ok\n        return {\n            nb_min: this.repeat.min,\n            nb_max: nb\n        }\n    }else{\n        return false\n    }\n}\n\nChar.prototype.toString = function(){\n    var res = 'Char ' + this.text\n    if(this.repeat !== undefined){\n        res += ' repeat {' + this.repeat.min + ',' + this.repeat.max + '}'\n        if(this.non_greedy){\n            res += '?'\n        }\n    }\n    return res\n}\n\nfunction CharSeq(chars, flags){\n    // sequence of consecutive characters\n    this.chars = chars\n    this.flags = flags\n    this.merge_same_chars()\n}\n\nCharSeq.prototype.add_char = function(char){\n    this.chars.push(char)\n    this.merge_same_chars()\n}\n\nCharSeq.prototype.fixed_length = function(){\n    var len = 0,\n        cps = [],\n        char_len\n    for(var char of this.chars){\n        if(! char.repeat){\n            char_len = 1\n        }else if(char.repeat.min == char.repeat.max){\n            char_len = char.repeat.min\n        }else{\n            len = false\n            break\n        }\n        for(var i = 0; i < char_len; i++){\n            cps.push(char.cp)\n        }\n        len += char_len\n    }\n    this.cps = cps\n    return this.len = len\n}\n\nCharSeq.prototype.match = function(string, pos, endpos){\n    var mos = [],\n        i = 0,\n        backtrack,\n        nb\n    this.len = this.len === undefined ? this.fixed_length() : this.len\n    // optimization if character sequence has a fixed length\n    if(this.len !== false && ! (this.flags.value & IGNORECASE.value)){\n        for(var i = 0; i < this.len; i++){\n            if(string.cp_at(pos + i) !== this.cps[i]){\n                return false\n            }\n        }\n        return {nb_min: this.len, nb_max: this.len}\n    }\n    for(var i = 0, len = this.chars.length; i < len; i++){\n        var char =  this.chars[i],\n            mo = char.match(string, pos, endpos) // form {nb_min, nb_max}\n        if(_debug.value){\n            console.log('CharSeq match, pos', pos, 'char', char, 'mo', mo)\n            alert()\n        }\n        if(mo){\n            nb = char.non_greedy ? mo.nb_min : mo.nb_max\n            mos.push({nb,\n                      nb_min: mo.nb_min,\n                      nb_max: mo.nb_max,\n                      non_greedy: !!char.non_greedy\n                     })\n            pos += nb\n        }else{\n            // backtrack\n            backtrack = false\n            while(mos.length > 0){\n                i--\n                mo = mos.pop()\n                pos -= mo.nb\n                nb = mo.nb\n                if(mo.non_greedy && nb < mo.nb_max){\n                    nb += 1\n                    backtrack = true\n                }else if(! mo.non_greedy && nb - 1 >= mo.nb_min){\n                    nb -= 1\n                    backtrack = true\n                }\n                if(backtrack){\n                    pos += nb\n                    mo.nb = nb\n                    mos.push(mo)\n                    break\n                }\n            }\n            if(mos.length == 0){\n                return false\n            }\n        }\n    }\n    var nb = 0,\n        last_mo = $B.last(mos)\n    for(var mo of mos.slice(0, mos.length - 1)){\n        nb += mo.nb\n    }\n    var res = {\n        nb_min: nb + last_mo.nb_min,\n        nb_max: nb + last_mo.nb_max\n    }\n    return res\n}\n\nCharSeq.prototype.merge_same_chars = function(){\n    // b?b merged into b+ etc.\n    var current,\n        chars = [],\n        merged\n    for(var item of this.chars){\n        if(current && current.char == item.char &&\n                current.non_greedy === item.non_greedy){\n            if(! current.repeat){\n                current.repeat = {min: 1, max: 1}\n            }\n            if(item.repeat){\n                current.repeat.min += item.repeat.min\n                current.repeat.max += item.repeat.max\n            }else{\n                current.repeat.min += 1\n                current.repeat.max += 1\n            }\n            merged = true\n        }else{\n            chars.push(item)\n        }\n        current = item\n    }\n    if(merged){\n        this.chars = chars\n    }\n}\n\nCharSeq.prototype.toString = function(){\n    var res = ''\n    for(var char of this.chars){\n        res += char.text\n    }\n    return 'CharSeq ' + res\n}\n\nfunction CharacterClass(pos, cp, length, groups){\n    this.cp = cp\n    this.value = chr(cp)\n    this.length = length\n    this.pos = pos\n\n    var flags = this.flags\n\n    // Test function : test(string, pos) returns:\n    // - true if \"this\" matches 1 character string[pos]\n    // - [true, 0] if \"this\" matches the empty string at pos\n    // - false or undefined if \"this\" doesn't match\n    switch(this.value){\n        case 'A':\n            this.test_func = function(string, pos){\n                if(pos == 0){\n                    return [true, 0]\n                }\n            }\n            break\n        case 's':\n            this.test_func = function(string, pos){\n                var cp = string.cp_at(pos)\n                return $B.in_unicode_category('Zs', cp) ||\n                    $B.unicode_bidi_whitespace.indexOf(cp) > -1\n            }\n            break\n        case 'S':\n            this.test_func = function(string, pos){\n                var cp = string.cp_at(pos)\n                return cp !== undefined &&\n                    ! $B.in_unicode_category('Zs', cp) &&\n                    $B.unicode_bidi_whitespace.indexOf(cp) == -1\n            }\n            break\n        case '.':\n            this.test_func = function(string, pos){\n                if(string.cp_at(pos) === undefined){\n                    return false\n                }\n                if(this.flags.value & DOTALL.value){\n                    return true\n                }else{\n                    return string.cp_at(pos) != 10\n                }\n            }\n            break\n        case 'd':\n            this.test_func = function(string, pos){\n                if(this.flags === undefined){\n                    console.log(\"\\\\d, no flags\", this)\n                }\n                var cp = string.cp_at(pos),\n                    tester = (this.flags.value & ASCII.value) ?\n                        is_ascii_digit : is_digit\n                return tester(cp)\n            }\n            break\n        case 'D':\n            this.test_func = function(string, pos){\n                var cp = string.cp_at(pos),\n                    tester = (this.flags.value & ASCII.value) ?\n                        is_ascii_digit : is_digit\n                return ! tester(cp)\n            }\n            break\n        case 'b':\n            this.test_func = function(string, pos){\n                var tester = is_word\n                if(this.is_bytes || (this.flags.value & ASCII.value)){\n                    tester = is_ascii_word\n                }\n                var cp = string.cp_at(pos),\n                    ok = {nb_min: 0, nb_max: 0}\n\n                // return true if char at pos is at the beginning or start\n                // of a word\n                if(pos == 0 && tester(cp)){\n                    return ok\n                }\n                if(string.cp_at(pos) === undefined && tester(string.cp_at(pos - 1))){\n                    return ok\n                }\n                if(pos > 0 && string.cp_at(pos) !== undefined){\n                    if((tester(string.cp_at(pos - 1))) !==\n                            tester(cp)){\n                        return ok\n                    }\n                }\n                return false\n            }\n            break\n        case 'B':\n            this.test_func = function(string, pos){\n                var tester = is_word\n                if(this.is_bytes || (this.flags.value & ASCII.value)){\n                    tester = is_ascii_word\n                }\n\n                var cp = string.cp_at(pos),\n                    ok = {nb_min: 0, nb_max: 0}\n                // test is true if char at pos is not at the beginning or\n                // start of a word\n                if(pos == 0 && cp === undefined){\n                    // empty string\n                    return false\n                }\n                if(pos == 0 && tester(cp)){\n                    return false\n                }\n                if(cp === undefined &&\n                        tester(string.cp_at(pos - 1))){\n                    return false\n                }\n                if(pos > 0 && cp !== undefined){\n                    if(tester(string.cp_at(pos - 1)) !== tester(cp)){\n                        return false\n                    }\n                }\n                return ok\n            }\n            break\n        case 'w':\n            this.test_func = function(string, pos){\n                var tester = is_word\n                if(this.is_bytes || (this.flags.value & ASCII.value)){\n                    tester = is_ascii_word\n                }\n                return tester(string.cp_at(pos))\n            }\n            break\n        case 'W':\n            this.test_func = function(string, pos){\n                var tester = is_word\n                if(this.is_bytes || (this.flags.value & ASCII.value)){\n                    tester = is_ascii_word\n                }\n                return ! tester(string.cp_at(pos))\n            }\n            break\n        case 'Z':\n            this.test_func = function(string, pos){\n                if(string.cp_at(pos) === undefined){\n                    return {nb_min: 0, nb_max: 0}\n                }\n            }\n            break\n    }\n}\n\nCharacterClass.prototype.fixed_length = function(){\n    return this.repeat ? false : 1\n}\n\nCharacterClass.prototype.match = function(string, pos, endpos){\n    // Returns {pos1, pos2} such that \"this\" matches all the substrings\n    // string[pos:i] with pos1 <= i < pos2, or false if no match\n    if(pos === undefined){\n        console.log('no pos')\n        throw Error()\n    }\n    var len = string.length\n    this.repeat = this.repeat || {min: 1, max: 1}\n\n    // browse string codepoints until they don't match, or the number of\n    // matches is above the maximum allowed\n    var i = 0\n    while(i < this.repeat.max && i < len){\n        var test = this.test_func(string, pos + i, this.flags)\n        if(! test){\n            break\n        }\n        i++\n    }\n\n    var nb = i\n    if(nb >= this.repeat.min){\n        // Number of repeats ok\n        if('bBAZ'.indexOf(this.value) > -1 ){\n            return {nb_min: 0, nb_max: 0}\n        }\n        return {\n            nb_min: this.repeat.min,\n            nb_max: nb\n        }\n    }else{\n        return false\n    }\n}\n\nCharacterClass.prototype.nb_repeats = Char.prototype.nb_repeats\n\nCharacterClass.prototype.toString = function(){\n    return '\\\\' + this.value\n}\n\nvar CharacterSet = function(pos, set, groups){\n    // character set\n    this.pos = pos\n    this.set = set\n    this.neg = set.neg\n}\n\nCharacterSet.prototype.fixed_length = function(){\n    return 1\n}\n\nCharacterSet.prototype.match = function(string, pos, endpos){\n    var ignore_case = this.flags && (this.flags.value & IGNORECASE.value),\n        test,\n        match = false,\n        i = 0,\n        cp\n\n    this.repeat = this.repeat || {min: 1, max: 1}\n\n    while(i < this.repeat.max && (cp = string.cp_at(pos + i)) !== undefined){\n        test = false\n\n        if(string.cp_at(pos) === undefined){\n            cp = EmptyString\n        }\n        try{\n            $B.codepoint2jsstring(cp)\n        }catch(err){\n            console.log(err.message)\n            console.log('cp', cp, '\\nstring', string, 'pos', pos)\n            console.log($B.print_stack())\n            throw _b_.Exception.$factory('bad codepoint')\n        }\n        var char = $B.codepoint2jsstring(cp),\n            cps = cased_cps(cp, ignore_case, this.flags.value & ASCII.value),\n            char_is_cased = cps.length > 1\n\n        for(var cp1 of cps){\n            for(var item of this.set.items){\n                if(Array.isArray(item.ord)){\n                    if(cp1 >= item.ord[0] &&\n                            cp1 <= item.ord[1]){\n                        test = true\n                        break\n                    }else if(ignore_case && char_is_cased){\n                        var start1 = chr(item.ord[0]).toUpperCase(),\n                            end1 = chr(item.ord[1]).toUpperCase(),\n                            char1 = char.toUpperCase()\n                        if(char1 >= start1 && char1 <= end1){\n                            test = true\n                        }\n                        var start1 = chr(item.ord[0]).toLowerCase(),\n                            end1 = chr(item.ord[1]).toLowerCase(),\n                            char1 = char.toLowerCase()\n                        if(char1 >= start1 && char1 <= end1){\n                            test = true\n                        }\n                    }\n                }else if(item instanceof CharacterClass){\n                    test = !! item.match(string, pos + i, endpos) // boolean\n                    if(test){\n                        break\n                    }\n                }else{\n                    if(item.ord == cp1){\n                        test = true\n                        break\n                    }\n                    item_str = typeof item == 'string' ? item : chr(item.ord)\n                    if(item_str == char){\n                        test = true\n                        break\n                    }\n                    if(ignore_case && char_is_cased &&\n                            (char.toUpperCase() == item_str.toUpperCase() ||\n                            char.toLowerCase() == item_str.toLowerCase())){\n                        test = true\n                        break\n                    }\n                }\n            }\n        }\n        if(this.neg){\n            test = ! test\n        }\n        if(test){\n            i++\n        }else{\n            break\n        }\n    }\n    var nb = i\n    if(nb >= this.repeat.min){\n        // Number of repeats ok\n        return {\n            nb_min: this.repeat.min,\n            nb_max: nb\n        }\n    }else{\n        return false\n    }\n\n}\n\nCharacterSet.prototype.nb_repeats = Char.prototype.nb_repeats\n\nCharacterSet.prototype.toString = function(){\n    return 'CharSet'\n}\n\nvar ConditionalBackref = function(pos, group_ref){\n    this.type = \"conditional backref\"\n    this.pos = pos\n    this.group_ref = group_ref\n    this.chars = []\n    this.match_codepoints = []\n    this.nb_success = 0\n    this.re_if_exists = new Group(pos)\n    this.re_if_not_exists = new Group(pos)\n    this.nb_options = 1\n}\n\nConditionalBackref.prototype.add = function(item){\n    if(this.nb_options == 1){\n        this.re_if_exists.add(item)\n    }else if(this.nb_options == 2){\n        this.re_if_not_exists.add(item)\n    }\n    item.parent = this\n}\n\nConditionalBackref.prototype.fixed_length = function(){\n    var len = this.re_if_exists.fixed_length()\n    if(len !== false && len == this.re_if_not_exists.fixed_length()){\n        return len\n    }\n    return false\n}\n\nConditionalBackref.prototype.match = function(string, pos, endpos, groups){\n    var re = groups[this.group_ref] ? this.re_if_exists :\n            this.re_if_not_exists,\n        pattern = {node: re, text: re + ''},\n        mo = match(pattern, string, pos, endpos, false, groups)\n    if(mo){\n        return {nb_min: mo.end - mo.start, nb_max: mo.end - mo.start}\n    }\n    return false\n}\n\nConditionalBackref.prototype.toString = function(){\n    return 'ConditionalBackref'\n}\n\nvar Group = function(pos, extension){\n    this.type = \"group\"\n    this.pos = pos\n    this.items = []\n    this.chars = []\n    this.groups = []\n    for(var key in extension){\n        this[key] = extension[key]\n    }\n    if(extension && extension.type){\n        if(extension.type.indexOf('lookahead') > -1){\n            this.is_lookahead = true\n        }else if(extension.type.indexOf('lookbehind') > -1){\n            this.is_lookbehind = true\n        }\n    }\n}\n\nGroup.prototype.add = Node.prototype.add\n\nGroup.prototype.toString = function(){\n    if(this.num === undefined){\n        var res = 'Group ' + this.type + ' ' + this.pattern\n    }else{\n        var res = 'Group #' + this.num + ' ' + this.pattern\n    }\n    if(this.repeat !== undefined){\n        res += ' repeat {' + this.repeat.min + ',' + this.repeat.max + '}'\n        if(this.non_greedy){\n            res += '?'\n        }\n    }\n    return res\n}\n\nBackReference.prototype.nb_repeats = Group.prototype.nb_repeats\n\nGroup.prototype.fixed_length = Node.prototype.fixed_length\n\nfunction groups_in(pattern, group_list){\n    if(group_list === undefined){\n        group_list = new Set()\n    }\n    if(pattern instanceof Group && pattern.hasOwnProperty('num')){\n        group_list.add(pattern.num)\n    }\n    if(pattern.items){\n        for(var subpattern of pattern.items){\n            for(var group of groups_in(subpattern, group_list)){\n                group_list.add(group)\n            }\n        }\n    }\n    return group_list\n}\n\nfunction GroupRef(group_num, item){\n    this.num = group_num\n    this.item = item\n}\n\nGroupRef.prototype.fixed_length = function(){\n    return this.item.fixed_length()\n}\n\nfunction Lookbehind(item){\n    this.re = item\n    this.neg = this.re.type == \"negative_lookbehind\"\n}\n\nLookbehind.prototype.match = function(string, pos, endpos, groups){\n    var ok = {nb_min: 0, nb_max: 0},\n        pattern = {node: this.re, text: this.re + ''},\n        length = this.re.length,\n        mo\n    if(pos - length < 0){\n        mo = false\n    }else{\n        mo = match(pattern, string, pos - length, endpos, false, groups)\n    }\n    if(mo){\n        return this.neg ? false : ok\n    }else{\n        return this.neg ? ok : false\n    }\n}\n\nLookbehind.prototype.fixed_length = function(){\n    return this.re.fixed_length()\n}\n\nLookbehind.prototype.toString = function(){\n    return \"Lookbehind\"\n}\n\nfunction SetFlags(pos, flags){\n    this.pos = pos\n    this.on_flags = flags.on_flags\n    this.off_flags = flags.off_flags\n    this.items = []\n}\n\nSetFlags.prototype.add = Node.prototype.add\n\nfunction StringStart(pos){\n    this.pos = pos\n}\n\nStringStart.prototype.match = function(string, pos, endpos){\n    var ok = {nb_min:0, nb_max: 0}\n    if(this.flags.value & MULTILINE.value){\n        return (pos == 0 || string.cp_at(pos - 1) == 10) ? ok : false\n    }\n    return pos == 0 ? ok : false\n}\n\nStringStart.prototype.fixed_length = function(){\n    return 0\n}\n\nStringStart.prototype.toString = function(){\n    return '^'\n}\n\nfunction StringEnd(pos){\n    this.pos = pos\n}\n\nStringEnd.prototype.match = function(string, pos, endpos){\n    var ok = {nb_min:0, nb_max: 0},\n        cp = string.cp_at(pos)\n    if(this.flags.value & MULTILINE.value){\n        return (pos > string.codepoints.length - 1 ||\n            cp == 10) ? ok : false\n    }\n    return pos > endpos - 1 ? ok :\n           (pos == endpos - 1 && cp == 10) ? ok : false\n}\n\nStringEnd.prototype.fixed_length = function(){\n    return 0\n}\n\nStringEnd.prototype.toString = function(){\n    return '$<end>'\n}\n\nvar cache = new Map()\n\nfunction compile(pattern, flags){\n    if(pattern.__class__ === Pattern){\n        if(flags !== no_flag){\n            throw _b_.ValueError.$factory(\"no flags\")\n        }\n        return pattern\n    }\n    if(cache.has(pattern.py_obj)){\n        if(cache.get(pattern.py_obj).has(flags.value || 0)){\n            return cache.get(pattern.py_obj).get(flags.value || 0)\n        }\n    }\n    var original_pattern = pattern,\n        original_flags = flags,\n        type = pattern.type,\n        choices,\n        allow_global_flags = true\n    pattern = pattern.codepoints\n    var is_bytes = type !== \"str\"\n    if(is_bytes && flags && (flags.value & U.value)){\n        throw _b_.ValueError.$factory(\"cannot use UNICODE flag with \" +\n            \"a bytes pattern\")\n    }\n    if(flags && (flags.value & U.value) &&\n            (flags.value & ASCII.value)){\n        throw _b_.ValueError.$factory(\"ASCII and UNICODE flags \" +\n            \"are incompatible\")\n    }\n    if(is_bytes){\n        // bytes patterns ignore re.ASCII flag\n        flags = Flag.$factory(flags.value || 0)\n        //flags.value &= ~ASCII.value\n    }\n    var group_num = 0,\n        group_stack = [],\n        groups = {},\n        pos,\n        lookbehind,\n        node = new Node(),\n        accept_inline_flag = true,\n        verbose = (flags.value || 0) & VERBOSE.value,\n        comment = false,\n        backrefs = {}\n    node.$groups = groups\n    for(var item of tokenize(pattern, type, verbose)){\n        item.flags = flags\n        item.is_bytes = is_bytes\n        if(lookbehind){\n            item.lookbehind = lookbehind\n            lookbehind.parent = item\n            lookbehind = false\n        }\n        if(allow_global_flags &&\n                (group_stack.length > 0 || ! (item instanceof SetFlags))){\n            allow_global_flags = false\n        }\n        if(item instanceof Group){\n            group_stack.push(item)\n            node.add(item)\n            item.state = \"open\"\n            group_num++\n            item.num = group_num\n            node = item // next items will be stored as group's items\n            pos = item.pos\n            if(item.non_capturing){\n                delete item.num\n                group_num--\n            }else if(item.type == \"name_def\"){\n                var value = item.value\n                if(groups[value.string] !== undefined){\n                    fail(`redefinition of group name` +\n                        ` '${value.string}' as group ${group_num}; was group` +\n                        ` ${groups[value.string].num}`, pos)\n                }\n                item.name = value.string\n                groups[value.string] = groups[group_num] =\n                    new GroupRef(group_num, item)\n            }else if(item.is_lookahead){\n                // a lookahead assertion is relative to the previous regexp\n                group_num--\n                while(node.items.length > 0){\n                    item.add(node.items.shift())\n                }\n                node = item\n            }else if(item.is_lookbehind){\n                // a lookbehind assertion is relative to the next regexp\n                node.parent.items.pop() // remove from node items\n                // temporarily create a group\n                groups[group_num] = new GroupRef(group_num, item)\n            }else if(item.type == \"flags\"){\n                // save flags before a group with inline flags, eg \"(?i:a)\"\n                item.flags_before = Flag.$factory(flags.value | 0)\n            }else{\n                groups[group_num] = new GroupRef(group_num, item)\n            }\n        }else if(item instanceof GroupEnd){\n            end_pos = item.pos\n            if(group_stack.length == 0){\n                fail(\"unbalanced parenthesis\", end_pos, original_pattern)\n            }\n            var item = group_stack.pop()\n            item.end_pos = end_pos\n            try{\n                item.pattern = from_codepoint_list(\n                    pattern.slice(item.pos, end_pos + 1))\n            }catch(err){\n                console.log(\"err avec pattern substring\", pattern)\n                throw err\n            }\n            if(item.is_lookbehind){\n                delete groups[group_num]\n                group_num--\n                // check that all elements have a fixed length\n                item.length = item.fixed_length()\n                if(item.length === false){\n                    fail(\"look-behind requires fixed-width pattern\", pos)\n                }\n                item.parent.add(new Lookbehind(item))\n                item.non_capturing = true\n                // store in variable \"lookbehind\", will be applied to next item\n                lookbehind = item\n            }else if(item.is_lookahead){\n                delete item.num\n            }\n            if(item instanceof Group && item.items.length == 0){\n                item.add(EmptyString)\n            }else if(item instanceof ConditionalBackref){\n                if(groups[item.group_ref] === undefined){\n                    // might be defined later; store in backrefs and check\n                    // when all items have been processed\n                    backrefs[item.group_ref] = backrefs[item.group_ref] | pos + 3\n                }\n                if(item.re_if_exists.items.length == 0){\n                    item.re_if_exists.add(EmptyString)\n                }else if(item.re_if_not_exists.items.length == 0){\n                    item.re_if_not_exists.pos = pos\n                    item.re_if_not_exists.add(EmptyString)\n                }\n            }else if(item.type == \"flags\"){\n                // restore flags when entering the group\n                flags = Flag.$factory(item.flags_before.value)\n            }\n            item.state = 'closed'\n            node = item.parent\n        }else if(item instanceof ConditionalBackref){\n            var pos = item.pos,\n                group_ref = item.group_ref\n            if(typeof group_ref == \"number\"){\n                if(group_ref == 0){\n                    fail(`bad group number`, pos + 3)\n                }else if(group_ref >= MAXGROUPS){\n                    fail(`invalid group reference ${group_ref}`, pos + 1)\n                }else if(groups[group_ref] &&\n                        groups[group_ref].item.state == \"open\"){\n                    fail(\"cannot refer to an open group\", pos)\n                }\n            }else if(groups[group_ref] !== undefined){\n                if(groups[group_ref].item.state == \"open\"){\n                    fail(\"cannot refer to an open group\", pos)\n                }\n            }else{\n                fail(`unknown group name '${group_ref}'`, pos)\n            }\n            group_stack.push(item)\n            node.add(item)\n            item.state = \"open\"\n            node = item // next items will be stored as group's items\n        }else if(item instanceof BackReference){\n            pos = item.pos\n            if(item.type == \"num\" && item.value > 99){\n                var head = item.value.toString().substr(0, 2)\n                fail(`invalid group reference ${head}`, pos + 1)\n            }\n            if(groups[item.value] !== undefined){\n                if(groups[item.value].item.state == \"open\"){\n                    fail(\"cannot refer to an open group\", pos)\n                }\n                var ref_item = groups[item.value].item.parent\n                while(ref_item){\n                    if(ref_item.is_lookbehind){\n                        fail(\"cannot refer to group defined in the same lookbehind subpattern\", pos)\n                    }\n                    ref_item = ref_item.parent\n                }\n            }else if(item.type == \"name\"){\n                fail(`unknown group name '${item.value}'`, pos)\n            }else if(item.type == \"num\"){\n                fail(`invalid group reference ${item.value}`, pos)\n            }\n            node.add(item)\n        }else if(item instanceof Char ||\n                item instanceof CharacterClass ||\n                item instanceof CharacterSet){\n            if(item instanceof CharacterSet){\n                for(var elt of item.set.items){\n                    elt.flags = flags\n                }\n            }\n            var added_to_charseq = false\n            if(item instanceof Char){\n                if(node.items && node.items.length > 0){\n                    var previous = $last(node.items)\n                    if(previous instanceof CharSeq){\n                        previous.add_char(item)\n                        added_to_charseq = true\n                    }else if(previous instanceof Char && ! previous.repeater){\n                        node.items.pop()\n                        node.items.push(new CharSeq([previous, item], flags))\n                        added_to_charseq = true\n                    }\n                }\n            }\n            if(! added_to_charseq){\n                node.add(item)\n            }\n        }else if(item instanceof Repeater){\n            // check that item is not in a lookbehind group\n            var pnode = node\n            while(pnode){\n                if(pnode.extension && pnode.extension.type &&\n                        pnode.extension.type.indexOf(\"lookbehind\") > -1){\n                    fail(\"look-behind requires fixed-width pattern\", pos)\n                }\n                pnode = pnode.parent\n            }\n            pos = item.pos\n            if(node.items.length == 0){\n                fail(\"nothing to repeat\", pos)\n            }\n            previous = $last(node.items)\n            if(previous instanceof Char ||\n                    previous instanceof CharSeq ||\n                    previous instanceof CharacterClass ||\n                    previous instanceof CharacterSet ||\n                    previous instanceof Group ||\n                    previous instanceof BackReference){\n                if(previous instanceof GroupEnd){\n                    // associate repeat with Group\n                    previous = previous.group\n                }else if(previous instanceof CharSeq){\n                    previous = $last(previous.chars)\n                }\n                if(previous.repeater){\n                    if(item.op == '?' && ! previous.non_greedy){\n                        if(previous.possessive){\n                            fail('multiple repeat', pos)\n                        }\n                        previous.non_greedy = true\n                        if(previous instanceof CharacterClass &&\n                                previous.value == '.'){\n                            previous.min_repeat_one = true\n                        }\n                    }else{\n                        if(item instanceof Repeater && item.op == '+'){\n                            if(previous.possessive || previous.non_greedy){\n                                fail('multiple repeat', pos)\n                            }\n                            previous.possessive = true\n                        }else{\n                            fail(\"multiple repeat\", pos)\n                        }\n                    }\n                }else{\n                    // convert to minimum and maximum number of repeats\n                    var min = 1,\n                        max = 1\n                    if(Array.isArray(item.op)){\n                        min = item.op[0]\n                        if(min >= MAXREPEAT){\n                            throw _b_.OverflowError.$factory(\n                                \"the repetition number is too large\")\n                        }\n                        max = item.op[1] === undefined ? min : item.op[1]\n                        if(isFinite(max) && max >= MAXREPEAT){\n                            throw _b_.OverflowError.$factory(\n                                \"the repetition number is too large\")\n                        }\n                        if(max < min){\n                            fail('min repeat greater than max repeat', pos)\n                        }\n                    }else if(item.op == \"?\"){\n                        min = 0\n                        max = 1\n                    }else if(item.op == \"*\"){\n                        min = 0\n                        max = Number.POSITIVE_INFINITY\n                    }else if(item.op == \"+\"){\n                        min = 1\n                        max = Number.POSITIVE_INFINITY\n                    }\n                    previous.repeater = item\n                    previous.repeat = {min, max}\n                    // mark all parents of item as no fixed length\n                    var parent = item\n                    while(parent){\n                        parent.fixed_length = false\n                        parent = parent.parent\n                    }\n                }\n            }else{\n                fail(\"nothing to repeat\", pos)\n            }\n        }else if(item instanceof Or){\n            if(group_stack.length > 0){\n                item.group = group_stack[group_stack.length - 1]\n            }else{\n                item.group = false\n            }\n            pos = item.pos\n            if(node instanceof ConditionalBackref){\n                // case '(?(num)a|'\n                if(node.nb_options == 1){\n                    node.nb_options++\n                }else{\n                    fail('conditional backref with more than ' +\n                       'two branches', pos)\n                }\n            }else if(node.items.length == 0){\n                // token \"|\" in  \"(|...)\" : first option is the empty string\n                var choice = new Choice(),\n                    case1 = new Case()\n                case1.add(new Char(pos, EmptyString))\n                choice.add(case1)\n                node.add(choice)\n                var case2 = new Case()\n                choice.add(case2)\n                node = case2\n            }else if(node instanceof Case){\n                // node.parent is already a Choice\n                var new_case = new Case()\n                node.parent.add(new_case)\n                node = new_case\n            }else{\n                // token \"|\" in \"(ab|...)\"\n                var previous = node.items[node.items.length - 1]\n                if(previous instanceof Case){\n                    var new_case = new Case()\n                    previous.add(new_case)\n                    node = new_case\n                }else{\n                    var choice = new Choice(),\n                        case1 = new Case(),\n                        first_rank = node.items[0].rank\n                    while(node.items.length > 0){\n                        case1.add(node.items.shift())\n                    }\n                    case1.groups = node.$groups\n                    for(var group of group_stack){\n                        choice.groups.push(group)\n                    }\n                    choice.add(case1)\n                    node.add(choice)\n                    var case2 = new Case()\n                    choice.add(case2)\n                    node = case2\n                }\n            }\n        }else if(item instanceof StringStart ||\n                 item instanceof StringEnd){\n            node.add(item)\n        }else if(item instanceof SetFlags){\n            if(group_stack.length == 0 && ! allow_global_flags){\n                // pattern like (?x) only allowed as first in reg exp\n                fail('global flags not at the start of the ' +\n                        'expression', item.pos)\n            }\n            // copy flags, otherwise re.ASCII etc might be modified\n            flags = Flag.$factory(flags.value || U.value)\n            if(item.on_flags.indexOf('u') > -1){\n                if(is_bytes){\n                    fail(\"re.error: bad inline flags: cannot use 'u' flag \" +\n                        \"with a bytes pattern\", pos)\n                }\n                if(flags && flags.value & ASCII.value){\n                    // switch to Unicode\n                    flags.value ^= ASCII.value\n                }\n                if(group_stack.length == 0 &&\n                        original_flags && original_flags.value & ASCII.value){\n                    throw _b_.ValueError.$factory(\"ASCII and UNICODE flags \" +\n                        \"are incompatible\")\n                }\n                if(item.on_flags.indexOf('a') > -1){\n                    throw _b_.ValueError.$factory(\"ASCII and UNICODE flags \" +\n                        \"are incompatible\")\n                }\n            }\n            if(item.on_flags.indexOf('a') > -1){\n                if(group_stack.length == 0 &&\n                        original_flags && original_flags.value & U.value){\n                    throw _b_.ValueError.$factory(\"ASCII and UNICODE flags \" +\n                        \"are incompatible\")\n                }\n                if(flags && flags.value & U.value){\n                    // switch to ASCII\n                    flags.value ^= U.value\n                }\n                if(item.on_flags.indexOf('u') > -1){\n                    throw _b_.ValueError.$factory(\"ASCII and UNICODE flags \" +\n                        \"are incompatible\")\n                }\n            }\n            if(flags.value === undefined){\n                flags.value = 32\n            }\n            if(item.items.length == 0){\n                if(! accept_inline_flag && group_stack.length == 0){\n                    var s = from_codepoint_list(pattern)\n                    warn(_b_.DeprecationWarning,\n                        `Flags not at the start of the expression '${s}'`,\n                        pos)\n                }\n                for(var on_flag of item.on_flags){\n                    if(! is_bytes || on_flag !== 'a'){\n                        flags.value |= inline_flags[on_flag].value\n                    }\n                }\n                for(var off_flag of item.off_flags){\n                    if(! is_bytes || off_flag !== 'a'){\n                        flags.value ^= inline_flags[off_flag].value\n                    }\n                }\n            }else{\n                node.add(item)\n            }\n        }else{\n            fail(\"unknown item type \" + item, pos)\n        }\n        if(! (item instanceof SetFlags) &&\n                ! (item instanceof Group && item.type == \"flags\")){\n            accept_inline_flag = false\n        }\n    }\n    for(ref in backrefs){\n        if(groups[ref] === undefined){\n            fail('invalid group name ' + ref, backrefs[ref])\n        }\n    }\n    if(group_stack.length > 0){\n        var last = group_stack[group_stack.length - 1]\n        fail(\"missing ), unterminated subpattern\", last.pos)\n    }\n    while(node.parent){\n        node = node.parent\n    }\n    node.pattern = from_codepoint_list(pattern)\n    node.groups = group_num\n    flags = flags === no_flag ? 32 : flags\n    node.flags = flags\n    var res = {\n        node,\n        groups,\n        flags,\n        original_flags,\n        text: from_codepoint_list(pattern),\n        type, // \"str\" or \"bytes\"\n        fixed_length: node.fixed_length()\n    }\n    if(! cache.has(original_pattern.py_obj)){\n        cache.set(original_pattern.py_obj, new Map())\n    }\n    cache.get(original_pattern.py_obj).set(original_flags.value || 0, res)\n    if(_debug.value){\n        show(node)\n    }\n    return res\n}\n\nfunction show(node, indent){\n    indent = indent === undefined ? 0 : indent\n    if(indent == 0){\n        log('root', node)\n    }\n    log(' '.repeat(indent) + node)\n    if(node.items !== undefined){\n        for(var item of node.items){\n            show(item, indent + 1)\n        }\n    }\n}\n\nfunction to_codepoint_list(s){\n    var items = []\n    if(typeof s == \"string\" || $B.$isinstance(s, _b_.str)){\n        if(typeof s != \"string\"){\n            s = s.valueOf()\n        }\n        for(var char of s){\n            items.push(char.codePointAt(0))\n        }\n        items.type = \"unicode\"\n    }else if($B.$isinstance(s, [_b_.bytes, _b_.bytearray, _b_.memoryview])){\n        if($B.$isinstance(s, _b_.memoryview)){\n            items = s.obj.source\n        }else{\n            items = s.source\n        }\n        items.type = \"bytes\"\n    }else{\n        throw Error('invalid type ' + $B.class_name(s))\n    }\n    return items\n}\n\n$B.nb_from_cp = 0\nfunction from_codepoint_list(codepoints, type){\n    $B.nb_from_cp++\n    // Return a string\n    if(type == \"bytes\"){\n        return _b_.bytes.$factory(codepoints)\n    }\n    var s = ''\n    for(var cp of codepoints){\n        s += _b_.chr(cp)\n    }\n    return $B.String(s)\n}\n\nfunction string2bytes(s){\n    var t = []\n    for(var i = 0, len = s.length; i < len; i++){\n        t.push(s.charCodeAt(i))\n    }\n    return _b_.bytes.$factory(t)\n}\n\nfunction check_pattern_flags(pattern, flags){\n    if(pattern.__class__ === Pattern){\n        if(flags !== no_flag){\n            throw _b_.ValueError.$factory(\n                \"cannot process flags argument with a compiled pattern\")\n        }\n    }\n    return pattern\n}\n\nfunction StringObj(obj){\n    // A StringObj object is a bridge between a Python string or bytes-like\n    // object and Javascript\n    // obj is the Python object\n    // this.string is a Javascript string\n    this.py_obj = obj\n    this.codepoints = []\n    this.type = \"str\"\n    this.is_string = typeof obj == 'string'\n    if(typeof obj == \"string\" ||\n            (obj instanceof String && ! obj.codepoints)){\n        // Python object represented as a Javascript string\n        this.string = obj\n        // Maps a position in codepoints to position in string\n        this.index_map = {}\n        for(var i = 0, len = obj.length; i < len; i++){\n            this.index_map[this.codepoints.length] = i\n            var cp = obj.codePointAt(i)\n            this.codepoints.push(cp)\n            if(cp >= 0x10000){\n                i++\n            }\n        }\n        this.length = _b_.str.__len__(obj)\n        if(obj instanceof String){\n            // store for next use\n            obj.codepoints = this.codepoints\n            obj.index_map = this.index_map\n        }\n    }else if(obj instanceof String){\n        // string with surrogate pairs\n        this.string = obj.string\n        this.codepoints = obj.codepoints\n        this.index_map = obj.index_map\n        this.length = _b_.str.__len__(obj)\n    }else if($B.$isinstance(obj, _b_.str)){ // str subclass\n        var so = new StringObj(_b_.str.$factory(obj))\n        this.string = so.string\n        this.codepoints = so.codepoints\n        this.length = _b_.str.__len__(obj)\n    }else if($B.$isinstance(obj, [_b_.bytes, _b_.bytearray])){\n        this.string = _b_.bytes.decode(obj, 'latin1')\n        this.codepoints = obj.source\n        this.type = \"bytes\"\n    }else if($B.$isinstance(obj, _b_.memoryview)){\n        this.string = _b_.bytes.decode(obj.obj, 'latin1')\n        this.codepoints = obj.obj.source\n        this.type = \"bytes\"\n    }else if(obj.__class__ && obj.__class__.$buffer_protocol){\n        // eg array.array\n        this.codepoints = _b_.list.$factory(obj)\n        this.string = from_codepoint_list(this.codepoints, \"bytes\")\n        this.type = \"bytes\"\n    }else if(Array.isArray(obj)){\n        // list of codepoints\n        this.codepoints = obj\n    }else{\n        throw _b_.TypeError.$factory(\n            `expected string or bytes-like object, got '${$B.class_name(obj)}'`)\n    }\n    if(this.length === undefined){\n        this.length = this.codepoints.length\n    }\n}\n\nStringObj.prototype.cp_at = function(pos){\n    if(pos >= this.length){\n        return undefined\n    }\n    /*\n    if(typeof this.string == 'string'){\n        return this.string.charCodeAt(pos)\n    }\n    */\n    var res = this.codepoints[pos]\n    if(res !== undefined){\n        return res\n    }\n}\n\nStringObj.prototype.substring = function(start, end){\n    // Returns a string\n    var s\n    if(this.string && this.index_map){\n        if(this.index_map[start] === undefined){\n            return ''\n        }\n        if(end === undefined){\n            return this.string.substr(this.index_map[start])\n        }\n        return this.string.substring(this.index_map[start],\n            this.index_map[end])\n    }\n    var codepoints,\n        res = ''\n    if(end === undefined){\n        codepoints = this.codepoints.slice(start)\n    }else{\n        codepoints = this.codepoints.slice(start, end)\n    }\n    return from_codepoint_list(codepoints, this.type)\n}\n\nStringObj.prototype.to_str = function(){\n    if(this.hasOwnProperty('string')){\n        return this.string\n    }\n    return from_codepoint_list(this.codepoints, this.type)\n}\n\nStringObj.from_codepoints = function(cps){\n    var res = new StringObj('')\n    res.codepoints = cps\n    for(var cp of cps){\n        res.string += _b_.chr(cp)\n    }\n    return res\n}\n\nfunction prepare(args){\n    // Check that all arguments are of the same type (string or bytes-like).\n    // Return an object with all attributes transformed into StringObj\n    // instances\n    var res = {},\n        keys = Object.keys(args),\n        first = keys[0]\n    res[first] = new StringObj(args[first])\n    res.type = res[first].type\n    for(var key of keys.slice(1)){\n        res[key] = new StringObj(args[key])\n        if(res[key].type != res.type){\n            throw _b_.TypeError.$factory(`not the same type for ${first} and ${key}`)\n        }\n    }\n    return res\n}\n\n\nfunction subn(pattern, repl, string, count, flags){\n    // string is a StringObj instance\n    // pattern is either a Pattern instance or a StringObj instance\n    var res = '',\n        pos = 0,\n        nb_sub = 0\n\n    if(pattern instanceof StringObj){\n        pattern = compile(pattern, flags)\n    }\n    if(typeof repl != \"function\"){\n        var data1 = transform_repl({repl}, pattern)\n        repl1 = data1.repl1\n    }\n    pos = 0\n    var s = string.to_str()\n    for(var bmo of module.finditer(Pattern.$factory(pattern), s).js_gen){\n        // finditer yields instances of MatchObject\n        var mo = bmo.mo // instance of MO\n        res += from_codepoint_list(string.codepoints.slice(pos, mo.start))\n        if(typeof repl == \"function\"){\n            var x = $B.$call(repl)(bmo)\n            if(x.__class__ === _b_.bytes){\n                x = _b_.bytes.decode(x, 'latin-1')\n            }\n            res += x // $B.$call(repl)(bmo)\n        }else{\n            res += repl1\n        }\n        nb_sub++\n        pos = mo.end\n        if(count != 0 && nb_sub >= count){\n            break\n        }\n    }\n    if(string.is_string){\n        res += string.string.substr(pos)\n    }else{\n        res += from_codepoint_list(string.codepoints.slice(pos))\n    }\n    if(pattern.type === \"bytes\"){\n        res = _b_.str.encode(res, \"latin-1\")\n    }\n    return [res, nb_sub]\n}\n\n// escaped chars : '\\t\\n\\x0b\\x0c\\r #$&()*+-.?[\\\\]^{|}~'\nvar escaped = [9, 10, 11, 12, 13, 32, 35, 36, 38, 40, 41, 42, 43, 45, 46, 63,\n               91, 92, 93, 94, 123, 124, 125, 126]\n\nfunction starts_with_string_start(pattern){\n    // returns true if the pattern starts with ^ or \\A\n    if(pattern.node){\n        pattern = pattern.node\n    }\n    if(pattern.items){\n        if(pattern.items.length == 0){\n            return false\n        }\n        return starts_with_string_start(pattern.items[0])\n    }else if(pattern instanceof CharacterClass){\n        return pattern.value == 'A'\n    }else if(pattern instanceof StringStart){\n        return true\n    }else{\n        return false\n    }\n}\n\nfunction* iterator(pattern, string, flags, original_string, pos, endpos){\n    var result = [],\n        pos = pos | 0,\n        cp,\n        accept_one = true // used to test one position after string end\n    while((cp = string.cp_at(pos)) !== undefined || accept_one){\n        var mo = match(pattern, string, pos, endpos)\n        if(mo){\n            yield MatchObject.$factory(mo)\n            if(mo.end == mo.start){\n                // If match has zero with, retry at the same position but\n                // with the flag no_zero_width set, to avoid infinite loops\n                mo = match(pattern, string, pos, endpos, true)\n                if(mo){\n                    yield MatchObject.$factory(mo)\n                    pos = mo.end\n                }else{\n                    pos++ // at least 1, else infinite loop\n                }\n            }else{\n                pos = mo.end\n            }\n        }else{\n            pos++\n        }\n        if(cp === undefined){\n            accept_one = false\n        }\n        if (starts_with_string_start(pattern) && !(flags.value & MULTILINE.value)) {\n            break\n        }\n    }\n    delete original_string.in_iteration\n}\n\n\nfunction MO(node, pos, mo, len){\n    // Match Object\n    this.node = node\n    this.start = pos\n    this.mo = mo\n    this.nb_min = mo.nb_min\n    this.nb_max = mo.nb_max\n    this.len = len\n    this.nb = this.node.non_greedy ? mo.nb_min : mo.nb_max\n    this.end = pos + len * this.nb\n}\n\nMO.prototype.backtrack = function(string, groups){\n    if(this.node.possessive){\n        return false\n    }\n    if(this.node.non_greedy && this.nb < this.nb_max){\n        this.nb++\n        this.end = this.start + this.len * this.nb\n        return true\n    }else if((! this.node.non_greedy) && this.nb > this.nb_min){\n        this.nb--\n        this.end = this.start + this.len * this.nb\n        return true\n    }else{\n        return false\n    }\n}\n\nfunction del_groups(groups, node){\n    if(node.num !== undefined){\n        delete groups[node.num]\n        groups.$last.splice(groups.$last.indexOf(node.num), 1)\n        if(node.name !== undefined){\n            delete groups[node.name]\n        }\n    }\n    for(var child of node.items){\n        if(child instanceof Group){\n            del_groups(groups, child)\n        }\n    }\n}\n\nfunction GroupMO(node, start, matches, string, groups, endpos){\n    // Match Object for Groups\n    this.node = node\n    this.start = start\n    this._matches = matches\n    this.matches = this.node.non_greedy ? matches.slice(0, this.node.repeat.min) : matches.slice()\n    this.string = string\n    this.end = this.matches.length > 0 ? $last(matches).end : start\n    this.endpos = endpos === undefined\n        ? matches.length > 0\n            ? $last(matches).end\n            : start\n        : endpos\n    this.$groups = groups\n}\n\nGroupMO.prototype.backtrack = function(string, groups){\n    if(_debug.value){\n        console.log('group MO backtrack, this', this)\n        alert()\n    }\n    // Try backtracking in the last match\n    if(this.node.possessive || this.node.atomic){\n        return false\n    }\n    if(this.matches.length > 0){\n        var _match = $last(this.matches),\n            mos = _match.mos,\n            nb0 = mos.length\n        while(mos.length > 0){\n            var mo = mos.pop()\n            if(mo.node instanceof Case){\n                var rank = mo.node.parent.items.indexOf(mo.node)\n                for(var _case of mo.node.parent.items.slice(rank + 1)){\n                    var _mo = match({node: _case, text: _case.text},\n                        string, mo.start)\n                    if(_mo){\n                        // update GroupMO object\n                        mos.push(_mo)\n                        this.end = _mo.end\n                        if(this.$groups.$last.length > 0){\n                            var ix = this.$groups.$last[this.$groups.$last.length - 1]\n                            this.$groups[ix].end = _mo.end\n                        }\n                        return true\n                    }\n                }\n            }\n            if(mo.backtrack(string, groups)){\n                mos.push(mo)\n                if(this.node.num !== undefined){\n                    groups[this.node.num].end = mo.end\n                }\n                this.end = mo.end\n                return true\n            }\n        }\n    }\n    // Else, remove last match if possible\n    if(this.node.non_greedy){\n        if(this.matches.length < this._matches.length){\n            this.matches.push(this._matches[this.matches.length])\n            this.end = $last(this.matches).end\n            return true\n        }else{\n            // remove this group and its children from groups\n            del_groups(groups, this.node)\n            this.end = this.start\n        }\n    }else{\n        if(this.matches.length > this.node.repeat.min &&\n                this.matches.length >= 1){\n            this.matches.pop()\n            if(this.matches.length > 0){\n                this.end = $last(this.matches).end\n            }else{\n                // remove this group and its children from groups\n                del_groups(groups, this.node)\n                this.end = this.start\n            }\n            return true\n        }\n    }\n    // Group fails; if some of its subgroups succeded, remove them from\n    // groups\n    if(this.node.repeat.min > 0){\n        del_groups(groups, this.node)\n    }\n    return false\n}\n\nGroupMO.prototype.toString = function(){\n    var repr = _b_.repr(this.string.substring(this.start, this.end))\n    repr = repr.substring(0, 50)\n    return '<re.Match object; span=(' + this.start + ', ' + this.end +\n        '), match=' + repr + '>'\n}\n\nGroupMO.prototype.groups = function(_default){\n    var res = [],\n        groupobj = this.$groups\n\n    for(var key in this.node.$groups){\n        if(isFinite(key)){\n            res[key] = groupobj[key] === undefined ? _default :\n                this.string.substring(groupobj[key].start, groupobj[key].end)\n        }\n    }\n    res.shift()\n    return $B.fast_tuple(res)\n}\n\n// Brython MatchObject\nvar MatchObject = $B.make_class(\"Match\",\n    function(mo){\n        return {\n            __class__: MatchObject,\n            mo\n        }\n    }\n)\n\nMatchObject.__copy__ = function(self){\n    return self\n}\n\nMatchObject.__deepcopy__ = function(self){\n    return self\n}\n\nMatchObject.__getitem__ = function(){\n    var $ = $B.args(\"__getitem__\", 2, {self: null, key: null},\n                ['self', 'key'], arguments, {}, null, null),\n        self = $.self,\n        key = $.key\n    if(Array.isArray(key)){\n        throw _b_.IndexError.$factory(\"no such group\")\n    }\n    if(key == 0){\n        return self.mo.string.substring(self.mo.start, self.mo.end)\n    }\n    var match = self.mo.$groups[key]\n    if(match !== undefined){\n        return self.mo.string.substring(match.start, match.end)\n    }else if(self.mo.node.$groups[key] !== undefined){\n        return _b_.None\n    }\n    throw _b_.IndexError.$factory(\"no such group\")\n}\n\nMatchObject.__repr__ = MatchObject.__str__ =  function(self){\n    return self.mo.toString()\n}\n\nMatchObject.end = function(self){\n    var $ = $B.args('end', 2, {self: null, group: null}, ['self', 'group'],\n                arguments, {group: 0}, null, null)\n    var group = MatchObject.group(self, $.group)\n    if(group === _b_.None){\n        return -1\n    }else if($.group == 0){\n        return self.mo.end\n    }else{\n        return self.mo.$groups[$.group].end\n    }\n}\n\nMatchObject.endpos = _b_.property.$factory(\n    function(self){\n        return self.mo.endpos\n    }\n)\n\nMatchObject.expand = function(){\n    var $ = $B.args(\"expand\", 2, {self: null, template: null},\n                ['self', 'template'], arguments, {}, null, null)\n    var data = {\n        repl: new StringObj($.template),\n    }\n    data = transform_repl(data, {groups: $.self.mo.node.$groups})\n    if(typeof data.repl == \"function\"){\n        return $B.$call(data.repl)(MatchObject.$factory($.self.mo))\n    }else{\n        return data.repl1\n    }\n}\n\nMatchObject.group = function(self){\n    var $ = $B.args(\"group\", 1, {self: null}, ['self'], arguments,\n                {}, 'args', null),\n            self = $.self,\n            args = $.args\n    if(args.length == 0){\n        args[0] = 0\n    }\n    var groupobj = self.mo.$groups,\n        result = []\n    for(var group_id of args){\n        if($B.rich_comp('__eq__', group_id, 0)){\n            result.push(self.mo.string.substring(self.mo.start, self.mo.end))\n            continue\n        }\n        try{\n            // Convert group_id to int if possible\n            group_id = $B.PyNumber_Index(group_id) // in py_utils.js\n        }catch(err){\n            // group_id can be an identifier\n        }\n        if(self.mo.node.$groups[group_id] === undefined){\n            throw _b_.IndexError.$factory(\"no such group\")\n        }\n        var group = groupobj[group_id] // found in match\n        result.push(group === undefined ?\n            _b_.None :\n            self.mo.string.substring(group.start, group.end))\n    }\n    if(args.length == 1){\n        return result[0]\n    }\n    return $B.fast_tuple(result)\n}\n\nMatchObject.groupdict = function(){\n    /*\n    Return a dictionary containing all the named subgroups of the match, keyed\n    by the subgroup name. The default argument is used for groups that did not\n    participate in the match; it defaults to None.\n    */\n    var $ = $B.args(\"groupdict\", 2, {self: null, default: null},\n                ['self', 'default'], arguments, {default: _b_.None},\n                null, null),\n        self = $.self,\n        groupobj = $.self.mo.$groups,\n        d = $B.empty_dict()\n    for(var key in $.self.mo.node.$groups){\n        if(! isFinite(key)){\n            var value = groupobj[key] === undefined ? $.default :\n                    groupobj[key]\n            if(value !== $.default){\n                value = self.mo.string.substring(value.start, value.end)\n            }\n            _b_.dict.$setitem(d, key, value)\n        }\n    }\n    return d\n}\n\nMatchObject.groups = function(self){\n    var $ = $B.args(\"group\", 2, {self: null, default: null},\n                ['self', 'default'], arguments,\n                {default: _b_.None}, null, null),\n            self = $.self,\n            _default = $.default\n    return self.mo.groups(_default)\n}\n\nMatchObject.lastindex = _b_.property.$factory(\n   function(self){\n        /* The integer index of the last matched capturing group, or None if\n           no group was matched at all.\n        */\n        var last = self.mo.$groups.$last\n        if(last.length == 0){\n            return _b_.None\n        }\n        return parseInt($last(last))\n    }\n)\n\nMatchObject.lastgroup = _b_.property.$factory(\n    function(self){\n        /* The name of the last matched capturing group, or None if the group\n           didn't have a name, or if no group was matched at all.\n        */\n        var lastindex = MatchObject.lastindex.fget(self)\n        if(lastindex === _b_.None){\n            return _b_.None\n        }\n        var group = self.mo.node.$groups[lastindex],\n            name = group.item.name\n        return name === undefined ? _b_.None : name\n    }\n)\n\nMatchObject.pos = _b_.property.$factory(\n    function(self){\n        return self.mo.start\n    }\n)\n\nMatchObject.re = _b_.property.$factory(\n    function(self){\n        return self.mo.node.pattern\n    }\n)\n\nMatchObject.regs = _b_.property.$factory(\n    function(self){\n        var res = [$B.fast_tuple($B.fast_tuple([self.mo.start, self.mo.end]))]\n        for(var group_num in self.mo.node.$groups){\n            if(isFinite(group_num)){\n                var group = self.mo.node.$groups[group_num].item\n                // group.pattern includes the opening and closing brackets\n                res.push($B.fast_tuple([group.pos,\n                    group.pos + group.pattern.length - 2]))\n            }\n        }\n        return $B.fast_tuple(res)\n    }\n)\n\nMatchObject.span = function(){\n    /*\n    Match.span([group])\n\n    For a match m, return the 2-tuple (m.start(group), m.end(group)). Note\n    that if group did not contribute to the match, this is (-1, -1). group\n    defaults to zero, the entire match.\n    */\n    var $ = $B.args(\"span\", 2, {self: null, group: null},\n                ['self', 'group'], arguments,\n                {group: 0}, null, null),\n            self = $.self,\n            group = $.group\n    if(group == 0){\n        return $B.fast_tuple([self.mo.start, self.mo.end])\n    }\n    var span = self.mo.$groups[group]\n    if(span === undefined){\n        return $B.fast_tuple([-1, -1])\n    }\n    return $B.fast_tuple([span.start, span.end])\n}\n\nMatchObject.start = function(self){\n    var $ = $B.args('end', 2, {self: null, group: null}, ['self', 'group'],\n                arguments, {group: 0}, null, null)\n    var group = MatchObject.group(self, $.group)\n    if(group === _b_.None){\n        return -1\n    }else if($.group == 0){\n        return self.mo.start\n    }else{\n        return self.mo.$groups[$.group].start\n    }\n}\n\nMatchObject.string = _b_.property.$factory(\n    function(self){\n        return self.mo.string.to_str()\n    }\n)\n\n$B.set_func_names(MatchObject, 're')\n\nfunction log(){\n    if(_debug.value){\n        console.log.apply(null, arguments)\n    }\n}\n\nfunction create_fullmatch_pattern(pattern){\n    // transform <pattern> into \"(?:<pattern>)$\"\n    // use a new pattern object, otherwise if pattern is in cache the\n    // value in cache would be changed\n    var new_pattern = {}\n    for(var key in pattern){\n        if(key == 'node'){\n            continue\n        }\n        new_pattern[key] = pattern[key]\n    }\n\n    var ncgroup = new Group() // non-capturing group\n    ncgroup.pos = 0\n    ncgroup.non_capturing = true\n    for(var item of pattern.node.items){\n        ncgroup.add(item)\n    }\n    var se = new StringEnd()\n    se.flags = Flag.$factory(32)\n    new_pattern.node = new Node()\n    new_pattern.node.add(ncgroup)\n    new_pattern.node.add(se)\n    return new_pattern\n}\n\nfunction match(pattern, string, pos, endpos, no_zero_width, groups){\n    // Follow the pattern tree structure\n    if(_debug.value){\n        console.log('match pattern', pattern.text, 'pos', pos, string.substring(pos))\n        if(pattern.text == \"\\\\.\"){\n            console.log('  ', pattern)\n        }\n        alert()\n    }\n    if(endpos !== undefined){\n        if(endpos < pos){\n            return false\n        }\n    }else{\n        endpos = string.length\n    }\n    if(pattern.node instanceof Node){\n        show(pattern.node)\n    }\n    if(groups === undefined){\n        groups = {$last:[]}\n    }\n    if(pattern.text === undefined){\n        console.log('no text', pattern)\n    }\n    var node = pattern.node,\n        mo\n    if(node.items){\n        // node is either a Choice between several items, or a sequence of\n        // items\n        if(node instanceof Choice){\n            mo = false\n            for(var _case of node.items){\n                mo = match({node: _case, text: _case.text}, string, pos,\n                    endpos, no_zero_width, groups)\n                if(mo){\n                    // remove groups inside choice and before successful case\n                    // that did not contribute to the match\n                    var groups_succeed = groups_in(_case),\n                        min_num = Math.min(Array.from(groups_succeed))\n                    for(var group_num of groups_in(node)){\n                        if(group_num < min_num){\n                            delete groups[group_num]\n                        }\n                    }\n                    if(_debug.value){\n                        console.log('case', _case + '', 'of choice', node +\n                            ' succeeds, groups', groups)\n                    }\n                    return mo\n                }else{\n                    if(_debug.value){\n                        console.log('case', _case + '', 'of choice', node +\n                            ' fails')\n                    }\n                }\n            }\n            return false\n        }else{\n            // sequence of items\n            node.repeat = node.repeat === undefined ? {min: 1, max: 1} :\n                node.repeat\n            var start = pos,\n                nb_repeat = 0,\n                nb_zerolength_repeat = 0,\n                matches = [],\n                mos,\n                match_start,\n                empty_matches = {}\n            // loop until we get enough repetitions\n            while(true){\n                if(empty_matches[pos]){\n                    // no use trying again\n                    return matches.length == 0 ? false :\n                       new GroupMO(node, start, matches, string, groups,\n                           endpos)\n                }\n                var initial_groups = Object.keys(groups)\n                mos = []\n                match_start = pos\n                if(_debug.value){\n                    console.log(\"pattern\", pattern.text,\n                        \"loop in group match, match start\", match_start)\n                }\n                var i = 0\n                while(i < node.items.length){\n                    var item = node.items[i]\n                    if(_debug.value){\n                        console.log('item', i, '/', node.items.length - 1,\n                            'of pattern', pattern.text)\n                    }\n                    var mo = match({node: item, text: item + ''}, string, pos,\n                        endpos, no_zero_width, groups)\n                    if(mo){\n                        if(item instanceof Group &&\n                                item.type == \"lookahead_assertion\"){\n                            log(\"lookahead assertion\", item + '',\n                                \"succeeds, mo\", mo)\n                        }else{\n                            mos.push(mo)\n                            pos = mo.end\n                        }\n                        i++\n                    }else{\n                        if(_debug.value){\n                            console.log('item ' + item, 'of group fails, nb_repeat',\n                                nb_repeat, 'node repeat', node.repeat)\n                        }\n                        var backtrack = false\n                        while(mos.length > 0){\n                            var mo = mos.pop()\n                            if(mo.backtrack === undefined){\n                                log('no backtrack for', mo)\n                            }\n                            if(_debug.value){\n                                console.log('try backtrack on mo', mo)\n                            }\n                            if(mo.backtrack(string, groups)){\n                                log('can backtrack, mo', mo)\n                                mos.push(mo)\n                                i = mos.length\n                                log('mos', mos, 'restart at item', i)\n                                pos = mo.end\n                                backtrack = true\n                                break\n                            }\n                        }\n                        if(backtrack){\n                            log('backtrack ok')\n                            continue\n                        }else{\n                            if(node.type == \"negative_lookahead_assertion\"){\n                                // If a negative lookahead assertion fails,\n                                // return a match\n                                var res = new GroupMO(node, start, matches,\n                                    string, groups, endpos)\n                                return res\n                            }\n                            if(nb_repeat == 0){\n                                // remove the groups introduced before\n                                // reaching this point\n                                for(var key in groups){\n                                    if(initial_groups.indexOf(key) == -1){\n                                        delete groups[key]\n                                    }\n                                }\n                            }\n                            if(nb_repeat >= node.repeat.min){\n                                log(\"enough repetitions for node\", node)\n                                if(node.type == \"negative_lookahead_assertion\"){\n                                    return false\n                                }\n                                return new GroupMO(node, start, matches, string,\n                                    groups, endpos)\n                            }\n                            return false\n                        }\n                    }\n                }\n                if(node.type == \"negative_lookahead_assertion\"){\n                    // If a negative lookahead succeeds, return false\n                    return false\n                }\n                nb_repeat++\n                if(pos > match_start){\n                    nb_zerolength_repeat = 0\n                }else{\n                    nb_zerolength_repeat++\n                    empty_matches[pos] = true\n                }\n                matches.push({start: match_start, end: pos, mos})\n                if(node.num !== undefined){\n                    groups[node.num] = $last(matches)\n                    if(node.name !== undefined){\n                        groups[node.name] = groups[node.num]\n                    }\n                    if(node.num != $last(groups.$last)){\n                        var ix = groups.$last.indexOf(node.num)\n                        if(ix > -1){\n                            groups.$last.splice(ix, 1)\n                        }\n                        groups.$last.push(node.num)\n                    }\n                }\n                if(nb_repeat >= node.repeat.max){\n                    var res = new GroupMO(node, start, matches, string,\n                        groups, endpos)\n                    if(res.start == res.end && no_zero_width){\n                        // no_zero_width is set when previous match in\n                        // iterator() had length 0; avoids infinite loops\n                        return false\n                    }\n                    return res\n                }\n                log('loop on group', pattern.text, 'nb repeats', nb_repeat,\n                    'nb zero length', nb_zerolength_repeat, 'groups', groups)\n                if(nb_zerolength_repeat == 65535){\n                    return matches.length == 0 ? false :\n                       new GroupMO(node, start, matches, string, groups,\n                           endpos)\n                }\n            }\n        }\n    }else{\n        // for BackReference, Char, CharSeq, CharacterClass, CharacterSet,\n        // ConditionalBackref, Lookbehind, StringStart, StringEnd\n        var mo = node.match(string, pos, endpos, groups)\n        if(_debug.value){\n            console.log(node + '', \"mo\", mo)\n        }\n        if(mo){\n            var len = mo.group_len === undefined ? 1 : mo.group_len,\n                ix = node.non_greedy ? mo.nb_min : mo.nb_max,\n                end = pos + len * ix\n            return new MO(node, pos, mo, len)\n        }else{\n            return false\n        }\n    }\n}\n\n// expose re module API\nvar module = {\n    cache: cache,\n    compile: function(){\n        var $ = $B.args(\"compile\", 2, {pattern: null, flags: null},\n                    ['pattern', 'flags'], arguments, {flags: no_flag},\n                    null, null)\n        if($.pattern && $.pattern.__class__ === Pattern){\n            if($.flags !== no_flag){\n                throw _b_.ValueError.$factory(\n                    \"cannot process flags argument with a compiled pattern\")\n            }\n            return $.pattern\n        }\n        $.pattern = check_pattern_flags($.pattern, $.flags)\n        var data = prepare({pattern: $.pattern})\n        if(typeof $.flags == \"number\"){\n            $.flags = Flag.$factory($.flags)\n        }\n        var jspat = compile(data.pattern, $.flags)\n        return Pattern.$factory(jspat)\n    },\n    error: error,\n    escape: function(){\n        var $ = $B.args(\"escape\", 1, {pattern: null}, ['pattern'], arguments,\n                    {}, null, null),\n            data = prepare({pattern: $.pattern}),\n            pattern = data.pattern,\n            res = []\n        for(var cp of pattern.codepoints){\n            if(escaped.indexOf(cp) > -1){\n                res.push(BACKSLASH)\n            }\n            res.push(cp)\n        }\n        res = from_codepoint_list(res, data.type)\n        if(data.type == \"bytes\" && $B.$isinstance(res, _b_.str)){\n            res = _b_.str.encode(res, 'latin1')\n        }\n        return res\n    },\n    findall: function(){\n        /* Return all non-overlapping matches of pattern in string, as a list\n           of strings. The string is scanned left-to-right, and matches are\n           returned in the order found. If one or more groups are present in\n           the pattern, return a list of groups; this will be a list of tuples\n           if the pattern has more than one group. Empty matches are included\n           in the result.\n        */\n        var $ = $B.args(\"findall\", 3,\n                    {pattern: null, string: null, flags: null},\n                    ['pattern', 'string', 'flags'], arguments,\n                    {flags: no_flag}, null, null),\n                pattern = $.pattern,\n                string = $.string,\n                flags = $.flags,\n                data\n        pattern = check_pattern_flags(pattern, flags)\n        if(pattern.__class__ === Pattern){\n            data = prepare({string})\n        }else{\n            data = prepare({string, pattern})\n            pattern = Pattern.$factory(compile(data.pattern, flags))\n        }\n        if(data.type === \"str\"){\n            function conv(s){\n                return s === EmptyString ? '' : s\n            }\n        }else{\n            function conv(s){\n                return string2bytes(s)\n            }\n        }\n\n        var iter = module.finditer.apply(null, arguments).js_gen,\n            res = []\n        while(true){\n            var next = iter.next()\n            if(next.done){\n                return $B.$list(res)\n            }\n            var bmo = next.value,\n                mo = bmo.mo,\n                groups = MatchObject.groups(bmo)\n\n            // replace None by the empty string\n            for(var i = 0, len = groups.length; i < len; i++){\n                groups[i] = groups[i] === _b_.None ? \"\" : groups[i]\n            }\n            if(groups.length > 0){\n                if(groups.length == 1){\n                    res.push(groups[0])\n                }else{\n                    res.push($B.fast_tuple(groups))\n                }\n            }else{\n                res.push(mo.string.substring(mo.start, mo.end))\n            }\n        }\n        console.log(\"end findall\")\n    },\n    finditer: function(){\n        var $ = $B.args(\"finditer\", 3,\n                    {pattern: null, string: null, flags: null},\n                    ['pattern', 'string', 'flags'], arguments,\n                    {flags: no_flag}, null, null),\n                pattern = $.pattern,\n                string = $.string,\n                flags = $.flags\n        if($B.$isinstance(string, [_b_.bytearray, _b_.memoryview])){\n            string.in_iteration = true\n        }\n        var original_string = string,\n            data\n        pattern = check_pattern_flags(pattern, flags)\n        if(pattern.__class__ === Pattern){\n            data = prepare({string})\n            flags = pattern.flags\n        }else{\n            data = prepare({string, pattern})\n            pattern = Pattern.$factory(compile(data.pattern, flags))\n        }\n        if(pattern.__class__ !== Pattern){\n            throw Error(\"pattern not a Python object\")\n        }\n        return $B.generator.$factory(iterator)(pattern.$pattern, data.string,\n            flags, original_string)\n    },\n    fullmatch: function(){\n        var $ = $B.args(\"fullmatch\", 3, {pattern: null, string: null, flags: null},\n                    ['pattern', 'string', 'flags'], arguments,\n                    {flags: no_flag}, null, null),\n                pattern = $.pattern,\n                string = $.string,\n                flags = $.flags\n        pattern = check_pattern_flags(pattern, flags)\n        var data\n        if(pattern.__class__ === Pattern){\n            data = prepare({string})\n            pattern = pattern.$pattern\n        }else{\n            data = prepare({pattern, string})\n            pattern = compile(data.pattern, flags)\n        }\n\n        var new_pattern = create_fullmatch_pattern(pattern)\n\n        // match transformed RE\n        var res = match(new_pattern, data.string, 0)\n        var bmo = res === false ? _b_.None : MatchObject.$factory(res)\n        if(bmo !== _b_.None){\n            if(bmo.mo.string.codepoints.length != bmo.mo.end - bmo.mo.start){\n                return _b_.None\n            }else{\n                return bmo\n            }\n        }\n        return _b_.None\n    },\n    Match: MatchObject,\n    match: function(){\n        var $ = $B.args(\"match\", 3, {pattern: null, string: null, flags: null},\n                    ['pattern', 'string', 'flags'], arguments,\n                    {flags: no_flag}, null, null),\n                pattern = $.pattern,\n                string = $.string,\n                flags = $.flags\n        pattern = check_pattern_flags(pattern, flags)\n        var data\n        if(pattern.__class__ === Pattern){\n            data = prepare({string})\n            pattern = pattern.$pattern\n        }else{\n            data = prepare({pattern, string})\n            pattern = compile(data.pattern, flags)\n        }\n        var res = match(pattern, data.string, 0)\n        return res === false ? _b_.None : MatchObject.$factory(res)\n    },\n    Pattern,\n    purge: function(){\n        var $ = $B.args(\"purge\", 0, {}, [], arguments, {}, null, null)\n        cache.clear()\n        return _b_.None\n    },\n    _reconstructor,\n    Scanner,\n    search: function(){\n        var $ = $B.args(\"search\", 3, {pattern: null, string: null, flags: null},\n                    ['pattern', 'string', 'flags'], arguments,\n                    {flags: no_flag}, null, null),\n                pattern = $.pattern,\n                string = $.string,\n                flags = $.flags,\n                data\n        pattern = check_pattern_flags(pattern, flags)\n        if(pattern.__class__ === Pattern){\n            data = prepare({string})\n        }else{\n            data = prepare({string, pattern})\n            pattern = Pattern.$factory(compile(data.pattern, flags))\n        }\n        data.pattern = pattern\n        // optimizations\n        if(pattern.pattern.startsWith('\\\\A') ||\n                pattern.pattern.startsWith('^')){\n            if(! (pattern.$pattern.node.items[0] instanceof Choice)){\n                var mo = match(data.pattern.$pattern, data.string, 0)\n                if(mo){\n                    return MatchObject.$factory(mo)\n                }else if(pattern.flags.value & MULTILINE.value){\n                    var pos = 0,\n                        cp\n                    while((cp = data.string.cp_at(pos)) !== undefined){\n                        if(cp == LINEFEED){\n                            mo = match(data.pattern.$pattern, data.string, pos + 1)\n                            if(mo){\n                                return MatchObject.$factory(mo)\n                            }\n                        }\n                        pos++\n                    }\n                }else{\n                    return _b_.None\n                }\n            }\n        }\n        if(pattern.$pattern.fixed_length !== false &&\n                isFinite(pattern.$pattern.fixed_length) &&\n                pattern.pattern.endsWith('$') &&\n                ! (pattern.flags.value & MULTILINE.value)){\n            var mo = match(data.pattern.$pattern, data.string,\n                data.string.length - pattern.$pattern.fixed_length)\n            if(mo){\n                return MatchObject.$factory(mo)\n            }\n            return _b_.None\n        }\n        var pos = 0\n        if(data.string.codepoints.length == 0){\n            mo = match(data.pattern.$pattern, data.string, 0)\n            if(mo){\n                mo.start = mo.end = 0\n            }\n            return mo ? MatchObject.$factory(mo) : _b_.None\n        }\n        while(pos < data.string.codepoints.length){\n            var mo = match(data.pattern.$pattern, data.string, pos)\n            if(mo){\n                return MatchObject.$factory(mo)\n            }else{\n                pos++\n            }\n        }\n        return _b_.None\n    },\n    set_debug: function(value){\n        _debug.value = value\n    },\n    split: function(){\n        var $ = $B.args(\"split\", 4,\n                    {pattern: null, string: null, maxsplit: null, flags: null},\n                    ['pattern', 'string', 'maxsplit', 'flags'],\n                    arguments, {maxsplit: 0, flags: no_flag}, null, null)\n        var res = [],\n            pattern = $.pattern,\n            string = $.string,\n            flags = $.flags,\n            pos = 0,\n            nb_split = 0,\n            data\n        if(pattern.__class__ !== Pattern){\n            data = prepare({pattern, string})\n            var comp = compile(data.pattern, flags)\n            pattern = Pattern.$factory(comp)\n        }else{\n            data = {pattern, string}\n        }\n        for(var bmo of module.finditer(pattern, $.string).js_gen){\n            var mo = bmo.mo, // finditer returns instances of MatchObject\n                groupobj = mo.$groups\n            res.push(data.string.substring(pos, mo.start))\n            for(var key in mo.node.$groups){\n                if(isFinite(key)){\n                    if(groupobj[key] !== undefined){\n                        res.push(data.string.substring(groupobj[key].start,\n                            groupobj[key].end))\n                    }else{\n                        res.push(_b_.None)\n                    }\n                }\n            }\n            nb_split++\n            pos = mo.end\n            if(pos >= $.string.length){\n                break\n            }\n            if($.maxsplit != 0 && nb_split >= $.maxsplit){\n                break\n            }\n        }\n        res.push(data.string.substring(pos))\n        if(data.type === \"bytes\"){\n            res = res.map(\n                function(x){\n                    return $B.$isinstance(x, _b_.bytes) ?\n                               x :\n                               _b_.str.encode(x, \"latin-1\")\n                }\n            )\n        }\n        return $B.$list(res)\n    },\n    sub: function(){\n        var $ = $B.args(\"sub\", 5,\n                {pattern: null, repl: null, string: null, count: null, flags: null},\n                ['pattern', 'repl', 'string', 'count', 'flags'],\n                arguments, {count: 0, flags: no_flag}, null, null),\n            pattern = $.pattern,\n            repl = $.repl,\n            string = $.string,\n            count = $.count,\n            flags = $.flags,\n            data\n        check_pattern_flags(pattern, flags)\n        if(typeof repl != \"function\"){\n            if(pattern.__class__ != Pattern){\n                data = prepare({pattern, string, repl})\n                pattern = compile(data.pattern, flags)\n            }else{\n                data = prepare({string, repl})\n                flags = pattern.flags\n                pattern = pattern.$pattern\n            }\n            data = transform_repl(data, pattern)\n        }else{\n            if(pattern.__class__ != Pattern){\n                data = prepare({pattern, string})\n                pattern = compile(data.pattern, flags)\n            }else{\n                data = prepare({string})\n                flags = pattern.flags\n                pattern = pattern.$pattern\n            }\n            data.repl = repl\n        }\n        return subn(pattern, data.repl, data.string, count, flags)[0]\n    },\n    subn: function(){\n        var $ = $B.args(\"sub\", 5,\n                {pattern: null, repl: null, string: null, count: null, flags: null},\n                ['pattern', 'repl', 'string', 'count', 'flags'],\n                arguments, {count: 0, flags: no_flag}, null, null),\n            pattern = $.pattern,\n            repl = $.repl,\n            string = $.string,\n            count = $.count,\n            flags = $.flags,\n            data\n        if(pattern.__class__ != Pattern){\n            data = prepare({pattern, repl, string})\n        }else{\n            data = prepare({repl, string})\n            data.pattern = pattern.$pattern\n        }\n        return $B.fast_tuple(subn(data.pattern, data.repl, data.string, count,\n            flags))\n    }\n\n}\n\nvar ASCII = module.A = module.ASCII = Flag.$factory(256)\nvar IGNORECASE = module.I = module.IGNORECASE = Flag.$factory(2)\nvar LOCALE = module.L = module.LOCALE = Flag.$factory(4)\nvar MULTILINE = module.M = module.MULTILINE = Flag.$factory(8)\nvar DOTALL = module.S = module.DOTALL = Flag.$factory(16)\nvar U = module.U = module.UNICODE = Flag.$factory(32)\nvar VERBOSE = module.X = module.VERBOSE = Flag.$factory(64)\nmodule.cache = cache\nmodule._compile = module.compile\n\n$B.set_func_names(module, 're')\n\nvar inline_flags = {\n    i: IGNORECASE,\n    L: LOCALE,\n    m: MULTILINE,\n    s: DOTALL,\n    u: U,\n    x: VERBOSE,\n    a: ASCII\n}\n\nvar flag_names = {\n    i: 'IGNORECASE',\n    L: 'LOCALE',\n    m: 'MULTILINE',\n    s: 'DOTALL',\n    u: 'U',\n    x: 'VERBOSE',\n    a: 'ASCII'\n}\n\n$B.addToImported('python_re', module)\n\n})(__BRYTHON__)"], "unicodedata": [".js", "// Implementation of unicodedata\n(function($B){\n\n    var _b_ = $B.builtins\n\n    // Load unicode table if not already loaded\n    if($B.unicodedb === undefined){\n        var xhr = new XMLHttpRequest\n        xhr.open(\"GET\",\n            $B.brython_path + \"unicode.txt\", false)\n        xhr.onreadystatechange = function(){\n            if(this.readyState == 4){\n                if(this.status == 200){\n                    $B.unicodedb = this.responseText\n                }else{\n                    console.log(\"Warning - could not \" +\n                        \"load unicode.txt\")\n                }\n            }\n        }\n        xhr.send()\n    }\n\n    function _info(chr){\n        var ord = _b_.ord(chr),\n            hex = ord.toString(16).toUpperCase()\n        while(hex.length < 4){hex = \"0\" + hex}\n        var re = new RegExp(\"^\" + hex +\";(.+?);(.*?);(.*?);(.*?);(.*?);(.*);(.*);(.*)$\",\n                \"m\"),\n            search = re.exec($B.unicodedb)\n        if(search === null){\n            return null\n        }else{\n            return {\n                name: search[1],\n                category: search[2],\n                combining: search[3],\n                bidirectional: search[4],\n                decomposition: search[5],\n                decimal: search[6],\n                digit: search[7],\n                numeric: search[8]\n            }\n        }\n    }\n\n    function bidirectional(chr){\n        var search = _info(chr)\n        if(search === null){\n            console.log(\"error\", chr, hex)\n            throw _b_.KeyError.$factory(chr)\n        }\n        return search.bidirectional\n    }\n\n    function category(chr){\n        // Returns the general category assigned to the character chr as\n        // string.\n        if(/\\p{Cn}/u.test(chr.charAt(0))){\n            return \"Cn\"\n        }\n        var search = _info(chr)\n        if(search === null){\n            console.log(\"error\", chr)\n            throw _b_.KeyError.$factory(chr)\n        }\n        return search.category\n    }\n\n    function combining(chr){\n        // Returns the general category assigned to the character chr as\n        // string.\n        var search = _info(chr)\n        if(search === null){\n            console.log(\"error\", chr)\n            throw _b_.KeyError.$factory(chr)\n        }\n        return parseInt(search.combining)\n    }\n\n    function decimal(chr, _default){\n        // Returns the decimal value assigned to the character chr as integer.\n        // If no such value is defined, default is returned, or, if not given,\n        // ValueError is raised.\n        var search = _info(chr)\n        if(search === null){\n            console.log(\"error\", chr)\n            throw _b_.KeyError.$factory(chr)\n        }\n        return parseInt(search.decimal)\n    }\n\n    function decomposition(chr, _default){\n        // Returns the decimal value assigned to the character chr as integer.\n        // If no such value is defined, default is returned, or, if not given,\n        // ValueError is raised.\n        var search = _info(chr)\n        if(search === null){\n            console.log(\"error\", chr)\n            throw _b_.KeyError.$factory(chr)\n        }\n        return search.decomposition\n    }\n\n    function digit(chr, _default){\n        // Returns the decimal value assigned to the character chr as integer.\n        // If no such value is defined, default is returned, or, if not given,\n        // ValueError is raised.\n        var search = _info(chr)\n        if(search === null){\n            console.log(\"error\", chr)\n            throw _b_.KeyError.$factory(chr)\n        }\n        return parseInt(search.digit)\n    }\n\n    function lookup(name){\n        // Look up character by name. If a character with the given name is\n        // found, return the corresponding character. If not found, KeyError\n        // is raised.\n        var re = new RegExp(\"^([0-9A-F]+);\" +\n            name + \";(.*)$\", \"m\")\n        search = re.exec($B.unicodedb)\n        if(search === null){\n            throw _b_.KeyError.$factory(\"undefined character name '\" +\n                name + \"'\")\n        }\n        var res = parseInt(search[1], 16)\n        return _b_.chr(res)\n    }\n\n    function name(chr, _default){\n        // Returns the name assigned to the character chr as a string. If no\n        // name is defined, default is returned, or, if not given, ValueError\n        // is raised.\n        var search = _info(chr)\n        if(search === null){\n            if(_default){return _default}\n            throw _b_.KeyError.$factory(\"undefined character name '\" +\n                chr + \"'\")\n        }\n        return search.name\n    }\n\n    function normalize(form, unistr){\n        if(! [\"NFC\", \"NFD\", \"NFKC\", \"NFKD\"].includes(form)){\n            throw _b_.ValueError.$factory('invalid normalization form')\n        }\n        return unistr.normalize(form)\n    }\n\n    function numeric(chr, _default){\n        // Returns the decimal value assigned to the character chr as integer.\n        // If no such value is defined, default is returned, or, if not given,\n        // ValueError is raised.\n        var search = _info(chr)\n        if(search === null){\n            if(_default){return _default}\n            throw _b_.KeyError.$factory(chr)\n        }\n        var parts = search.numeric.split('/'),\n            value\n        if(parts.length == 1){\n            value = parseFloat(search.numeric)\n        }else{\n            value = parseInt(parts[0]) / parseInt(parts[1])\n        }\n        return $B.fast_float(value)\n    }\n\n    var module = {\n        bidirectional: bidirectional,\n        category: category,\n        combining: combining,\n        decimal: decimal,\n        decomposition: decomposition,\n        digit: digit,\n        lookup: lookup,\n        name: name,\n        normalize: normalize,\n        numeric: numeric,\n        unidata_version: \"11.0.0\"\n    }\n    module.ucd_3_2_0 = {}\n    for(var key in module){\n        if(key == \"unidata_version\"){\n            module.ucd_3_2_0[key] = '3.2.0'\n        }else{\n            module.ucd_3_2_0[key] = module[key] // approximation...\n        }\n    }\n    $B.addToImported('unicodedata', module)\n\n})(__BRYTHON__)"], "xml_helpers": [".js", "var _b_ = $B.builtins\n\nvar FAIL = {FAIL: true}\nvar DONE = {DONE: true}\nvar END = {END: true}\n\nfunction is_id_start(char){\n  return char !== END && char.match(/[a-zA-Z_]/)\n}\n\nfunction is_id_continue(char){\n  return char !== END && (\".-:_\".includes(char) || char.match(/[a-zA-Z_0-9]/))\n}\n\nfunction is_space(char){\n    return char !== END && ' \\t\\r\\n'.includes(char)\n}\n\nfunction is_num(char){\n    return char !== END && char.match(/\\d/)\n}\n\nfunction is_char(char){\n    return char !== END && ! '<&\"'.includes(char)\n}\n\nfunction get_top(element){\n    while(element.origin){\n        element = element.origin\n    }\n    return element\n}\n\nfunction get_pos(element){\n    return get_top(element)._pos\n}\n\nfunction get_sub(element, start, end){\n    return get_top(element)._buffer.substring(start, end)\n}\n\nfunction show_position(element, pos){\n    var src = get_top(element)._buffer\n    console.log('    ' + src)\n    console.log('    ' + ' '.repeat(pos) + '^')\n}\n\nfunction reset_pos(element, pos){\n    if(pos === undefined){\n        throw Error('reset at undefined')\n    }\n    get_top(element)._pos = pos\n}\n\nfunction update_pos(element, pos){\n    element.pos = pos\n}\n\nfunction show_path(rule){\n    if(rule.constructor === undefined){\n        console.log('rule', rule, 'no constructor')\n        alert()\n    }\n    var name = rule.constructor.name\n    if(name.endsWith('_rule')){\n        name = name.substr(0, name.length - 5)\n    }\n    var t = [name + '@' + rule.pos]\n    while(rule.origin){\n        if(rule.origin.constructor === Object){\n            break\n        }\n        name = rule.origin.constructor.name\n        if(name.endsWith('_rule_')){\n            name = name.substr(0, name.length - 5)\n        }\n        t.push(name + '@' + rule.origin.pos)\n        rule = rule.origin\n    }\n\n    console.log('show path', t)\n}\n\nfunction set_expect(element, expect){\n    var test = false // element.constructor.name == 'Attribute_rule' && expect == 1\n    if(test){\n        console.log('set expect of', element)\n        console.log(`  >>> set expect of ${element.constructor.name} to ${expect}`)\n        alert()\n    }\n    element.expect = expect\n    if(element.rules[expect]){\n        var rule = element.rules[expect]\n        rule.start = get_pos(element)\n    }\n    if(test){\n        console.log('   !!! after set expect', element)\n        alert()\n    }\n}\n\nfunction read_char(element){\n    var parser = get_top(element)\n    return parser._buffer[parser._pos] || END\n}\n\nfunction raise_error_known_position(parser, message){\n    var pos = parser._pos\n    message += ' at position ' + pos\n    var ix = pos\n    while(ix >= 0 && parser._buffer[ix] !== '\\\\n'){\n        ix--\n    }\n    message += '\\\\n' + parser._buffer.substring(ix, pos + 1)\n    message += '\\\\n' + ' '.repeat(pos - ix - 1) + '^'\n    throw Error(message)\n}\n\nfunction raise_error(element, char){\n    var head = element\n    while(head.origin){\n        head = head.origin\n    }\n    console.log('head', head)\n    var cls = element.constructor.name,\n        message = cls + ' expected ' + element.expect +\n            ', got: ' + char\n    raise_error_known_position(head, message)\n}\n\nfunction get_string(rule){\n    if(rule instanceof LITERAL){\n        return rule.string\n    }else if(rule instanceof Letter_rule ||\n            rule instanceof CHARSET_rule){\n        var s = get_sub(rule, rule.pos, rule.pos + 1)\n        return s\n    }\n    if(rule.items === undefined){\n        console.log('no items for rule', rule)\n    }\n    if(rule.constructor.name == 'element_rule'){\n        console.log('get string of', rule)\n        alert()\n    }\n    var s = ''\n    for(var i = 0, len = rule.items.length; i < len; i++){\n        var item = rule.items[i],\n            last = item[item.length - 1]\n        if(rule.result_store[i] === undefined){\n            continue\n        }\n        if('?+*'.includes(last)){\n            s += rule.result_store[i].join('')\n        }else{\n            s += rule.result_store[i]\n        }\n    }\n    return s\n}\n\nfunction get_value(rule){\n    // get string value for rule\n    if(rule === undefined){\n        console.log(Error().stack)\n    }\n    var res = ''\n    if(rule.value){\n        return rule.value\n    }else if(rule.alt && rule.selected_rule){\n        if(false){ //get_parent(rule, tmp_7_rule)){\n            console.log('get_value, selected rule', rule.selected_rule)\n        }\n        return get_value(rule.selected_rule)\n    }else{\n        for(var rank in rule.result_store){\n            var rules = rule.result_store[rank]\n            if(Array.isArray(rules)){\n                res += rules.map(get_value).join('')\n            }else{\n                res += get_value(rules)\n            }\n        }\n    }\n    return res\n}\n\nfunction get_rank(rule){\n    return parseInt(Object.keys(rule.result_store)[0])\n}\n\nfunction get_parent(rule, type){\n    var parent = rule.origin\n    while(parent){\n        if(parent instanceof type){\n            return parent\n        }\n        parent = parent.origin\n    }\n    return null\n}\n\nfunction get_doctype_info(rule){\n    console.log('get doctype info', rule)\n    var systemId = _b_.None,\n        publicId = _b_.None\n    if(get_value(rule.rules[3])){\n        ext_id = external_id(rule.rules[3].rules[1])\n        console.log('ext_id 259', ext_id)\n        systemId = ext_id.systemId\n        publicId = ext_id.publicId\n    }\n    var name = get_value(rule.rules[2])\n    return {name, systemId, publicId}\n}\n\nfunction external_id(ext_id){\n    var ext_id_value = get_value(ext_id),\n        systemId = _b_.None,\n        publicId = _b_.None\n    if(ext_id_value){\n        switch(ext_id.selected_option){\n            case 0:\n                systemId = get_value(ext_id.selected_rule.rules[2])\n                systemId = systemId.substr(1, systemId.length - 2)\n                break\n            case 1:\n                publicId = get_value(ext_id.selected_rule.rules[2])\n                systemId = get_value(ext_id.selected_rule.rules[4])\n                publicId = publicId.substr(1, publicId.length - 2)\n                systemId = systemId.substr(1, systemId.length - 2)\n                break\n        }\n    }\n    return {publicId, systemId}\n}\n\nfunction fromCharRef(v){\n    if(v.startsWith('&#x')){\n        v = String.fromCodePoint(parseInt(v.substr(3)))\n    }else if(v.startsWith('&#')){\n        v = String.fromCodePoint(parseInt(v.substr(2)))\n    }\n    return v\n}\n\nvar handler = {\n    AttDef: function(parser, rule){\n        // S Name S AttType S DefaultDecl\n        var defaultdecl = rule.rules[5],\n            def_value = _b_.None,\n            required = 0\n        switch(defaultdecl.selected_option){\n            case 0:\n                required = true\n                break\n            case 2:\n                def_value = get_value(defaultdecl.rules[2].rules[1])\n                break\n        }\n        var res = {\n            elname: get_value(rule.origin.rules[2]),\n            attname: get_value(rule.rules[1]),\n            type: get_value(rule.rules[3]),\n            default: def_value,\n            required\n        }\n        var f = $B.$getattr(parser, \"AttlistDeclHandler\", null)\n        if(f !== null){\n            $B.$call(f)(res.elname, res.attname, res.type, res.default, res.required)\n        }\n        return res\n    },\n    CData: function(parser, rule){\n        var f = $B.$getattr(parser, \"StartCdataSectionHandler\", null)\n        if(f !== null){\n            $B.$call(f)()\n        }\n        var chardata = get_value(rule)\n        var f = $B.$getattr(parser, \"CharacterDataHandler\", null)\n        if(f !== null){\n            $B.$call(f)(chardata)\n        }\n        var f = $B.$getattr(parser, \"EndCdataSectionHandler\", null)\n        if(f !== null){\n            $B.$call(f)()\n        }\n        return {value: get_value(rule)}\n    },\n    CharData: function(parser, rule){\n        console.log('chardata', rule)\n        var value = get_value(rule)\n        var f = $B.$getattr(parser, \"CharacterDataHandler\", null)\n        if(f !== null){\n            $B.$call(f)(value)\n        }\n        return {value: get_value(rule)}\n    },\n    Comment: function(parser, rule){\n        console.log('comment', rule)\n        var value = get_value(rule.rules[1])\n        var f = $B.$getattr(parser, \"CommentHandler\", null)\n        if(f !== null){\n            $B.$call(f)(value)\n        }\n        return {value}\n    },\n    doctypedecl: function(parser, rule){\n        console.log('doctype', rule, 'ext id', get_value(rule.rules[3]))\n        if(! rule.start_done){\n            // if doctype has no intSubset\n            var info = get_doctype_info(rule)\n            var f = $B.$getattr(parser, \"StartDoctypeDeclHandler\", null)\n            if(f !== null){\n                $B.$call(f)(info.name, info.systemId, info.publicId, false)\n            }\n        }\n        if(rule.hasExternal && parser.standalone == 0){\n            var f = $B.$getattr(parser, \"NotStandaloneHandler\", null)\n            if(f !== null){\n                $B.$call(f)()\n            }\n        }\n        var f = $B.$getattr(parser, \"EndDoctypeDeclHandler\", null)\n        if(f !== null){\n            $B.$call(f)()\n        }\n\n    },\n    elementdecl: function(parser, rule){\n        console.log('element decl', rule)\n        var name = get_value(rule.rules[2]),\n            model = get_value(rule.rules[4])\n        switch(model){\n            case 'ANY':\n                model = $B.fast_tuple([models.XML_CTYPE_ANY, 0, _b_.None, $B.fast_tuple([])])\n                break\n        }\n        var f = $B.$getattr(parser, \"ElementDeclHandler\", null)\n        if(f !== null){\n            $B.$call(f)(name, model)\n        }\n\n        return {name, model}\n    },\n    ETag: function(parser, rule){\n        var name = get_value(rule.rules[1]),\n            is_ns_decl\n        if(parser.namespaces && parser.namespaces.hasOwnProperty(name)){\n            var ns_name = name.split(':')[0]\n            is_ns_decl = true\n            name = parser.namespaces[name]\n        }\n        var f = $B.$getattr(parser, \"EndElementHandler\", null)\n        if(f !== null){\n            $B.$call(f)(name)\n        }\n        if(is_ns_decl){\n            var f = $B.$getattr(parser, \"EndNamespaceDeclHandler\", null)\n            if(f !== null){\n                $B.$call(f)(ns_name)\n            }\n        }\n        return {name: get_value(rule.rules[1])}\n    },\n    ExternalID: function(parser, rule){\n        var doctype = get_parent(rule, doctypedecl_rule)\n        doctype.hasExternal = true\n    },\n    GEDecl: function(parser, rule){\n        // '<!ENTITY' S Name S EntityDef S? '>'\n        var entitydef = rule.rules[4],\n            value = _b_.None,\n            base = _b_.None,\n            systemId = _b_.None,\n            publicId = _b_.None,\n            notationName = _b_.None\n        // EntityValue | (ExternalID NDataDecl?)\n        switch(entitydef.selected_option){\n            case 0:\n                // EntityValue    ::=  '\"' ([^%&\"] | PEReference | Reference)* '\"'\n                //  |  \"'\" ([^%&'] | PEReference | Reference)* \"'\"\n                var entity_value = entitydef.selected_rule.selected_rule\n                console.log('entity value', entity_value)\n                var value = ''\n                for(var item of entity_value.result_store[1]){\n                    var v = get_value(entity_value.result_store[1][0])\n                    value += fromCharRef(v)\n                }\n                console.log('value', v)\n                break\n            case 1:\n                var ext_id = external_id(entitydef.selected_rule.rules[0])\n                systemId = ext_id.systemId\n                publicId = ext_id.publicId\n                if(entitydef.selected_rule.result_store[1]){\n                    // NDataDecl ::=  S 'NDATA' S Name\n                    notationName = get_value(entitydef.selected_rule.rules[1].rules[3])\n                }\n        }\n        // EntityDeclHandler(entityName, is_parameter_entity, value, base, systemId, publicId, notationName)\n        var res = {\n            name: get_value(rule.rules[2]),\n            is_parameter_entity: 0,\n            value,\n            systemId,\n            publicId,\n            notationName\n        }\n        var unparsed_handled\n        if(res.name == \"unparsed_entity\"){\n            var f = $B.$getattr(parser, \"UnparsedEntityDeclHandler\", null)\n            if(f !== null){\n                unparsed_handled = true\n                $B.$call(f)(res.name, base,\n                            res.systemId, res.publicId, res.notationName)\n            }\n        }\n        if(! unparsed_handled){\n            var f = $B.$getattr(parser, \"EntityDeclHandler\", null)\n            if(f !== null){\n                $B.$call(f)(res.name, res.is_parameter_entity, res.value, base,\n                            res.systemId, res.publicId, res.notationName)\n            }\n        }\n        return res\n    },\n    start_intSubset: function(parser, rule){\n        // Found when starting an internal subset inside a doctype declaration\n        // Used to call StartDoctypeHandler with has_internal_subset set\n        var doctype_decl = get_parent(rule, doctypedecl_rule),\n            info = get_doctype_info(doctype_decl)\n        if(doctype_decl.hasExternal && ! parser.standalone){\n            var f = $B.$getattr(parser, \"NotStandaloneHandler\", null)\n            if(f !== null){\n                $B.$call(f)()\n            }\n        }\n        doctype_decl.start_done = true\n        delete doctype_decl.sentNotStandalone\n        var f = $B.$getattr(parser, \"StartDoctypeDeclHandler\", null)\n        if(f !== null){\n            $B.$call(f)(info.name, info.systemId, info.publicId, true)\n        }\n\n    },\n    NotationDecl: function(parser, rule){\n        // '<!NOTATION' S Name S (ExternalID | PublicID) S? '>'\n        var base = _b_.None,\n            systemId = _b_.None,\n            publicId = _b_.None,\n            ext_or_public = rule.rules[4]\n\n        switch(ext_or_public.selected_option){\n            case 0:\n                var ext_id = external_id(ext_or_public.selected_rule)\n                systemId = ext_id.systemId\n                publicId = ext_id.publicId\n                break\n            case 1:\n                publicId = get_value(ext_or_public.selected_rule.rules[2])\n                break\n        }\n        var res = {\n            name: get_value(rule.rules[2]),\n            base,\n            systemId,\n            publicId\n        }\n        var f = $B.$getattr(parser, \"NotationDeclHandler\", null)\n        if(f !== null){\n            $B.$call(f)(res.name, res.base, res.systemId, res.publicId)\n        }\n\n        return res\n    },\n    PI: function(parser, rule){\n        console.log('PI', rule)\n        var name = get_value(rule.rules[1].rules[0]),\n            attrs = get_value(rule.rules[2]).trimLeft()\n        var f = $B.$getattr(parser, \"ProcessingInstructionHandler\", null)\n        if(f !== null){\n            $B.$call(f)(name, attrs)\n        }\n        return {name, attrs}\n    },\n    STag: function(parser, rule){\n        var name = get_value(rule.rules[1])\n        var attrs = rule.result_store[2],\n            attr_result = $B.empty_dict()\n        if(attrs){\n            for(var attr of attrs){\n                var attr_value_store = attr.result_store[1].result_store[2].selected_rule.result_store[1],\n                    attr_value = ''\n                for(var item of attr_value_store){\n                    var v = get_value(item)\n                    attr_value += fromCharRef(v)\n                }\n                var attr_name = get_value(attr.result_store[1].result_store[0])\n                if(attr_name.startsWith('xmlns:')){\n                    var prefix = attr_name.substr(6),\n                        uri = attr_value\n                    var name1 = uri + '!' + name.split(':')[1]\n                    parser.namespaces = parser.namespaces ?? {}\n                    parser.namespaces[name] = name1\n                    name = name1\n                    var f = $B.$getattr(parser, \"StartNamespaceDeclHandler\", null)\n                    if(f !== null){\n                        $B.$call(f)(prefix, uri)\n                    }\n                }else{\n                    _b_.dict.$setitem(attr_result, attr_name, attr_value)\n                }\n            }\n        }\n        var f = $B.$getattr(parser, \"StartElementHandler\", null)\n        if(f !== null){\n            $B.$call(f)(name, attr_result)\n        }\n        return {name, attr_result}\n    },\n    XMLDecl: function(parser, rule){\n        // '<?xml' VersionInfo EncodingDecl? SDDecl? S? '?>'\n        var encoding,\n            standalone = -1\n        if(rule.result_store[2]){\n            // S 'encoding' Eq ('\"' EncName '\"' | \"'\" EncName \"'\" )\n            encoding = get_value(rule.rules[2].rules[3].selected_rule.rules[1])\n        }\n        if(rule.result_store[3]){\n            // S 'standalone' Eq ((\"'\" ('yes' | 'no') \"'\") | ('\"' ('yes' | 'no') '\"'))\n            sddecl = rule.rules[3]\n            standalone = get_value(sddecl.rules[3].selected_rule.rules[1])\n            standalone = standalone == 'yes' ? 1 : 0\n        }\n        parser.standalone = standalone // used for NotStandaloneHandler\n        var attr_result = $B.empty_dict(),\n            attrs = {\n                version: get_value(rule.rules[1].rules[3].selected_rule.rules[1]),\n                encoding,\n                standalone\n            }\n        for(var attr in attrs){\n            _b_.dict.$setitem(attr_result, attr, attrs[attr])\n        }\n        var f = $B.$getattr(parser, \"XmlDeclHandler\", null)\n        if(f !== null){\n            $B.$call(f)(attrs.version, attrs.encoding, attrs.standalone)\n        }\n        return {name, attr_result}\n    }\n}\n\n\nfunction emit(rule){\n    // called when a rule is done\n    var rname = rule.constructor.name\n    rname = rname.substr(0, rname.length - 5)\n    if(handler[rname]){\n        var parser = get_top(rule)\n        // console.log('emit', rname)\n        handler[rname](parser, rule)\n    }\n}\n\nfunction handle_simple(element, next_if_ok, rule, char){\n    if(char === FAIL){\n        if(typeof element.origin.feed !== 'function'){\n            console.log('not a func', element)\n        }\n        return element.origin.feed(FAIL)\n    }else if(char === DONE){\n        element.result_store[element.expect] = rule // get_sub(rule, rule.pos, get_pos(rule)) // get_string(rule)\n        var test = (rule.constructor.name == 'element_rule' ||\n                rule.constructor.name == 'Attribute_rule')\n        rule.reset()\n        emit(rule)\n        set_expect(element, next_if_ok)\n        return element.feed(read_char(element))\n    }else if(char === END){\n        set_expect(element, next_if_ok)\n        return element\n    }else{\n        return rule.feed(char)\n    }\n}\n\nfunction handle_plus(element, rank, next_if_ok, rule, char){\n    if(char === FAIL){\n        if(element.repeats[rank] == 0){\n            reset_pos(element, rule.pos)\n            return element.origin.feed(FAIL)\n        }\n        set_expect(element, next_if_ok)\n        reset_pos(element, rule.pos)\n        rule.reset()\n        return element.feed(read_char(element))\n    }else if(char === DONE){\n        element.result_store[rank] = element.result_store[rank] || []\n        element.result_store[rank].push(rule)\n        element.repeats[rank] += 1\n        update_pos(element, get_pos(element))\n        //rule.reset()\n        emit(rule)\n        set_expect(element, next_if_ok)\n        delete element.rules[rank]\n        return element.feed(read_char(element))\n    }else if(char === END){\n        set_expect(element, next_if_ok)\n        return element.feed(char)\n    }else{\n        return rule.feed(char)\n    }\n}\n\nfunction handle_star(element, rank, next_if_ok, rule, char){\n    var test = false // rule instanceof tmp_6_rule\n    if(test){\n        console.log('HANDLE STAR', rule, 'char', char)\n    }\n    if(char === FAIL){\n        set_expect(element, next_if_ok)\n        reset_pos(element, rule.pos)\n        rule.reset()\n        return element.feed(read_char(element))\n    }else if(char === DONE){\n        if(test){\n            console.log(rule, 'DONE')\n        }\n        if(rule.alt){\n            element.selected_option = element.expect\n            element.selected_rule = rule\n        }\n        element.result_store[rank] = element.result_store[rank] || []\n        element.result_store[rank].push(rule)\n        element.repeats[rank] += 1\n        update_pos(element, get_pos(element))\n        //rule.reset()\n        emit(rule)\n        delete element.rules[rank]\n        return element.feed(read_char(element))\n    }else if(char === END){\n        set_expect(element, next_if_ok)\n        return element.feed(char)\n    }else{\n        return rule.feed(char)\n    }\n}\n\nfunction handle_zero_or_one(element, rank, next_if_ok, rule, char){\n    if(char === FAIL){\n        set_expect(element, next_if_ok)\n        reset_pos(element, rule.pos)\n        rule.reset()\n        return element.feed(read_char(element))\n    }else if(char === DONE){\n        element.result_store[rank] = element.result_store[rank] || []\n        element.result_store[rank].push(rule)\n        element.repeats[rank] += 1\n        update_pos(element, get_pos(element))\n        emit(rule)\n        rule.reset()\n        set_expect(element, next_if_ok)\n        return element.feed(read_char(element))\n    }else if(char === END){\n        set_expect(element, next_if_ok)\n        return element.feed(char)\n    }else{\n        return rule.feed(char)\n    }\n}\n\nfunction handle_alt(element, alt_index, rule, char){\n    if(char === FAIL){\n        set_expect(element, alt_index)\n        reset_pos(element, element.pos)\n        return element.origin.feed(read_char(element))\n    }else if(char === DONE){\n        if(['AttValue_rule'].includes(rule.constructor.name)){\n            console.log('DONE', rule.constructor.name, get_sub(rule, rule.pos, get_pos(rule)))\n            console.log('  ', rule)\n            alert()\n        }\n        element.selected_option = element.expect\n        element.selected_rule = rule\n        element.result_store[element.expect] = rule\n        emit(rule)\n        rule.reset()\n        return element.origin.feed(char)\n    }else if(char === END){\n        set_expect(element, -1)\n        return element\n    }else{\n        return rule.feed(char)\n    }\n}\n\nfunction handle_last(element, rule, char){\n    var test = false // element instanceof tmp_6_rule\n    if(test){\n        console.log('handle_last', rule, char)\n        alert()\n    }\n    if(char === FAIL){\n        return element.origin.feed(FAIL)\n    }else if(char === DONE){\n        element.result_store[element.expect] = rule\n        if(element.alt){\n            element.selected_option = element.expect\n            element.selected_rule = rule\n            if(test){\n                console.log('set selected', element)\n                console.log('value', get_value(rule))\n                element.coucou = 'ici'\n                alert()\n            }\n        }\n        emit(rule)\n        rule.reset()\n        set_expect(element, -1)\n        if(test){\n            console.log('return control to element', element)\n            alert()\n        }\n        return element.feed(char)\n    }else if(char === END){\n        set_expect(element, -1)\n        return element\n    }else{\n        return rule.feed(char)\n    }\n}\n\nfunction expect_literal(element, literal, char){\n    if(! element.hasOwnProperty('expected_pos')){\n        element.expected_pos = 0\n    }\n    if(literal[element.expected_pos] == char){\n        element.expected_pos++\n        if(element.expected_pos == literal.length){\n            delete element.expected_pos\n            return {value: literal}\n        }else{\n            return {value: null}\n        }\n    }\n    return FAIL\n}\n\nfunction LITERAL(origin, string, next_if_ok, args){\n    this.origin = origin\n    this.string = string\n    this.next_if_ok = next_if_ok\n    this.args = args\n    this.pos = get_pos(this)\n    this.str_pos = 0\n}\n\nLITERAL.prototype.reset = function(){\n    this.str_pos = 0\n}\n\nLITERAL.prototype.feed = function(char){\n    //console.log('LITERAL', this.string, 'expects', this.string[this.str_pos], 'char', char)\n    if(this.string == '<!DOCTYPE>'){\n        console.log('LITERAL feed', this.string, char, this.str_pos)\n    }\n    if(this.str_pos == this.string.length){\n        this.value = this.string\n        return this.origin.feed(DONE)\n    }\n    if(char == this.string[this.str_pos]){\n        this.str_pos++\n        return this\n    }else{\n        return this.origin.feed(FAIL)\n    }\n}\n\nfunction NAME_rule(origin, next_if_ok){\n  this.origin = origin\n  this.rank = this.origin.expect\n  this.next_if_ok = next_if_ok\n  this.value = ''\n  this.pos = get_pos(this)\n}\n\nNAME_rule.prototype.reset = function(){\n    this.value = ''\n}\n\nNAME_rule.prototype.feed = function(char){\n    console.log('NAME_rule, value', this.value, 'char', char)\n  if(this.value == ''){\n    if(is_id_start(char)){\n      this.value = char\n    }else{\n      return this.origin.feed(FAIL)\n    }\n  }else if(is_id_continue(char)){\n    this.value += char\n  }else{\n    return this.origin.feed(DONE)\n  }\n  return this\n}\n\nfunction NUMBER_rule(origin, next_if_ok, args){\n  this.origin = origin\n  this.rank = this.origin.expect\n  this.next_if_ok = next_if_ok\n  this.args = args\n  this.pos = get_pos(this)\n  this.value = ''\n}\n\nNUMBER_rule.prototype.reset = function(){\n    this.value = ''\n}\n\nNUMBER_rule.prototype.feed = function(char){\n  if(this.value == ''){\n    if(is_num(char)){\n      this.value = char\n    }else if(this.args.next_if_fail !== undefined){\n        this.origin.expect = this.args.next_if_fail\n        return this.origin.feed(char)\n    }else{\n      return FAIL\n    }\n  }else if(is_num(char)){\n    this.value += char\n  }else{\n    this.origin.expect = this.next_if_ok\n    this.origin.store_result(this)\n    return this.origin.feed(char)\n  }\n  return this\n}\n\nfunction start_intSubset_rule(origin){\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.rank = this.origin.expect\n  this.value = ''\n}\n\nstart_intSubset_rule.prototype.feed = function(char){\n    // always succeeds\n    return this.origin.feed(DONE)\n}\n\nstart_intSubset_rule.prototype.reset = function(){\n    // ignore\n}\n\nfunction S_rule(origin){\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.rank = this.origin.expect\n  this.value = ''\n}\n\nS_rule.prototype.reset = function(){\n    this.value = ''\n}\n\nS_rule.prototype.feed = function(char){\n  if(is_space(char)){\n      this.value += char\n      return this\n  }else if(this.value.length > 0){\n      return this.origin.feed(DONE)\n  }else{\n      return this.origin.feed(FAIL)\n  }\n}\n\nfunction CHAR_rule(origin, next_if_ok, args){\n  this.origin = origin\n  this.next_if_ok = next_if_ok\n  this.args = args\n}\n\nCHAR_rule.prototype.feed = function(char){\n    if(is_char(char)){\n        this.value = char\n        return this.origin\n    }else{\n        return FAIL\n    }\n}\n\nvar hex_range_re = /^#x([a-fA-F0-9]+)-#x([a-fA-F0-9]+)$/\nvar charset_range_re = /(\\w)-(\\w)/g\n\n\nfunction CHARSET_rule(origin, charset, next_if_ok){\n    this.origin = origin\n    this.charset = charset\n    this.next_if_ok = next_if_ok\n    this.pos = get_pos(origin)\n    this.value = ''\n    var negative = charset.startsWith('^'),\n        body = negative ? charset.substr(1) : charset\n\n    var mo = body.match(hex_range_re)\n    if(mo){\n        var left = parseInt(`0x${mo[1]}`, 16),\n            right = parseInt(`0x${mo[2]}`, 16)\n        if(negative){\n            this.test = function(char){\n                var cp = char.charCodeAt(0)\n                return (cp < left) || (cp > right)\n            }\n        }else{\n            this.test = function(char){\n                var cp = char.charCodeAt(0)\n                return (cp >= left) && (cp <= right)\n            }\n        }\n        return\n    }\n\n    var ranges = []\n    for(var mo of body.matchAll(charset_range_re)){\n        ranges.push(mo.slice(1))\n    }\n    if(ranges.length > 0){\n        if(negative){\n            this.test = function(char){\n                for(var range of ranges){\n                    if(char >= range[0] && char <= range[1]){\n                        return false\n                    }\n                }\n                return true\n            }\n        }else{\n            this.test = function(char){\n                for(var range of ranges){\n                    if(char >= range[0] && char <= range[1]){\n                        return true\n                    }\n                }\n                return false\n            }\n        }\n        return\n    }\n\n    if(charset.startsWith('^')){\n        this.test = char => ! charset.substr(1).includes(char)\n    }else{\n        this.test = char => charset.includes(char)\n    }\n}\n\nCHARSET_rule.prototype.reset = function(){\n    delete this.done\n}\n\nCHARSET_rule.prototype.feed = function(char){\n    if(char !== END && this.test(char)){\n        this.value += char\n        return this\n    }else if(this.value.length > 0){\n        return this.origin.feed(DONE)\n    }else{\n        return this.origin.feed(FAIL)\n    }\n}\n\nfunction BaseChar_rule(origin){\n    this.origin = origin\n    this.pos = get_pos(origin)\n}\n\nBaseChar_rule.prototype.reset = function(){\n    delete this.done\n}\n\nBaseChar_rule.prototype.feed = function(char){\n    //console.log('BaseChar_rule, char', char, 'this.done', this.done)\n    if(this.done){\n        return this.origin.feed(DONE)\n    }else if(/\\p{L}/u.exec(char)){\n        this.done = true\n        return this\n    }else{\n        return this.origin.feed(FAIL)\n    }\n}\n\nfunction Letter_rule(origin){\n    this.origin = origin\n    this.pos = get_pos(origin)\n}\n\nLetter_rule.prototype.reset = function(){\n    delete this.done\n}\n\nLetter_rule.prototype.feed = function(char){\n    if(this.done){\n        return this.origin.feed(DONE)\n    }else if(/\\p{L}/u.exec(char)){\n        this.done = true\n        this.value = char\n        return this\n    }else{\n        return this.origin.feed(FAIL)\n    }\n}\n\nfunction NameChar_rule(origin){\n    this.origin = origin\n    this.rank = origin.expect\n    this.value = ''\n    var result_store = this.origin.result_store\n    result_store[this.rank] = result_store[this.rank] ?? []\n    this.pos = get_pos(origin)\n}\n\nNameChar_rule.prototype.reset = function(){\n    delete this.done\n}\n\nNameChar_rule.prototype.feed = function(char){\n    if(this.done){\n        return this.origin.feed(DONE)\n    }else if(is_id_continue(char)){\n        this.value += char\n        return this\n    }else{\n        if(this.value == ''){\n            return this.origin.feed(FAIL)\n        }\n        return this.origin.feed(DONE)\n    }\n}\n\nfunction PIText_rule(origin){\n    this.origin = origin\n    this.value = ''\n    this.pos = get_pos(origin)\n}\n\nPIText_rule.prototype.reset = function(){}\n\nPIText_rule.prototype.feed = function(char){\n    if(char === END){\n        return this.origin.feed(FAIL)\n    }\n    this.value += char\n    if(this.value.endsWith('?>')){\n        reset_pos(this, get_pos(this) - 1)\n        this.value = this.value.substr(0, this.value.length - 2)\n        return this.origin.feed(DONE)\n    }\n    return this\n}\n\nfunction CommentText_rule(origin){\n    this.origin = origin\n    this.value = ''\n    this.pos = get_pos(origin)\n}\n\nCommentText_rule.prototype.reset = function(){}\n\nCommentText_rule.prototype.feed = function(char){\n    if(char === END){\n        return this.origin.feed(FAIL)\n    }\n    this.value += char\n    if(this.value.endsWith('-->')){\n        reset_pos(this, get_pos(this) - 2)\n        this.value = this.value.substr(0, this.value.length - 3)\n        if(this.value.endsWith('-')){\n            return this.origin.feed(FAIL)\n        }\n        return this.origin.feed(DONE)\n    }\n    return this\n}\n\nfunction CharData_rule(origin){\n    this.origin = origin\n    this.pos = get_pos(origin)\n    this.value = ''\n}\n\nCharData_rule.prototype.reset = function(){}\n\nCharData_rule.prototype.feed = function(char){\n    // [^<&]* - ([^<&]* ']]>' [^<&]*)\n    if(char === END){\n        return this.origin.feed(FAIL)\n    }\n    if('<&'.includes(char)){\n        return this.origin.feed(DONE)\n    }\n    this.value += char\n    if(this.value.endsWith(']]>')){\n        reset_pos(this, get_pos(this) - 2)\n        this.value = this.value.substr(0, this.value.length - 3)\n        return this.origin.feed(DONE)\n    }\n    return this\n}\n\nfunction CData_rule(origin){\n    this.origin = origin\n    this.pos = get_pos(origin)\n    this.value = ''\n}\n\nCData_rule.prototype.reset = function(){}\n\nCData_rule.prototype.feed = function(char){\n    // (Char* - (Char* ']]>' Char*))\n    if(char === END){\n        return this.origin.feed(FAIL)\n    }\n    this.value += char\n    if(this.value.endsWith(']]>')){\n        reset_pos(this, get_pos(this) - 2)\n        this.value = this.value.substr(0, this.value.length - 3)\n        return this.origin.feed(DONE)\n    }\n    return this\n}\n\nfunction Ignore_rule(origin){\n    this.origin = origin\n    this.pos = get_pos(origin)\n    this.value = ''\n}\n\nIgnore_rule.prototype.reset = function(){}\n\nIgnore_rule.prototype.feed = function(char){\n    // Char* - (Char* ('<![' | ']]>') Char*)\n    if(char === END){\n        return this.origin.feed(FAIL)\n    }\n    this.value += char\n    if(this.value.endsWith('<![') || this.value.endsWith(']]>')){\n        reset_pos(this, get_pos(this) - 2)\n        this.value = this.value.substr(0, this.value.length - 3)\n        return this.origin.feed(DONE)\n    }\n    return this\n}\n\nfunction PITarget_rule(origin){\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // Name\n  this.items = ['Name', 'tmp_21']\n  this.rules = []\n  this.repeats = []\n}\n\nPITarget_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // Name\n      if(! this.rules[0]){\n        this.rules[0] = new Name_rule(this)\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case 1: // tmp_21\n      if(! this.rules[1]){\n        this.rules[1] = new tmp_21_rule(this)\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      var value = get_value(this)\n      if(value.toLowerCase() == 'xml'){\n          return this.origin.feed(FAIL)\n      }\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\nPITarget_rule.prototype.reset = function(){\n  this.expect = 0\n}\n"], "xml_parser": [".js", "(function($B){\nvar _b_ = $B.builtins\n\nvar FAIL = {FAIL: true}\nvar DONE = {DONE: true}\nvar END = {END: true}\n\nfunction is_id_start(char){\n  return char !== END && char.match(/[a-zA-Z_]/)\n}\n\nfunction is_id_continue(char){\n  return char !== END && (\".-:_\".includes(char) || char.match(/[a-zA-Z_0-9]/))\n}\n\nfunction is_space(char){\n    return char !== END && ' \\t\\r\\n'.includes(char)\n}\n\nfunction is_num(char){\n    return char !== END && char.match(/\\d/)\n}\n\nfunction is_char(char){\n    return char !== END && ! '<&\"'.includes(char)\n}\n\nfunction get_top(element){\n    while(element.origin){\n        element = element.origin\n    }\n    return element\n}\n\nfunction get_pos(element){\n    return get_top(element)._pos\n}\n\nfunction get_sub(element, start, end){\n    return get_top(element)._buffer.substring(start, end)\n}\n\nfunction show_position(element, pos){\n    var src = get_top(element)._buffer\n    console.log('    ' + src)\n    console.log('    ' + ' '.repeat(pos) + '^')\n}\n\nfunction reset_pos(element, pos){\n    if(pos === undefined){\n        throw Error('reset at undefined')\n    }\n    get_top(element)._pos = pos\n}\n\nfunction update_pos(element, pos){\n    element.pos = pos\n}\n\nfunction show_path(rule){\n    if(rule.constructor === undefined){\n        console.log('rule', rule, 'no constructor')\n        alert()\n    }\n    var name = rule.constructor.name\n    if(name.endsWith('_rule')){\n        name = name.substr(0, name.length - 5)\n    }\n    var t = [name + '@' + rule.pos]\n    while(rule.origin){\n        if(rule.origin.constructor === Object){\n            break\n        }\n        name = rule.origin.constructor.name\n        if(name.endsWith('_rule_')){\n            name = name.substr(0, name.length - 5)\n        }\n        t.push(name + '@' + rule.origin.pos)\n        rule = rule.origin\n    }\n\n    console.log('show path', t)\n}\n\nfunction set_expect(element, expect){\n    var test = false // element.constructor.name == 'Attribute_rule' && expect == 1\n    if(test){\n        console.log('set expect of', element)\n        console.log(`  >>> set expect of ${element.constructor.name} to ${expect}`)\n        alert()\n    }\n    element.expect = expect\n    if(element.rules[expect]){\n        var rule = element.rules[expect]\n        rule.start = get_pos(element)\n    }\n    if(test){\n        console.log('   !!! after set expect', element)\n        alert()\n    }\n}\n\nfunction read_char(element){\n    var parser = get_top(element)\n    return parser._buffer[parser._pos] || END\n}\n\nfunction raise_error_known_position(parser, message){\n    var pos = parser._pos\n    message += ' at position ' + pos\n    var ix = pos\n    while(ix >= 0 && parser._buffer[ix] !== '\\\\n'){\n        ix--\n    }\n    message += '\\\\n' + parser._buffer.substring(ix, pos + 1)\n    message += '\\\\n' + ' '.repeat(pos - ix - 1) + '^'\n    throw Error(message)\n}\n\nfunction raise_error(element, char){\n    var head = element\n    while(head.origin){\n        head = head.origin\n    }\n    console.log('head', head)\n    var cls = element.constructor.name,\n        message = cls + ' expected ' + element.expect +\n            ', got: ' + char\n    raise_error_known_position(head, message)\n}\n\nfunction get_string(rule){\n    if(rule instanceof LITERAL){\n        return rule.string\n    }else if(rule instanceof Letter_rule ||\n            rule instanceof CHARSET_rule){\n        var s = get_sub(rule, rule.pos, rule.pos + 1)\n        return s\n    }\n    if(rule.items === undefined){\n        console.log('no items for rule', rule)\n    }\n    if(rule.constructor.name == 'element_rule'){\n        console.log('get string of', rule)\n        alert()\n    }\n    var s = ''\n    for(var i = 0, len = rule.items.length; i < len; i++){\n        var item = rule.items[i],\n            last = item[item.length - 1]\n        if(rule.result_store[i] === undefined){\n            continue\n        }\n        if('?+*'.includes(last)){\n            s += rule.result_store[i].join('')\n        }else{\n            s += rule.result_store[i]\n        }\n    }\n    return s\n}\n\nfunction get_value(rule){\n    // get string value for rule\n    if(rule === undefined){\n        console.log(Error().stack)\n    }\n    var res = ''\n    if(rule.value){\n        return rule.value\n    }else if(rule.alt && rule.selected_rule){\n        if(false){ //get_parent(rule, tmp_7_rule)){\n            console.log('get_value, selected rule', rule.selected_rule)\n        }\n        return get_value(rule.selected_rule)\n    }else{\n        for(var rank in rule.result_store){\n            var rules = rule.result_store[rank]\n            if(Array.isArray(rules)){\n                res += rules.map(get_value).join('')\n            }else{\n                res += get_value(rules)\n            }\n        }\n    }\n    return res\n}\n\nfunction get_rank(rule){\n    return parseInt(Object.keys(rule.result_store)[0])\n}\n\nfunction get_parent(rule, type){\n    var parent = rule.origin\n    while(parent){\n        if(parent instanceof type){\n            return parent\n        }\n        parent = parent.origin\n    }\n    return null\n}\n\nfunction get_doctype_info(rule){\n    console.log('get doctype info', rule)\n    var systemId = _b_.None,\n        publicId = _b_.None\n    if(get_value(rule.rules[3])){\n        ext_id = external_id(rule.rules[3].rules[1])\n        console.log('ext_id 259', ext_id)\n        systemId = ext_id.systemId\n        publicId = ext_id.publicId\n    }\n    var name = get_value(rule.rules[2])\n    return {name, systemId, publicId}\n}\n\nfunction external_id(ext_id){\n    var ext_id_value = get_value(ext_id),\n        systemId = _b_.None,\n        publicId = _b_.None\n    if(ext_id_value){\n        switch(ext_id.selected_option){\n            case 0:\n                systemId = get_value(ext_id.selected_rule.rules[2])\n                systemId = systemId.substr(1, systemId.length - 2)\n                break\n            case 1:\n                publicId = get_value(ext_id.selected_rule.rules[2])\n                systemId = get_value(ext_id.selected_rule.rules[4])\n                publicId = publicId.substr(1, publicId.length - 2)\n                systemId = systemId.substr(1, systemId.length - 2)\n                break\n        }\n    }\n    return {publicId, systemId}\n}\n\nfunction fromCharRef(v){\n    if(v.startsWith('&#x')){\n        v = String.fromCodePoint(parseInt(v.substr(3)))\n    }else if(v.startsWith('&#')){\n        v = String.fromCodePoint(parseInt(v.substr(2)))\n    }\n    return v\n}\n\nvar handler = {\n    AttDef: function(parser, rule){\n        // S Name S AttType S DefaultDecl\n        var defaultdecl = rule.rules[5],\n            def_value = _b_.None,\n            required = 0\n        switch(defaultdecl.selected_option){\n            case 0:\n                required = true\n                break\n            case 2:\n                def_value = get_value(defaultdecl.rules[2].rules[1])\n                break\n        }\n        var res = {\n            elname: get_value(rule.origin.rules[2]),\n            attname: get_value(rule.rules[1]),\n            type: get_value(rule.rules[3]),\n            default: def_value,\n            required\n        }\n        var f = $B.$getattr(parser, \"AttlistDeclHandler\", null)\n        if(f !== null){\n            $B.$call(f)(res.elname, res.attname, res.type, res.default, res.required)\n        }\n        return res\n    },\n    CData: function(parser, rule){\n        var f = $B.$getattr(parser, \"StartCdataSectionHandler\", null)\n        if(f !== null){\n            $B.$call(f)()\n        }\n        var chardata = get_value(rule)\n        var f = $B.$getattr(parser, \"CharacterDataHandler\", null)\n        if(f !== null){\n            $B.$call(f)(chardata)\n        }\n        var f = $B.$getattr(parser, \"EndCdataSectionHandler\", null)\n        if(f !== null){\n            $B.$call(f)()\n        }\n        return {value: get_value(rule)}\n    },\n    CharData: function(parser, rule){\n        console.log('chardata', rule)\n        var value = get_value(rule)\n        var f = $B.$getattr(parser, \"CharacterDataHandler\", null)\n        if(f !== null){\n            $B.$call(f)(value)\n        }\n        return {value: get_value(rule)}\n    },\n    Comment: function(parser, rule){\n        console.log('comment', rule)\n        var value = get_value(rule.rules[1])\n        var f = $B.$getattr(parser, \"CommentHandler\", null)\n        if(f !== null){\n            $B.$call(f)(value)\n        }\n        return {value}\n    },\n    doctypedecl: function(parser, rule){\n        console.log('doctype', rule, 'ext id', get_value(rule.rules[3]))\n        if(! rule.start_done){\n            // if doctype has no intSubset\n            var info = get_doctype_info(rule)\n            var f = $B.$getattr(parser, \"StartDoctypeDeclHandler\", null)\n            if(f !== null){\n                $B.$call(f)(info.name, info.systemId, info.publicId, false)\n            }\n        }\n        if(rule.hasExternal && parser.standalone == 0){\n            var f = $B.$getattr(parser, \"NotStandaloneHandler\", null)\n            if(f !== null){\n                $B.$call(f)()\n            }\n        }\n        var f = $B.$getattr(parser, \"EndDoctypeDeclHandler\", null)\n        if(f !== null){\n            $B.$call(f)()\n        }\n\n    },\n    elementdecl: function(parser, rule){\n        console.log('element decl', rule)\n        var name = get_value(rule.rules[2]),\n            model = get_value(rule.rules[4])\n        switch(model){\n            case 'ANY':\n                model = $B.fast_tuple([models.XML_CTYPE_ANY, 0, _b_.None, $B.fast_tuple([])])\n                break\n        }\n        var f = $B.$getattr(parser, \"ElementDeclHandler\", null)\n        if(f !== null){\n            $B.$call(f)(name, model)\n        }\n\n        return {name, model}\n    },\n    ETag: function(parser, rule){\n        var name = get_value(rule.rules[1]),\n            is_ns_decl\n        if(parser.namespaces && parser.namespaces.hasOwnProperty(name)){\n            var ns_name = name.split(':')[0]\n            is_ns_decl = true\n            name = parser.namespaces[name]\n        }\n        var f = $B.$getattr(parser, \"EndElementHandler\", null)\n        if(f !== null){\n            $B.$call(f)(name)\n        }\n        if(is_ns_decl){\n            var f = $B.$getattr(parser, \"EndNamespaceDeclHandler\", null)\n            if(f !== null){\n                $B.$call(f)(ns_name)\n            }\n        }\n        return {name: get_value(rule.rules[1])}\n    },\n    ExternalID: function(parser, rule){\n        var doctype = get_parent(rule, doctypedecl_rule)\n        doctype.hasExternal = true\n    },\n    GEDecl: function(parser, rule){\n        // '<!ENTITY' S Name S EntityDef S? '>'\n        var entitydef = rule.rules[4],\n            value = _b_.None,\n            base = _b_.None,\n            systemId = _b_.None,\n            publicId = _b_.None,\n            notationName = _b_.None\n        // EntityValue | (ExternalID NDataDecl?)\n        switch(entitydef.selected_option){\n            case 0:\n                // EntityValue    ::=  '\"' ([^%&\"] | PEReference | Reference)* '\"'\n                //  |  \"'\" ([^%&'] | PEReference | Reference)* \"'\"\n                var entity_value = entitydef.selected_rule.selected_rule\n                console.log('entity value', entity_value)\n                var value = ''\n                for(var item of entity_value.result_store[1]){\n                    var v = get_value(entity_value.result_store[1][0])\n                    value += fromCharRef(v)\n                }\n                console.log('value', v)\n                break\n            case 1:\n                var ext_id = external_id(entitydef.selected_rule.rules[0])\n                systemId = ext_id.systemId\n                publicId = ext_id.publicId\n                if(entitydef.selected_rule.result_store[1]){\n                    // NDataDecl ::=  S 'NDATA' S Name\n                    notationName = get_value(entitydef.selected_rule.rules[1].rules[3])\n                }\n        }\n        // EntityDeclHandler(entityName, is_parameter_entity, value, base, systemId, publicId, notationName)\n        var res = {\n            name: get_value(rule.rules[2]),\n            is_parameter_entity: 0,\n            value,\n            systemId,\n            publicId,\n            notationName\n        }\n        var unparsed_handled\n        if(res.name == \"unparsed_entity\"){\n            var f = $B.$getattr(parser, \"UnparsedEntityDeclHandler\", null)\n            if(f !== null){\n                unparsed_handled = true\n                $B.$call(f)(res.name, base,\n                            res.systemId, res.publicId, res.notationName)\n            }\n        }\n        if(! unparsed_handled){\n            var f = $B.$getattr(parser, \"EntityDeclHandler\", null)\n            if(f !== null){\n                $B.$call(f)(res.name, res.is_parameter_entity, res.value, base,\n                            res.systemId, res.publicId, res.notationName)\n            }\n        }\n        return res\n    },\n    start_intSubset: function(parser, rule){\n        // Found when starting an internal subset inside a doctype declaration\n        // Used to call StartDoctypeHandler with has_internal_subset set\n        var doctype_decl = get_parent(rule, doctypedecl_rule),\n            info = get_doctype_info(doctype_decl)\n        if(doctype_decl.hasExternal && ! parser.standalone){\n            var f = $B.$getattr(parser, \"NotStandaloneHandler\", null)\n            if(f !== null){\n                $B.$call(f)()\n            }\n        }\n        doctype_decl.start_done = true\n        delete doctype_decl.sentNotStandalone\n        var f = $B.$getattr(parser, \"StartDoctypeDeclHandler\", null)\n        if(f !== null){\n            $B.$call(f)(info.name, info.systemId, info.publicId, true)\n        }\n\n    },\n    NotationDecl: function(parser, rule){\n        // '<!NOTATION' S Name S (ExternalID | PublicID) S? '>'\n        var base = _b_.None,\n            systemId = _b_.None,\n            publicId = _b_.None,\n            ext_or_public = rule.rules[4]\n\n        switch(ext_or_public.selected_option){\n            case 0:\n                var ext_id = external_id(ext_or_public.selected_rule)\n                systemId = ext_id.systemId\n                publicId = ext_id.publicId\n                break\n            case 1:\n                publicId = get_value(ext_or_public.selected_rule.rules[2])\n                break\n        }\n        var res = {\n            name: get_value(rule.rules[2]),\n            base,\n            systemId,\n            publicId\n        }\n        var f = $B.$getattr(parser, \"NotationDeclHandler\", null)\n        if(f !== null){\n            $B.$call(f)(res.name, res.base, res.systemId, res.publicId)\n        }\n\n        return res\n    },\n    PI: function(parser, rule){\n        console.log('PI', rule)\n        var name = get_value(rule.rules[1].rules[0]),\n            attrs = get_value(rule.rules[2]).trimLeft()\n        var f = $B.$getattr(parser, \"ProcessingInstructionHandler\", null)\n        if(f !== null){\n            $B.$call(f)(name, attrs)\n        }\n        return {name, attrs}\n    },\n    STag: function(parser, rule){\n        var name = get_value(rule.rules[1])\n        var attrs = rule.result_store[2],\n            attr_result = $B.empty_dict()\n        if(attrs){\n            for(var attr of attrs){\n                var attr_value_store = attr.result_store[1].result_store[2].selected_rule.result_store[1],\n                    attr_value = ''\n                for(var item of attr_value_store){\n                    var v = get_value(item)\n                    attr_value += fromCharRef(v)\n                }\n                var attr_name = get_value(attr.result_store[1].result_store[0])\n                if(attr_name.startsWith('xmlns:')){\n                    var prefix = attr_name.substr(6),\n                        uri = attr_value\n                    var name1 = uri + '!' + name.split(':')[1]\n                    parser.namespaces = parser.namespaces ?? {}\n                    parser.namespaces[name] = name1\n                    name = name1\n                    var f = $B.$getattr(parser, \"StartNamespaceDeclHandler\", null)\n                    if(f !== null){\n                        $B.$call(f)(prefix, uri)\n                    }\n                }else{\n                    _b_.dict.$setitem(attr_result, attr_name, attr_value)\n                }\n            }\n        }\n        var f = $B.$getattr(parser, \"StartElementHandler\", null)\n        if(f !== null){\n            $B.$call(f)(name, attr_result)\n        }\n        return {name, attr_result}\n    },\n    XMLDecl: function(parser, rule){\n        // '<?xml' VersionInfo EncodingDecl? SDDecl? S? '?>'\n        var encoding,\n            standalone = -1\n        if(rule.result_store[2]){\n            // S 'encoding' Eq ('\"' EncName '\"' | \"'\" EncName \"'\" )\n            encoding = get_value(rule.rules[2].rules[3].selected_rule.rules[1])\n        }\n        if(rule.result_store[3]){\n            // S 'standalone' Eq ((\"'\" ('yes' | 'no') \"'\") | ('\"' ('yes' | 'no') '\"'))\n            sddecl = rule.rules[3]\n            standalone = get_value(sddecl.rules[3].selected_rule.rules[1])\n            standalone = standalone == 'yes' ? 1 : 0\n        }\n        parser.standalone = standalone // used for NotStandaloneHandler\n        var attr_result = $B.empty_dict(),\n            attrs = {\n                version: get_value(rule.rules[1].rules[3].selected_rule.rules[1]),\n                encoding,\n                standalone\n            }\n        for(var attr in attrs){\n            _b_.dict.$setitem(attr_result, attr, attrs[attr])\n        }\n        var f = $B.$getattr(parser, \"XmlDeclHandler\", null)\n        if(f !== null){\n            $B.$call(f)(attrs.version, attrs.encoding, attrs.standalone)\n        }\n        return {name, attr_result}\n    }\n}\n\n\nfunction emit(rule){\n    // called when a rule is done\n    var rname = rule.constructor.name\n    rname = rname.substr(0, rname.length - 5)\n    if(handler[rname]){\n        var parser = get_top(rule)\n        // console.log('emit', rname)\n        handler[rname](parser, rule)\n    }\n}\n\nfunction handle_simple(element, next_if_ok, rule, char){\n    if(char === FAIL){\n        if(typeof element.origin.feed !== 'function'){\n            console.log('not a func', element)\n        }\n        return element.origin.feed(FAIL)\n    }else if(char === DONE){\n        element.result_store[element.expect] = rule // get_sub(rule, rule.pos, get_pos(rule)) // get_string(rule)\n        var test = (rule.constructor.name == 'element_rule' ||\n                rule.constructor.name == 'Attribute_rule')\n        rule.reset()\n        emit(rule)\n        set_expect(element, next_if_ok)\n        return element.feed(read_char(element))\n    }else if(char === END){\n        set_expect(element, next_if_ok)\n        return element\n    }else{\n        return rule.feed(char)\n    }\n}\n\nfunction handle_plus(element, rank, next_if_ok, rule, char){\n    if(char === FAIL){\n        if(element.repeats[rank] == 0){\n            reset_pos(element, rule.pos)\n            return element.origin.feed(FAIL)\n        }\n        set_expect(element, next_if_ok)\n        reset_pos(element, rule.pos)\n        rule.reset()\n        return element.feed(read_char(element))\n    }else if(char === DONE){\n        element.result_store[rank] = element.result_store[rank] || []\n        element.result_store[rank].push(rule)\n        element.repeats[rank] += 1\n        update_pos(element, get_pos(element))\n        //rule.reset()\n        emit(rule)\n        set_expect(element, next_if_ok)\n        delete element.rules[rank]\n        return element.feed(read_char(element))\n    }else if(char === END){\n        set_expect(element, next_if_ok)\n        return element.feed(char)\n    }else{\n        return rule.feed(char)\n    }\n}\n\nfunction handle_star(element, rank, next_if_ok, rule, char){\n    var test = false // rule instanceof tmp_6_rule\n    if(test){\n        console.log('HANDLE STAR', rule, 'char', char)\n    }\n    if(char === FAIL){\n        set_expect(element, next_if_ok)\n        reset_pos(element, rule.pos)\n        rule.reset()\n        return element.feed(read_char(element))\n    }else if(char === DONE){\n        if(test){\n            console.log(rule, 'DONE')\n        }\n        if(rule.alt){\n            element.selected_option = element.expect\n            element.selected_rule = rule\n        }\n        element.result_store[rank] = element.result_store[rank] || []\n        element.result_store[rank].push(rule)\n        element.repeats[rank] += 1\n        update_pos(element, get_pos(element))\n        //rule.reset()\n        emit(rule)\n        delete element.rules[rank]\n        return element.feed(read_char(element))\n    }else if(char === END){\n        set_expect(element, next_if_ok)\n        return element.feed(char)\n    }else{\n        return rule.feed(char)\n    }\n}\n\nfunction handle_zero_or_one(element, rank, next_if_ok, rule, char){\n    if(char === FAIL){\n        set_expect(element, next_if_ok)\n        reset_pos(element, rule.pos)\n        rule.reset()\n        return element.feed(read_char(element))\n    }else if(char === DONE){\n        element.result_store[rank] = element.result_store[rank] || []\n        element.result_store[rank].push(rule)\n        element.repeats[rank] += 1\n        update_pos(element, get_pos(element))\n        emit(rule)\n        rule.reset()\n        set_expect(element, next_if_ok)\n        return element.feed(read_char(element))\n    }else if(char === END){\n        set_expect(element, next_if_ok)\n        return element.feed(char)\n    }else{\n        return rule.feed(char)\n    }\n}\n\nfunction handle_alt(element, alt_index, rule, char){\n    if(char === FAIL){\n        set_expect(element, alt_index)\n        reset_pos(element, element.pos)\n        return element.origin.feed(read_char(element))\n    }else if(char === DONE){\n        if(['AttValue_rule'].includes(rule.constructor.name)){\n            console.log('DONE', rule.constructor.name, get_sub(rule, rule.pos, get_pos(rule)))\n            console.log('  ', rule)\n            alert()\n        }\n        element.selected_option = element.expect\n        element.selected_rule = rule\n        element.result_store[element.expect] = rule\n        emit(rule)\n        rule.reset()\n        return element.origin.feed(char)\n    }else if(char === END){\n        set_expect(element, -1)\n        return element\n    }else{\n        return rule.feed(char)\n    }\n}\n\nfunction handle_last(element, rule, char){\n    var test = false // element instanceof tmp_6_rule\n    if(test){\n        console.log('handle_last', rule, char)\n        alert()\n    }\n    if(char === FAIL){\n        return element.origin.feed(FAIL)\n    }else if(char === DONE){\n        element.result_store[element.expect] = rule\n        if(element.alt){\n            element.selected_option = element.expect\n            element.selected_rule = rule\n            if(test){\n                console.log('set selected', element)\n                console.log('value', get_value(rule))\n                element.coucou = 'ici'\n                alert()\n            }\n        }\n        emit(rule)\n        rule.reset()\n        set_expect(element, -1)\n        if(test){\n            console.log('return control to element', element)\n            alert()\n        }\n        return element.feed(char)\n    }else if(char === END){\n        set_expect(element, -1)\n        return element\n    }else{\n        return rule.feed(char)\n    }\n}\n\nfunction expect_literal(element, literal, char){\n    if(! element.hasOwnProperty('expected_pos')){\n        element.expected_pos = 0\n    }\n    if(literal[element.expected_pos] == char){\n        element.expected_pos++\n        if(element.expected_pos == literal.length){\n            delete element.expected_pos\n            return {value: literal}\n        }else{\n            return {value: null}\n        }\n    }\n    return FAIL\n}\n\nfunction LITERAL(origin, string, next_if_ok, args){\n    this.origin = origin\n    this.string = string\n    this.next_if_ok = next_if_ok\n    this.args = args\n    this.pos = get_pos(this)\n    this.str_pos = 0\n}\n\nLITERAL.prototype.reset = function(){\n    this.str_pos = 0\n}\n\nLITERAL.prototype.feed = function(char){\n    //console.log('LITERAL', this.string, 'expects', this.string[this.str_pos], 'char', char)\n    if(this.string == '<!DOCTYPE>'){\n        console.log('LITERAL feed', this.string, char, this.str_pos)\n    }\n    if(this.str_pos == this.string.length){\n        this.value = this.string\n        return this.origin.feed(DONE)\n    }\n    if(char == this.string[this.str_pos]){\n        this.str_pos++\n        return this\n    }else{\n        return this.origin.feed(FAIL)\n    }\n}\n\nfunction NAME_rule(origin, next_if_ok){\n  this.origin = origin\n  this.rank = this.origin.expect\n  this.next_if_ok = next_if_ok\n  this.value = ''\n  this.pos = get_pos(this)\n}\n\nNAME_rule.prototype.reset = function(){\n    this.value = ''\n}\n\nNAME_rule.prototype.feed = function(char){\n    console.log('NAME_rule, value', this.value, 'char', char)\n  if(this.value == ''){\n    if(is_id_start(char)){\n      this.value = char\n    }else{\n      return this.origin.feed(FAIL)\n    }\n  }else if(is_id_continue(char)){\n    this.value += char\n  }else{\n    return this.origin.feed(DONE)\n  }\n  return this\n}\n\nfunction NUMBER_rule(origin, next_if_ok, args){\n  this.origin = origin\n  this.rank = this.origin.expect\n  this.next_if_ok = next_if_ok\n  this.args = args\n  this.pos = get_pos(this)\n  this.value = ''\n}\n\nNUMBER_rule.prototype.reset = function(){\n    this.value = ''\n}\n\nNUMBER_rule.prototype.feed = function(char){\n  if(this.value == ''){\n    if(is_num(char)){\n      this.value = char\n    }else if(this.args.next_if_fail !== undefined){\n        this.origin.expect = this.args.next_if_fail\n        return this.origin.feed(char)\n    }else{\n      return FAIL\n    }\n  }else if(is_num(char)){\n    this.value += char\n  }else{\n    this.origin.expect = this.next_if_ok\n    this.origin.store_result(this)\n    return this.origin.feed(char)\n  }\n  return this\n}\n\nfunction start_intSubset_rule(origin){\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.rank = this.origin.expect\n  this.value = ''\n}\n\nstart_intSubset_rule.prototype.feed = function(char){\n    // always succeeds\n    return this.origin.feed(DONE)\n}\n\nstart_intSubset_rule.prototype.reset = function(){\n    // ignore\n}\n\nfunction S_rule(origin){\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.rank = this.origin.expect\n  this.value = ''\n}\n\nS_rule.prototype.reset = function(){\n    this.value = ''\n}\n\nS_rule.prototype.feed = function(char){\n  if(is_space(char)){\n      this.value += char\n      return this\n  }else if(this.value.length > 0){\n      return this.origin.feed(DONE)\n  }else{\n      return this.origin.feed(FAIL)\n  }\n}\n\nfunction CHAR_rule(origin, next_if_ok, args){\n  this.origin = origin\n  this.next_if_ok = next_if_ok\n  this.args = args\n}\n\nCHAR_rule.prototype.feed = function(char){\n    if(is_char(char)){\n        this.value = char\n        return this.origin\n    }else{\n        return FAIL\n    }\n}\n\nvar hex_range_re = /^#x([a-fA-F0-9]+)-#x([a-fA-F0-9]+)$/\nvar charset_range_re = /(\\w)-(\\w)/g\n\n\nfunction CHARSET_rule(origin, charset, next_if_ok){\n    this.origin = origin\n    this.charset = charset\n    this.next_if_ok = next_if_ok\n    this.pos = get_pos(origin)\n    this.value = ''\n    var negative = charset.startsWith('^'),\n        body = negative ? charset.substr(1) : charset\n\n    var mo = body.match(hex_range_re)\n    if(mo){\n        var left = parseInt(`0x${mo[1]}`, 16),\n            right = parseInt(`0x${mo[2]}`, 16)\n        if(negative){\n            this.test = function(char){\n                var cp = char.charCodeAt(0)\n                return (cp < left) || (cp > right)\n            }\n        }else{\n            this.test = function(char){\n                var cp = char.charCodeAt(0)\n                return (cp >= left) && (cp <= right)\n            }\n        }\n        return\n    }\n\n    var ranges = []\n    for(var mo of body.matchAll(charset_range_re)){\n        ranges.push(mo.slice(1))\n    }\n    if(ranges.length > 0){\n        if(negative){\n            this.test = function(char){\n                for(var range of ranges){\n                    if(char >= range[0] && char <= range[1]){\n                        return false\n                    }\n                }\n                return true\n            }\n        }else{\n            this.test = function(char){\n                for(var range of ranges){\n                    if(char >= range[0] && char <= range[1]){\n                        return true\n                    }\n                }\n                return false\n            }\n        }\n        return\n    }\n\n    if(charset.startsWith('^')){\n        this.test = char => ! charset.substr(1).includes(char)\n    }else{\n        this.test = char => charset.includes(char)\n    }\n}\n\nCHARSET_rule.prototype.reset = function(){\n    delete this.done\n}\n\nCHARSET_rule.prototype.feed = function(char){\n    if(char !== END && this.test(char)){\n        this.value += char\n        return this\n    }else if(this.value.length > 0){\n        return this.origin.feed(DONE)\n    }else{\n        return this.origin.feed(FAIL)\n    }\n}\n\nfunction BaseChar_rule(origin){\n    this.origin = origin\n    this.pos = get_pos(origin)\n}\n\nBaseChar_rule.prototype.reset = function(){\n    delete this.done\n}\n\nBaseChar_rule.prototype.feed = function(char){\n    //console.log('BaseChar_rule, char', char, 'this.done', this.done)\n    if(this.done){\n        return this.origin.feed(DONE)\n    }else if(/\\p{L}/u.exec(char)){\n        this.done = true\n        return this\n    }else{\n        return this.origin.feed(FAIL)\n    }\n}\n\nfunction Letter_rule(origin){\n    this.origin = origin\n    this.pos = get_pos(origin)\n}\n\nLetter_rule.prototype.reset = function(){\n    delete this.done\n}\n\nLetter_rule.prototype.feed = function(char){\n    if(this.done){\n        return this.origin.feed(DONE)\n    }else if(/\\p{L}/u.exec(char)){\n        this.done = true\n        this.value = char\n        return this\n    }else{\n        return this.origin.feed(FAIL)\n    }\n}\n\nfunction NameChar_rule(origin){\n    this.origin = origin\n    this.rank = origin.expect\n    this.value = ''\n    var result_store = this.origin.result_store\n    result_store[this.rank] = result_store[this.rank] ?? []\n    this.pos = get_pos(origin)\n}\n\nNameChar_rule.prototype.reset = function(){\n    delete this.done\n}\n\nNameChar_rule.prototype.feed = function(char){\n    if(this.done){\n        return this.origin.feed(DONE)\n    }else if(is_id_continue(char)){\n        this.value += char\n        return this\n    }else{\n        if(this.value == ''){\n            return this.origin.feed(FAIL)\n        }\n        return this.origin.feed(DONE)\n    }\n}\n\nfunction PIText_rule(origin){\n    this.origin = origin\n    this.value = ''\n    this.pos = get_pos(origin)\n}\n\nPIText_rule.prototype.reset = function(){}\n\nPIText_rule.prototype.feed = function(char){\n    if(char === END){\n        return this.origin.feed(FAIL)\n    }\n    this.value += char\n    if(this.value.endsWith('?>')){\n        reset_pos(this, get_pos(this) - 1)\n        this.value = this.value.substr(0, this.value.length - 2)\n        return this.origin.feed(DONE)\n    }\n    return this\n}\n\nfunction CommentText_rule(origin){\n    this.origin = origin\n    this.value = ''\n    this.pos = get_pos(origin)\n}\n\nCommentText_rule.prototype.reset = function(){}\n\nCommentText_rule.prototype.feed = function(char){\n    if(char === END){\n        return this.origin.feed(FAIL)\n    }\n    this.value += char\n    if(this.value.endsWith('-->')){\n        reset_pos(this, get_pos(this) - 2)\n        this.value = this.value.substr(0, this.value.length - 3)\n        if(this.value.endsWith('-')){\n            return this.origin.feed(FAIL)\n        }\n        return this.origin.feed(DONE)\n    }\n    return this\n}\n\nfunction CharData_rule(origin){\n    this.origin = origin\n    this.pos = get_pos(origin)\n    this.value = ''\n}\n\nCharData_rule.prototype.reset = function(){}\n\nCharData_rule.prototype.feed = function(char){\n    // [^<&]* - ([^<&]* ']]>' [^<&]*)\n    if(char === END){\n        return this.origin.feed(FAIL)\n    }\n    if('<&'.includes(char)){\n        return this.origin.feed(DONE)\n    }\n    this.value += char\n    if(this.value.endsWith(']]>')){\n        reset_pos(this, get_pos(this) - 2)\n        this.value = this.value.substr(0, this.value.length - 3)\n        return this.origin.feed(DONE)\n    }\n    return this\n}\n\nfunction CData_rule(origin){\n    this.origin = origin\n    this.pos = get_pos(origin)\n    this.value = ''\n}\n\nCData_rule.prototype.reset = function(){}\n\nCData_rule.prototype.feed = function(char){\n    // (Char* - (Char* ']]>' Char*))\n    if(char === END){\n        return this.origin.feed(FAIL)\n    }\n    this.value += char\n    if(this.value.endsWith(']]>')){\n        reset_pos(this, get_pos(this) - 2)\n        this.value = this.value.substr(0, this.value.length - 3)\n        return this.origin.feed(DONE)\n    }\n    return this\n}\n\nfunction Ignore_rule(origin){\n    this.origin = origin\n    this.pos = get_pos(origin)\n    this.value = ''\n}\n\nIgnore_rule.prototype.reset = function(){}\n\nIgnore_rule.prototype.feed = function(char){\n    // Char* - (Char* ('<![' | ']]>') Char*)\n    if(char === END){\n        return this.origin.feed(FAIL)\n    }\n    this.value += char\n    if(this.value.endsWith('<![') || this.value.endsWith(']]>')){\n        reset_pos(this, get_pos(this) - 2)\n        this.value = this.value.substr(0, this.value.length - 3)\n        return this.origin.feed(DONE)\n    }\n    return this\n}\n\nfunction PITarget_rule(origin){\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // Name\n  this.items = ['Name', 'tmp_21']\n  this.rules = []\n  this.repeats = []\n}\n\nPITarget_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // Name\n      if(! this.rules[0]){\n        this.rules[0] = new Name_rule(this)\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case 1: // tmp_21\n      if(! this.rules[1]){\n        this.rules[1] = new tmp_21_rule(this)\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      var value = get_value(this)\n      if(value.toLowerCase() == 'xml'){\n          return this.origin.feed(FAIL)\n      }\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\nPITarget_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nvar rules = {\ndocument: `[prolog, element, Misc*, <class 'xml_grammar_parser.End'>]`,\nChar: `['\\\\t', '\\\\n', '\\\\r', [#x20-#xD7FF], [#xE000-#xFFFD], [#x10000-#x10FFFF]]`,\nS: `[tmp_1+]`,\ntmp_1: `[' ', '\\\\t', '\\\\r', '\\\\n']`,\nName: `[tmp_2, NameChar*]`,\ntmp_2: `[Letter, '_', ':']`,\nNames: `[Name, tmp_3*]`,\ntmp_3: `[' ', Name]`,\nNmtoken: `[NameChar+]`,\nNmtokens: `[Nmtoken, tmp_4*]`,\ntmp_4: `[' ', Nmtoken]`,\nEntityValue: `[tmp_7, tmp_8]`,\ntmp_5: `[[^%&'], PEReference, Reference]`,\ntmp_6: `[[^%&\"], PEReference, Reference]`,\ntmp_7: `['\"', tmp_6*, '\"']`,\ntmp_8: `[\"'\", tmp_5*, \"'\"]`,\nAttValue: `[tmp_11, tmp_12]`,\ntmp_9: `[[^<&'], Reference]`,\ntmp_10: `[[^<&\"], Reference]`,\ntmp_11: `['\"', tmp_10*, '\"']`,\ntmp_12: `[\"'\", tmp_9*, \"'\"]`,\nSystemLiteral: `[tmp_14, tmp_13]`,\ntmp_13: `[\"'\", [^'], \"'\"]`,\ntmp_14: `['\"', [^\"], '\"']`,\nPubidLiteral: `[tmp_15, tmp_16]`,\ntmp_15: `['\"', PubidChar*, '\"']`,\ntmp_16: `[\"'\", PubidCharNoQuote*, \"'\"]`,\nPubidChar: `[' ', '\\\\r', '\\\\n', [a-zA-Z0-9], [-'()+,./:=?;!*#@$_%]]`,\nPubidCharNoQuote: `[' ', '\\\\r', '\\\\n', [a-zA-Z0-9], [-()+,./:=?;!*#@$_%]]`,\nComment: `['<!--', CommentText, '-->']`,\nPI: `['<?', PITarget, tmp_17?, '?>']`,\ntmp_17: `[S, PIText]`,\nCDSect: `[CDStart, CData, CDEnd]`,\nCDStart: `['<![CDATA[']`,\nCDEnd: `[']]>']`,\nprolog: `[XMLDecl?, Misc*, tmp_18?]`,\ntmp_18: `[doctypedecl, Misc*]`,\nXMLDecl: `['<?xml', VersionInfo, EncodingDecl?, SDDecl?, S?, '?>']`,\nVersionInfo: `[S, 'version', Eq, tmp_19]`,\ntmp_19: `[tmp_20, tmp_21]`,\ntmp_20: `[\"'\", VersionNum, \"'\"]`,\ntmp_21: `['\"', VersionNum, '\"']`,\nEq: `[S?, '=', S?]`,\nVersionNum: `['1.0']`,\nMisc: `[Comment, PI, S]`,\ndoctypedecl: `['<!DOCTYPE', S, Name, tmp_23?, S?, tmp_22?, '>']`,\ntmp_22: `['[', start_intSubset, intSubset, ']', S?]`,\ntmp_23: `[S, ExternalID]`,\nDeclSep: `[PEReference, S]`,\nintSubset: `[tmp_24*]`,\ntmp_24: `[markupdecl, DeclSep]`,\nmarkupdecl: `[elementdecl, AttlistDecl, EntityDecl, NotationDecl, PI, Comment]`,\nextSubset: `[TextDecl?, extSubsetDecl]`,\nextSubsetDecl: `[tmp_25*]`,\ntmp_25: `[markupdecl, conditionalSect, DeclSep]`,\nSDDecl: `[S, 'standalone', Eq, tmp_30]`,\ntmp_26: `['yes', 'no']`,\ntmp_27: `['yes', 'no']`,\ntmp_28: `['\"', tmp_26, '\"']`,\ntmp_29: `[\"'\", tmp_27, \"'\"]`,\ntmp_30: `[tmp_29, tmp_28]`,\nelement: `[EmptyElemTag, tmp_31]`,\ntmp_31: `[STag, content, ETag]`,\nSTag: `['<', Name, tmp_32*, S?, '>']`,\ntmp_32: `[S, Attribute]`,\nAttribute: `[Name, Eq, AttValue]`,\nETag: `['</', Name, S?, '>']`,\ncontent: `[CharData?, tmp_34*]`,\ntmp_33: `[element, Reference, CDSect, PI, Comment]`,\ntmp_34: `[tmp_33, CharData?]`,\nEmptyElemTag: `['<', Name, tmp_35*, S?, '/>']`,\ntmp_35: `[S, Attribute]`,\nelementdecl: `['<!ELEMENT', S, Name, S, contentspec, S?, '>']`,\ncontentspec: `['EMPTY', 'ANY', Mixed, children]`,\nchildren: `[tmp_37, tmp_36?]`,\ntmp_36: `['?', '*', '+']`,\ntmp_37: `[choice, seq]`,\ncp: `[tmp_39, tmp_38?]`,\ntmp_38: `['?', '*', '+']`,\ntmp_39: `[Name, choice, seq]`,\nchoice: `['(', S?, cp, tmp_40+, S?, ')']`,\ntmp_40: `[S?, '|', S?, cp]`,\nseq: `['(', S?, cp, tmp_41*, S?, ')']`,\ntmp_41: `[S?, ',', S?, cp]`,\nMixed: `[tmp_43, tmp_44]`,\ntmp_42: `[S?, '|', S?, Name]`,\ntmp_43: `['(', S?, '#PCDATA', tmp_42*, S?, ')*']`,\ntmp_44: `['(', S?, '#PCDATA', S?, ')']`,\nAttlistDecl: `['<!ATTLIST', S, Name, AttDef*, S?, '>']`,\nAttDef: `[S, Name, S, AttType, S, DefaultDecl]`,\nAttType: `[StringType, TokenizedType, EnumeratedType]`,\nStringType: `['CDATA']`,\nTokenizedType: `['ID', 'IDREF', 'IDREFS', 'ENTITY', 'ENTITIES', 'NMTOKEN', 'NMTOKENS']`,\nEnumeratedType: `[NotationType, Enumeration]`,\nNotationType: `['NOTATION', S, '(', S?, Name, tmp_45*, S?, ')']`,\ntmp_45: `[S?, '|', S?, Name]`,\nEnumeration: `['(', S?, Nmtoken, tmp_46*, S?, ')']`,\ntmp_46: `[S?, '|', S?, Nmtoken]`,\nDefaultDecl: `['#REQUIRED', '#IMPLIED', tmp_48]`,\ntmp_47: `['#FIXED', S]`,\ntmp_48: `[tmp_47?, AttValue]`,\nconditionalSect: `[includeSect, ignoreSect]`,\nincludeSect: `['<![', S?, 'INCLUDE', S?, '[', extSubsetDecl, ']]>']`,\nignoreSect: `['<![', S?, 'IGNORE', S?, '[', ignoreSectContents*, ']]>']`,\nignoreSectContents: `[Ignore, tmp_49*]`,\ntmp_49: `['<![', ignoreSectContents, ']]>', Ignore]`,\nCharRef: `[tmp_50, tmp_51]`,\ntmp_50: `['&#', [0-9], ';']`,\ntmp_51: `['&#x', [0-9a-fA-F], ';']`,\nReference: `[EntityRef, CharRef]`,\nEntityRef: `['&', Name, ';']`,\nPEReference: `['%', Name, ';']`,\nEntityDecl: `[GEDecl, PEDecl]`,\nGEDecl: `['<!ENTITY', S, Name, S, EntityDef, S?, '>']`,\nPEDecl: `['<!ENTITY', S, '%', S, Name, S, PEDef, S?, '>']`,\nEntityDef: `[EntityValue, tmp_52]`,\ntmp_52: `[ExternalID, NDataDecl?]`,\nPEDef: `[EntityValue, ExternalID]`,\nExternalID: `[tmp_53, tmp_54]`,\ntmp_53: `['SYSTEM', S, SystemLiteral]`,\ntmp_54: `['PUBLIC', S, PubidLiteral, S, SystemLiteral]`,\nNDataDecl: `[S, 'NDATA', S, Name]`,\nTextDecl: `['<?xml', VersionInfo?, EncodingDecl, S?, '?>']`,\nextParsedEnt: `[TextDecl?, content]`,\nEncodingDecl: `[S, 'encoding', Eq, tmp_55]`,\ntmp_55: `[tmp_56, tmp_57]`,\ntmp_56: `['\"', EncName, '\"']`,\ntmp_57: `[\"'\", EncName, \"'\"]`,\nEncName: `[[A-Za-z], tmp_58*]`,\ntmp_58: `[[A-Za-z0-9._], '-']`,\nNotationDecl: `['<!NOTATION', S, Name, S, tmp_59, S?, '>']`,\ntmp_59: `[ExternalID, PublicID]`,\nPublicID: `['PUBLIC', S, PubidLiteral]`,\n}\nfunction document_rule(origin){\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // prolog\n  this.items = ['prolog', 'element', 'Misc*', \"<class 'xml_grammar_parser.End'>\"]\n  this.rules = []\n  this.repeats = []\n}\n\ndocument_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // prolog\n      if(! this.rules[0]){\n        this.rules[0] = new prolog_rule(this)\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 1, rule, char)\n    case 1: // element\n      if(! this.rules[1]){\n        this.rules[1] = new element_rule(this)\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 2, rule, char)\n    case 2: // Misc*\n      if(! this.rules[2]){\n        this.rules[2] = new Misc_rule(this)\n        this.repeats[2] = 0\n      }\n      rule = this.rules[2]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_star(this, 2, 3, rule, char)\n    case -1:\n    case 3:\n      if(char == END){\n        return DONE\n      }\n      return FAIL\n  }\n  return this\n}\n\ndocument_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction Char_rule(origin){\n  this.alt = true\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // '\\t'\n  this.items = [\"'\\\\t'\", \"'\\\\n'\", \"'\\\\r'\", '[#x20-#xD7FF]', '[#xE000-#xFFFD]', '[#x10000-#x10FFFF]']\n  this.rules = []\n  this.repeats = []\n}\n\nChar_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // '\\t'\n      if(! this.rules[0]){\n        this.rules[0] = new LITERAL(this, String.fromCharCode(9))\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_alt(this, 1, rule, char)\n    case 1: // '\\n'\n      if(! this.rules[1]){\n        this.rules[1] = new LITERAL(this, String.fromCharCode(10))\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_alt(this, 2, rule, char)\n    case 2: // '\\r'\n      if(! this.rules[2]){\n        this.rules[2] = new LITERAL(this, String.fromCharCode(13))\n      }\n      rule = this.rules[2]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_alt(this, 3, rule, char)\n    case 3: // [#x20-#xD7FF]\n      if(! this.rules[3]){\n        this.rules[3] = new CHARSET_rule(this, '#x20-#xD7FF')\n      }\n      rule = this.rules[3]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_alt(this, 4, rule, char)\n    case 4: // [#xE000-#xFFFD]\n      if(! this.rules[4]){\n        this.rules[4] = new CHARSET_rule(this, '#xE000-#xFFFD')\n      }\n      rule = this.rules[4]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_alt(this, 5, rule, char)\n    case 5: // [#x10000-#x10FFFF]\n      if(! this.rules[5]){\n        this.rules[5] = new CHARSET_rule(this, '#x10000-#x10FFFF')\n      }\n      rule = this.rules[5]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\nChar_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction S_rule(origin){\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // tmp_1+\n  this.items = ['tmp_1+']\n  this.rules = []\n  this.repeats = []\n}\n\nS_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // tmp_1+\n      if(! this.rules[0]){\n        this.rules[0] = new tmp_1_rule(this)\n        this.repeats[0] = 0\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_plus(this, 0,-1, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\nS_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction tmp_1_rule(origin){\n  this.alt = true\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // ' '\n  this.items = [\"' '\", \"'\\\\t'\", \"'\\\\r'\", \"'\\\\n'\"]\n  this.rules = []\n  this.repeats = []\n}\n\ntmp_1_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // ' '\n      if(! this.rules[0]){\n        this.rules[0] = new LITERAL(this, String.fromCharCode(32))\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_alt(this, 1, rule, char)\n    case 1: // '\\t'\n      if(! this.rules[1]){\n        this.rules[1] = new LITERAL(this, String.fromCharCode(9))\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_alt(this, 2, rule, char)\n    case 2: // '\\r'\n      if(! this.rules[2]){\n        this.rules[2] = new LITERAL(this, String.fromCharCode(13))\n      }\n      rule = this.rules[2]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_alt(this, 3, rule, char)\n    case 3: // '\\n'\n      if(! this.rules[3]){\n        this.rules[3] = new LITERAL(this, String.fromCharCode(10))\n      }\n      rule = this.rules[3]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\ntmp_1_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction Name_rule(origin){\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // tmp_2\n  this.items = ['tmp_2', 'NameChar*']\n  this.rules = []\n  this.repeats = []\n}\n\nName_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // tmp_2\n      if(! this.rules[0]){\n        this.rules[0] = new tmp_2_rule(this)\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 1, rule, char)\n    case 1: // NameChar*\n      if(! this.rules[1]){\n        this.rules[1] = new NameChar_rule(this)\n        this.repeats[1] = 0\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_star(this, 1, -1, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\nName_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction tmp_2_rule(origin){\n  this.alt = true\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // Letter\n  this.items = ['Letter', \"'_'\", \"':'\"]\n  this.rules = []\n  this.repeats = []\n}\n\ntmp_2_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // Letter\n      if(! this.rules[0]){\n        this.rules[0] = new Letter_rule(this)\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_alt(this, 1, rule, char)\n    case 1: // '_'\n      if(! this.rules[1]){\n        this.rules[1] = new LITERAL(this, '_')\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_alt(this, 2, rule, char)\n    case 2: // ':'\n      if(! this.rules[2]){\n        this.rules[2] = new LITERAL(this, ':')\n      }\n      rule = this.rules[2]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\ntmp_2_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction Names_rule(origin){\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // Name\n  this.items = ['Name', 'tmp_3*']\n  this.rules = []\n  this.repeats = []\n}\n\nNames_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // Name\n      if(! this.rules[0]){\n        this.rules[0] = new Name_rule(this)\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 1, rule, char)\n    case 1: // tmp_3*\n      if(! this.rules[1]){\n        this.rules[1] = new tmp_3_rule(this)\n        this.repeats[1] = 0\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_star(this, 1, -1, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\nNames_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction tmp_3_rule(origin){\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // ' '\n  this.items = [\"' '\", 'Name']\n  this.rules = []\n  this.repeats = []\n}\n\ntmp_3_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // ' '\n      if(! this.rules[0]){\n        this.rules[0] = new LITERAL(this, String.fromCharCode(32))\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 1, rule, char)\n    case 1: // Name\n      if(! this.rules[1]){\n        this.rules[1] = new Name_rule(this)\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\ntmp_3_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction Nmtoken_rule(origin){\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // NameChar+\n  this.items = ['NameChar+']\n  this.rules = []\n  this.repeats = []\n}\n\nNmtoken_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // NameChar+\n      if(! this.rules[0]){\n        this.rules[0] = new NameChar_rule(this)\n        this.repeats[0] = 0\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_plus(this, 0,-1, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\nNmtoken_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction Nmtokens_rule(origin){\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // Nmtoken\n  this.items = ['Nmtoken', 'tmp_4*']\n  this.rules = []\n  this.repeats = []\n}\n\nNmtokens_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // Nmtoken\n      if(! this.rules[0]){\n        this.rules[0] = new Nmtoken_rule(this)\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 1, rule, char)\n    case 1: // tmp_4*\n      if(! this.rules[1]){\n        this.rules[1] = new tmp_4_rule(this)\n        this.repeats[1] = 0\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_star(this, 1, -1, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\nNmtokens_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction tmp_4_rule(origin){\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // ' '\n  this.items = [\"' '\", 'Nmtoken']\n  this.rules = []\n  this.repeats = []\n}\n\ntmp_4_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // ' '\n      if(! this.rules[0]){\n        this.rules[0] = new LITERAL(this, String.fromCharCode(32))\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 1, rule, char)\n    case 1: // Nmtoken\n      if(! this.rules[1]){\n        this.rules[1] = new Nmtoken_rule(this)\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\ntmp_4_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction EntityValue_rule(origin){\n  this.alt = true\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // tmp_7\n  this.items = ['tmp_7', 'tmp_8']\n  this.rules = []\n  this.repeats = []\n}\n\nEntityValue_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // tmp_7\n      if(! this.rules[0]){\n        this.rules[0] = new tmp_7_rule(this)\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_alt(this, 1, rule, char)\n    case 1: // tmp_8\n      if(! this.rules[1]){\n        this.rules[1] = new tmp_8_rule(this)\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\nEntityValue_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction tmp_5_rule(origin){\n  this.alt = true\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // [^%&']\n  this.items = [\"[^%&']\", 'PEReference', 'Reference']\n  this.rules = []\n  this.repeats = []\n}\n\ntmp_5_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // [^%&']\n      if(! this.rules[0]){\n        this.rules[0] = new CHARSET_rule(this, '^%&\\'')\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_alt(this, 1, rule, char)\n    case 1: // PEReference\n      if(! this.rules[1]){\n        this.rules[1] = new PEReference_rule(this)\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_alt(this, 2, rule, char)\n    case 2: // Reference\n      if(! this.rules[2]){\n        this.rules[2] = new Reference_rule(this)\n      }\n      rule = this.rules[2]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\ntmp_5_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction tmp_6_rule(origin){\n  this.alt = true\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // [^%&\"]\n  this.items = ['[^%&\"]', 'PEReference', 'Reference']\n  this.rules = []\n  this.repeats = []\n}\n\ntmp_6_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // [^%&\"]\n      if(! this.rules[0]){\n        this.rules[0] = new CHARSET_rule(this, '^%&\"')\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_alt(this, 1, rule, char)\n    case 1: // PEReference\n      if(! this.rules[1]){\n        this.rules[1] = new PEReference_rule(this)\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_alt(this, 2, rule, char)\n    case 2: // Reference\n      if(! this.rules[2]){\n        this.rules[2] = new Reference_rule(this)\n      }\n      rule = this.rules[2]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\ntmp_6_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction tmp_7_rule(origin){\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // '\"'\n  this.items = ['\\'\"\\'', 'tmp_6*', '\\'\"\\'']\n  this.rules = []\n  this.repeats = []\n}\n\ntmp_7_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // '\"'\n      if(! this.rules[0]){\n        this.rules[0] = new LITERAL(this, '\"')\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 1, rule, char)\n    case 1: // tmp_6*\n      if(! this.rules[1]){\n        this.rules[1] = new tmp_6_rule(this)\n        this.repeats[1] = 0\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_star(this, 1, 2, rule, char)\n    case 2: // '\"'\n      if(! this.rules[2]){\n        this.rules[2] = new LITERAL(this, '\"')\n      }\n      rule = this.rules[2]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\ntmp_7_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction tmp_8_rule(origin){\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // \"'\"\n  this.items = ['\"\\'\"', 'tmp_5*', '\"\\'\"']\n  this.rules = []\n  this.repeats = []\n}\n\ntmp_8_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // \"'\"\n      if(! this.rules[0]){\n        this.rules[0] = new LITERAL(this, '\\'')\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 1, rule, char)\n    case 1: // tmp_5*\n      if(! this.rules[1]){\n        this.rules[1] = new tmp_5_rule(this)\n        this.repeats[1] = 0\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_star(this, 1, 2, rule, char)\n    case 2: // \"'\"\n      if(! this.rules[2]){\n        this.rules[2] = new LITERAL(this, '\\'')\n      }\n      rule = this.rules[2]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\ntmp_8_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction AttValue_rule(origin){\n  this.alt = true\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // tmp_11\n  this.items = ['tmp_11', 'tmp_12']\n  this.rules = []\n  this.repeats = []\n}\n\nAttValue_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // tmp_11\n      if(! this.rules[0]){\n        this.rules[0] = new tmp_11_rule(this)\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_alt(this, 1, rule, char)\n    case 1: // tmp_12\n      if(! this.rules[1]){\n        this.rules[1] = new tmp_12_rule(this)\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\nAttValue_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction tmp_9_rule(origin){\n  this.alt = true\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // [^<&']\n  this.items = [\"[^<&']\", 'Reference']\n  this.rules = []\n  this.repeats = []\n}\n\ntmp_9_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // [^<&']\n      if(! this.rules[0]){\n        this.rules[0] = new CHARSET_rule(this, '^<&\\'')\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_alt(this, 1, rule, char)\n    case 1: // Reference\n      if(! this.rules[1]){\n        this.rules[1] = new Reference_rule(this)\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\ntmp_9_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction tmp_10_rule(origin){\n  this.alt = true\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // [^<&\"]\n  this.items = ['[^<&\"]', 'Reference']\n  this.rules = []\n  this.repeats = []\n}\n\ntmp_10_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // [^<&\"]\n      if(! this.rules[0]){\n        this.rules[0] = new CHARSET_rule(this, '^<&\"')\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_alt(this, 1, rule, char)\n    case 1: // Reference\n      if(! this.rules[1]){\n        this.rules[1] = new Reference_rule(this)\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\ntmp_10_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction tmp_11_rule(origin){\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // '\"'\n  this.items = ['\\'\"\\'', 'tmp_10*', '\\'\"\\'']\n  this.rules = []\n  this.repeats = []\n}\n\ntmp_11_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // '\"'\n      if(! this.rules[0]){\n        this.rules[0] = new LITERAL(this, '\"')\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 1, rule, char)\n    case 1: // tmp_10*\n      if(! this.rules[1]){\n        this.rules[1] = new tmp_10_rule(this)\n        this.repeats[1] = 0\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_star(this, 1, 2, rule, char)\n    case 2: // '\"'\n      if(! this.rules[2]){\n        this.rules[2] = new LITERAL(this, '\"')\n      }\n      rule = this.rules[2]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\ntmp_11_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction tmp_12_rule(origin){\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // \"'\"\n  this.items = ['\"\\'\"', 'tmp_9*', '\"\\'\"']\n  this.rules = []\n  this.repeats = []\n}\n\ntmp_12_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // \"'\"\n      if(! this.rules[0]){\n        this.rules[0] = new LITERAL(this, '\\'')\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 1, rule, char)\n    case 1: // tmp_9*\n      if(! this.rules[1]){\n        this.rules[1] = new tmp_9_rule(this)\n        this.repeats[1] = 0\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_star(this, 1, 2, rule, char)\n    case 2: // \"'\"\n      if(! this.rules[2]){\n        this.rules[2] = new LITERAL(this, '\\'')\n      }\n      rule = this.rules[2]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\ntmp_12_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction SystemLiteral_rule(origin){\n  this.alt = true\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // tmp_14\n  this.items = ['tmp_14', 'tmp_13']\n  this.rules = []\n  this.repeats = []\n}\n\nSystemLiteral_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // tmp_14\n      if(! this.rules[0]){\n        this.rules[0] = new tmp_14_rule(this)\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_alt(this, 1, rule, char)\n    case 1: // tmp_13\n      if(! this.rules[1]){\n        this.rules[1] = new tmp_13_rule(this)\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\nSystemLiteral_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction tmp_13_rule(origin){\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // \"'\"\n  this.items = ['\"\\'\"', \"[^']\", '\"\\'\"']\n  this.rules = []\n  this.repeats = []\n}\n\ntmp_13_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // \"'\"\n      if(! this.rules[0]){\n        this.rules[0] = new LITERAL(this, '\\'')\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 1, rule, char)\n    case 1: // [^']\n      if(! this.rules[1]){\n        this.rules[1] = new CHARSET_rule(this, '^\\'')\n        this.repeats[1] = 0\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_star(this, 1, 2, rule, char)\n    case 2: // \"'\"\n      if(! this.rules[2]){\n        this.rules[2] = new LITERAL(this, '\\'')\n      }\n      rule = this.rules[2]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\ntmp_13_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction tmp_14_rule(origin){\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // '\"'\n  this.items = ['\\'\"\\'', '[^\"]', '\\'\"\\'']\n  this.rules = []\n  this.repeats = []\n}\n\ntmp_14_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // '\"'\n      if(! this.rules[0]){\n        this.rules[0] = new LITERAL(this, '\"')\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 1, rule, char)\n    case 1: // [^\"]\n      if(! this.rules[1]){\n        this.rules[1] = new CHARSET_rule(this, '^\"')\n        this.repeats[1] = 0\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_star(this, 1, 2, rule, char)\n    case 2: // '\"'\n      if(! this.rules[2]){\n        this.rules[2] = new LITERAL(this, '\"')\n      }\n      rule = this.rules[2]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\ntmp_14_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction PubidLiteral_rule(origin){\n  this.alt = true\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // tmp_15\n  this.items = ['tmp_15', 'tmp_16']\n  this.rules = []\n  this.repeats = []\n}\n\nPubidLiteral_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // tmp_15\n      if(! this.rules[0]){\n        this.rules[0] = new tmp_15_rule(this)\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_alt(this, 1, rule, char)\n    case 1: // tmp_16\n      if(! this.rules[1]){\n        this.rules[1] = new tmp_16_rule(this)\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\nPubidLiteral_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction tmp_15_rule(origin){\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // '\"'\n  this.items = ['\\'\"\\'', 'PubidChar*', '\\'\"\\'']\n  this.rules = []\n  this.repeats = []\n}\n\ntmp_15_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // '\"'\n      if(! this.rules[0]){\n        this.rules[0] = new LITERAL(this, '\"')\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 1, rule, char)\n    case 1: // PubidChar*\n      if(! this.rules[1]){\n        this.rules[1] = new PubidChar_rule(this)\n        this.repeats[1] = 0\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_star(this, 1, 2, rule, char)\n    case 2: // '\"'\n      if(! this.rules[2]){\n        this.rules[2] = new LITERAL(this, '\"')\n      }\n      rule = this.rules[2]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\ntmp_15_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction tmp_16_rule(origin){\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // \"'\"\n  this.items = ['\"\\'\"', 'PubidCharNoQuote*', '\"\\'\"']\n  this.rules = []\n  this.repeats = []\n}\n\ntmp_16_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // \"'\"\n      if(! this.rules[0]){\n        this.rules[0] = new LITERAL(this, '\\'')\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 1, rule, char)\n    case 1: // PubidCharNoQuote*\n      if(! this.rules[1]){\n        this.rules[1] = new PubidCharNoQuote_rule(this)\n        this.repeats[1] = 0\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_star(this, 1, 2, rule, char)\n    case 2: // \"'\"\n      if(! this.rules[2]){\n        this.rules[2] = new LITERAL(this, '\\'')\n      }\n      rule = this.rules[2]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\ntmp_16_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction PubidChar_rule(origin){\n  this.alt = true\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // ' '\n  this.items = [\"' '\", \"'\\\\r'\", \"'\\\\n'\", '[a-zA-Z0-9]', \"[-'()+,./:=?;!*#@$_%]\"]\n  this.rules = []\n  this.repeats = []\n}\n\nPubidChar_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // ' '\n      if(! this.rules[0]){\n        this.rules[0] = new LITERAL(this, String.fromCharCode(32))\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_alt(this, 1, rule, char)\n    case 1: // '\\r'\n      if(! this.rules[1]){\n        this.rules[1] = new LITERAL(this, String.fromCharCode(13))\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_alt(this, 2, rule, char)\n    case 2: // '\\n'\n      if(! this.rules[2]){\n        this.rules[2] = new LITERAL(this, String.fromCharCode(10))\n      }\n      rule = this.rules[2]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_alt(this, 3, rule, char)\n    case 3: // [a-zA-Z0-9]\n      if(! this.rules[3]){\n        this.rules[3] = new CHARSET_rule(this, 'a-zA-Z0-9')\n      }\n      rule = this.rules[3]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_alt(this, 4, rule, char)\n    case 4: // [-'()+,./:=?;!*#@$_%]\n      if(! this.rules[4]){\n        this.rules[4] = new CHARSET_rule(this, '-\\'()+,./:=?;!*#@$_%')\n      }\n      rule = this.rules[4]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\nPubidChar_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction PubidCharNoQuote_rule(origin){\n  this.alt = true\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // ' '\n  this.items = [\"' '\", \"'\\\\r'\", \"'\\\\n'\", '[a-zA-Z0-9]', '[-()+,./:=?;!*#@$_%]']\n  this.rules = []\n  this.repeats = []\n}\n\nPubidCharNoQuote_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // ' '\n      if(! this.rules[0]){\n        this.rules[0] = new LITERAL(this, String.fromCharCode(32))\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_alt(this, 1, rule, char)\n    case 1: // '\\r'\n      if(! this.rules[1]){\n        this.rules[1] = new LITERAL(this, String.fromCharCode(13))\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_alt(this, 2, rule, char)\n    case 2: // '\\n'\n      if(! this.rules[2]){\n        this.rules[2] = new LITERAL(this, String.fromCharCode(10))\n      }\n      rule = this.rules[2]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_alt(this, 3, rule, char)\n    case 3: // [a-zA-Z0-9]\n      if(! this.rules[3]){\n        this.rules[3] = new CHARSET_rule(this, 'a-zA-Z0-9')\n      }\n      rule = this.rules[3]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_alt(this, 4, rule, char)\n    case 4: // [-()+,./:=?;!*#@$_%]\n      if(! this.rules[4]){\n        this.rules[4] = new CHARSET_rule(this, '-()+,./:=?;!*#@$_%')\n      }\n      rule = this.rules[4]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\nPubidCharNoQuote_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction Comment_rule(origin){\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // '<!--'\n  this.items = [\"'<!--'\", 'CommentText', \"'-->'\"]\n  this.rules = []\n  this.repeats = []\n}\n\nComment_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // '<!--'\n      if(! this.rules[0]){\n        this.rules[0] = new LITERAL(this, '<!--')\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 1, rule, char)\n    case 1: // CommentText\n      if(! this.rules[1]){\n        this.rules[1] = new CommentText_rule(this)\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 2, rule, char)\n    case 2: // '-->'\n      if(! this.rules[2]){\n        this.rules[2] = new LITERAL(this, '-->')\n      }\n      rule = this.rules[2]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\nComment_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction PI_rule(origin){\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // '<?'\n  this.items = [\"'<?'\", 'PITarget', 'tmp_17?', \"'?>'\"]\n  this.rules = []\n  this.repeats = []\n}\n\nPI_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // '<?'\n      if(! this.rules[0]){\n        this.rules[0] = new LITERAL(this, '<?')\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 1, rule, char)\n    case 1: // PITarget\n      if(! this.rules[1]){\n        this.rules[1] = new PITarget_rule(this)\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 2, rule, char)\n    case 2: // tmp_17?\n      if(! this.rules[2]){\n        this.rules[2] = new tmp_17_rule(this)\n        this.repeats[2] = 0\n      }\n      rule = this.rules[2]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_zero_or_one(this, 2, 3, rule, char)\n    case 3: // '?>'\n      if(! this.rules[3]){\n        this.rules[3] = new LITERAL(this, '?>')\n      }\n      rule = this.rules[3]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\nPI_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction tmp_17_rule(origin){\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // S\n  this.items = ['S', 'PIText']\n  this.rules = []\n  this.repeats = []\n}\n\ntmp_17_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // S\n      if(! this.rules[0]){\n        this.rules[0] = new S_rule(this)\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 1, rule, char)\n    case 1: // PIText\n      if(! this.rules[1]){\n        this.rules[1] = new PIText_rule(this)\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\ntmp_17_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction CDSect_rule(origin){\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // CDStart\n  this.items = ['CDStart', 'CData', 'CDEnd']\n  this.rules = []\n  this.repeats = []\n}\n\nCDSect_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // CDStart\n      if(! this.rules[0]){\n        this.rules[0] = new CDStart_rule(this)\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 1, rule, char)\n    case 1: // CData\n      if(! this.rules[1]){\n        this.rules[1] = new CData_rule(this)\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 2, rule, char)\n    case 2: // CDEnd\n      if(! this.rules[2]){\n        this.rules[2] = new CDEnd_rule(this)\n      }\n      rule = this.rules[2]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\nCDSect_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction CDStart_rule(origin){\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // '<![CDATA['\n  this.items = [\"'<![CDATA['\"]\n  this.rules = []\n  this.repeats = []\n}\n\nCDStart_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // '<![CDATA['\n      if(! this.rules[0]){\n        this.rules[0] = new LITERAL(this, '<![CDATA[')\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\nCDStart_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction CDEnd_rule(origin){\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // ']]>'\n  this.items = [\"']]>'\"]\n  this.rules = []\n  this.repeats = []\n}\n\nCDEnd_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // ']]>'\n      if(! this.rules[0]){\n        this.rules[0] = new LITERAL(this, ']]>')\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\nCDEnd_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction prolog_rule(origin){\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // XMLDecl?\n  this.items = ['XMLDecl?', 'Misc*', 'tmp_18?']\n  this.rules = []\n  this.repeats = []\n}\n\nprolog_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // XMLDecl?\n      if(! this.rules[0]){\n        this.rules[0] = new XMLDecl_rule(this)\n        this.repeats[0] = 0\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_zero_or_one(this, 0, 1, rule, char)\n    case 1: // Misc*\n      if(! this.rules[1]){\n        this.rules[1] = new Misc_rule(this)\n        this.repeats[1] = 0\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_star(this, 1, 2, rule, char)\n    case 2: // tmp_18?\n      if(! this.rules[2]){\n        this.rules[2] = new tmp_18_rule(this)\n        this.repeats[2] = 0\n      }\n      rule = this.rules[2]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_zero_or_one(this, 2, -1, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\nprolog_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction tmp_18_rule(origin){\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // doctypedecl\n  this.items = ['doctypedecl', 'Misc*']\n  this.rules = []\n  this.repeats = []\n}\n\ntmp_18_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // doctypedecl\n      if(! this.rules[0]){\n        this.rules[0] = new doctypedecl_rule(this)\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 1, rule, char)\n    case 1: // Misc*\n      if(! this.rules[1]){\n        this.rules[1] = new Misc_rule(this)\n        this.repeats[1] = 0\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_star(this, 1, -1, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\ntmp_18_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction XMLDecl_rule(origin){\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // '<?xml'\n  this.items = [\"'<?xml'\", 'VersionInfo', 'EncodingDecl?', 'SDDecl?', 'S?', \"'?>'\"]\n  this.rules = []\n  this.repeats = []\n}\n\nXMLDecl_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // '<?xml'\n      if(! this.rules[0]){\n        this.rules[0] = new LITERAL(this, '<?xml')\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 1, rule, char)\n    case 1: // VersionInfo\n      if(! this.rules[1]){\n        this.rules[1] = new VersionInfo_rule(this)\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 2, rule, char)\n    case 2: // EncodingDecl?\n      if(! this.rules[2]){\n        this.rules[2] = new EncodingDecl_rule(this)\n        this.repeats[2] = 0\n      }\n      rule = this.rules[2]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_zero_or_one(this, 2, 3, rule, char)\n    case 3: // SDDecl?\n      if(! this.rules[3]){\n        this.rules[3] = new SDDecl_rule(this)\n        this.repeats[3] = 0\n      }\n      rule = this.rules[3]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_zero_or_one(this, 3, 4, rule, char)\n    case 4: // S?\n      if(! this.rules[4]){\n        this.rules[4] = new S_rule(this)\n        this.repeats[4] = 0\n      }\n      rule = this.rules[4]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_zero_or_one(this, 4, 5, rule, char)\n    case 5: // '?>'\n      if(! this.rules[5]){\n        this.rules[5] = new LITERAL(this, '?>')\n      }\n      rule = this.rules[5]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\nXMLDecl_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction VersionInfo_rule(origin){\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // S\n  this.items = ['S', \"'version'\", 'Eq', 'tmp_19']\n  this.rules = []\n  this.repeats = []\n}\n\nVersionInfo_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // S\n      if(! this.rules[0]){\n        this.rules[0] = new S_rule(this)\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 1, rule, char)\n    case 1: // 'version'\n      if(! this.rules[1]){\n        this.rules[1] = new LITERAL(this, 'version')\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 2, rule, char)\n    case 2: // Eq\n      if(! this.rules[2]){\n        this.rules[2] = new Eq_rule(this)\n      }\n      rule = this.rules[2]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 3, rule, char)\n    case 3: // tmp_19\n      if(! this.rules[3]){\n        this.rules[3] = new tmp_19_rule(this)\n      }\n      rule = this.rules[3]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\nVersionInfo_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction tmp_19_rule(origin){\n  this.alt = true\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // tmp_20\n  this.items = ['tmp_20', 'tmp_21']\n  this.rules = []\n  this.repeats = []\n}\n\ntmp_19_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // tmp_20\n      if(! this.rules[0]){\n        this.rules[0] = new tmp_20_rule(this)\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_alt(this, 1, rule, char)\n    case 1: // tmp_21\n      if(! this.rules[1]){\n        this.rules[1] = new tmp_21_rule(this)\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\ntmp_19_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction tmp_20_rule(origin){\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // \"'\"\n  this.items = ['\"\\'\"', 'VersionNum', '\"\\'\"']\n  this.rules = []\n  this.repeats = []\n}\n\ntmp_20_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // \"'\"\n      if(! this.rules[0]){\n        this.rules[0] = new LITERAL(this, '\\'')\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 1, rule, char)\n    case 1: // VersionNum\n      if(! this.rules[1]){\n        this.rules[1] = new VersionNum_rule(this)\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 2, rule, char)\n    case 2: // \"'\"\n      if(! this.rules[2]){\n        this.rules[2] = new LITERAL(this, '\\'')\n      }\n      rule = this.rules[2]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\ntmp_20_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction tmp_21_rule(origin){\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // '\"'\n  this.items = ['\\'\"\\'', 'VersionNum', '\\'\"\\'']\n  this.rules = []\n  this.repeats = []\n}\n\ntmp_21_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // '\"'\n      if(! this.rules[0]){\n        this.rules[0] = new LITERAL(this, '\"')\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 1, rule, char)\n    case 1: // VersionNum\n      if(! this.rules[1]){\n        this.rules[1] = new VersionNum_rule(this)\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 2, rule, char)\n    case 2: // '\"'\n      if(! this.rules[2]){\n        this.rules[2] = new LITERAL(this, '\"')\n      }\n      rule = this.rules[2]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\ntmp_21_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction Eq_rule(origin){\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // S?\n  this.items = ['S?', \"'='\", 'S?']\n  this.rules = []\n  this.repeats = []\n}\n\nEq_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // S?\n      if(! this.rules[0]){\n        this.rules[0] = new S_rule(this)\n        this.repeats[0] = 0\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_zero_or_one(this, 0, 1, rule, char)\n    case 1: // '='\n      if(! this.rules[1]){\n        this.rules[1] = new LITERAL(this, '=')\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 2, rule, char)\n    case 2: // S?\n      if(! this.rules[2]){\n        this.rules[2] = new S_rule(this)\n        this.repeats[2] = 0\n      }\n      rule = this.rules[2]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_zero_or_one(this, 2, -1, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\nEq_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction VersionNum_rule(origin){\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // '1.0'\n  this.items = [\"'1.0'\"]\n  this.rules = []\n  this.repeats = []\n}\n\nVersionNum_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // '1.0'\n      if(! this.rules[0]){\n        this.rules[0] = new LITERAL(this, '1.0')\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\nVersionNum_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction Misc_rule(origin){\n  this.alt = true\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // Comment\n  this.items = ['Comment', 'PI', 'S']\n  this.rules = []\n  this.repeats = []\n}\n\nMisc_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // Comment\n      if(! this.rules[0]){\n        this.rules[0] = new Comment_rule(this)\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_alt(this, 1, rule, char)\n    case 1: // PI\n      if(! this.rules[1]){\n        this.rules[1] = new PI_rule(this)\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_alt(this, 2, rule, char)\n    case 2: // S\n      if(! this.rules[2]){\n        this.rules[2] = new S_rule(this)\n      }\n      rule = this.rules[2]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\nMisc_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction doctypedecl_rule(origin){\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // '<!DOCTYPE'\n  this.items = [\"'<!DOCTYPE'\", 'S', 'Name', 'tmp_23?', 'S?', 'tmp_22?', \"'>'\"]\n  this.rules = []\n  this.repeats = []\n}\n\ndoctypedecl_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // '<!DOCTYPE'\n      if(! this.rules[0]){\n        this.rules[0] = new LITERAL(this, '<!DOCTYPE')\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 1, rule, char)\n    case 1: // S\n      if(! this.rules[1]){\n        this.rules[1] = new S_rule(this)\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 2, rule, char)\n    case 2: // Name\n      if(! this.rules[2]){\n        this.rules[2] = new Name_rule(this)\n      }\n      rule = this.rules[2]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 3, rule, char)\n    case 3: // tmp_23?\n      if(! this.rules[3]){\n        this.rules[3] = new tmp_23_rule(this)\n        this.repeats[3] = 0\n      }\n      rule = this.rules[3]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_zero_or_one(this, 3, 4, rule, char)\n    case 4: // S?\n      if(! this.rules[4]){\n        this.rules[4] = new S_rule(this)\n        this.repeats[4] = 0\n      }\n      rule = this.rules[4]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_zero_or_one(this, 4, 5, rule, char)\n    case 5: // tmp_22?\n      if(! this.rules[5]){\n        this.rules[5] = new tmp_22_rule(this)\n        this.repeats[5] = 0\n      }\n      rule = this.rules[5]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_zero_or_one(this, 5, 6, rule, char)\n    case 6: // '>'\n      if(! this.rules[6]){\n        this.rules[6] = new LITERAL(this, '>')\n      }\n      rule = this.rules[6]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\ndoctypedecl_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction tmp_22_rule(origin){\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // '['\n  this.items = [\"'['\", 'start_intSubset', 'intSubset', \"']'\", 'S?']\n  this.rules = []\n  this.repeats = []\n}\n\ntmp_22_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // '['\n      if(! this.rules[0]){\n        this.rules[0] = new LITERAL(this, '[')\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 1, rule, char)\n    case 1: // start_intSubset\n      if(! this.rules[1]){\n        this.rules[1] = new start_intSubset_rule(this)\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 2, rule, char)\n    case 2: // intSubset\n      if(! this.rules[2]){\n        this.rules[2] = new intSubset_rule(this)\n      }\n      rule = this.rules[2]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 3, rule, char)\n    case 3: // ']'\n      if(! this.rules[3]){\n        this.rules[3] = new LITERAL(this, ']')\n      }\n      rule = this.rules[3]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 4, rule, char)\n    case 4: // S?\n      if(! this.rules[4]){\n        this.rules[4] = new S_rule(this)\n        this.repeats[4] = 0\n      }\n      rule = this.rules[4]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_zero_or_one(this, 4, -1, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\ntmp_22_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction tmp_23_rule(origin){\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // S\n  this.items = ['S', 'ExternalID']\n  this.rules = []\n  this.repeats = []\n}\n\ntmp_23_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // S\n      if(! this.rules[0]){\n        this.rules[0] = new S_rule(this)\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 1, rule, char)\n    case 1: // ExternalID\n      if(! this.rules[1]){\n        this.rules[1] = new ExternalID_rule(this)\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\ntmp_23_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction DeclSep_rule(origin){\n  this.alt = true\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // PEReference\n  this.items = ['PEReference', 'S']\n  this.rules = []\n  this.repeats = []\n}\n\nDeclSep_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // PEReference\n      if(! this.rules[0]){\n        this.rules[0] = new PEReference_rule(this)\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_alt(this, 1, rule, char)\n    case 1: // S\n      if(! this.rules[1]){\n        this.rules[1] = new S_rule(this)\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\nDeclSep_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction intSubset_rule(origin){\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // tmp_24*\n  this.items = ['tmp_24*']\n  this.rules = []\n  this.repeats = []\n}\n\nintSubset_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // tmp_24*\n      if(! this.rules[0]){\n        this.rules[0] = new tmp_24_rule(this)\n        this.repeats[0] = 0\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_star(this, 0, -1, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\nintSubset_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction tmp_24_rule(origin){\n  this.alt = true\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // markupdecl\n  this.items = ['markupdecl', 'DeclSep']\n  this.rules = []\n  this.repeats = []\n}\n\ntmp_24_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // markupdecl\n      if(! this.rules[0]){\n        this.rules[0] = new markupdecl_rule(this)\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_alt(this, 1, rule, char)\n    case 1: // DeclSep\n      if(! this.rules[1]){\n        this.rules[1] = new DeclSep_rule(this)\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\ntmp_24_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction markupdecl_rule(origin){\n  this.alt = true\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // elementdecl\n  this.items = ['elementdecl', 'AttlistDecl', 'EntityDecl', 'NotationDecl', 'PI', 'Comment']\n  this.rules = []\n  this.repeats = []\n}\n\nmarkupdecl_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // elementdecl\n      if(! this.rules[0]){\n        this.rules[0] = new elementdecl_rule(this)\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_alt(this, 1, rule, char)\n    case 1: // AttlistDecl\n      if(! this.rules[1]){\n        this.rules[1] = new AttlistDecl_rule(this)\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_alt(this, 2, rule, char)\n    case 2: // EntityDecl\n      if(! this.rules[2]){\n        this.rules[2] = new EntityDecl_rule(this)\n      }\n      rule = this.rules[2]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_alt(this, 3, rule, char)\n    case 3: // NotationDecl\n      if(! this.rules[3]){\n        this.rules[3] = new NotationDecl_rule(this)\n      }\n      rule = this.rules[3]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_alt(this, 4, rule, char)\n    case 4: // PI\n      if(! this.rules[4]){\n        this.rules[4] = new PI_rule(this)\n      }\n      rule = this.rules[4]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_alt(this, 5, rule, char)\n    case 5: // Comment\n      if(! this.rules[5]){\n        this.rules[5] = new Comment_rule(this)\n      }\n      rule = this.rules[5]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\nmarkupdecl_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction extSubset_rule(origin){\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // TextDecl?\n  this.items = ['TextDecl?', 'extSubsetDecl']\n  this.rules = []\n  this.repeats = []\n}\n\nextSubset_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // TextDecl?\n      if(! this.rules[0]){\n        this.rules[0] = new TextDecl_rule(this)\n        this.repeats[0] = 0\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_zero_or_one(this, 0, 1, rule, char)\n    case 1: // extSubsetDecl\n      if(! this.rules[1]){\n        this.rules[1] = new extSubsetDecl_rule(this)\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\nextSubset_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction extSubsetDecl_rule(origin){\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // tmp_25*\n  this.items = ['tmp_25*']\n  this.rules = []\n  this.repeats = []\n}\n\nextSubsetDecl_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // tmp_25*\n      if(! this.rules[0]){\n        this.rules[0] = new tmp_25_rule(this)\n        this.repeats[0] = 0\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_star(this, 0, -1, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\nextSubsetDecl_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction tmp_25_rule(origin){\n  this.alt = true\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // markupdecl\n  this.items = ['markupdecl', 'conditionalSect', 'DeclSep']\n  this.rules = []\n  this.repeats = []\n}\n\ntmp_25_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // markupdecl\n      if(! this.rules[0]){\n        this.rules[0] = new markupdecl_rule(this)\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_alt(this, 1, rule, char)\n    case 1: // conditionalSect\n      if(! this.rules[1]){\n        this.rules[1] = new conditionalSect_rule(this)\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_alt(this, 2, rule, char)\n    case 2: // DeclSep\n      if(! this.rules[2]){\n        this.rules[2] = new DeclSep_rule(this)\n      }\n      rule = this.rules[2]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\ntmp_25_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction SDDecl_rule(origin){\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // S\n  this.items = ['S', \"'standalone'\", 'Eq', 'tmp_30']\n  this.rules = []\n  this.repeats = []\n}\n\nSDDecl_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // S\n      if(! this.rules[0]){\n        this.rules[0] = new S_rule(this)\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 1, rule, char)\n    case 1: // 'standalone'\n      if(! this.rules[1]){\n        this.rules[1] = new LITERAL(this, 'standalone')\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 2, rule, char)\n    case 2: // Eq\n      if(! this.rules[2]){\n        this.rules[2] = new Eq_rule(this)\n      }\n      rule = this.rules[2]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 3, rule, char)\n    case 3: // tmp_30\n      if(! this.rules[3]){\n        this.rules[3] = new tmp_30_rule(this)\n      }\n      rule = this.rules[3]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\nSDDecl_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction tmp_26_rule(origin){\n  this.alt = true\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // 'yes'\n  this.items = [\"'yes'\", \"'no'\"]\n  this.rules = []\n  this.repeats = []\n}\n\ntmp_26_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // 'yes'\n      if(! this.rules[0]){\n        this.rules[0] = new LITERAL(this, 'yes')\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_alt(this, 1, rule, char)\n    case 1: // 'no'\n      if(! this.rules[1]){\n        this.rules[1] = new LITERAL(this, 'no')\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\ntmp_26_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction tmp_27_rule(origin){\n  this.alt = true\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // 'yes'\n  this.items = [\"'yes'\", \"'no'\"]\n  this.rules = []\n  this.repeats = []\n}\n\ntmp_27_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // 'yes'\n      if(! this.rules[0]){\n        this.rules[0] = new LITERAL(this, 'yes')\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_alt(this, 1, rule, char)\n    case 1: // 'no'\n      if(! this.rules[1]){\n        this.rules[1] = new LITERAL(this, 'no')\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\ntmp_27_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction tmp_28_rule(origin){\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // '\"'\n  this.items = ['\\'\"\\'', 'tmp_26', '\\'\"\\'']\n  this.rules = []\n  this.repeats = []\n}\n\ntmp_28_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // '\"'\n      if(! this.rules[0]){\n        this.rules[0] = new LITERAL(this, '\"')\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 1, rule, char)\n    case 1: // tmp_26\n      if(! this.rules[1]){\n        this.rules[1] = new tmp_26_rule(this)\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 2, rule, char)\n    case 2: // '\"'\n      if(! this.rules[2]){\n        this.rules[2] = new LITERAL(this, '\"')\n      }\n      rule = this.rules[2]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\ntmp_28_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction tmp_29_rule(origin){\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // \"'\"\n  this.items = ['\"\\'\"', 'tmp_27', '\"\\'\"']\n  this.rules = []\n  this.repeats = []\n}\n\ntmp_29_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // \"'\"\n      if(! this.rules[0]){\n        this.rules[0] = new LITERAL(this, '\\'')\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 1, rule, char)\n    case 1: // tmp_27\n      if(! this.rules[1]){\n        this.rules[1] = new tmp_27_rule(this)\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 2, rule, char)\n    case 2: // \"'\"\n      if(! this.rules[2]){\n        this.rules[2] = new LITERAL(this, '\\'')\n      }\n      rule = this.rules[2]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\ntmp_29_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction tmp_30_rule(origin){\n  this.alt = true\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // tmp_29\n  this.items = ['tmp_29', 'tmp_28']\n  this.rules = []\n  this.repeats = []\n}\n\ntmp_30_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // tmp_29\n      if(! this.rules[0]){\n        this.rules[0] = new tmp_29_rule(this)\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_alt(this, 1, rule, char)\n    case 1: // tmp_28\n      if(! this.rules[1]){\n        this.rules[1] = new tmp_28_rule(this)\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\ntmp_30_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction element_rule(origin){\n  this.alt = true\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // EmptyElemTag\n  this.items = ['EmptyElemTag', 'tmp_31']\n  this.rules = []\n  this.repeats = []\n}\n\nelement_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // EmptyElemTag\n      if(! this.rules[0]){\n        this.rules[0] = new EmptyElemTag_rule(this)\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_alt(this, 1, rule, char)\n    case 1: // tmp_31\n      if(! this.rules[1]){\n        this.rules[1] = new tmp_31_rule(this)\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\nelement_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction tmp_31_rule(origin){\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // STag\n  this.items = ['STag', 'content', 'ETag']\n  this.rules = []\n  this.repeats = []\n}\n\ntmp_31_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // STag\n      if(! this.rules[0]){\n        this.rules[0] = new STag_rule(this)\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 1, rule, char)\n    case 1: // content\n      if(! this.rules[1]){\n        this.rules[1] = new content_rule(this)\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 2, rule, char)\n    case 2: // ETag\n      if(! this.rules[2]){\n        this.rules[2] = new ETag_rule(this)\n      }\n      rule = this.rules[2]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\ntmp_31_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction STag_rule(origin){\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // '<'\n  this.items = [\"'<'\", 'Name', 'tmp_32*', 'S?', \"'>'\"]\n  this.rules = []\n  this.repeats = []\n}\n\nSTag_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // '<'\n      if(! this.rules[0]){\n        this.rules[0] = new LITERAL(this, '<')\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 1, rule, char)\n    case 1: // Name\n      if(! this.rules[1]){\n        this.rules[1] = new Name_rule(this)\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 2, rule, char)\n    case 2: // tmp_32*\n      if(! this.rules[2]){\n        this.rules[2] = new tmp_32_rule(this)\n        this.repeats[2] = 0\n      }\n      rule = this.rules[2]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_star(this, 2, 3, rule, char)\n    case 3: // S?\n      if(! this.rules[3]){\n        this.rules[3] = new S_rule(this)\n        this.repeats[3] = 0\n      }\n      rule = this.rules[3]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_zero_or_one(this, 3, 4, rule, char)\n    case 4: // '>'\n      if(! this.rules[4]){\n        this.rules[4] = new LITERAL(this, '>')\n      }\n      rule = this.rules[4]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\nSTag_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction tmp_32_rule(origin){\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // S\n  this.items = ['S', 'Attribute']\n  this.rules = []\n  this.repeats = []\n}\n\ntmp_32_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // S\n      if(! this.rules[0]){\n        this.rules[0] = new S_rule(this)\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 1, rule, char)\n    case 1: // Attribute\n      if(! this.rules[1]){\n        this.rules[1] = new Attribute_rule(this)\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\ntmp_32_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction Attribute_rule(origin){\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // Name\n  this.items = ['Name', 'Eq', 'AttValue']\n  this.rules = []\n  this.repeats = []\n}\n\nAttribute_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // Name\n      if(! this.rules[0]){\n        this.rules[0] = new Name_rule(this)\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 1, rule, char)\n    case 1: // Eq\n      if(! this.rules[1]){\n        this.rules[1] = new Eq_rule(this)\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 2, rule, char)\n    case 2: // AttValue\n      if(! this.rules[2]){\n        this.rules[2] = new AttValue_rule(this)\n      }\n      rule = this.rules[2]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\nAttribute_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction ETag_rule(origin){\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // '</'\n  this.items = [\"'</'\", 'Name', 'S?', \"'>'\"]\n  this.rules = []\n  this.repeats = []\n}\n\nETag_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // '</'\n      if(! this.rules[0]){\n        this.rules[0] = new LITERAL(this, '</')\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 1, rule, char)\n    case 1: // Name\n      if(! this.rules[1]){\n        this.rules[1] = new Name_rule(this)\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 2, rule, char)\n    case 2: // S?\n      if(! this.rules[2]){\n        this.rules[2] = new S_rule(this)\n        this.repeats[2] = 0\n      }\n      rule = this.rules[2]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_zero_or_one(this, 2, 3, rule, char)\n    case 3: // '>'\n      if(! this.rules[3]){\n        this.rules[3] = new LITERAL(this, '>')\n      }\n      rule = this.rules[3]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\nETag_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction content_rule(origin){\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // CharData?\n  this.items = ['CharData?', 'tmp_34*']\n  this.rules = []\n  this.repeats = []\n}\n\ncontent_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // CharData?\n      if(! this.rules[0]){\n        this.rules[0] = new CharData_rule(this)\n        this.repeats[0] = 0\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_zero_or_one(this, 0, 1, rule, char)\n    case 1: // tmp_34*\n      if(! this.rules[1]){\n        this.rules[1] = new tmp_34_rule(this)\n        this.repeats[1] = 0\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_star(this, 1, -1, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\ncontent_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction tmp_33_rule(origin){\n  this.alt = true\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // element\n  this.items = ['element', 'Reference', 'CDSect', 'PI', 'Comment']\n  this.rules = []\n  this.repeats = []\n}\n\ntmp_33_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // element\n      if(! this.rules[0]){\n        this.rules[0] = new element_rule(this)\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_alt(this, 1, rule, char)\n    case 1: // Reference\n      if(! this.rules[1]){\n        this.rules[1] = new Reference_rule(this)\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_alt(this, 2, rule, char)\n    case 2: // CDSect\n      if(! this.rules[2]){\n        this.rules[2] = new CDSect_rule(this)\n      }\n      rule = this.rules[2]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_alt(this, 3, rule, char)\n    case 3: // PI\n      if(! this.rules[3]){\n        this.rules[3] = new PI_rule(this)\n      }\n      rule = this.rules[3]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_alt(this, 4, rule, char)\n    case 4: // Comment\n      if(! this.rules[4]){\n        this.rules[4] = new Comment_rule(this)\n      }\n      rule = this.rules[4]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\ntmp_33_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction tmp_34_rule(origin){\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // tmp_33\n  this.items = ['tmp_33', 'CharData?']\n  this.rules = []\n  this.repeats = []\n}\n\ntmp_34_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // tmp_33\n      if(! this.rules[0]){\n        this.rules[0] = new tmp_33_rule(this)\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 1, rule, char)\n    case 1: // CharData?\n      if(! this.rules[1]){\n        this.rules[1] = new CharData_rule(this)\n        this.repeats[1] = 0\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_zero_or_one(this, 1, -1, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\ntmp_34_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction EmptyElemTag_rule(origin){\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // '<'\n  this.items = [\"'<'\", 'Name', 'tmp_35*', 'S?', \"'/>'\"]\n  this.rules = []\n  this.repeats = []\n}\n\nEmptyElemTag_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // '<'\n      if(! this.rules[0]){\n        this.rules[0] = new LITERAL(this, '<')\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 1, rule, char)\n    case 1: // Name\n      if(! this.rules[1]){\n        this.rules[1] = new Name_rule(this)\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 2, rule, char)\n    case 2: // tmp_35*\n      if(! this.rules[2]){\n        this.rules[2] = new tmp_35_rule(this)\n        this.repeats[2] = 0\n      }\n      rule = this.rules[2]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_star(this, 2, 3, rule, char)\n    case 3: // S?\n      if(! this.rules[3]){\n        this.rules[3] = new S_rule(this)\n        this.repeats[3] = 0\n      }\n      rule = this.rules[3]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_zero_or_one(this, 3, 4, rule, char)\n    case 4: // '/>'\n      if(! this.rules[4]){\n        this.rules[4] = new LITERAL(this, '/>')\n      }\n      rule = this.rules[4]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\nEmptyElemTag_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction tmp_35_rule(origin){\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // S\n  this.items = ['S', 'Attribute']\n  this.rules = []\n  this.repeats = []\n}\n\ntmp_35_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // S\n      if(! this.rules[0]){\n        this.rules[0] = new S_rule(this)\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 1, rule, char)\n    case 1: // Attribute\n      if(! this.rules[1]){\n        this.rules[1] = new Attribute_rule(this)\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\ntmp_35_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction elementdecl_rule(origin){\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // '<!ELEMENT'\n  this.items = [\"'<!ELEMENT'\", 'S', 'Name', 'S', 'contentspec', 'S?', \"'>'\"]\n  this.rules = []\n  this.repeats = []\n}\n\nelementdecl_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // '<!ELEMENT'\n      if(! this.rules[0]){\n        this.rules[0] = new LITERAL(this, '<!ELEMENT')\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 1, rule, char)\n    case 1: // S\n      if(! this.rules[1]){\n        this.rules[1] = new S_rule(this)\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 2, rule, char)\n    case 2: // Name\n      if(! this.rules[2]){\n        this.rules[2] = new Name_rule(this)\n      }\n      rule = this.rules[2]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 3, rule, char)\n    case 3: // S\n      if(! this.rules[3]){\n        this.rules[3] = new S_rule(this)\n      }\n      rule = this.rules[3]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 4, rule, char)\n    case 4: // contentspec\n      if(! this.rules[4]){\n        this.rules[4] = new contentspec_rule(this)\n      }\n      rule = this.rules[4]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 5, rule, char)\n    case 5: // S?\n      if(! this.rules[5]){\n        this.rules[5] = new S_rule(this)\n        this.repeats[5] = 0\n      }\n      rule = this.rules[5]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_zero_or_one(this, 5, 6, rule, char)\n    case 6: // '>'\n      if(! this.rules[6]){\n        this.rules[6] = new LITERAL(this, '>')\n      }\n      rule = this.rules[6]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\nelementdecl_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction contentspec_rule(origin){\n  this.alt = true\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // 'EMPTY'\n  this.items = [\"'EMPTY'\", \"'ANY'\", 'Mixed', 'children']\n  this.rules = []\n  this.repeats = []\n}\n\ncontentspec_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // 'EMPTY'\n      if(! this.rules[0]){\n        this.rules[0] = new LITERAL(this, 'EMPTY')\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_alt(this, 1, rule, char)\n    case 1: // 'ANY'\n      if(! this.rules[1]){\n        this.rules[1] = new LITERAL(this, 'ANY')\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_alt(this, 2, rule, char)\n    case 2: // Mixed\n      if(! this.rules[2]){\n        this.rules[2] = new Mixed_rule(this)\n      }\n      rule = this.rules[2]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_alt(this, 3, rule, char)\n    case 3: // children\n      if(! this.rules[3]){\n        this.rules[3] = new children_rule(this)\n      }\n      rule = this.rules[3]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\ncontentspec_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction children_rule(origin){\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // tmp_37\n  this.items = ['tmp_37', 'tmp_36?']\n  this.rules = []\n  this.repeats = []\n}\n\nchildren_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // tmp_37\n      if(! this.rules[0]){\n        this.rules[0] = new tmp_37_rule(this)\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 1, rule, char)\n    case 1: // tmp_36?\n      if(! this.rules[1]){\n        this.rules[1] = new tmp_36_rule(this)\n        this.repeats[1] = 0\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_zero_or_one(this, 1, -1, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\nchildren_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction tmp_36_rule(origin){\n  this.alt = true\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // '?'\n  this.items = [\"'?'\", \"'*'\", \"'+'\"]\n  this.rules = []\n  this.repeats = []\n}\n\ntmp_36_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // '?'\n      if(! this.rules[0]){\n        this.rules[0] = new LITERAL(this, '?')\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_alt(this, 1, rule, char)\n    case 1: // '*'\n      if(! this.rules[1]){\n        this.rules[1] = new LITERAL(this, '*')\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_alt(this, 2, rule, char)\n    case 2: // '+'\n      if(! this.rules[2]){\n        this.rules[2] = new LITERAL(this, '+')\n      }\n      rule = this.rules[2]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\ntmp_36_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction tmp_37_rule(origin){\n  this.alt = true\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // choice\n  this.items = ['choice', 'seq']\n  this.rules = []\n  this.repeats = []\n}\n\ntmp_37_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // choice\n      if(! this.rules[0]){\n        this.rules[0] = new choice_rule(this)\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_alt(this, 1, rule, char)\n    case 1: // seq\n      if(! this.rules[1]){\n        this.rules[1] = new seq_rule(this)\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\ntmp_37_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction cp_rule(origin){\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // tmp_39\n  this.items = ['tmp_39', 'tmp_38?']\n  this.rules = []\n  this.repeats = []\n}\n\ncp_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // tmp_39\n      if(! this.rules[0]){\n        this.rules[0] = new tmp_39_rule(this)\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 1, rule, char)\n    case 1: // tmp_38?\n      if(! this.rules[1]){\n        this.rules[1] = new tmp_38_rule(this)\n        this.repeats[1] = 0\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_zero_or_one(this, 1, -1, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\ncp_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction tmp_38_rule(origin){\n  this.alt = true\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // '?'\n  this.items = [\"'?'\", \"'*'\", \"'+'\"]\n  this.rules = []\n  this.repeats = []\n}\n\ntmp_38_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // '?'\n      if(! this.rules[0]){\n        this.rules[0] = new LITERAL(this, '?')\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_alt(this, 1, rule, char)\n    case 1: // '*'\n      if(! this.rules[1]){\n        this.rules[1] = new LITERAL(this, '*')\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_alt(this, 2, rule, char)\n    case 2: // '+'\n      if(! this.rules[2]){\n        this.rules[2] = new LITERAL(this, '+')\n      }\n      rule = this.rules[2]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\ntmp_38_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction tmp_39_rule(origin){\n  this.alt = true\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // Name\n  this.items = ['Name', 'choice', 'seq']\n  this.rules = []\n  this.repeats = []\n}\n\ntmp_39_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // Name\n      if(! this.rules[0]){\n        this.rules[0] = new Name_rule(this)\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_alt(this, 1, rule, char)\n    case 1: // choice\n      if(! this.rules[1]){\n        this.rules[1] = new choice_rule(this)\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_alt(this, 2, rule, char)\n    case 2: // seq\n      if(! this.rules[2]){\n        this.rules[2] = new seq_rule(this)\n      }\n      rule = this.rules[2]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\ntmp_39_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction choice_rule(origin){\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // '('\n  this.items = [\"'('\", 'S?', 'cp', 'tmp_40+', 'S?', \"')'\"]\n  this.rules = []\n  this.repeats = []\n}\n\nchoice_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // '('\n      if(! this.rules[0]){\n        this.rules[0] = new LITERAL(this, '(')\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 1, rule, char)\n    case 1: // S?\n      if(! this.rules[1]){\n        this.rules[1] = new S_rule(this)\n        this.repeats[1] = 0\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_zero_or_one(this, 1, 2, rule, char)\n    case 2: // cp\n      if(! this.rules[2]){\n        this.rules[2] = new cp_rule(this)\n      }\n      rule = this.rules[2]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 3, rule, char)\n    case 3: // tmp_40+\n      if(! this.rules[3]){\n        this.rules[3] = new tmp_40_rule(this)\n        this.repeats[3] = 0\n      }\n      rule = this.rules[3]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_plus(this, 3,4, rule, char)\n    case 4: // S?\n      if(! this.rules[4]){\n        this.rules[4] = new S_rule(this)\n        this.repeats[4] = 0\n      }\n      rule = this.rules[4]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_zero_or_one(this, 4, 5, rule, char)\n    case 5: // ')'\n      if(! this.rules[5]){\n        this.rules[5] = new LITERAL(this, ')')\n      }\n      rule = this.rules[5]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\nchoice_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction tmp_40_rule(origin){\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // S?\n  this.items = ['S?', \"'|'\", 'S?', 'cp']\n  this.rules = []\n  this.repeats = []\n}\n\ntmp_40_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // S?\n      if(! this.rules[0]){\n        this.rules[0] = new S_rule(this)\n        this.repeats[0] = 0\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_zero_or_one(this, 0, 1, rule, char)\n    case 1: // '|'\n      if(! this.rules[1]){\n        this.rules[1] = new LITERAL(this, '|')\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 2, rule, char)\n    case 2: // S?\n      if(! this.rules[2]){\n        this.rules[2] = new S_rule(this)\n        this.repeats[2] = 0\n      }\n      rule = this.rules[2]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_zero_or_one(this, 2, 3, rule, char)\n    case 3: // cp\n      if(! this.rules[3]){\n        this.rules[3] = new cp_rule(this)\n      }\n      rule = this.rules[3]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\ntmp_40_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction seq_rule(origin){\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // '('\n  this.items = [\"'('\", 'S?', 'cp', 'tmp_41*', 'S?', \"')'\"]\n  this.rules = []\n  this.repeats = []\n}\n\nseq_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // '('\n      if(! this.rules[0]){\n        this.rules[0] = new LITERAL(this, '(')\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 1, rule, char)\n    case 1: // S?\n      if(! this.rules[1]){\n        this.rules[1] = new S_rule(this)\n        this.repeats[1] = 0\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_zero_or_one(this, 1, 2, rule, char)\n    case 2: // cp\n      if(! this.rules[2]){\n        this.rules[2] = new cp_rule(this)\n      }\n      rule = this.rules[2]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 3, rule, char)\n    case 3: // tmp_41*\n      if(! this.rules[3]){\n        this.rules[3] = new tmp_41_rule(this)\n        this.repeats[3] = 0\n      }\n      rule = this.rules[3]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_star(this, 3, 4, rule, char)\n    case 4: // S?\n      if(! this.rules[4]){\n        this.rules[4] = new S_rule(this)\n        this.repeats[4] = 0\n      }\n      rule = this.rules[4]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_zero_or_one(this, 4, 5, rule, char)\n    case 5: // ')'\n      if(! this.rules[5]){\n        this.rules[5] = new LITERAL(this, ')')\n      }\n      rule = this.rules[5]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\nseq_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction tmp_41_rule(origin){\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // S?\n  this.items = ['S?', \"','\", 'S?', 'cp']\n  this.rules = []\n  this.repeats = []\n}\n\ntmp_41_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // S?\n      if(! this.rules[0]){\n        this.rules[0] = new S_rule(this)\n        this.repeats[0] = 0\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_zero_or_one(this, 0, 1, rule, char)\n    case 1: // ','\n      if(! this.rules[1]){\n        this.rules[1] = new LITERAL(this, ',')\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 2, rule, char)\n    case 2: // S?\n      if(! this.rules[2]){\n        this.rules[2] = new S_rule(this)\n        this.repeats[2] = 0\n      }\n      rule = this.rules[2]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_zero_or_one(this, 2, 3, rule, char)\n    case 3: // cp\n      if(! this.rules[3]){\n        this.rules[3] = new cp_rule(this)\n      }\n      rule = this.rules[3]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\ntmp_41_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction Mixed_rule(origin){\n  this.alt = true\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // tmp_43\n  this.items = ['tmp_43', 'tmp_44']\n  this.rules = []\n  this.repeats = []\n}\n\nMixed_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // tmp_43\n      if(! this.rules[0]){\n        this.rules[0] = new tmp_43_rule(this)\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_alt(this, 1, rule, char)\n    case 1: // tmp_44\n      if(! this.rules[1]){\n        this.rules[1] = new tmp_44_rule(this)\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\nMixed_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction tmp_42_rule(origin){\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // S?\n  this.items = ['S?', \"'|'\", 'S?', 'Name']\n  this.rules = []\n  this.repeats = []\n}\n\ntmp_42_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // S?\n      if(! this.rules[0]){\n        this.rules[0] = new S_rule(this)\n        this.repeats[0] = 0\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_zero_or_one(this, 0, 1, rule, char)\n    case 1: // '|'\n      if(! this.rules[1]){\n        this.rules[1] = new LITERAL(this, '|')\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 2, rule, char)\n    case 2: // S?\n      if(! this.rules[2]){\n        this.rules[2] = new S_rule(this)\n        this.repeats[2] = 0\n      }\n      rule = this.rules[2]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_zero_or_one(this, 2, 3, rule, char)\n    case 3: // Name\n      if(! this.rules[3]){\n        this.rules[3] = new Name_rule(this)\n      }\n      rule = this.rules[3]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\ntmp_42_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction tmp_43_rule(origin){\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // '('\n  this.items = [\"'('\", 'S?', \"'#PCDATA'\", 'tmp_42*', 'S?', \"')*'\"]\n  this.rules = []\n  this.repeats = []\n}\n\ntmp_43_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // '('\n      if(! this.rules[0]){\n        this.rules[0] = new LITERAL(this, '(')\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 1, rule, char)\n    case 1: // S?\n      if(! this.rules[1]){\n        this.rules[1] = new S_rule(this)\n        this.repeats[1] = 0\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_zero_or_one(this, 1, 2, rule, char)\n    case 2: // '#PCDATA'\n      if(! this.rules[2]){\n        this.rules[2] = new LITERAL(this, '#PCDATA')\n      }\n      rule = this.rules[2]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 3, rule, char)\n    case 3: // tmp_42*\n      if(! this.rules[3]){\n        this.rules[3] = new tmp_42_rule(this)\n        this.repeats[3] = 0\n      }\n      rule = this.rules[3]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_star(this, 3, 4, rule, char)\n    case 4: // S?\n      if(! this.rules[4]){\n        this.rules[4] = new S_rule(this)\n        this.repeats[4] = 0\n      }\n      rule = this.rules[4]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_zero_or_one(this, 4, 5, rule, char)\n    case 5: // ')*'\n      if(! this.rules[5]){\n        this.rules[5] = new LITERAL(this, ')*')\n      }\n      rule = this.rules[5]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\ntmp_43_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction tmp_44_rule(origin){\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // '('\n  this.items = [\"'('\", 'S?', \"'#PCDATA'\", 'S?', \"')'\"]\n  this.rules = []\n  this.repeats = []\n}\n\ntmp_44_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // '('\n      if(! this.rules[0]){\n        this.rules[0] = new LITERAL(this, '(')\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 1, rule, char)\n    case 1: // S?\n      if(! this.rules[1]){\n        this.rules[1] = new S_rule(this)\n        this.repeats[1] = 0\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_zero_or_one(this, 1, 2, rule, char)\n    case 2: // '#PCDATA'\n      if(! this.rules[2]){\n        this.rules[2] = new LITERAL(this, '#PCDATA')\n      }\n      rule = this.rules[2]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 3, rule, char)\n    case 3: // S?\n      if(! this.rules[3]){\n        this.rules[3] = new S_rule(this)\n        this.repeats[3] = 0\n      }\n      rule = this.rules[3]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_zero_or_one(this, 3, 4, rule, char)\n    case 4: // ')'\n      if(! this.rules[4]){\n        this.rules[4] = new LITERAL(this, ')')\n      }\n      rule = this.rules[4]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\ntmp_44_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction AttlistDecl_rule(origin){\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // '<!ATTLIST'\n  this.items = [\"'<!ATTLIST'\", 'S', 'Name', 'AttDef*', 'S?', \"'>'\"]\n  this.rules = []\n  this.repeats = []\n}\n\nAttlistDecl_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // '<!ATTLIST'\n      if(! this.rules[0]){\n        this.rules[0] = new LITERAL(this, '<!ATTLIST')\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 1, rule, char)\n    case 1: // S\n      if(! this.rules[1]){\n        this.rules[1] = new S_rule(this)\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 2, rule, char)\n    case 2: // Name\n      if(! this.rules[2]){\n        this.rules[2] = new Name_rule(this)\n      }\n      rule = this.rules[2]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 3, rule, char)\n    case 3: // AttDef*\n      if(! this.rules[3]){\n        this.rules[3] = new AttDef_rule(this)\n        this.repeats[3] = 0\n      }\n      rule = this.rules[3]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_star(this, 3, 4, rule, char)\n    case 4: // S?\n      if(! this.rules[4]){\n        this.rules[4] = new S_rule(this)\n        this.repeats[4] = 0\n      }\n      rule = this.rules[4]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_zero_or_one(this, 4, 5, rule, char)\n    case 5: // '>'\n      if(! this.rules[5]){\n        this.rules[5] = new LITERAL(this, '>')\n      }\n      rule = this.rules[5]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\nAttlistDecl_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction AttDef_rule(origin){\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // S\n  this.items = ['S', 'Name', 'S', 'AttType', 'S', 'DefaultDecl']\n  this.rules = []\n  this.repeats = []\n}\n\nAttDef_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // S\n      if(! this.rules[0]){\n        this.rules[0] = new S_rule(this)\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 1, rule, char)\n    case 1: // Name\n      if(! this.rules[1]){\n        this.rules[1] = new Name_rule(this)\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 2, rule, char)\n    case 2: // S\n      if(! this.rules[2]){\n        this.rules[2] = new S_rule(this)\n      }\n      rule = this.rules[2]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 3, rule, char)\n    case 3: // AttType\n      if(! this.rules[3]){\n        this.rules[3] = new AttType_rule(this)\n      }\n      rule = this.rules[3]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 4, rule, char)\n    case 4: // S\n      if(! this.rules[4]){\n        this.rules[4] = new S_rule(this)\n      }\n      rule = this.rules[4]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 5, rule, char)\n    case 5: // DefaultDecl\n      if(! this.rules[5]){\n        this.rules[5] = new DefaultDecl_rule(this)\n      }\n      rule = this.rules[5]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\nAttDef_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction AttType_rule(origin){\n  this.alt = true\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // StringType\n  this.items = ['StringType', 'TokenizedType', 'EnumeratedType']\n  this.rules = []\n  this.repeats = []\n}\n\nAttType_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // StringType\n      if(! this.rules[0]){\n        this.rules[0] = new StringType_rule(this)\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_alt(this, 1, rule, char)\n    case 1: // TokenizedType\n      if(! this.rules[1]){\n        this.rules[1] = new TokenizedType_rule(this)\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_alt(this, 2, rule, char)\n    case 2: // EnumeratedType\n      if(! this.rules[2]){\n        this.rules[2] = new EnumeratedType_rule(this)\n      }\n      rule = this.rules[2]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\nAttType_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction StringType_rule(origin){\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // 'CDATA'\n  this.items = [\"'CDATA'\"]\n  this.rules = []\n  this.repeats = []\n}\n\nStringType_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // 'CDATA'\n      if(! this.rules[0]){\n        this.rules[0] = new LITERAL(this, 'CDATA')\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\nStringType_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction TokenizedType_rule(origin){\n  this.alt = true\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // 'ID'\n  this.items = [\"'ID'\", \"'IDREF'\", \"'IDREFS'\", \"'ENTITY'\", \"'ENTITIES'\", \"'NMTOKEN'\", \"'NMTOKENS'\"]\n  this.rules = []\n  this.repeats = []\n}\n\nTokenizedType_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // 'ID'\n      if(! this.rules[0]){\n        this.rules[0] = new LITERAL(this, 'ID')\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_alt(this, 1, rule, char)\n    case 1: // 'IDREF'\n      if(! this.rules[1]){\n        this.rules[1] = new LITERAL(this, 'IDREF')\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_alt(this, 2, rule, char)\n    case 2: // 'IDREFS'\n      if(! this.rules[2]){\n        this.rules[2] = new LITERAL(this, 'IDREFS')\n      }\n      rule = this.rules[2]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_alt(this, 3, rule, char)\n    case 3: // 'ENTITY'\n      if(! this.rules[3]){\n        this.rules[3] = new LITERAL(this, 'ENTITY')\n      }\n      rule = this.rules[3]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_alt(this, 4, rule, char)\n    case 4: // 'ENTITIES'\n      if(! this.rules[4]){\n        this.rules[4] = new LITERAL(this, 'ENTITIES')\n      }\n      rule = this.rules[4]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_alt(this, 5, rule, char)\n    case 5: // 'NMTOKEN'\n      if(! this.rules[5]){\n        this.rules[5] = new LITERAL(this, 'NMTOKEN')\n      }\n      rule = this.rules[5]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_alt(this, 6, rule, char)\n    case 6: // 'NMTOKENS'\n      if(! this.rules[6]){\n        this.rules[6] = new LITERAL(this, 'NMTOKENS')\n      }\n      rule = this.rules[6]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\nTokenizedType_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction EnumeratedType_rule(origin){\n  this.alt = true\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // NotationType\n  this.items = ['NotationType', 'Enumeration']\n  this.rules = []\n  this.repeats = []\n}\n\nEnumeratedType_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // NotationType\n      if(! this.rules[0]){\n        this.rules[0] = new NotationType_rule(this)\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_alt(this, 1, rule, char)\n    case 1: // Enumeration\n      if(! this.rules[1]){\n        this.rules[1] = new Enumeration_rule(this)\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\nEnumeratedType_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction NotationType_rule(origin){\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // 'NOTATION'\n  this.items = [\"'NOTATION'\", 'S', \"'('\", 'S?', 'Name', 'tmp_45*', 'S?', \"')'\"]\n  this.rules = []\n  this.repeats = []\n}\n\nNotationType_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // 'NOTATION'\n      if(! this.rules[0]){\n        this.rules[0] = new LITERAL(this, 'NOTATION')\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 1, rule, char)\n    case 1: // S\n      if(! this.rules[1]){\n        this.rules[1] = new S_rule(this)\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 2, rule, char)\n    case 2: // '('\n      if(! this.rules[2]){\n        this.rules[2] = new LITERAL(this, '(')\n      }\n      rule = this.rules[2]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 3, rule, char)\n    case 3: // S?\n      if(! this.rules[3]){\n        this.rules[3] = new S_rule(this)\n        this.repeats[3] = 0\n      }\n      rule = this.rules[3]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_zero_or_one(this, 3, 4, rule, char)\n    case 4: // Name\n      if(! this.rules[4]){\n        this.rules[4] = new Name_rule(this)\n      }\n      rule = this.rules[4]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 5, rule, char)\n    case 5: // tmp_45*\n      if(! this.rules[5]){\n        this.rules[5] = new tmp_45_rule(this)\n        this.repeats[5] = 0\n      }\n      rule = this.rules[5]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_star(this, 5, 6, rule, char)\n    case 6: // S?\n      if(! this.rules[6]){\n        this.rules[6] = new S_rule(this)\n        this.repeats[6] = 0\n      }\n      rule = this.rules[6]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_zero_or_one(this, 6, 7, rule, char)\n    case 7: // ')'\n      if(! this.rules[7]){\n        this.rules[7] = new LITERAL(this, ')')\n      }\n      rule = this.rules[7]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\nNotationType_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction tmp_45_rule(origin){\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // S?\n  this.items = ['S?', \"'|'\", 'S?', 'Name']\n  this.rules = []\n  this.repeats = []\n}\n\ntmp_45_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // S?\n      if(! this.rules[0]){\n        this.rules[0] = new S_rule(this)\n        this.repeats[0] = 0\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_zero_or_one(this, 0, 1, rule, char)\n    case 1: // '|'\n      if(! this.rules[1]){\n        this.rules[1] = new LITERAL(this, '|')\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 2, rule, char)\n    case 2: // S?\n      if(! this.rules[2]){\n        this.rules[2] = new S_rule(this)\n        this.repeats[2] = 0\n      }\n      rule = this.rules[2]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_zero_or_one(this, 2, 3, rule, char)\n    case 3: // Name\n      if(! this.rules[3]){\n        this.rules[3] = new Name_rule(this)\n      }\n      rule = this.rules[3]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\ntmp_45_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction Enumeration_rule(origin){\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // '('\n  this.items = [\"'('\", 'S?', 'Nmtoken', 'tmp_46*', 'S?', \"')'\"]\n  this.rules = []\n  this.repeats = []\n}\n\nEnumeration_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // '('\n      if(! this.rules[0]){\n        this.rules[0] = new LITERAL(this, '(')\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 1, rule, char)\n    case 1: // S?\n      if(! this.rules[1]){\n        this.rules[1] = new S_rule(this)\n        this.repeats[1] = 0\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_zero_or_one(this, 1, 2, rule, char)\n    case 2: // Nmtoken\n      if(! this.rules[2]){\n        this.rules[2] = new Nmtoken_rule(this)\n      }\n      rule = this.rules[2]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 3, rule, char)\n    case 3: // tmp_46*\n      if(! this.rules[3]){\n        this.rules[3] = new tmp_46_rule(this)\n        this.repeats[3] = 0\n      }\n      rule = this.rules[3]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_star(this, 3, 4, rule, char)\n    case 4: // S?\n      if(! this.rules[4]){\n        this.rules[4] = new S_rule(this)\n        this.repeats[4] = 0\n      }\n      rule = this.rules[4]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_zero_or_one(this, 4, 5, rule, char)\n    case 5: // ')'\n      if(! this.rules[5]){\n        this.rules[5] = new LITERAL(this, ')')\n      }\n      rule = this.rules[5]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\nEnumeration_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction tmp_46_rule(origin){\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // S?\n  this.items = ['S?', \"'|'\", 'S?', 'Nmtoken']\n  this.rules = []\n  this.repeats = []\n}\n\ntmp_46_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // S?\n      if(! this.rules[0]){\n        this.rules[0] = new S_rule(this)\n        this.repeats[0] = 0\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_zero_or_one(this, 0, 1, rule, char)\n    case 1: // '|'\n      if(! this.rules[1]){\n        this.rules[1] = new LITERAL(this, '|')\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 2, rule, char)\n    case 2: // S?\n      if(! this.rules[2]){\n        this.rules[2] = new S_rule(this)\n        this.repeats[2] = 0\n      }\n      rule = this.rules[2]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_zero_or_one(this, 2, 3, rule, char)\n    case 3: // Nmtoken\n      if(! this.rules[3]){\n        this.rules[3] = new Nmtoken_rule(this)\n      }\n      rule = this.rules[3]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\ntmp_46_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction DefaultDecl_rule(origin){\n  this.alt = true\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // '#REQUIRED'\n  this.items = [\"'#REQUIRED'\", \"'#IMPLIED'\", 'tmp_48']\n  this.rules = []\n  this.repeats = []\n}\n\nDefaultDecl_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // '#REQUIRED'\n      if(! this.rules[0]){\n        this.rules[0] = new LITERAL(this, '#REQUIRED')\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_alt(this, 1, rule, char)\n    case 1: // '#IMPLIED'\n      if(! this.rules[1]){\n        this.rules[1] = new LITERAL(this, '#IMPLIED')\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_alt(this, 2, rule, char)\n    case 2: // tmp_48\n      if(! this.rules[2]){\n        this.rules[2] = new tmp_48_rule(this)\n      }\n      rule = this.rules[2]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\nDefaultDecl_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction tmp_47_rule(origin){\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // '#FIXED'\n  this.items = [\"'#FIXED'\", 'S']\n  this.rules = []\n  this.repeats = []\n}\n\ntmp_47_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // '#FIXED'\n      if(! this.rules[0]){\n        this.rules[0] = new LITERAL(this, '#FIXED')\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 1, rule, char)\n    case 1: // S\n      if(! this.rules[1]){\n        this.rules[1] = new S_rule(this)\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\ntmp_47_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction tmp_48_rule(origin){\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // tmp_47?\n  this.items = ['tmp_47?', 'AttValue']\n  this.rules = []\n  this.repeats = []\n}\n\ntmp_48_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // tmp_47?\n      if(! this.rules[0]){\n        this.rules[0] = new tmp_47_rule(this)\n        this.repeats[0] = 0\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_zero_or_one(this, 0, 1, rule, char)\n    case 1: // AttValue\n      if(! this.rules[1]){\n        this.rules[1] = new AttValue_rule(this)\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\ntmp_48_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction conditionalSect_rule(origin){\n  this.alt = true\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // includeSect\n  this.items = ['includeSect', 'ignoreSect']\n  this.rules = []\n  this.repeats = []\n}\n\nconditionalSect_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // includeSect\n      if(! this.rules[0]){\n        this.rules[0] = new includeSect_rule(this)\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_alt(this, 1, rule, char)\n    case 1: // ignoreSect\n      if(! this.rules[1]){\n        this.rules[1] = new ignoreSect_rule(this)\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\nconditionalSect_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction includeSect_rule(origin){\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // '<!['\n  this.items = [\"'<!['\", 'S?', \"'INCLUDE'\", 'S?', \"'['\", 'extSubsetDecl', \"']]>'\"]\n  this.rules = []\n  this.repeats = []\n}\n\nincludeSect_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // '<!['\n      if(! this.rules[0]){\n        this.rules[0] = new LITERAL(this, '<![')\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 1, rule, char)\n    case 1: // S?\n      if(! this.rules[1]){\n        this.rules[1] = new S_rule(this)\n        this.repeats[1] = 0\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_zero_or_one(this, 1, 2, rule, char)\n    case 2: // 'INCLUDE'\n      if(! this.rules[2]){\n        this.rules[2] = new LITERAL(this, 'INCLUDE')\n      }\n      rule = this.rules[2]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 3, rule, char)\n    case 3: // S?\n      if(! this.rules[3]){\n        this.rules[3] = new S_rule(this)\n        this.repeats[3] = 0\n      }\n      rule = this.rules[3]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_zero_or_one(this, 3, 4, rule, char)\n    case 4: // '['\n      if(! this.rules[4]){\n        this.rules[4] = new LITERAL(this, '[')\n      }\n      rule = this.rules[4]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 5, rule, char)\n    case 5: // extSubsetDecl\n      if(! this.rules[5]){\n        this.rules[5] = new extSubsetDecl_rule(this)\n      }\n      rule = this.rules[5]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 6, rule, char)\n    case 6: // ']]>'\n      if(! this.rules[6]){\n        this.rules[6] = new LITERAL(this, ']]>')\n      }\n      rule = this.rules[6]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\nincludeSect_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction ignoreSect_rule(origin){\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // '<!['\n  this.items = [\"'<!['\", 'S?', \"'IGNORE'\", 'S?', \"'['\", 'ignoreSectContents*', \"']]>'\"]\n  this.rules = []\n  this.repeats = []\n}\n\nignoreSect_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // '<!['\n      if(! this.rules[0]){\n        this.rules[0] = new LITERAL(this, '<![')\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 1, rule, char)\n    case 1: // S?\n      if(! this.rules[1]){\n        this.rules[1] = new S_rule(this)\n        this.repeats[1] = 0\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_zero_or_one(this, 1, 2, rule, char)\n    case 2: // 'IGNORE'\n      if(! this.rules[2]){\n        this.rules[2] = new LITERAL(this, 'IGNORE')\n      }\n      rule = this.rules[2]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 3, rule, char)\n    case 3: // S?\n      if(! this.rules[3]){\n        this.rules[3] = new S_rule(this)\n        this.repeats[3] = 0\n      }\n      rule = this.rules[3]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_zero_or_one(this, 3, 4, rule, char)\n    case 4: // '['\n      if(! this.rules[4]){\n        this.rules[4] = new LITERAL(this, '[')\n      }\n      rule = this.rules[4]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 5, rule, char)\n    case 5: // ignoreSectContents*\n      if(! this.rules[5]){\n        this.rules[5] = new ignoreSectContents_rule(this)\n        this.repeats[5] = 0\n      }\n      rule = this.rules[5]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_star(this, 5, 6, rule, char)\n    case 6: // ']]>'\n      if(! this.rules[6]){\n        this.rules[6] = new LITERAL(this, ']]>')\n      }\n      rule = this.rules[6]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\nignoreSect_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction ignoreSectContents_rule(origin){\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // Ignore\n  this.items = ['Ignore', 'tmp_49*']\n  this.rules = []\n  this.repeats = []\n}\n\nignoreSectContents_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // Ignore\n      if(! this.rules[0]){\n        this.rules[0] = new Ignore_rule(this)\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 1, rule, char)\n    case 1: // tmp_49*\n      if(! this.rules[1]){\n        this.rules[1] = new tmp_49_rule(this)\n        this.repeats[1] = 0\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_star(this, 1, -1, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\nignoreSectContents_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction tmp_49_rule(origin){\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // '<!['\n  this.items = [\"'<!['\", 'ignoreSectContents', \"']]>'\", 'Ignore']\n  this.rules = []\n  this.repeats = []\n}\n\ntmp_49_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // '<!['\n      if(! this.rules[0]){\n        this.rules[0] = new LITERAL(this, '<![')\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 1, rule, char)\n    case 1: // ignoreSectContents\n      if(! this.rules[1]){\n        this.rules[1] = new ignoreSectContents_rule(this)\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 2, rule, char)\n    case 2: // ']]>'\n      if(! this.rules[2]){\n        this.rules[2] = new LITERAL(this, ']]>')\n      }\n      rule = this.rules[2]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 3, rule, char)\n    case 3: // Ignore\n      if(! this.rules[3]){\n        this.rules[3] = new Ignore_rule(this)\n      }\n      rule = this.rules[3]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\ntmp_49_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction CharRef_rule(origin){\n  this.alt = true\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // tmp_50\n  this.items = ['tmp_50', 'tmp_51']\n  this.rules = []\n  this.repeats = []\n}\n\nCharRef_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // tmp_50\n      if(! this.rules[0]){\n        this.rules[0] = new tmp_50_rule(this)\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_alt(this, 1, rule, char)\n    case 1: // tmp_51\n      if(! this.rules[1]){\n        this.rules[1] = new tmp_51_rule(this)\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\nCharRef_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction tmp_50_rule(origin){\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // '&#'\n  this.items = [\"'&#'\", '[0-9]', \"';'\"]\n  this.rules = []\n  this.repeats = []\n}\n\ntmp_50_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // '&#'\n      if(! this.rules[0]){\n        this.rules[0] = new LITERAL(this, '&#')\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 1, rule, char)\n    case 1: // [0-9]\n      if(! this.rules[1]){\n        this.rules[1] = new CHARSET_rule(this, '0-9')\n        this.repeats[1] = 0\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_plus(this, 1,2, rule, char)\n    case 2: // ';'\n      if(! this.rules[2]){\n        this.rules[2] = new LITERAL(this, ';')\n      }\n      rule = this.rules[2]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\ntmp_50_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction tmp_51_rule(origin){\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // '&#x'\n  this.items = [\"'&#x'\", '[0-9a-fA-F]', \"';'\"]\n  this.rules = []\n  this.repeats = []\n}\n\ntmp_51_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // '&#x'\n      if(! this.rules[0]){\n        this.rules[0] = new LITERAL(this, '&#x')\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 1, rule, char)\n    case 1: // [0-9a-fA-F]\n      if(! this.rules[1]){\n        this.rules[1] = new CHARSET_rule(this, '0-9a-fA-F')\n        this.repeats[1] = 0\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_plus(this, 1,2, rule, char)\n    case 2: // ';'\n      if(! this.rules[2]){\n        this.rules[2] = new LITERAL(this, ';')\n      }\n      rule = this.rules[2]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\ntmp_51_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction Reference_rule(origin){\n  this.alt = true\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // EntityRef\n  this.items = ['EntityRef', 'CharRef']\n  this.rules = []\n  this.repeats = []\n}\n\nReference_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // EntityRef\n      if(! this.rules[0]){\n        this.rules[0] = new EntityRef_rule(this)\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_alt(this, 1, rule, char)\n    case 1: // CharRef\n      if(! this.rules[1]){\n        this.rules[1] = new CharRef_rule(this)\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\nReference_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction EntityRef_rule(origin){\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // '&'\n  this.items = [\"'&'\", 'Name', \"';'\"]\n  this.rules = []\n  this.repeats = []\n}\n\nEntityRef_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // '&'\n      if(! this.rules[0]){\n        this.rules[0] = new LITERAL(this, '&')\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 1, rule, char)\n    case 1: // Name\n      if(! this.rules[1]){\n        this.rules[1] = new Name_rule(this)\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 2, rule, char)\n    case 2: // ';'\n      if(! this.rules[2]){\n        this.rules[2] = new LITERAL(this, ';')\n      }\n      rule = this.rules[2]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\nEntityRef_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction PEReference_rule(origin){\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // '%'\n  this.items = [\"'%'\", 'Name', \"';'\"]\n  this.rules = []\n  this.repeats = []\n}\n\nPEReference_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // '%'\n      if(! this.rules[0]){\n        this.rules[0] = new LITERAL(this, '%')\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 1, rule, char)\n    case 1: // Name\n      if(! this.rules[1]){\n        this.rules[1] = new Name_rule(this)\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 2, rule, char)\n    case 2: // ';'\n      if(! this.rules[2]){\n        this.rules[2] = new LITERAL(this, ';')\n      }\n      rule = this.rules[2]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\nPEReference_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction EntityDecl_rule(origin){\n  this.alt = true\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // GEDecl\n  this.items = ['GEDecl', 'PEDecl']\n  this.rules = []\n  this.repeats = []\n}\n\nEntityDecl_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // GEDecl\n      if(! this.rules[0]){\n        this.rules[0] = new GEDecl_rule(this)\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_alt(this, 1, rule, char)\n    case 1: // PEDecl\n      if(! this.rules[1]){\n        this.rules[1] = new PEDecl_rule(this)\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\nEntityDecl_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction GEDecl_rule(origin){\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // '<!ENTITY'\n  this.items = [\"'<!ENTITY'\", 'S', 'Name', 'S', 'EntityDef', 'S?', \"'>'\"]\n  this.rules = []\n  this.repeats = []\n}\n\nGEDecl_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // '<!ENTITY'\n      if(! this.rules[0]){\n        this.rules[0] = new LITERAL(this, '<!ENTITY')\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 1, rule, char)\n    case 1: // S\n      if(! this.rules[1]){\n        this.rules[1] = new S_rule(this)\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 2, rule, char)\n    case 2: // Name\n      if(! this.rules[2]){\n        this.rules[2] = new Name_rule(this)\n      }\n      rule = this.rules[2]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 3, rule, char)\n    case 3: // S\n      if(! this.rules[3]){\n        this.rules[3] = new S_rule(this)\n      }\n      rule = this.rules[3]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 4, rule, char)\n    case 4: // EntityDef\n      if(! this.rules[4]){\n        this.rules[4] = new EntityDef_rule(this)\n      }\n      rule = this.rules[4]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 5, rule, char)\n    case 5: // S?\n      if(! this.rules[5]){\n        this.rules[5] = new S_rule(this)\n        this.repeats[5] = 0\n      }\n      rule = this.rules[5]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_zero_or_one(this, 5, 6, rule, char)\n    case 6: // '>'\n      if(! this.rules[6]){\n        this.rules[6] = new LITERAL(this, '>')\n      }\n      rule = this.rules[6]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\nGEDecl_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction PEDecl_rule(origin){\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // '<!ENTITY'\n  this.items = [\"'<!ENTITY'\", 'S', \"'%'\", 'S', 'Name', 'S', 'PEDef', 'S?', \"'>'\"]\n  this.rules = []\n  this.repeats = []\n}\n\nPEDecl_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // '<!ENTITY'\n      if(! this.rules[0]){\n        this.rules[0] = new LITERAL(this, '<!ENTITY')\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 1, rule, char)\n    case 1: // S\n      if(! this.rules[1]){\n        this.rules[1] = new S_rule(this)\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 2, rule, char)\n    case 2: // '%'\n      if(! this.rules[2]){\n        this.rules[2] = new LITERAL(this, '%')\n      }\n      rule = this.rules[2]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 3, rule, char)\n    case 3: // S\n      if(! this.rules[3]){\n        this.rules[3] = new S_rule(this)\n      }\n      rule = this.rules[3]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 4, rule, char)\n    case 4: // Name\n      if(! this.rules[4]){\n        this.rules[4] = new Name_rule(this)\n      }\n      rule = this.rules[4]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 5, rule, char)\n    case 5: // S\n      if(! this.rules[5]){\n        this.rules[5] = new S_rule(this)\n      }\n      rule = this.rules[5]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 6, rule, char)\n    case 6: // PEDef\n      if(! this.rules[6]){\n        this.rules[6] = new PEDef_rule(this)\n      }\n      rule = this.rules[6]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 7, rule, char)\n    case 7: // S?\n      if(! this.rules[7]){\n        this.rules[7] = new S_rule(this)\n        this.repeats[7] = 0\n      }\n      rule = this.rules[7]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_zero_or_one(this, 7, 8, rule, char)\n    case 8: // '>'\n      if(! this.rules[8]){\n        this.rules[8] = new LITERAL(this, '>')\n      }\n      rule = this.rules[8]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\nPEDecl_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction EntityDef_rule(origin){\n  this.alt = true\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // EntityValue\n  this.items = ['EntityValue', 'tmp_52']\n  this.rules = []\n  this.repeats = []\n}\n\nEntityDef_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // EntityValue\n      if(! this.rules[0]){\n        this.rules[0] = new EntityValue_rule(this)\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_alt(this, 1, rule, char)\n    case 1: // tmp_52\n      if(! this.rules[1]){\n        this.rules[1] = new tmp_52_rule(this)\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\nEntityDef_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction tmp_52_rule(origin){\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // ExternalID\n  this.items = ['ExternalID', 'NDataDecl?']\n  this.rules = []\n  this.repeats = []\n}\n\ntmp_52_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // ExternalID\n      if(! this.rules[0]){\n        this.rules[0] = new ExternalID_rule(this)\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 1, rule, char)\n    case 1: // NDataDecl?\n      if(! this.rules[1]){\n        this.rules[1] = new NDataDecl_rule(this)\n        this.repeats[1] = 0\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_zero_or_one(this, 1, -1, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\ntmp_52_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction PEDef_rule(origin){\n  this.alt = true\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // EntityValue\n  this.items = ['EntityValue', 'ExternalID']\n  this.rules = []\n  this.repeats = []\n}\n\nPEDef_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // EntityValue\n      if(! this.rules[0]){\n        this.rules[0] = new EntityValue_rule(this)\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_alt(this, 1, rule, char)\n    case 1: // ExternalID\n      if(! this.rules[1]){\n        this.rules[1] = new ExternalID_rule(this)\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\nPEDef_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction ExternalID_rule(origin){\n  this.alt = true\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // tmp_53\n  this.items = ['tmp_53', 'tmp_54']\n  this.rules = []\n  this.repeats = []\n}\n\nExternalID_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // tmp_53\n      if(! this.rules[0]){\n        this.rules[0] = new tmp_53_rule(this)\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_alt(this, 1, rule, char)\n    case 1: // tmp_54\n      if(! this.rules[1]){\n        this.rules[1] = new tmp_54_rule(this)\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\nExternalID_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction tmp_53_rule(origin){\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // 'SYSTEM'\n  this.items = [\"'SYSTEM'\", 'S', 'SystemLiteral']\n  this.rules = []\n  this.repeats = []\n}\n\ntmp_53_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // 'SYSTEM'\n      if(! this.rules[0]){\n        this.rules[0] = new LITERAL(this, 'SYSTEM')\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 1, rule, char)\n    case 1: // S\n      if(! this.rules[1]){\n        this.rules[1] = new S_rule(this)\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 2, rule, char)\n    case 2: // SystemLiteral\n      if(! this.rules[2]){\n        this.rules[2] = new SystemLiteral_rule(this)\n      }\n      rule = this.rules[2]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\ntmp_53_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction tmp_54_rule(origin){\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // 'PUBLIC'\n  this.items = [\"'PUBLIC'\", 'S', 'PubidLiteral', 'S', 'SystemLiteral']\n  this.rules = []\n  this.repeats = []\n}\n\ntmp_54_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // 'PUBLIC'\n      if(! this.rules[0]){\n        this.rules[0] = new LITERAL(this, 'PUBLIC')\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 1, rule, char)\n    case 1: // S\n      if(! this.rules[1]){\n        this.rules[1] = new S_rule(this)\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 2, rule, char)\n    case 2: // PubidLiteral\n      if(! this.rules[2]){\n        this.rules[2] = new PubidLiteral_rule(this)\n      }\n      rule = this.rules[2]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 3, rule, char)\n    case 3: // S\n      if(! this.rules[3]){\n        this.rules[3] = new S_rule(this)\n      }\n      rule = this.rules[3]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 4, rule, char)\n    case 4: // SystemLiteral\n      if(! this.rules[4]){\n        this.rules[4] = new SystemLiteral_rule(this)\n      }\n      rule = this.rules[4]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\ntmp_54_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction NDataDecl_rule(origin){\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // S\n  this.items = ['S', \"'NDATA'\", 'S', 'Name']\n  this.rules = []\n  this.repeats = []\n}\n\nNDataDecl_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // S\n      if(! this.rules[0]){\n        this.rules[0] = new S_rule(this)\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 1, rule, char)\n    case 1: // 'NDATA'\n      if(! this.rules[1]){\n        this.rules[1] = new LITERAL(this, 'NDATA')\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 2, rule, char)\n    case 2: // S\n      if(! this.rules[2]){\n        this.rules[2] = new S_rule(this)\n      }\n      rule = this.rules[2]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 3, rule, char)\n    case 3: // Name\n      if(! this.rules[3]){\n        this.rules[3] = new Name_rule(this)\n      }\n      rule = this.rules[3]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\nNDataDecl_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction TextDecl_rule(origin){\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // '<?xml'\n  this.items = [\"'<?xml'\", 'VersionInfo?', 'EncodingDecl', 'S?', \"'?>'\"]\n  this.rules = []\n  this.repeats = []\n}\n\nTextDecl_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // '<?xml'\n      if(! this.rules[0]){\n        this.rules[0] = new LITERAL(this, '<?xml')\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 1, rule, char)\n    case 1: // VersionInfo?\n      if(! this.rules[1]){\n        this.rules[1] = new VersionInfo_rule(this)\n        this.repeats[1] = 0\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_zero_or_one(this, 1, 2, rule, char)\n    case 2: // EncodingDecl\n      if(! this.rules[2]){\n        this.rules[2] = new EncodingDecl_rule(this)\n      }\n      rule = this.rules[2]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 3, rule, char)\n    case 3: // S?\n      if(! this.rules[3]){\n        this.rules[3] = new S_rule(this)\n        this.repeats[3] = 0\n      }\n      rule = this.rules[3]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_zero_or_one(this, 3, 4, rule, char)\n    case 4: // '?>'\n      if(! this.rules[4]){\n        this.rules[4] = new LITERAL(this, '?>')\n      }\n      rule = this.rules[4]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\nTextDecl_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction extParsedEnt_rule(origin){\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // TextDecl?\n  this.items = ['TextDecl?', 'content']\n  this.rules = []\n  this.repeats = []\n}\n\nextParsedEnt_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // TextDecl?\n      if(! this.rules[0]){\n        this.rules[0] = new TextDecl_rule(this)\n        this.repeats[0] = 0\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_zero_or_one(this, 0, 1, rule, char)\n    case 1: // content\n      if(! this.rules[1]){\n        this.rules[1] = new content_rule(this)\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\nextParsedEnt_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction EncodingDecl_rule(origin){\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // S\n  this.items = ['S', \"'encoding'\", 'Eq', 'tmp_55']\n  this.rules = []\n  this.repeats = []\n}\n\nEncodingDecl_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // S\n      if(! this.rules[0]){\n        this.rules[0] = new S_rule(this)\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 1, rule, char)\n    case 1: // 'encoding'\n      if(! this.rules[1]){\n        this.rules[1] = new LITERAL(this, 'encoding')\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 2, rule, char)\n    case 2: // Eq\n      if(! this.rules[2]){\n        this.rules[2] = new Eq_rule(this)\n      }\n      rule = this.rules[2]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 3, rule, char)\n    case 3: // tmp_55\n      if(! this.rules[3]){\n        this.rules[3] = new tmp_55_rule(this)\n      }\n      rule = this.rules[3]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\nEncodingDecl_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction tmp_55_rule(origin){\n  this.alt = true\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // tmp_56\n  this.items = ['tmp_56', 'tmp_57']\n  this.rules = []\n  this.repeats = []\n}\n\ntmp_55_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // tmp_56\n      if(! this.rules[0]){\n        this.rules[0] = new tmp_56_rule(this)\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_alt(this, 1, rule, char)\n    case 1: // tmp_57\n      if(! this.rules[1]){\n        this.rules[1] = new tmp_57_rule(this)\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\ntmp_55_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction tmp_56_rule(origin){\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // '\"'\n  this.items = ['\\'\"\\'', 'EncName', '\\'\"\\'']\n  this.rules = []\n  this.repeats = []\n}\n\ntmp_56_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // '\"'\n      if(! this.rules[0]){\n        this.rules[0] = new LITERAL(this, '\"')\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 1, rule, char)\n    case 1: // EncName\n      if(! this.rules[1]){\n        this.rules[1] = new EncName_rule(this)\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 2, rule, char)\n    case 2: // '\"'\n      if(! this.rules[2]){\n        this.rules[2] = new LITERAL(this, '\"')\n      }\n      rule = this.rules[2]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\ntmp_56_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction tmp_57_rule(origin){\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // \"'\"\n  this.items = ['\"\\'\"', 'EncName', '\"\\'\"']\n  this.rules = []\n  this.repeats = []\n}\n\ntmp_57_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // \"'\"\n      if(! this.rules[0]){\n        this.rules[0] = new LITERAL(this, '\\'')\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 1, rule, char)\n    case 1: // EncName\n      if(! this.rules[1]){\n        this.rules[1] = new EncName_rule(this)\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 2, rule, char)\n    case 2: // \"'\"\n      if(! this.rules[2]){\n        this.rules[2] = new LITERAL(this, '\\'')\n      }\n      rule = this.rules[2]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\ntmp_57_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction EncName_rule(origin){\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // [A-Za-z]\n  this.items = ['[A-Za-z]', 'tmp_58*']\n  this.rules = []\n  this.repeats = []\n}\n\nEncName_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // [A-Za-z]\n      if(! this.rules[0]){\n        this.rules[0] = new CHARSET_rule(this, 'A-Za-z')\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 1, rule, char)\n    case 1: // tmp_58*\n      if(! this.rules[1]){\n        this.rules[1] = new tmp_58_rule(this)\n        this.repeats[1] = 0\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_star(this, 1, -1, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\nEncName_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction tmp_58_rule(origin){\n  this.alt = true\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // [A-Za-z0-9._]\n  this.items = ['[A-Za-z0-9._]', \"'-'\"]\n  this.rules = []\n  this.repeats = []\n}\n\ntmp_58_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // [A-Za-z0-9._]\n      if(! this.rules[0]){\n        this.rules[0] = new CHARSET_rule(this, 'A-Za-z0-9._')\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_alt(this, 1, rule, char)\n    case 1: // '-'\n      if(! this.rules[1]){\n        this.rules[1] = new LITERAL(this, '-')\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\ntmp_58_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction NotationDecl_rule(origin){\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // '<!NOTATION'\n  this.items = [\"'<!NOTATION'\", 'S', 'Name', 'S', 'tmp_59', 'S?', \"'>'\"]\n  this.rules = []\n  this.repeats = []\n}\n\nNotationDecl_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // '<!NOTATION'\n      if(! this.rules[0]){\n        this.rules[0] = new LITERAL(this, '<!NOTATION')\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 1, rule, char)\n    case 1: // S\n      if(! this.rules[1]){\n        this.rules[1] = new S_rule(this)\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 2, rule, char)\n    case 2: // Name\n      if(! this.rules[2]){\n        this.rules[2] = new Name_rule(this)\n      }\n      rule = this.rules[2]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 3, rule, char)\n    case 3: // S\n      if(! this.rules[3]){\n        this.rules[3] = new S_rule(this)\n      }\n      rule = this.rules[3]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 4, rule, char)\n    case 4: // tmp_59\n      if(! this.rules[4]){\n        this.rules[4] = new tmp_59_rule(this)\n      }\n      rule = this.rules[4]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 5, rule, char)\n    case 5: // S?\n      if(! this.rules[5]){\n        this.rules[5] = new S_rule(this)\n        this.repeats[5] = 0\n      }\n      rule = this.rules[5]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_zero_or_one(this, 5, 6, rule, char)\n    case 6: // '>'\n      if(! this.rules[6]){\n        this.rules[6] = new LITERAL(this, '>')\n      }\n      rule = this.rules[6]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\nNotationDecl_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction tmp_59_rule(origin){\n  this.alt = true\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // ExternalID\n  this.items = ['ExternalID', 'PublicID']\n  this.rules = []\n  this.repeats = []\n}\n\ntmp_59_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // ExternalID\n      if(! this.rules[0]){\n        this.rules[0] = new ExternalID_rule(this)\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_alt(this, 1, rule, char)\n    case 1: // PublicID\n      if(! this.rules[1]){\n        this.rules[1] = new PublicID_rule(this)\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\ntmp_59_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nfunction PublicID_rule(origin){\n  this.origin = origin\n  this.pos = get_pos(this)\n  this.result_store = {}\n  this.expect = 0 // 'PUBLIC'\n  this.items = [\"'PUBLIC'\", 'S', 'PubidLiteral']\n  this.rules = []\n  this.repeats = []\n}\n\nPublicID_rule.prototype.feed = function(char){\n  var res, rule\n  switch(this.expect){\n    case 0: // 'PUBLIC'\n      if(! this.rules[0]){\n        this.rules[0] = new LITERAL(this, 'PUBLIC')\n      }\n      rule = this.rules[0]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 1, rule, char)\n    case 1: // S\n      if(! this.rules[1]){\n        this.rules[1] = new S_rule(this)\n      }\n      rule = this.rules[1]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_simple(this, 2, rule, char)\n    case 2: // PubidLiteral\n      if(! this.rules[2]){\n        this.rules[2] = new PubidLiteral_rule(this)\n      }\n      rule = this.rules[2]\n      rule.pos = rule.pos ?? get_pos(this)\n      return handle_last(this, rule, char)\n    case -1:\n      return this.origin.feed(DONE)\n  }\n  return this\n}\n\nPublicID_rule.prototype.reset = function(){\n  this.expect = 0\n}\n\nvar models = {\n   XML_CTYPE_ANY: 2,\n   XML_CTYPE_CHOICE: 5,\n   XML_CTYPE_EMPTY: 1,\n   XML_CTYPE_MIXED: 3,\n   XML_CTYPE_NAME: 4,\n   XML_CTYPE_SEQ: 6,\n}\n\n__BRYTHON__.addToImported('xml_parser', {\n    DOCUMENT: document_rule,\n    models\n})\n\n})(__BRYTHON__)"], "_ajax": [".js", "// ajax\n__BRYTHON__.imported._ajax = (function($B){\n\n\nvar $N = $B.builtins.None,\n    _b_ = $B.builtins\n\nvar add_to_res = function(res, key, val) {\n    if($B.$isinstance(val, _b_.list)){\n        for (j = 0; j < val.length; j++) {\n            add_to_res(res, key, val[j])\n        }\n    }else if (val instanceof File || val instanceof Blob){\n        res.append(key, val)\n    }else{\n        res.append(key, _b_.str.$factory(val))\n    }\n}\n\nfunction set_timeout(self, timeout){\n    if(timeout.seconds !== undefined){\n        self.js.$requestTimer = setTimeout(\n            function() {\n                self.js.abort()\n                if(timeout.func){\n                    timeout.func()\n                }\n            },\n            timeout.seconds * 1000)\n    }\n}\n\nfunction _read(req){\n    var xhr = req.js\n    if(xhr.responseType == \"json\"){\n        return $B.structuredclone2pyobj(xhr.response)\n    }\n    if(req.charset_user_defined){\n        // on blocking mode, xhr.response is a string\n        var bytes = []\n        for(var i = 0, len = xhr.response.length; i < len; i++){\n            var cp = xhr.response.codePointAt(i)\n            if(cp > 0xf700){\n                bytes.push(cp - 0xf700)\n            }else{\n                bytes.push(cp)\n            }\n        }\n    }else if(typeof xhr.response == \"string\"){\n        if(req.mode == 'binary'){\n            return _b_.str.encode(xhr.response,\n                $B.$getattr(req, 'encoding', 'utf-8'))\n        }\n        return xhr.response\n    }else{\n        // else it's an ArrayBuffer\n        var buf = new Uint8Array(xhr.response),\n            bytes = Array.from(buf.values())\n    }\n    var b = _b_.bytes.$factory(bytes),\n        mode = $B.$getattr(req, 'mode', null)\n    if(mode == \"binary\"){\n        return b\n    }else if(mode == \"document\"){\n        return $B.jsobj2pyobj(xhr.response)\n    }else{\n        var encoding = $B.$getattr(req, 'encoding', \"utf-8\")\n        return _b_.bytes.decode(b, encoding)\n    }\n}\n\nfunction stringify(d){\n    var items = []\n    for(var entry of _b_.dict.$iter_items(d)){\n        items.push(encodeURIComponent(entry.key) + \"=\" +\n                   encodeURIComponent(entry.value))\n    }\n    return items.join(\"&\")\n}\n\nfunction handle_kwargs(self, kw, method){\n    var data,\n        encoding,\n        headers = {},\n        cache,\n        mode = \"text\",\n        timeout = {},\n        rawdata\n\n    for(var item of _b_.dict.$iter_items(kw)){\n        var key = item.key\n        if(key == \"data\"){\n            var rawdata = item.value\n            if(typeof rawdata == \"string\" || rawdata instanceof FormData){\n                data = rawdata\n            }else if(rawdata.__class__ === _b_.dict){\n                data = stringify(rawdata)\n            }else{\n                throw _b_.TypeError.$factory(\"wrong type for data: \" +\n                    $B.class_name(rawdata))\n            }\n        }else if(key == \"encoding\"){\n            encoding = item.value\n        }else if(key == \"headers\"){\n            var value = item.value\n            if(! $B.$isinstance(value, _b_.dict)){\n                throw _b_.ValueError.$factory(\n                    \"headers must be a dict, not \" + $B.class_name(value))\n            }\n            for(var subitem of _b_.dict.$iter_items(value)){\n                headers[subitem.key.toLowerCase()] = subitem.value\n            }\n        }else if(key.startsWith(\"on\")){\n            var event = key.substr(2)\n            if(event == \"timeout\"){\n                timeout.func = item.value\n            }else{\n                var f = item.value\n                ajax.bind(self, event, f)\n            }\n        }else if(key == \"mode\"){\n            var mode = item.value\n        }else if(key == \"timeout\"){\n            timeout.seconds = item.value\n        }else if(key == \"cache\"){\n            cache = item.value\n        }\n    }\n    if(encoding && mode != \"text\"){\n        throw _b_.ValueError.$factory(\"encoding not supported for mode \" +\n            mode)\n    }\n    if((method == \"post\" || method == \"put\") && ! headers){\n        // For POST requests, set default header\n        self.js.setRequestHeader(\"Content-type\",\n                                 \"application/x-www-form-urlencoded\")\n    }\n\n    return {cache, data, rawdata, encoding, headers, mode, timeout}\n}\n\nvar ajax = $B.make_class('ajax')\n\najax.__repr__ = function(self){\n    return '<object Ajax>'\n}\n\najax.__getattribute__ = function(self, attr){\n    if(ajax[attr] !== undefined){\n        return function(){\n            return ajax[attr].call(null, self, ...arguments)\n        }\n    }else if(attr == \"text\"){\n        return _read(self)\n    }else if(attr == \"json\"){\n        if(self.js.responseType == \"json\"){\n            return _read(self)\n        }else{\n            var resp = _read(self)\n            try{\n                return $B.structuredclone2pyobj(JSON.parse(resp))\n            }catch(err){\n                console.log('attr json, invalid resp', resp)\n                throw err\n            }\n        }\n    }else if(self.js[attr] !== undefined){\n        if(typeof self.js[attr] == \"function\"){\n            return function(){\n                if(attr == \"setRequestHeader\"){\n                    ajax.set_header.call(null, self, ...arguments)\n                }else{\n                    if(attr == 'overrideMimeType'){\n                        console.log('override mime type')\n                        self.hasMimeType = true\n                    }\n                    return self.js[attr](...arguments)\n                }\n            }\n        }else{\n            return self.js[attr]\n        }\n    }else if(attr == \"xml\"){\n        return $B.jsobj2pyobj(self.js.responseXML)\n    }\n    return _b_.object.__getattribute__(self, attr)\n}\n\najax.bind = function(self, evt, func){\n    // req.bind(evt,func) is the same as req.onevt = func\n    self.js['on' + evt] = function(){\n        try{\n            return func.apply(null, arguments)\n        }catch(err){\n            $B.handle_error(err)\n        }\n    }\n    return _b_.None\n}\n\najax.open = function(){\n    var $ = $B.args('open', 4,\n            {self: null, method: null, url: null, async: null},\n            ['self', 'method', 'url', 'async'], arguments,\n            {async: true}, null, null),\n        self = $.self,\n        method = $.method,\n        url = $.url,\n        async = $.async\n    if(typeof method !== \"string\"){\n        throw _b_.TypeError.$factory(\n            'open() argument method should be string, got ' +\n            $B.class_name(method))\n    }\n    if(typeof url !== \"string\"){\n        throw _b_.TypeError.$factory(\n            'open() argument url should be string, got ' +\n            $B.class_name(url))\n    }\n    self.$method = method\n    self.blocking = ! self.async\n    self.js.open(method, url, async)\n}\n\najax.read = function(self){\n    return _read(self)\n}\n\najax.send = function(self, params){\n    // params can be Python dictionary or string\n    var content_type\n    for(var key in self.headers){\n        var value = self.headers[key]\n        self.js.setRequestHeader(key, value)\n        if(key == 'content-type'){\n            content_type = value\n        }\n    }\n    if(($B.$getattr(self, 'encoding', false) ||\n            $B.$getattr(self, 'blocking', false)) && ! self.hasMimeType){\n        // On blocking mode, or if an encoding has been specified,\n        // override Mime type so that bytes are not processed\n        // (unless the Mime type has been explicitely set)\n        self.js.overrideMimeType('text/plain;charset=x-user-defined')\n        self.charset_user_defined = true\n    }\n    var res = ''\n    if(! params){\n        self.js.send()\n        return _b_.None\n    }\n    if($B.$isinstance(params, _b_.str)){\n        res = params\n    }else if($B.$isinstance(params, _b_.dict)){\n        if(content_type == 'multipart/form-data'){\n            // The FormData object serializes the data in the 'multipart/form-data'\n            // content-type so we may as well override that header if it was set\n            // by the user.\n            res = new FormData()\n            var items = _b_.list.$factory(_b_.dict.items(params))\n            for(var i = 0, len = items.length; i < len; i++){\n                add_to_res(res, _b_.str.$factory(items[i][0]), items[i][1])\n            }\n        }else{\n            if(self.$method && self.$method.toUpperCase() == \"POST\" &&\n                    ! content_type){\n                // Set default Content-Type for POST requests\n                self.js.setRequestHeader(\"Content-Type\",\n                    \"application/x-www-form-urlencoded\")\n            }\n            var items = _b_.list.$factory(_b_.dict.items(params))\n            for(var i = 0, len = items.length; i < len; i++){\n                var key = encodeURIComponent(_b_.str.$factory(items[i][0]));\n                if($B.$isinstance(items[i][1], _b_.list)){\n                    for (j = 0; j < items[i][1].length; j++) {\n                        res += key +'=' +\n                            encodeURIComponent(_b_.str.$factory(items[i][1][j])) + '&'\n                    }\n                }else{\n                    res += key + '=' +\n                        encodeURIComponent(_b_.str.$factory(items[i][1])) + '&'\n                }\n            }\n            res = res.substr(0, res.length - 1)\n        }\n    }else if(params instanceof FormData){\n        res = params\n    }else{\n        throw _b_.TypeError.$factory(\n            \"send() argument must be string or dictionary, not '\" +\n            _b_.str.$factory(params.__class__) + \"'\")\n    }\n    self.js.send(res)\n    return _b_.None\n}\n\najax.responseType = _b_.property.$factory(\n    function(_self){\n        return _self.responseType\n    },\n    function(_self, value){\n        _self.js.responseType = value\n    }\n)\n\najax.withCredentials = _b_.property.$factory(\n    function(_self){\n        return _self.withCredentials\n    },\n    function(_self, value){\n        _self.js.withCredentials = value\n    }\n)\n\najax.set_header = function(self, key, value){\n    self.headers[key.toLowerCase()] = value\n}\n\najax.set_timeout = function(self, seconds, func){\n    self.js.$requestTimer = setTimeout(\n        function() {\n            self.js.abort()\n            func()\n        },\n        seconds * 1000)\n}\n\najax.$factory = function(){\n\n    var xmlhttp = new XMLHttpRequest()\n\n    xmlhttp.onreadystatechange = function(){\n        // here, \"this\" refers to xmlhttp\n        var state = this.readyState\n        if(this.responseType == \"\" || this.responseType == \"text\"){\n            res.js.text = this.responseText\n        }\n        var timer = this.$requestTimer\n        if(state == 0 && this.onuninitialized){\n            this.onuninitialized(res)\n        }else if(state == 1 && this.onloading){\n            this.onloading(res)\n        }else if(state == 2 && this.onloaded){\n            this.onloaded(res)\n        }else if(state == 3 && this.oninteractive){\n            this.oninteractive(res)\n        }else if(state == 4 && this.oncomplete){\n            if(timer !== null){\n                globalThis.clearTimeout(timer)\n            }\n            this.oncomplete(res)\n        }\n    }\n    var res = {\n        __class__: ajax,\n        __dict__: $B.empty_dict(),\n        js: xmlhttp,\n        headers: {}\n    }\n    return res\n}\n\n\nfunction _request_without_body(method){\n    var $ = $B.args(method, 3, {method: null, url: null, blocking: null},\n        [\"method\", \"url\", \"blocking\"], arguments, {blocking: false},\n        null, \"kw\"),\n    method = $.method,\n    url = $.url,\n    async = !$.blocking,\n    kw = $.kw\n\n    var self = ajax.$factory()\n    self.blocking = $.blocking\n    var items = handle_kwargs(self, kw, method),\n        mode = items.mode,\n        encoding = items.encoding,\n        qs = items.data\n    $B.$setattr(self, 'mode', mode)\n    $B.$setattr(self, 'encoding', encoding)\n    if(qs){\n        url += \"?\" + qs\n    }\n    if(! (items.cache === true)){\n        url += (qs ? \"&\" : \"?\") + (new Date()).getTime()\n    }\n    self.js.open(method.toUpperCase(), url, async)\n\n    if(async){\n        if(mode == \"json\" || mode == \"document\"){\n            self.js.responseType = mode\n        }else{\n            self.js.responseType = \"arraybuffer\"\n            if(mode != \"text\" && mode != \"binary\"){\n                throw _b_.ValueError.$factory(\"invalid mode: \" + mode)\n            }\n        }\n    }else{\n        self.js.overrideMimeType('text/plain;charset=x-user-defined')\n        self.charset_user_defined = true\n    }\n    for(var key in items.headers){\n        self.js.setRequestHeader(key, items.headers[key])\n    }\n    var timeout = items.timeout\n    if(timeout.seconds){\n        ajax.set_timeout(self, timeout.seconds, timeout.func)\n    }\n    // Add function read() to return str or bytes according to mode\n    self.js.send()\n}\n\nfunction _request_with_body(method){\n    var $ = $B.args(method, 3, {method: null, url: null, blocking: null},\n        [\"method\", \"url\", \"blocking\"], arguments, {blocking: false},\n        null, \"kw\"),\n        method = $.method,\n        url = $.url,\n        async = !$.blocking,\n        kw = $.kw,\n        content_type\n    var self = ajax.$factory()\n    self.js.open(method.toUpperCase(), url, async)\n    var items = handle_kwargs(self, kw, method), // common with browser.aio\n        data = items.data\n\n    if($B.$isinstance(data, _b_.dict)){\n        data = stringify(data)\n    }\n    for(var key in items.headers){\n        var value = items.headers[key]\n        self.js.setRequestHeader(key, value)\n        if(key == 'content-type'){\n            content_type = value\n        }\n    }\n    if(method.toUpperCase() == 'POST' && !content_type){\n        // set default Content-Type for POST requests\n        self.js.setRequestHeader('Content-Type',\n            'application/x-www-form-urlencoded')\n    }\n\n    // Add function read() to return str or bytes according to mode\n    self.js.read = function(){\n        return _read(self)\n    }\n    self.js.send(data)\n}\n\nfunction form_data(form){\n    var missing = {},\n        $ = $B.args('form_data', 1, {form: null}, ['form'], arguments,\n            {form: missing}, null, null)\n    if($.form === missing){\n        return new FormData()\n    }else{\n        return new FormData($.form)\n    }\n}\n\nfunction connect(){\n    _request_without_body.call(null, \"connect\", ...arguments)\n}\n\nfunction _delete(){\n    _request_without_body.call(null, \"delete\", ...arguments)\n}\n\nfunction get(){\n    _request_without_body.call(null, \"get\", ...arguments)\n}\n\nfunction head(){\n    _request_without_body.call(null, \"head\", ...arguments)\n}\n\nfunction options(){\n    _request_without_body.call(null, \"options\", ...arguments)\n}\n\nfunction patch(){\n    _request_with_body.call(null, \"patch\", ...arguments)\n}\n\nfunction post(){\n    _request_with_body.call(null, \"post\", ...arguments)\n}\n\nfunction put(){\n    _request_with_body.call(null, \"put\", ...arguments)\n}\n\nfunction trace(){\n    _request_without_body.call(null, \"trace\", ...arguments)\n}\n\nfunction file_upload(){\n    // ajax.file_upload(url, file, method=\"POST\", **callbacks)\n    var $ = $B.args(\"file_upload\", 2, {url: null, \"file\": file},\n            [\"url\", \"file\"], arguments, {}, null, \"kw\"),\n        url = $.url,\n        file = $.file,\n        kw = $.kw\n\n    var self = ajax.$factory()\n\n    var items = handle_kwargs(self, kw, method),\n        rawdata = items.rawdata,\n        headers = items.headers\n\n    for(var key in headers){\n        var value = headers[key]\n        self.js.setRequestHeader(key, value)\n        if(key == 'content-type'){\n            content_type = value\n        }\n    }\n\n    var timeout = items.timeout\n    if(timeout.seconds){\n        ajax.set_timeout(self, timeout.seconds, timeout.func)\n    }\n\n    var method = _b_.dict.$get_string(kw, 'method', 'POST'),\n        field_name = _b_.dict.$get_string(kw, 'field_name', 'filetosave')\n\n    var formdata = new FormData()\n    formdata.append(field_name, file, file.name)\n\n    if(rawdata){\n        if(rawdata instanceof FormData){\n            // append additional data\n            for(var d of rawdata){\n                formdata.append(d[0], d[1])\n            }\n        }else if($B.$isinstance(rawdata, _b_.dict)){\n            for(var item of _b_.dict.$iter_items(rawdata)){\n                formdata.append(item.key, item.value)\n            }\n        }else{\n            throw _b_.ValueError.$factory(\n                'data value must be a dict of form_data')\n        }\n    }\n\n    self.js.open(method, url, _b_.True)\n    self.js.send(formdata)\n\n}\n\n$B.set_func_names(ajax)\n\nreturn {\n    ajax: ajax,\n    Ajax: ajax,\n    delete: _delete,\n    file_upload: file_upload,\n    connect,\n    form_data,\n    get,\n    head,\n    options,\n    patch,\n    post,\n    put,\n    trace\n}\n\n})(__BRYTHON__)\n"], "_ast": [".js", "(function($B){\n\nvar _b_ = $B.builtins,\n    ast = $B.ast, // created in py2js\n    mod = {}\nmod.PyCF_ONLY_AST = $B.PyCF_ONLY_AST\nmod.PyCF_TYPE_COMMENTS = $B.PyCF_TYPE_COMMENTS\nmod.AST = $B.AST // in builtin_modules.js\n$B.create_python_ast_classes() // in py_ast.js\nfor(var klass in ast){\n    mod[klass] = $B.python_ast_classes[klass]\n}\n\nvar Load = 'Load',\n    Store = 'Store',\n    Del = 'Del'\n\n// Note: the ensure_literal_* functions are only used to validate a restricted\n//       set of non-recursive literals that have already been checked with\n//       validate_expr, so they don't accept the validator state\nfunction ensure_literal_number(exp, allow_real, allow_imaginary){\n    if(exp.__class__ !== mod.Constant){\n        return false\n    }\n    var value = exp.value\n    if(allow_real && $B.$isinstance(value, [_b_.int, _b_.float])){\n        return true\n    }\n    if(allow_imaginary && $B.$isinstance(value, _b_.complex)){\n        return true\n    }\n    return false\n}\n\nfunction ensure_literal_negative(exp, allow_real, allow_imaginary){\n    if(exp.__class__ !== mod.UnaryOp){\n        return false\n    }\n    // Must be negation ...\n    if(exp.op !== mod.USub) {\n        return false\n    }\n    // ... of a constant ...\n    var operand = exp.operand\n    if(operand.__class__ !== mod.Constant){\n        return false\n    }\n    // ... number\n    return ensure_literal_number(operand, allow_real, allow_imaginary)\n}\n\nfunction ensure_literal_complex(exp){\n    if(exp.__class__ !== mod.BinOp){\n        return false\n    }\n    var left = exp.left,\n        right = exp.right;\n    // Ensure op is addition or subtraction\n    if(exp.op !== mod.Add && exp.op !== mod.Sub){\n        return false\n    }\n    // Check LHS is a real number (potentially signed)\n    switch(left.__class__){\n        case mod.Constant:\n            if(!ensure_literal_number(left, true, false)){\n                return false\n            }\n            break;\n        case mod.UnaryOp:\n            if(!ensure_literal_negative(left, true, false)){\n                return false\n            }\n            break;\n        default:\n            return false\n    }\n    // Check RHS is an imaginary number (no separate sign allowed)\n    switch(right.__class__){\n        case mod.Constant:\n            if(!ensure_literal_number(right, false, true)){\n                return false\n            }\n            break;\n        default:\n            return false\n    }\n    return true\n}\n\nfunction validate_arguments(args){\n    validate_args(args.posonlyargs)\n    validate_args(args.args)\n    if(args.vararg && args.vararg.annotation){\n        validate_expr(args.vararg.annotation, Load)\n    }\n    validate_args(args.kwonlyargs)\n    if(args.kwarg && args.kwarg.annotation){\n        validate_expr(args.kwarg.annotation, Load)\n    }\n    if(args.defaults.length > args.posonlyargs.length + args.args.length){\n        throw _b_.ValueError.$factory(\n            \"more positional defaults than args on arguments\")\n    }\n    if(args.kw_defaults.length != args.kwonlyargs.length){\n        throw _b_.ValueError.$factory(\n            \"length of kwonlyargs is not the same as \" +\n            \"kw_defaults on arguments\")\n    }\n    validate_exprs(args.defaults, Load, 0)\n    validate_exprs(args.kw_defaults, Load, 1)\n}\n\nfunction validate_pattern(p, star_ok){\n    var ret = -1\n    switch(p.__class__) {\n        case mod.MatchValue:\n            validate_pattern_match_value(p.value)\n            break;\n        case mod.MatchSingleton:\n            if([_b_.None, _b_.True, _b_.False].indexOf(p.value) == -1){\n                throw _b_.ValueError(\n                    \"MatchSingleton can only contain True, False and None\")\n            }\n            break;\n        case mod.MatchSequence:\n            validate_patterns(p.patterns, 1);\n            break;\n        case mod.MatchMapping:\n            if(p.keys.length != p.patterns.length){\n                throw _b_.ValueError.$factory(\n                    \"MatchMapping doesn't have the same number of keys as patterns\");\n            }\n            if(p.rest){\n                validate_capture(p.rest)\n            }\n\n            var keys = p.keys;\n            for(var key of keys){\n                if(key.__class__ === mod.Constant) {\n                    var literal = key.value;\n                    if([_b_.None, _b_.True, _b_.False].indexOf(literal) > -1){\n                        /* validate_pattern_match_value will ensure the key\n                           doesn't contain True, False and None but it is\n                           syntactically valid, so we will pass those on in\n                           a special case. */\n                        continue;\n                    }\n                }\n                validate_pattern_match_value(key)\n            }\n            validate_patterns(p.patterns, 0);\n            break;\n        case mod.MatchClass:\n            if(p.kwd_attrs.length != p.kwd_patterns.length){\n                throw _b_.ValueError.$factory(\n                    \"MatchClass doesn't have the same number of \" +\n                    \"keyword attributes as patterns\")\n            }\n            validate_expr(p.cls, Load)\n            var cls = p.cls;\n            while(true){\n                if(cls.__class__ === mod.Name){\n                    break\n                }else if(cls.__class__ === mod.Attribute) {\n                    cls = cls.value;\n                    continue;\n                }else {\n                    throw _b_.ValueError.$factory(\n                        \"MatchClass cls field can only contain Name \" +\n                        \"or Attribute nodes.\")\n                }\n            }\n\n            for(var identifier of p.kwd_attrs){\n                validate_name(identifier)\n            }\n\n            validate_patterns(p.patterns, 0)\n            validate_patterns(p.kwd_patterns, 0);\n            break;\n        case mod.MatchStar:\n            if (!star_ok) {\n                throw _b_.ValueError.$factory(\"can't use MatchStar here\")\n            }\n            if(p.name === undefined){\n                validate_capture(p.name)\n            }\n            break;\n        case mod.MatchAs:\n            if(p.name){\n                validate_capture(p.name)\n            }\n            if(p.pattern == undefined){\n                ret = 1;\n            }else if(p.name == undefined){\n                throw _b_.ValueError.$factory(\n                    \"MatchAs must specify a target name if a pattern is given\")\n            }else{\n                validate_pattern(p.pattern, 0);\n            }\n            break;\n        case mod.MatchOr:\n            if(p.patterns.length < 2){\n                throw _b_.ValueError.$factory(\n                    \"MatchOr requires at least 2 patterns\")\n            }\n            validate_patterns(p.patterns, 0)\n            break;\n    // No default case, so the compiler will emit a warning if new pattern\n    // kinds are added without being handled here\n    }\n    if(ret < 0){\n        throw _b_.SystemError.$factory(\"unexpected pattern\")\n    }\n    return true\n}\n\nfunction validate_patterns(patterns, star_ok){\n    for(var pattern of patterns){\n        validate_pattern(pattern, star_ok)\n    }\n    return true\n}\n\nfunction validate_pattern_match_value(exp){\n    validate_expr(exp, Load)\n    switch (exp.__class__){\n        case mod.Constant:\n            /* Ellipsis and immutable sequences are not allowed.\n               For True, False and None, MatchSingleton() should\n               be used */\n            validate_expr(exp, Load)\n            var literal = exp.value\n            if($B.$isinstance(literal, [_b_.int, _b_.float, _b_.bytes,\n                    _b_.complex, _b_.str])){\n                return true\n            }\n            throw _b_.ValueError.$factory(\n                \"unexpected constant inside of a literal pattern\")\n        case mod.Attribute:\n            // Constants and attribute lookups are always permitted\n            return true\n        case mod.UnaryOp:\n            // Negated numbers are permitted (whether real or imaginary)\n            // Compiler will complain if AST folding doesn't create a constant\n            if(ensure_literal_negative(exp, true, true)){\n                return true\n            }\n            break;\n        case mod.BinOp:\n            // Complex literals are permitted\n            // Compiler will complain if AST folding doesn't create a constant\n            if(ensure_literal_complex(exp)){\n                return true\n            }\n            break;\n        case mod.JoinedStr:\n            // Handled in the later stages\n            return 1;\n        default:\n            break;\n    }\n    throw _b_.ValueError.$factory(\n        \"patterns may only match literals and attribute lookups\")\n}\n\nfunction validate_capture(name){\n    if(name == \"_\"){\n        throw _b_.ValueError.$factory(\"can't capture name '_' in patterns\")\n    }\n    validate_name(name)\n}\n\nfunction validate_name(name){\n    var forbidden = [\"None\", \"True\", \"False\"]\n    if(forbidden.indexOf(name) > -1){\n        throw _b_.ValueError.$factory(`identifier field can't represent` +\n            ` '${name}' constant\", forbidden[i]`)\n    }\n    return true\n}\n\nfunction validate_comprehension(gens){\n    if(gens.length == 0) {\n        throw _b_.ValueError.$factory(\"comprehension with no generators\")\n    }\n    for(var comp of gens){\n        validate_expr(comp.target, Store)\n        validate_expr(comp.iter, Load)\n        validate_exprs(comp.ifs, Load, 0)\n    }\n    return true\n}\n\nfunction validate_keywords(keywords){\n    for(var keyword of keywords){\n        validate_expr(keyword.value, Load)\n    }\n    return true\n}\n\nfunction validate_args(args){\n    for(var arg of args){\n        if(arg.annotation){\n            validate_expr(arg.annotation, Load)\n        }\n    }\n    return true\n}\n\nfunction validate_nonempty_seq(seq, what, owner){\n    if(seq.length > 0){\n        return true\n    }\n    throw _b_.ValueError.$factory(`empty ${what} on ${owner}`)\n}\n\nfunction validate_assignlist(targets, ctx){\n    validate_nonempty_seq(targets, \"targets\", ctx == Del ? \"Delete\" : \"Assign\")\n    validate_exprs(targets, ctx, 0)\n}\n\nfunction validate_body(body, owner){\n    validate_nonempty_seq(body, \"body\", owner)\n    validate_stmts(body)\n}\n\nfunction validate_exprs(exprs, ctx, null_ok){\n    for(var expr of exprs){\n        if(expr !== _b_.None){\n            validate_expr(expr, ctx)\n        }else if(!null_ok){\n            throw _b_.ValueError.$factory(\n                            \"None disallowed in expression list\")\n        }\n\n    }\n    return true\n}\n\nfunction validate_expr(exp, ctx){\n    var check_ctx = 1,\n        actual_ctx;\n\n    /* First check expression context. */\n    switch (exp.__class__) {\n    case mod.Name:\n        validate_name(exp.id)\n        actual_ctx = exp.ctx\n        break;\n    case mod.Attribute:\n    case mod.Subscript:\n    case mod.Starred:\n    case mod.List:\n    case mod.Tuple:\n        actual_ctx = exp.ctx;\n        break\n    default:\n        if(ctx != Load){\n            throw _b_.ValueError.$factory(\"expression which can't be \" +\n                `assigned to in ${ctx} context`)\n        }\n        check_ctx = 0;\n        /* set actual_ctx to prevent gcc warning */\n        actual_ctx = 0;\n    }\n    actual_ctx = actual_ctx === 0 ? actual_ctx :\n                 actual_ctx.__class__.__name__\n    if(check_ctx && actual_ctx != ctx){\n        throw _b_.ValueError.$factory(`expression must have ` +\n            `${ctx} context but has ${actual_ctx} instead`)\n    }\n\n    /* Now validate expression. */\n    switch (exp.__class__) {\n    case mod.BoolOp:\n        if(exp.values.length < 2){\n            throw _b_.ValueError.$factory(\"BoolOp with less than 2 values\")\n        }\n        validate_exprs(exp.values, Load, 0);\n        break;\n    case mod.BinOp:\n        validate_expr(exp.left, Load)\n        validate_expr(exp.right, Load)\n        break;\n    case mod.UnaryOp:\n        validate_expr(exp.operand, Load);\n        break;\n    case mod.Lambda:\n        validate_arguments(exp.args)\n        validate_expr(exp.body, Load);\n        break;\n    case mod.IfExp:\n        validate_expr(exp.test, Load)\n        validate_expr(exp.body, Load)\n        validate_expr(exp.orelse, Load)\n        break;\n    case mod.Dict:\n        if(exp.keys.length != exp.values.length){\n            throw _b_.ValueError.$factory(\n                \"Dict doesn't have the same number of keys as values\");\n        }\n        /* null_ok=1 for keys expressions to allow dict unpacking to work in\n           dict literals, i.e. ``{**{a:b}}`` */\n        validate_exprs(exp.keys, Load, 1)\n        validate_exprs(exp.values, Load, 0);\n        break;\n    case mod.Set:\n        validate_exprs(exp.elts, Load, 0);\n        break;\n    case mod.ListComp:\n    case mod.SetComp:\n    case mod.GeneratorExp:\n        validate_comprehension(exp.generators)\n        validate_expr(exp.elt, Load)\n        break;\n    case mod.DictComp:\n        validate_comprehension(exp.generators)\n        validate_expr(exp.key, Load)\n        validate_expr(exp.value, Load)\n        break;\n    case mod.Yield:\n        if(exp.value){\n            validate_expr(exp.value, Load)\n        }\n        break;\n    case mod.YieldFrom:\n        validate_expr(exp.value, Load)\n        break;\n    case mod.Await:\n        validate_expr(exp.value, Load)\n        break;\n    case mod.Compare:\n        if(exp.comparators.length == 0){\n            throw _b_.ValueError.$factory(\"Compare with no comparators\")\n        }\n        if(exp.comparators.length != exp.ops){\n            throw _b_.ValueError.$factory(\"Compare has a different number \" +\n                            \"of comparators and operands\")\n        }\n        validate_exprs(exp.comparators, Load, 0)\n        validate_expr(exp.left, Load)\n        break;\n    case mod.Call:\n        validate_expr(exp.func, Load)\n        validate_exprs(exp.args, Load, 0)\n        validate_keywords(exp.keywords)\n        break;\n    case mod.Constant:\n        validate_constant(exp.value)\n        break;\n    case mod.JoinedStr:\n        validate_exprs(exp.values, Load, 0)\n        break;\n    case mod.FormattedValue:\n        validate_expr(exp.value, Load)\n        if (exp.format_spec) {\n            validate_expr(exp.format_spec, Load)\n            break;\n        }\n        break;\n    case mod.Attribute:\n        validate_expr(exp.value, Load)\n        break;\n    case mod.Subscript:\n        validate_expr(exp.slice, Load)\n        validate_expr(exp.value, Load)\n        break;\n    case mod.Starred:\n        validate_expr(exp.value, ctx)\n        break;\n    case mod.Slice:\n        if(exp.lower){\n            validate_expr(exp.lower, Load)\n        }\n        if(exp.upper){\n            validate_expr(exp.upper, Load)\n        }\n        if(exp.step){\n            validate_expr(exp.step, Load)\n        }\n        break;\n    case mod.List:\n        validate_exprs(exp.elts, ctx, 0)\n        break;\n    case mod.Tuple:\n        validate_exprs(exp.elts, ctx, 0)\n        break;\n    case mod.NamedExpr:\n        validate_expr(exp.value, Load)\n        break;\n    /* This last case doesn't have any checking. */\n    case mod.Name:\n        ret = 1;\n        break;\n    // No default case mod.so compiler emits warning for unhandled cases\n    }\n    return true\n}\n\nfunction validate_constant(value){\n    if (value == _b_.None || value == _b_.Ellipsis){\n        return true\n    }\n    if($B.$isinstance(value,\n            [_b_.int, _b_.float, _b_.complex, _b_.bool, _b_.bytes, _b_.str])){\n        return true\n    }\n\n    if($B.$isinstance(value, [_b_.tuple, _b_.frozenset])){\n        var it = _b_.iter(value)\n        while(true){\n            try{\n                var item = _b_.next(it)\n                validate_constant(item)\n            }catch(err){\n                if($B.is_exc(err, [_b_.StopIteration])){\n                    return true\n                }\n                throw err\n            }\n        }\n    }\n}\n\nfunction validate_stmts(seq){\n    for(var stmt of seq) {\n        if(stmt !== _b_.None){\n            validate_stmt(stmt)\n        }else{\n            throw _b_.ValueError.$factory(\"None disallowed in statement list\");\n        }\n    }\n}\n\nfunction validate_stmt(stmt){\n    switch (stmt.__class__) {\n    case mod.FunctionDef:\n        validate_body(stmt.body, \"FunctionDef\")\n        validate_arguments(stmt.args)\n        validate_exprs(stmt.decorator_list, Load, 0)\n        if(stmt.returns){\n             validate_expr(stmt.returns, Load)\n        }\n        break;\n    case mod.ClassDef:\n        validate_body(stmt.body, \"ClassDef\")\n        validate_exprs(stmt.bases, Load, 0)\n        validate_keywords(stmt.keywords)\n        validate_exprs(stmtdecorator_list, Load, 0)\n        break;\n    case mod.Return:\n        if(stmt.value){\n            validate_expr(stmt.value, Load)\n        }\n        break;\n    case mod.Delete:\n        validate_assignlist(stmt.targets, Del);\n        break;\n    case mod.Assign:\n        validate_assignlist(stmt.targets, Store)\n        validate_expr(stmt.value, Load)\n        break;\n    case mod.AugAssign:\n        validate_expr(stmt.target, Store) &&\n            validate_expr(stmt.value, Load);\n        break;\n    case mod.AnnAssign:\n        if(stmt.target.__class__ != mod.Name && stmt.simple){\n            throw _b_.TypeError.$factory(\n                \"AnnAssign with simple non-Name target\")\n        }\n        validate_expr(stmt.target, Store)\n        if(stmt.value){\n            validate_expr(stmt.value, Load)\n            validate_expr(stmt.annotation, Load);\n        }\n        break;\n    case mod.For:\n        validate_expr(stmt.target, Store)\n        validate_expr(stmt.iter, Load)\n        validate_body(stmt.body, \"For\")\n        validate_stmts(stmt.orelse)\n        break;\n    case mod.AsyncFor:\n        validate_expr(stmt.target, Store)\n        validate_expr(stmt.iter, Load)\n        validate_body(stmt.body, \"AsyncFor\")\n        validate_stmts(stmt.orelse)\n        break;\n    case mod.While:\n        validate_expr(stmt.test, Load)\n        validate_body(stmt.body, \"While\")\n        validate_stmts(stmt.orelse)\n        break;\n    case mod.If:\n        validate_expr(stmt.test, Load)\n        validate_body(stmt.body, \"If\")\n        validate_stmts(stmt.orelse)\n        break;\n    case mod.With:\n        validate_nonempty_seq(stmt.items, \"items\", \"With\")\n        for (var item of stmt.items){\n            validate_expr(item.context_expr, Load) &&\n                (! item.optional_vars || validate_expr(item.optional_vars, Store))\n        }\n        validate_body(stmt.body, \"With\");\n        break;\n    case mod.AsyncWith:\n        validate_nonempty_seq(stmt.items, \"items\", \"AsyncWith\")\n        for(var item of stmt.items){\n            validate_expr(item.context_expr, Load)\n            if(item.optional_vars){\n                validate_expr(item.optional_vars, Store)\n            }\n        }\n        validate_body(stmt.body, \"AsyncWith\");\n        break;\n    case mod.Match:\n        validate_expr(stmt.subject, Load)\n        validate_nonempty_seq(stmt.cases, \"cases\", \"Match\")\n        for(var m of stmt.cases){\n            validate_pattern(m.pattern, 0)\n            if(m.guard){\n                validate_expr(m.guard, Load)\n            }\n            validate_body(m.body, \"match_case\")\n        }\n        break;\n    case mod.Raise:\n        if(stmt.exc){\n            validate_expr(stmt.exc, Load)\n            if(stmt.cause){\n                validate_expr(stmt.cause, Load)\n            }\n            break;\n        }\n        if(stmt.cause) {\n            throw _b_.ValueError.$factory(\"Raise with cause but no exception\");\n        }\n        break;\n    case mod.Try:\n        validate_body(stmt.body, \"Try\")\n        if(stmt.handlers.length == 0 + stmt.finalbody.length == 0){\n            throw _b_.ValueError.$factor(\n                \"Try has neither except handlers nor finalbody\");\n        }\n        if(stmt.handlers.length == 0 && stmt.orelse.length > 0){\n            throw _b_.ValueError.$factory(\n                \"Try has orelse but no except handlers\");\n        }\n        for(var handler of stmt.handlers){\n            if(handler.type){\n                validate_expr(handler.type, Load)\n                validate_body(handler.body, \"ExceptHandler\")\n            }\n        }\n        if(stmt.finalbody.length > 0){\n            validate_stmts(stmt.finalbody)\n        }\n        if(stmt.orelse.length > 0){\n            validate_stmts(stmt.orelse)\n        }\n        break;\n    case mod.TryStar:\n        validate_body(stmt.body, \"TryStar\")\n        if(stmt.handlers.length + stmt.finalbody.length == 0){\n            throw _b_.ValueError.$factory(\n                \"TryStar has neither except handlers nor finalbody\");\n        }\n        if(stmt.handlers.length == 0 && stmt.orelse.length > 0){\n            throw _b_.ValueError.$factory(\n                \"TryStar has orelse but no except handlers\");\n        }\n        for(var handler of stm.handlers){\n            if(handler.type){\n                validate_expr(handler.type, Load)\n                validate_body(handler.body, \"ExceptHandler\")\n            }\n        }\n        if(stmt.finalbody.length > 0){\n            validate_stmts(stmt.finalbody)\n        }\n        if(stmt.orelse.length > 0){\n            validate_stmts(stmt.orelse)\n        }\n        break;\n    case mod.Assert:\n        validate_expr(stmt.test, Load)\n        if(stmt.msg){\n            validate_expr(stmt.msg, Load)\n        }\n        break;\n    case mod.Import:\n        validate_nonempty_seq(stmt.names, \"names\", \"Import\");\n        break;\n    case mod.ImportFrom:\n        if(stmt.level < 0) {\n            throw _b_.ValueError.$factory(\"Negative ImportFrom level\")\n        }\n        validate_nonempty_seq(stmt.names, \"names\", \"ImportFrom\");\n        break;\n    case mod.Global:\n        validate_nonempty_seq(stmt.names, \"names\", \"Global\");\n        break;\n    case mod.Nonlocal:\n        validate_nonempty_seq(stmt.names, \"names\", \"Nonlocal\");\n        break;\n    case mod.Expr:\n        validate_expr(stmt.value, Load);\n        break;\n    case mod.AsyncFunctionDef:\n        validate_body(stmt.body, \"AsyncFunctionDef\")\n        validate_arguments(stmt.args)\n        validate_exprs(stmt.decorator_list, Load, 0)\n        if(stmt.returns){\n            validate_expr(stmt.returns, Load)\n        }\n        break;\n    case mod.Pass:\n    case mod.Break:\n    case mod.Continue:\n        break;\n    // No default case so compiler emits warning for unhandled cases\n    }\n}\n\n\nmod._validate = function(ast_obj){\n    switch (ast_obj.__class__) {\n        case mod.Module:\n            validate_stmts(ast_obj.body);\n            break;\n        case mod.Interactive:\n            validate_stmts(ast_obj.body);\n            break;\n        case mod.Expression:\n            validate_expr(ast_obj.body, Load);\n            break;\n        case mod.FunctionType:\n            validate_exprs(ast_obj.argtypes, Load, 0) &&\n                  validate_expr(ast_obj.returns, Load);\n            break;\n        // No default case so compiler emits warning for unhandled cases\n    }\n}\n\n$B.imported._ast = mod\n\n}\n)(__BRYTHON__)\n"], "_base64": [".js", "(function($B){\n\nvar _b_ = $B.builtins,\n    _keyStr = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\"\n\nfunction make_alphabet(altchars){\n    var alphabet = _keyStr\n    if(altchars !== undefined && altchars !== _b_.None){\n        // altchars is an instance of Python bytes\n        var source = altchars.source\n        alphabet = alphabet.substr(0,alphabet.length-3) +\n            _b_.chr(source[0]) + _b_.chr(source[1]) + '='\n    }\n    return alphabet\n}\n\nvar Base64 = {\n    error: function(){return 'binascii_error'},\n\n    encode: function(bytes, altchars){\n\n        var input = bytes.source,\n            output = \"\",\n            chr1, chr2, chr3, enc1, enc2, enc3, enc4\n        var i = 0\n\n        var alphabet = make_alphabet(altchars)\n\n        while(i < input.length){\n\n            chr1 = input[i++]\n            chr2 = input[i++]\n            chr3 = input[i++]\n\n            enc1 = chr1 >> 2\n            enc2 = ((chr1 & 3) << 4) | (chr2 >> 4)\n            enc3 = ((chr2 & 15) << 2) | (chr3 >> 6)\n            enc4 = chr3 & 63\n\n            if(isNaN(chr2)){\n                enc3 = enc4 = 64\n            }else if(isNaN(chr3)){\n                enc4 = 64\n            }\n\n            output = output + alphabet.charAt(enc1) +\n                alphabet.charAt(enc2) +\n                alphabet.charAt(enc3) +\n                alphabet.charAt(enc4)\n\n        }\n        return _b_.bytes.$factory(output, 'utf-8', 'strict')\n    },\n\n\n    decode: function(bytes, altchars, validate){\n        var output = [],\n            chr1, chr2, chr3,\n            enc1, enc2, enc3, enc4\n\n        var alphabet = make_alphabet(altchars)\n\n        var input = bytes.source\n\n        // If validate is set, check that all characters in input\n        // are in the alphabet\n        var _input = ''\n        var padding = 0\n        for(var i = 0, len = input.length; i < len; i++){\n            var car = String.fromCharCode(input[i])\n            var char_num = alphabet.indexOf(car)\n            if(char_num == -1){\n                if(validate){\n                    throw Base64.error(\"Non-base64 digit found: \" + car)\n                }\n            }else if(char_num == 64 && i < input.length - 2){\n                if(validate){\n                    throw Base64.error(\"Non-base64 digit found: \" + car)\n                }\n            }else if(char_num == 64 && i >= input.length - 2){\n                padding++\n                _input += car\n            }else{\n                _input += car\n            }\n        }\n        input = _input\n        if(_input.length == padding){\n            return _b_.bytes.$factory([])\n        }\n        if( _input.length % 4 > 0){\n            throw Base64.error(\"Incorrect padding\")\n        }\n\n        var i = 0\n        while(i < input.length){\n\n            enc1 = alphabet.indexOf(input.charAt(i++))\n            enc2 = alphabet.indexOf(input.charAt(i++))\n            enc3 = alphabet.indexOf(input.charAt(i++))\n            enc4 = alphabet.indexOf(input.charAt(i++))\n\n            chr1 = (enc1 << 2) | (enc2 >> 4)\n            chr2 = ((enc2 & 15) << 4) | (enc3 >> 2)\n            chr3 = ((enc3 & 3) << 6) | enc4\n\n            output.push(chr1)\n\n            if(enc3 != 64){\n                output.push(chr2)\n            }\n            if(enc4 != 64){\n                output.push(chr3)\n            }\n\n        }\n        // return Python bytes\n        return _b_.bytes.$factory(output, 'utf-8', 'strict')\n\n    },\n\n    _utf8_encode: function(string){\n        string = string.replace(/\\r\\n/g, \"\\n\")\n        var utftext = \"\";\n\n        for(var n = 0; n < string.length; n++){\n\n            var c = string.charCodeAt(n)\n\n            if(c < 128){\n                utftext += String.fromCharCode(c)\n            }else if((c > 127) && (c < 2048)){\n                utftext += String.fromCharCode((c >> 6) | 192)\n                utftext += String.fromCharCode((c & 63) | 128)\n            }else{\n                utftext += String.fromCharCode((c >> 12) | 224)\n                utftext += String.fromCharCode(((c >> 6) & 63) | 128)\n                utftext += String.fromCharCode((c & 63) | 128)\n            }\n\n        }\n\n        return utftext\n    },\n\n    _utf8_decode: function(utftext) {\n        var string = \"\",\n            i = 0,\n            c = c1 = c2 = 0\n\n        while(i < utftext.length){\n\n            c = utftext.charCodeAt(i)\n\n            if(c < 128){\n                string += String.fromCharCode(c)\n                i++\n            }else if((c > 191) && (c < 224)){\n                c2 = utftext.charCodeAt(i + 1)\n                string += String.fromCharCode(((c & 31) << 6) | (c2 & 63))\n                i += 2\n            }else{\n                c2 = utftext.charCodeAt(i + 1)\n                c3 = utftext.charCodeAt(i + 2)\n                string += String.fromCharCode(\n                    ((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63))\n                i += 3\n            }\n\n        }\n\n        return string\n    }\n\n}\n\n$B.addToImported('_base64', {Base64:Base64})\n}\n\n)(__BRYTHON__)"], "_binascii": [".js", "(function($B){\n\nvar _b_ = $B.builtins,\n    _keyStr = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\"\n\nvar error = $B.make_class(\"error\", _b_.Exception.$factory)\nerror.__bases__ = [_b_.Exception]\n$B.set_func_names(error, \"binascii\")\n\nfunction decode(bytes, altchars, validate){\n    var output = [],\n        chr1, chr2, chr3,\n        enc1, enc2, enc3, enc4\n\n    var alphabet = make_alphabet(altchars)\n\n    var input = bytes.source\n\n    // If validate is set, check that all characters in input\n    // are in the alphabet\n    var _input = ''\n    var padding = 0\n    for(var i = 0, len = input.length; i < len; i++){\n        var car = String.fromCharCode(input[i])\n        var char_num = alphabet.indexOf(car)\n        if(char_num == -1){\n            if(validate){\n                throw error.$factory(\"Non-base64 digit found: \" + car)\n            }\n        }else if(char_num == 64 && i < input.length - 2){\n            if(validate){\n                throw error.$factory(\"Non-base64 digit found: \" + car)\n            }\n        }else if(char_num == 64 && i >= input.length - 2){\n            padding++\n            _input += car\n        }else{\n            _input += car\n        }\n    }\n    input = _input\n    if(_input.length == padding){\n        return _b_.bytes.$factory([])\n    }\n    if( _input.length % 4 > 0){\n        throw error.$factory(\"Incorrect padding\")\n    }\n\n    var i = 0\n    while(i < input.length){\n\n        enc1 = alphabet.indexOf(input.charAt(i++))\n        enc2 = alphabet.indexOf(input.charAt(i++))\n        enc3 = alphabet.indexOf(input.charAt(i++))\n        enc4 = alphabet.indexOf(input.charAt(i++))\n\n        chr1 = (enc1 << 2) | (enc2 >> 4)\n        chr2 = ((enc2 & 15) << 4) | (enc3 >> 2)\n        chr3 = ((enc3 & 3) << 6) | enc4\n\n        output.push(chr1)\n\n        if(enc3 != 64){output.push(chr2)}\n        if(enc4 != 64){output.push(chr3)}\n\n    }\n    // return Python bytes\n    return _b_.bytes.$factory(output)\n}\n\n\nvar hex2int = {},\n    hex = '0123456789abcdef'\nfor(var i = 0; i < hex.length; i++){\n    hex2int[hex[i]] = i\n    hex2int[hex[i].toUpperCase()] = i\n}\n\nfunction make_alphabet(altchars){\n    var alphabet = _keyStr\n    if(altchars !== undefined && altchars !== _b_.None){\n        // altchars is an instance of Python bytes\n        var source = altchars.source\n        alphabet = alphabet.substr(0,alphabet.length-3) +\n            _b_.chr(source[0]) + _b_.chr(source[1]) + '='\n    }\n    return alphabet\n}\n\nvar module = {\n    a2b_base64: function(){\n        var $ = $B.args(\"a2b_base64\", 2, {s: null, strict_mode: null},\n                ['s', 'strict_mode'],\n                arguments, {strict_mode: false}, null, null)\n        var bytes\n        if($B.$isinstance($.s, _b_.str)){\n            bytes = _b_.str.encode($.s, 'ascii')\n        }else if($B.$isinstance($.s, [_b_.bytes, _b_.bytearray])){\n            bytes = $.s\n        }else{\n            throw _b_.TypeError.$factory('wrong type: ' + $B.class_name($.s))\n        }\n        return decode(bytes)\n    },\n    a2b_hex: function(){\n        var $ = $B.args(\"a2b_hex\", 1, {s: null}, ['s'],\n                arguments, {}, null, null),\n            s = $.s\n        if($B.$isinstance(s, _b_.bytes)){\n            s = _b_.bytes.decode(s, 'ascii')\n        }\n        if(typeof s !== \"string\"){\n            throw _b_.TypeError.$factory(\"argument should be bytes, \" +\n                \"buffer or ASCII string, not '\" + $B.class_name(s) + \"'\")\n        }\n\n        var len = s.length\n        if(len % 2 == 1){\n            throw _b_.TypeError.$factory('Odd-length string')\n        }\n\n        var res = []\n        for(var i = 0; i < len; i += 2){\n            res.push((hex2int[s.charAt(i)] << 4) + hex2int[s.charAt(i + 1)])\n        }\n        return _b_.bytes.$factory(res)\n    },\n    b2a_base64: function(){\n        var $ = $B.args(\"b2a_base64\", 1, {data: null}, ['data'],\n                arguments, {}, null, \"kw\")\n        var newline = _b_.dict.$get_string($.kw, 'newline', false)\n\n        var bytes_list = $B.to_bytes($.data)\n        var i = 0\n        var size = 100000\n        var s = ''\n        while(i < bytes_list.length){\n            s += String.fromCharCode.apply(null, bytes_list.slice(i, i + size))\n            i += size\n        }\n\n        var res = btoa(s)\n\n        if(newline){\n            res += \"\\n\"\n        }\n        return _b_.bytes.$factory(res, \"ascii\")\n    },\n    b2a_hex: function(obj){\n        var string = $B.to_bytes(obj),\n            res = []\n        function conv(c){\n            if(c > 9){\n                c = c + 'a'.charCodeAt(0) - 10\n            }else{\n                c = c + '0'.charCodeAt(0)\n            }\n            return c\n        }\n        string.forEach(function(char){\n            res.push(conv((char >> 4) & 0xf))\n            res.push(conv(char & 0xf))\n        })\n        return _b_.bytes.$factory(res)\n    },\n    b2a_uu: function(obj){\n        var string = _b_.bytes.decode(obj, 'ascii')\n        var len = string.length,\n            res = String.fromCharCode((0x20 + len) & 0x3F)\n        while(string.length > 0){\n            var s = string.slice(0, 3)\n            while(s.length < 3){s.push(String.fromCharCode(0))}\n            var A = s[0],\n                B = s[1],\n                C = s[2]\n            var a = (A >> 2) & 0x3F,\n                b = ((A << 4) | ((B >> 4) & 0xF)) & 0x3F,\n                c = (((B << 2) | ((C >> 6) & 0x3)) & 0x3F),\n                d = C & 0x3F\n            res += String.fromCharCode(0x20 + a, 0x20 + b, 0x20 + c, 0x20 + d)\n            string = string.slice(3)\n        }\n        return _b_.bytes.$factory(res + \"\\n\", \"ascii\")\n    },\n    error: error\n}\n\nmodule.hexlify = module.b2a_hex\nmodule.unhexlify = module.a2b_hex\n\n$B.imported._binascii = module\n}\n)(__BRYTHON__)"], "_io_classes": [".js", "var _b_ = __BRYTHON__.builtins\n\nfunction get_self(name, args){\n    return $B.args(name, 1, {self: null}, [\"self\"], args, {}, null, null).self\n}\n\nvar _IOBase = $B.make_class(\"_IOBase\")\n_IOBase.__mro__ = [_b_.object]\n\n_IOBase.close = function(){\n    get_self(\"close\", arguments).__closed = true\n}\n\n_IOBase.flush = function(){\n    get_self(\"flush\", arguments)\n    return _b_.None\n}\n\n$B.set_func_names(_IOBase, '_io')\n\n// Base class for binary streams that support some kind of buffering.\nvar _BufferedIOBase = $B.make_class(\"_BufferedIOBase\")\n_BufferedIOBase.__mro__ = [_IOBase, _b_.object]\n\n_BufferedIOBase.__enter__ = function(self){\n    return self\n}\n_BufferedIOBase.__exit__ = function(self, type, value, traceback){\n    try{\n        $B.$call($B.$getattr(self, 'close'))()\n        self.__closed = true\n        return true\n    }catch(err){\n        return false\n    }\n}\n\n$B.set_func_names(_BufferedIOBase, '_io')\n\n// Base class for raw binary I/O.\nvar _RawIOBase = $B.make_class(\"_RawIOBase\")\n\n_RawIOBase.__mro__ = [_IOBase, _b_.object]\n\n_RawIOBase.read = function(){\n    var $ = $B.args(\"read\", 2, {self: null, size: null}, [\"self\", \"size\"],\n                    arguments, {size: -1}, null, null),\n        self = $.self,\n        size = $.size,\n        res\n    self.$pos = self.$pos || 0\n    if(size == -1){\n        if(self.$pos == 0){\n            res = self.$content\n        }else{\n            res = _b_.bytes.$factory(self.$content.source.slice(self.$pos))\n        }\n        self.$pos = self.$content.source.length - 1\n    }else{\n        res = _b_.bytes.$factory(self.$content.source.slice(self.$pos, size))\n        self.$pos += size\n    }\n    return res\n}\n\n_RawIOBase.readall = function(){\n    return _RawIOBase.read(get_self(\"readall\", arguments))\n}\n\n$B.set_func_names(_RawIOBase, '_io')\n\n// Base class for text streams.\n_TextIOBase = $B.make_class(\"_TextIOBase\")\n_TextIOBase.__mro__ = [_IOBase, _b_.object]\n\nvar StringIO = $B.make_class(\"StringIO\",\n    function(){\n        var $ = $B.args(\"StringIO\", 2, {value: null, newline: null},\n                [\"value\", \"newline\"], arguments, {value: '', newline: \"\\n\"},\n                null, null)\n        return {\n            __class__: StringIO,\n            $counter: 0,\n            $content: $.value\n        }\n    }\n)\n\nStringIO.__mro__ = [$B.Reader, _b_.object]\n\nStringIO.getvalue = function(){\n    var $ = $B.args(\"getvalue\", 1, {self: null},\n            [\"self\"], arguments, {}, null, null)\n    return $.self.$content.substr(0) // copy\n}\n\nStringIO.truncate = function(self, size){\n    var $ = $B.args('truncate', 2, {self: null, size: null}, ['self', 'size'],\n            arguments, {size: _b_.None}, null, null),\n        self = $.self,\n        size = $.size\n    if(size === _b_.None){\n        size = self.$counter\n    }\n    self.$content = self.$content.substr(0, size)\n    self.$counter = self.$content.length\n    return self.$counter\n}\n\nStringIO.write = function(){\n    var $ = $B.args(\"write\", 2, {self: null, data: null},\n            [\"self\", \"data\"], arguments, {}, null, null)\n    if(! $B.$isinstance($.data, _b_.str)){\n        throw _b_.TypeError.$factory('string argument expected, got ' +\n            `'${$B.class_name($.data)}'`)\n    }\n    var text = $.self.$content,\n        position = $.self.$counter\n    if(position > text.length){\n        text += String.fromCodePoint(0).repeat(position - text.length)\n    }\n    text = text.substr(0, position) + $.data +\n        text.substr(position + $.data.length)\n    $.self.$content = text\n    $.self.$counter = position + $.data.length\n    return $.data.length\n}\n\n$B.set_func_names(StringIO, \"_io\")\n\nvar BytesIO = $B.make_class(\"BytesIO\",\n    function(){\n        var $ = $B.args(\"BytesIO\", 1, {value: null},\n                [\"value\"], arguments, {value: _b_.bytes.$factory()},\n                null, null)\n        return {\n            __class__: BytesIO,\n            $binary: true,\n            $content: $.value,\n            $length: $.value.source.length,\n            $counter: 0\n        }\n    }\n)\nBytesIO.__mro__ = [$B.Reader, _b_.object]\n\nBytesIO.getbuffer = function(){\n    var self = get_self(\"getbuffer\", arguments)\n    return _b_.memoryview.$factory(self.$content)\n}\n\nBytesIO.getvalue = function(){\n    var self = get_self(\"getvalue\", arguments)\n    return self.$content\n}\n\nBytesIO.read = function(){\n    var $ = $B.args(\"read\", 2, {self: null, nbytes: null},\n            [\"self\", \"nbytes\"], arguments, {nbytes: _b_.None}, null, null),\n        self = $.self,\n        nbytes = $.nbytes,\n        res\n    var source = self.$content.source\n    if(nbytes === _b_.None){\n        res = $B.fast_bytes(source.slice(self.$counter))\n        self.$counter = source.length\n    }else if(! _b_.isinstance(nbytes, _b_.int)){\n        throw _b_.TypeError.$factory('number of bytes should be int, not ' +\n            $B.class_name(nbytes))\n    }else{\n        res = $B.fast_bytes(source.slice(self.$counter,\n                            self.$counter + nbytes))\n        self.$counter = Math.min(self.$counter + nbytes, source.length)\n    }\n    return res\n}\n\nBytesIO.write = function(){\n    var $ = $B.args(\"write\", 2, {self: null, data: null},\n            [\"self\", \"data\"], arguments, {}, null, null)\n    var data_cls = $B.get_class($.data)\n    if(! data_cls.$buffer_protocol){\n        throw _b_.TypeError.$factory('a bytes-like object is required, ' +\n            `not '${$B.class_name($.data)}'`)\n    }\n    var source = $.self.$content.source,\n        counter = $.self.$counter,\n        data = _b_.bytes.$factory($.data)\n    if(counter > source.length){\n        // pad with 0's\n        var padding = (new Array(counter - source.length)).fill(0)\n        source.splice(source.length, 0, ...padding)\n    }\n    source.splice(counter, data.source.length, ...data.source)\n    $.self.$counter += data.source.length\n    return _b_.None\n}\n\n$B.set_func_names(BytesIO, \"_io\")\n\nvar BlockingIOError = $B.make_class('BlockingIOError')\nBlockingIOError.__bases__ = [_b_.OSError]\n\n$B.set_func_names(BlockingIOError, '_io')\n\nvar $module = (function($B){\n    return {\n        _BufferedIOBase,\n        _IOBase,\n        _RawIOBase,\n        _TextIOBase: $B.make_class(\"_TextIOBase\",\n            function(){\n                return \"fileio\"\n            }\n        ),\n        BlockingIOError,\n        BytesIO: BytesIO,\n        FileIO: $B.make_class(\"_TextIOBase\",\n            function(){\n                return \"fileio\"\n            }\n        ),\n        StringIO: StringIO,\n        BufferedReader: $B.BufferedReader,\n        BufferedWriter: $B.make_class(\"_TextIOBase\",\n            function(){\n                return \"fileio\"\n            }\n        ),\n        BufferedRWPair: $B.make_class(\"_TextIOBase\",\n            function(){\n                return \"fileio\"\n            }\n        ),\n        BufferedRandom: $B.make_class(\"_TextIOBase\",\n            function(){\n                return \"fileio\"\n            }\n        ),\n        IncrementalNewlineDecoder: $B.make_class(\"_TextIOBase\",\n            function(){\n                return \"fileio\"\n            }\n        ),\n        TextIOWrapper: $B.TextIOWrapper\n    }\n})(__BRYTHON__)\n$module._IOBase.__doc__ = \"_IOBase\"\n\n__BRYTHON__.imported._io_classes = $module"], "_json": [".js", "(function($B){\n\nvar _b_ = $B.builtins\n\nfunction simple(obj){\n    switch(typeof obj){\n        case 'string':\n        case 'number':\n        case 'boolean':\n            return true\n    }\n    if(obj instanceof Number ||\n            Array.isArray(obj) ||\n            $B.$isinstance(obj, [_b_.list, _b_.tuple, _b_.dict])){\n        return true\n    }\n    return false\n}\n\nfunction to_json(obj, level){\n    var $defaults = {skipkeys:_b_.False, ensure_ascii:_b_.True,\n            check_circular:_b_.True, allow_nan:_b_.True, cls:_b_.None,\n            indent:_b_.None, separators:_b_.None, \"default\":_b_.None,\n            sort_keys:_b_.False},\n        $ = $B.args(\"to_json\", 2, {obj: null, level: null}, ['obj', 'level'],\n                    arguments, {level: 1}, null, \"kw\")\n\n    var kw = _b_.dict.$to_obj($.kw)\n    for(var key in $defaults){\n        if(! kw.hasOwnProperty(key)){\n            kw[key] = $defaults[key]\n        }\n    }\n\n    var indent = kw.indent,\n        ensure_ascii = kw.ensure_ascii,\n        separators = kw.separators === _b_.None ?\n             kw.indent === _b_.None ? [', ', ': '] : [',', ': '] :\n            kw.separators,\n        skipkeys = kw.skipkeys,\n        _default = kw.default,\n        sort_keys = kw.sort_keys,\n        allow_nan = kw.allow_nan,\n        check_circular = kw.check_circular\n\n    var item_separator = separators[0],\n        key_separator = separators[1]\n    if(indent !== _b_.None){\n        var indent_str\n        if(typeof indent == \"string\"){\n            indent_str = indent\n        }else if(typeof indent == \"number\" && indent >= 1){\n            indent_str = \" \".repeat(indent)\n        }else{\n            throw _b_.ValueError.$factory(\"invalid indent: \" +\n                _b_.str.$factory(indent))\n        }\n    }\n    var kwarg = {$kw: [{}]}\n    for(var key in kw){\n        kwarg.$kw[0][key] = kw[key]\n    }\n\n    switch(typeof obj){\n        case 'string':\n            var res = JSON.stringify(obj)\n            if(ensure_ascii){\n                var escaped = ''\n                for(var i = 0, len = res.length; i < len; i++){\n                    var u = res.codePointAt(i)\n                    if(u > 127){\n                        u = u.toString(16)\n                        while(u.length < 4){\n                            u = \"0\" + u\n                        }\n                        escaped += '\\\\u' + u\n                    }else{\n                        escaped += res.charAt(i)\n                    }\n                }\n                return escaped\n            }\n            return res\n        case 'boolean':\n            return obj.toString()\n        case 'number':\n            if([Infinity, -Infinity].indexOf(obj) > -1 ||\n                    isNaN(obj)){\n                if(! allow_nan){\n                    throw _b_.ValueError.$factory(\n                        'Out of range float values are not JSON compliant')\n                }\n            }\n            return obj.toString()\n    }\n    if(obj instanceof String){\n        if(! ensure_ascii){\n            return $B.String(obj)\n        }\n        // string with surrogate pairs. cf. issue #1903.\n        var res = ''\n        if(obj.surrogates){\n            var s_ix = 0,\n                s_pos = obj.surrogates[s_ix]\n            for(var i = 0, len = obj.length; i < len; i++){\n                if(i == s_pos){\n                    var code = obj.codePointAt(i) - 0x10000\n                    res += '\\\\u' + (0xD800 | (code >> 10)).toString(16) +\n                           '\\\\u' + (0xDC00 | (code & 0x3FF)).toString(16)\n                    i++\n                    s_ix++\n                    s_pos = obj.surrogates[s_ix]\n                }else{\n                    var code = obj.charCodeAt(i)\n                    if(code < 127){\n                        var x = _b_.repr(obj[i])\n                        res += x.substr(1, x.length - 2)\n                    }else{\n                        var x = code.toString(16)\n                        while(x.length < 4){\n                            x = '0' + x\n                        }\n                        res += '\\\\u' + x\n                    }\n                }\n            }\n        }\n        return '\"' + res.replace(new RegExp('\"', \"g\"), '\\\\\"') + '\"'\n    }\n\n    if($B.$isinstance(obj, [_b_.list, _b_.tuple])){\n        var res = []\n        var sep = item_separator,\n            first = '[',\n            last = ']'\n        if(indent !== _b_.None){\n            sep += \"\\n\" + indent_str.repeat(level)\n            first = '[' + '\\n' + indent_str.repeat(level)\n            last = '\\n' + indent_str.repeat(level - 1) + ']'\n            level++\n        }\n        for(var i = 0, len = obj.length; i < len; i++){\n            res.push(to_json(obj[i], level, kwarg))\n        }\n        return first + res.join(sep) + last\n    }else if($B.$isinstance(obj, _b_.float)){\n        return obj.value\n    }else if(obj.__class__ === $B.long_int){\n        return obj.value.toString()\n    }else if(obj === _b_.None){\n        return \"null\"\n    }else if($B.$isinstance(obj, _b_.dict)){\n        var res = [],\n            items = Array.from($B.make_js_iterator(_b_.dict.items(obj)))\n        if(sort_keys){\n            // Sort keys by alphabetical order\n            items.sort()\n        }\n        var sep = item_separator,\n            first = '{',\n            last = '}'\n        if(indent !== _b_.None){\n            sep += \"\\n\" + indent_str.repeat(level)\n            first = '{' + '\\n' + indent_str.repeat(level)\n            last = '\\n' + indent_str.repeat(level - 1) + '}'\n            level++\n        }\n        for(var i = 0, len = items.length; i < len; i++){\n            var item = items[i]\n            if(! simple(item[0])){\n                if(! skipkeys){\n                    throw _b_.TypeError.$factory(\"keys must be str, int, \" +\n                        \"float, bool or None, not \" + $B.class_name(obj))\n                }\n            }else{\n                // In the result, key must be a string\n                var key = _b_.str.$factory(item[0])\n                // Check circular reference\n                if(check_circular && $B.repr.enter(item[1])){\n                    throw _b_.ValueError.$factory(\"Circular reference detected\")\n                }\n                res.push(\n                    [to_json(key, level, kwarg), to_json(item[1], level, kwarg)].\n                    join(key_separator))\n                if(check_circular){\n                    $B.repr.leave(item[1])\n                }\n            }\n        }\n        return first + res.join(sep) + last\n    }\n    // For other types, use function default if provided\n    if(_default == _b_.None){\n        throw _b_.TypeError.$factory(\"Object of type \" + $B.class_name(obj) +\n            \" is not JSON serializable\")\n    }else{\n        return to_json($B.$call(_default)(obj), level, kwarg)\n    }\n}\n\nfunction loads(s){\n    var args = []\n    for(var i = 1, len = arguments.length; i < len; i++){\n        args.push(arguments[i])\n    }\n    var decoder = JSONDecoder.$factory.apply(null, args)\n    return JSONDecoder.decode(decoder, s)\n}\n\nfunction to_py(obj, kw){\n    // Conversion to Python objects\n    // kw are the keyword arguments to loads()\n    var res\n    if(obj instanceof List){\n        return $B.$list(obj.items.map(x => to_py(x, kw)))\n    }else if(obj instanceof Dict){\n        if(kw.object_pairs_hook !== _b_.None){\n            var pairs = []\n            for(var i = 0, len = obj.keys.length; i < len; i++){\n                pairs.push($B.fast_tuple([obj.keys[i],\n                    to_py(obj.values[i], kw)]))\n            }\n            return $B.$call(kw.object_pairs_hook)(pairs)\n        }else{\n            var dict = $B.empty_dict()\n            for(var i = 0, len = obj.keys.length; i < len; i++){\n                _b_.dict.$setitem(dict, obj.keys[i], to_py(obj.values[i], kw))\n            }\n            return kw.object_hook === _b_.None ? dict :\n                $B.$call(kw.object_hook)(dict)\n        }\n    }else if(obj.type == 'str'){\n        return obj.value\n    }else if(obj.type == 'num'){\n        if(obj.value.search(/[.eE]/) > -1){\n            // float\n            if(kw.parse_float !== _b_.None){\n                return $B.$call(kw.parse_float)(obj.value)\n            }\n            return $B.fast_float(parseFloat(obj.value))\n        }else{\n            // integer\n            if(kw.parse_int !== _b_.None){\n                return $B.$call(kw.parse_int)(obj.value)\n            }\n            var int = parseInt(obj.value)\n            if(Math.abs(int) < $B.max_int){\n                return int\n            }else{\n                return $B.fast_long_int(BigInt(obj.value))\n            }\n        }\n    }else{\n        if(obj instanceof Number && kw.parse_float !== _b_.None){\n            return $B.$call(kw.parse_float)(obj)\n        }else if(kw.parse_int !== _b_.None &&\n                (typeof obj == 'number' || obj.__class__ === $B.long_int)){\n            return $B.$call(kw.parse_int)(obj)\n        }else if(kw.parse_constant !== _b_.None && ! isFinite(obj)){\n            return kw.parse_constant(obj)\n        }\n        return obj\n    }\n}\n\nvar escapes = {'n': '\\n',\n               't': '\\t',\n               'b': '\\b',\n               'r': '\\r',\n               'f': '\\f',\n               '\\\\': '\\\\',\n               '\"': '\\\"',\n               \"'\": \"\\\\'\",\n               '/': '/'\n               }\n\nfunction string_at(s, i){\n    var error = $B.$call($B.imported[\"json\"].JSONDecodeError)\n\n    var j = i + 1,\n        escaped = false,\n        len = s.length,\n        value = ''\n    while(j < len){\n        if(s[j] == '\"' && ! escaped){\n            return [{type: 'str', value}, j + 1]\n        }else if(! escaped && s[j] == '\\\\'){\n            escaped = ! escaped\n            j++\n        }else if(escaped){\n            var esc = escapes[s[j]]\n            if(esc){\n                value += esc\n                j++\n                escaped = false\n            }else if(s[j] == 'u' &&\n                    s.substr(j + 1, 4).match(/[0-9a-fA-f]{4}/)){\n                // unicode escape\n                value += String.fromCharCode(parseInt(s.substr(j + 1, 4), 16))\n                j += 5\n                escaped = ! escaped\n            }else{\n                throw error('invalid escape \"' + s[j] + '\"', s, j)\n            }\n        }else{\n            value += s[j]\n            j++\n        }\n    }\n}\n\nfunction to_num(num_string, nb_dots, exp){\n    // convert to correct Brython type\n    if(exp || nb_dots){\n        return new Number(num_string)\n    }else{\n        var int = parseInt(num_string)\n        if(Math.abs(int) < $B.max_int){\n            return int\n        }else{\n            if(num_string.startsWith('-')){\n                return $B.fast_long_int(num_string.substr(1), false)\n            }else{\n                return $B.fast_long_int(num_string, true)\n            }\n        }\n    }\n}\n\nfunction num_at(s, i){\n  var res = s[i],\n      j = i + 1,\n      nb_dots = 0,\n      exp = false,\n      len = s.length\n  while(j < len){\n      if(s[j].match(/\\d/)){\n        j++\n      }else if(s[j] == '.' && nb_dots == 0){\n        nb_dots++\n        j++\n      }else if('eE'.indexOf(s[j]) > -1 && ! exp){\n        exp = ! exp\n        j++\n      }else if(s[j] == '-' && 'eE'.includes(s[j-1])){\n        j++\n      }else{\n        return [{type: 'num', value: s.substring(i, j)}, j]\n      }\n  }\n  return [{type: 'num', value: s.substring(i, j)}, j]\n}\n\nvar JSONError = $B.make_class('json.decoder.JSONError')\nJSONError.__bases__ = [_b_.Exception]\nJSONError.__mro__ = _b_.type.mro(JSONError)\n\n\nfunction* tokenize(s){\n  var i = 0,\n      len = s.length,\n      line_num = 1,\n      column_start = 0,\n      value,\n      end\n  while(i < len){\n    if(s[i] == \" \" || s[i] == '\\r' || s[i] == '\\n' || s[i] == '\\t'){\n      i++\n      line_num++\n      column_start = i\n    }else if('[]{}:,'.indexOf(s[i]) > -1){\n      yield [s[i], i]\n      i++\n    }else if(s.substr(i, 4) == 'null'){\n      yield [_b_.None , i]\n      i += 4\n    }else if(s.substr(i, 4) == 'true'){\n      yield [true, i]\n      i += 4\n    }else if(s.substr(i, 5) == 'false'){\n      yield [false, i]\n      i += 5\n    }else if(s.substr(i, 8) == 'Infinity'){\n      yield [{type: 'num', value: 'Infinity'}, i]\n      i += 8\n    }else if(s.substr(i, 9) == '-Infinity'){\n      yield [{type: 'num', value: '-Infinity'}, i]\n      i += 9\n    }else if(s.substr(i, 3) == 'NaN'){\n      yield [{type: 'num', value: 'NaN'}, i]\n      i += 3\n    }else if(s[i] == '\"'){\n      value = string_at(s, i)\n      yield value\n      i = value[1]\n    }else if(s[i].match(/\\d/) || s[i] == '-'){\n      value = num_at(s, i)\n      yield value\n      i = value[1]\n    }else{\n      throw $B.$call(JSONError)('Extra data: ' +\n          `line ${line_num} column ${1 + i - column_start}`)\n    }\n  }\n}\n\nfunction Node(parent){\n    this.parent = parent\n    if(parent instanceof List){\n        this.list = parent.items\n    }else if(parent instanceof Dict){\n        this.list = parent.values\n    }else if(parent === undefined){\n        this.list = []\n    }\n}\n\nNode.prototype.transition = function(token){\n    if([true, false, _b_.None].includes(token) ||\n            ['str', 'num'].includes(token.type)){\n        if(this.parent === undefined &&\n                (this.list.length > 0 || this.content)){\n            throw Error('Extra data')\n        }\n        this.list.push(token)\n        return this.parent ? this.parent : this\n    }else if(token == '{'){\n        if(this.parent === undefined){\n          this.content = new Dict(this)\n          return this.content\n        }\n        return new Dict(this.parent)\n    }else if(token == '['){\n        if(this.parent === undefined){\n            this.content = new List(this)\n            return this.content\n        }\n        return new List(this.parent)\n    }else{\n        throw Error('unexpected item:' + token)\n    }\n}\n\nfunction Dict(parent){\n    this.parent = parent\n    this.keys = []\n    this.values = []\n    this.expect = 'key'\n    if(parent instanceof List){\n        parent.items.push(this)\n    }else if(parent instanceof Dict){\n        parent.values.push(this)\n    }\n}\n\nDict.prototype.transition = function(token){\n    if(this.expect == 'key'){\n        if(token.type == 'str'){\n            this.keys.push(token.value)\n            this.expect = ':'\n            return this\n        }else if(token == '}' && this.keys.length == 0){\n            return this.parent\n        }else{\n            throw Error('expected str')\n        }\n    }else if(this.expect == ':'){\n        if(token == ':'){\n          this.expect = '}'\n          return new Node(this)\n        }else{\n          throw Error('expected :')\n        }\n    }else if(this.expect == '}'){\n        if(token == '}'){\n            return this.parent\n        }else if(token == ','){\n            this.expect = 'key'\n            return this\n        }\n        throw Error('expected }')\n    }\n}\n\nfunction List(parent){\n    if(parent instanceof List){\n        parent.items.push(this)\n    }\n    this.parent = parent\n    this.items = []\n    this.expect = 'item'\n}\n\nList.prototype.transition = function(token){\n    if(this.expect == 'item'){\n        this.expect = ','\n        if([true, false, _b_.None].indexOf(token) > -1){\n            this.items.push(token)\n            return this\n        }else if(token.type == 'num' || token.type == 'str'){\n            this.items.push(token)\n            return this\n        }else if(token == '{'){\n            return new Dict(this)\n        }else if(token == '['){\n            return new List(this)\n        }else if(token == ']'){\n            if(this.items.length == 0){\n                if(this.parent instanceof Dict){\n                    this.parent.values.push(this)\n                }\n                return this.parent\n            }\n            throw Error('unexpected ]')\n        }else{\n            console.log('token', token)\n            throw Error('unexpected item:' + token)\n        }\n\n    }else if(this.expect == ','){\n        this.expect = 'item'\n        if(token == ','){\n          return this\n        }else if(token == ']'){\n          if(this.parent instanceof Dict){\n              this.parent.values.push(this)\n          }\n          return this.parent\n        }else{\n          throw Error('expected :')\n        }\n    }\n}\n\nfunction parse(s){\n  var res,\n      state,\n      node = new Node(),\n      root = node,\n      token\n  for(var item of tokenize(s)){\n      token = item[0]\n      try{\n          node = node.transition(token)\n      }catch(err){\n          console.log('error, item', item)\n          console.log(err, err.message)\n          console.log('node', node)\n          if(err.__class__){\n              throw err\n          }else{\n              var error = $B.$call($B.imported[\"json\"].JSONDecodeError)\n              throw error(err.message, s, item[1])\n          }\n      }\n  }\n  return root.content ? root.content : root.list[0]\n}\n\nvar JSONDecoder = $B.make_class(\"JSONDecoder\",\n    function(){\n        var $defaults = {cls: _b_.None, object_hook: _b_.None,\n                parse_float: _b_.None, parse_int: _b_.None,\n                parse_constant: _b_.None, object_pairs_hook: _b_.None},\n            $ = $B.args(\"decode\", 0, {}, [], arguments, {}, null, \"kw\")\n        var kw = _b_.dict.$to_obj($.kw)\n        for(var key in $defaults){\n            if(kw[key] === undefined){\n                kw[key] = $defaults[key]\n            }\n        }\n        return {\n            __class__: JSONDecoder,\n            object_hook: kw.object_hook,\n            parse_float: kw.parse_float,\n            parse_int: kw.parse_int,\n            parse_constant: kw.parse_constant,\n            object_pairs_hook: kw.object_pairs_hook,\n            memo: $B.empty_dict()\n        }\n    }\n)\n\nJSONDecoder.decode = function(self, s){\n    return to_py(parse(s), self)\n}\n\n$B.imported._json = {\n    dumps: function(){\n        return _b_.str.$factory(to_json.apply(null, arguments))\n    },\n    loads,\n    JSONDecoder\n}\n\n})(__BRYTHON__)"], "_jsre": [".js", "(function($B){\n\n    var _b_ = $B.builtins\n\n    var MatchObject = $B.make_class(\"Match\",\n        function(jsmatch, string, pattern){\n            return {\n                __class__: MatchObject,\n                jsmatch: jsmatch,\n                string: string\n            }\n        }\n    )\n    MatchObject.item = function(self, rank){\n        return self.jsmatch[rank]\n    }\n    MatchObject.group = function(self){\n        var res = []\n        for(var i = 0, _len_i = arguments.length; i < _len_i; i++){\n            if(self.jsmatch[arguments[i]] === undefined){res.push(_b_.None)}\n            else{res.push(self.jsmatch[arguments[i]])}\n        }\n        if(arguments.length == 1){return res[0]}\n        return _b_.tuple.$factory(res)\n    }\n    MatchObject.groups = function(self, _default){\n        if(_default === undefined){_default = _b_.None}\n        var res = []\n        for(var i = 1, _len_i = self.length; i < _len_i; i++){\n            if(self.jsmatch[i] === undefined){res.push(_default)}\n            else{res.push(self.jsmatch[i])}\n        }\n        return _b_.tuple.$factory(res)\n    }\n    MatchObject.start = function(self){\n        return self.index\n    }\n    MatchObject.end = function(self){\n        return self.length - self.index\n    }\n\n    $B.set_func_names(MatchObject, '_jsre')\n\n    var obj = {\n        __str__: function(){return \"<module 're'>\"}\n    }\n    obj.A = obj.ASCII = 256\n    obj.I = obj.IGNORECASE = 2 // 'i'\n    obj.L = obj.LOCALE = 4\n    obj.M = obj.MULTILINE = 8 // 'm'\n    obj.S = obj.DOTALL = 16\n    obj.U = obj.UNICODE = 32\n    obj.X = obj.VERBOSE = 64\n    obj._is_valid = function(pattern) {\n        if ($B.$options.re == 'pyre'){return false}  //force use of python's re module\n        if ($B.$options.re == 'jsre'){return true}   //force use of brythons re module\n        // FIXME: Improve\n\n        if(! $B.$isinstance(pattern, _b_.str)){\n           // this is probably a SRE_PATTERN, so return false, and let\n           // python's re module handle this.\n           return false\n        }\n        var is_valid = false\n        try{\n            new RegExp(pattern)\n            is_valid = true\n        }\n        catch(e){}\n        if(! is_valid){return false}  //if js won't parse the pattern return false\n\n        // using reference http://www.regular-expressions.info/\n        // to compare python re and javascript regex libraries\n\n        // look for things javascript does not support\n        // check for name capturing group\n        var mylist = ['?P=', '?P<', '(?#', '(?<=', '(?<!', '(?(']\n        for(var i = 0, _len_i = mylist.length; i < _len_i; i++) {\n           if (pattern.indexOf(mylist[i]) > -1) return false\n        }\n\n        var re_list=['\\{,\\d+\\}']\n        for(var i=0, _len_i = re_list.length; i < _len_i; i++) {\n           var _re = new RegExp(re_list[i])\n           if (_re.test(pattern)){return false}\n        }\n\n        // it looks like the pattern has passed all our tests so lets assume\n        // javascript can handle this pattern.\n        return true\n    }\n    var $SRE_PatternDict = {\n        __class__:_b_.type,\n        $infos:{\n            __name__:'SRE_Pattern'\n        }\n    }\n    $SRE_PatternDict.__mro__ = [_b_.object]\n    $SRE_PatternDict.findall = function(self, string){\n        return obj.findall(self.pattern, string, self.flags)\n    }\n    $SRE_PatternDict.finditer = function(self, string){\n        return obj.finditer(self.pattern, string, self.flags)\n    }\n    $SRE_PatternDict.match = function(self, string){\n        return obj.match(self.pattern, string, self.flags)\n    }\n    $SRE_PatternDict.search = function(self, string){\n        return obj.search(self.pattern, string, self.flags)\n    }\n    $SRE_PatternDict.sub = function(self,repl,string){\n        return obj.sub(self.pattern,repl,string,self.flags)\n    }\n    $B.set_func_names($SRE_PatternDict, \"_jsre\")\n    // TODO: groups\n    // TODO: groupindex\n    function normflags(flags){\n        return ((flags & obj.I)? 'i' : '') + ((flags & obj.M)? 'm' : '');\n    }\n    // TODO: fullmatch()\n    // TODO: split()\n    // TODO: subn()\n    obj.compile = function(pattern, flags){\n        return {\n            __class__: $SRE_PatternDict,\n            pattern: pattern,\n            flags: normflags(flags)\n        }\n    }\n    obj.escape = function(string){\n        // Escape all the characters in pattern except ASCII letters, numbers\n        // and '_'. This is useful if you want to match an arbitrary literal\n        // string that may have regular expression metacharacters in it.\n        var res = ''\n        var ok = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_'\n        for(var i = 0, _len_i = string.length; i < _len_i; i++){\n            if(ok.search(string.charAt(i))>-1){res += string.charAt(i)}\n        }\n        return res\n    }\n    obj.findall = function(pattern, string, flags){\n        var $ns=$B.args('re.findall', 2,\n            {pattern:null, string:null}, ['pattern', 'string'],\n            arguments,{}, 'args', 'kw') ,\n            args = $ns['args'] ,\n            _flags = 0;\n        if(args.length>0){var flags = args[0]}\n        else{var _flags = $B.$getattr($ns['kw'], 'get')('flags', 0)}\n\n        var flags = normflags()\n        flags += 'gm'\n        var jsp = new RegExp(pattern,flags),\n            jsmatch = string.match(jsp)\n        if(jsmatch === null){return []}\n        return jsmatch\n    }\n    obj.finditer = function(pattern, string, flags){\n        var $ns=$B.args('re.finditer', 2,\n            {pattern:null, string:null}, ['pattern', 'string'],\n            arguments,{},'args','kw'),\n            args = $ns['args'],\n            _flags = 0;\n        if(args.length>0){var flags=args[0]}\n        else{var _flags = $B.$getattr($ns['kw'], 'get')('flags', 0)}\n\n        var flags = normflags()\n        flags += 'gm'\n        var jsp = new RegExp(pattern, flags),\n            jsmatch = string.match(jsp);\n        if(jsmatch === null){return []}\n\n        var _list = []\n        for(var j = 0, _len_j = jsmatch.length; j < _len_j; j++) {\n            var mo = {}\n            mo._match=jsmatch[j]\n            mo.group = function(){\n               var res = []\n               for(var i=0, _len_i = arguments.length; i < _len_i;i++){\n                   if(jsmatch[arguments[i]] === undefined){res.push(_b_.None)}\n                   else{res.push(jsmatch[arguments[i]])}\n               }\n               if(arguments.length == 1){return res[0]}\n               return _b_.tuple.$factory(res)\n            }\n            mo.groups = function(_default){\n               if(_default === undefined){_default = _b_.None}\n               var res = []\n               for(var i = 1, _len_i = jsmatch.length; i < _len_i; i++){\n                  if(jsmatch[i] === undefined){res.push(_default)}\n                  else{res.push(jsmatch[i])}\n               }\n               return _b_.tuple.$factory(res)\n            }\n            mo.start = function(){return mo._match.index}\n            mo.end = function(){return mo._match.length - mo._match.index}\n            mo.string = string\n            _list.push(mo)\n        }\n        return _list\n    }\n    obj.search = function(pattern, string){\n        var $ns = $B.args('re.search', 2,\n            {pattern:null, string:null},['pattern', 'string'],\n            arguments, {}, 'args', 'kw')\n        var args = $ns['args']\n        if(args.length>0){var flags = args[0]}\n        else{var flags = $B.$getattr($ns['kw'], 'get')('flags', '')}\n        flags = normflags(flags)\n        var jsp = new RegExp(pattern, flags)\n        var jsmatch = string.match(jsp)\n        if(jsmatch === null){return _b_.None}\n        return MatchObject.$factory(jsmatch, string, pattern)\n    }\n    obj.sub = function(pattern, repl, string){\n        var $ns=$B.args('re.search', 3,\n            {pattern: null, repl: null, string: null},\n            ['pattern', 'repl', 'string'],\n            arguments,{}, 'args', 'kw')\n        for($var in $ns){eval(\"var \" + $var + \"=$ns[$var]\")}\n        var args = $ns['args']\n        var count = _b_.dict.get($ns['kw'], 'count', 0)\n        var flags = _b_.dict.get($ns['kw'], 'flags', '')\n        if(args.length > 0){var count = args[0]}\n        if(args.length > 1){var flags = args[1]}\n        flags = normflags(flags)\n        if(typeof repl == \"string\"){\n            // backreferences are \\1, \\2... in Python but $1,$2... in Javascript\n            repl = repl.replace(/\\\\(\\d+)/g, '$$$1')\n        }else if(typeof repl == \"function\"){\n            // the argument passed to the Python function is the match object\n            // the arguments passed to the Javascript function are :\n            // - the matched substring\n            // - the matched groups\n            // - the offset of the matched substring inside the string\n            // - the string being examined\n            var $repl1 = function(){\n                var mo = Object()\n                mo.string = arguments[arguments.length - 1]\n                var matched = arguments[0];\n                var start = arguments[arguments.length - 2]\n                var end = start + matched.length\n                mo.start = function(){return start}\n                mo.end = function(){return end}\n                groups = []\n                for(var i = 1, _len_i = arguments.length-2; i < _len_i; i++){\n                    groups.push(arguments[i])\n                }\n                mo.groups = function(_default){\n                    if(_default === undefined){_default = _b_.None}\n                    var res = []\n                    for(var i = 0, _len_i = groups.length; i < _len_i; i++){\n                        if(groups[i] === undefined){res.push(_default)}\n                        else{res.push(groups[i])}\n                    }\n                    return res\n                }\n                mo.group = function(i){\n                    if(i==0){return matched}\n                    return groups[i-1]\n                }\n                return repl(mo)\n            }\n        }\n        if(count == 0){flags += 'g'}\n        var jsp = new RegExp(pattern, flags)\n        if(typeof repl == 'function'){return string.replace(jsp, $repl1)}\n        else{return string.replace(jsp, repl)}\n    }\n    obj.match = (function(search_func){\n        return function(){\n            // match is like search but pattern must start with ^\n            var pattern = arguments[0]\n            if(pattern.charAt(0) != '^'){pattern = '^'+pattern}\n            var args = [pattern]\n            for(var i = 1, _len_i = arguments.length; i < _len_i; i++){\n                args.push(arguments[i])\n            }\n            return search_func.apply(null, args)\n        }\n    })(obj.search)\n\n    $B.addToImported('_jsre', obj)\n}\n)(__BRYTHON__)\n"], "_locale": [".js", "var am = {\n    \"C\": \"AM\",\n    \"aa\": \"saaku\",\n    \"ab\": \"AM\",\n    \"ae\": \"AM\",\n    \"af\": \"vm.\",\n    \"ak\": \"AN\",\n    \"am\": \"\\u1325\\u12cb\\u1275\",\n    \"an\": \"AM\",\n    \"ar\": \"\\u0635\",\n    \"as\": \"\\u09f0\\u09be\\u09a4\\u09bf\\u09aa\\u09c1\",\n    \"av\": \"AM\",\n    \"ay\": \"AM\",\n    \"az\": \"AM\",\n    \"ba\": \"\",\n    \"be\": \"\",\n    \"bg\": \"\",\n    \"bh\": \"AM\",\n    \"bi\": \"AM\",\n    \"bm\": \"AM\",\n    \"bn\": \"AM\",\n    \"bo\": \"\\u0f66\\u0f94\\u0f0b\\u0f51\\u0fb2\\u0f7c\",\n    \"br\": \"A.M.\",\n    \"bs\": \"prijepodne\",\n    \"ca\": \"a. m.\",\n    \"ce\": \"AM\",\n    \"ch\": \"AM\",\n    \"co\": \"\",\n    \"cr\": \"AM\",\n    \"cs\": \"dop.\",\n    \"cu\": \"\\u0414\\u041f\",\n    \"cv\": \"AM\",\n    \"cy\": \"yb\",\n    \"da\": \"\",\n    \"de\": \"\",\n    \"dv\": \"\\u0789\\u0786\",\n    \"dz\": \"\\u0f66\\u0f94\\u0f0b\\u0f46\\u0f0b\",\n    \"ee\": \"\\u014bdi\",\n    \"el\": \"\\u03c0\\u03bc\",\n    \"en\": \"AM\",\n    \"eo\": \"atm\",\n    \"es\": \"\",\n    \"et\": \"AM\",\n    \"eu\": \"AM\",\n    \"fa\": \"\\u0642.\\u0638\",\n    \"ff\": \"\",\n    \"fi\": \"ap.\",\n    \"fj\": \"AM\",\n    \"fo\": \"um fyr.\",\n    \"fr\": \"\",\n    \"fy\": \"AM\",\n    \"ga\": \"r.n.\",\n    \"gd\": \"m\",\n    \"gl\": \"a.m.\",\n    \"gn\": \"a.m.\",\n    \"gu\": \"\\u0aaa\\u0ac2\\u0ab0\\u0acd\\u0ab5\\u00a0\\u0aae\\u0aa7\\u0acd\\u0aaf\\u0abe\\u0ab9\\u0acd\\u0aa8\",\n    \"gv\": \"a.m.\",\n    \"ha\": \"AM\",\n    \"he\": \"AM\",\n    \"hi\": \"\\u092a\\u0942\\u0930\\u094d\\u0935\\u093e\\u0939\\u094d\\u0928\",\n    \"ho\": \"AM\",\n    \"hr\": \"\",\n    \"ht\": \"AM\",\n    \"hu\": \"de.\",\n    \"hy\": \"\",\n    \"hz\": \"AM\",\n    \"ia\": \"a.m.\",\n    \"id\": \"AM\",\n    \"ie\": \"AM\",\n    \"ig\": \"A.M.\",\n    \"ii\": \"\\ua0b5\\ua1aa\\ua20c\\ua210\",\n    \"ik\": \"AM\",\n    \"io\": \"AM\",\n    \"is\": \"f.h.\",\n    \"it\": \"\",\n    \"iu\": \"AM\",\n    \"ja\": \"\\u5348\\u524d\",\n    \"jv\": \"\",\n    \"ka\": \"AM\",\n    \"kg\": \"AM\",\n    \"ki\": \"Kiroko\",\n    \"kj\": \"AM\",\n    \"kk\": \"AM\",\n    \"kl\": \"\",\n    \"km\": \"\\u1796\\u17d2\\u179a\\u17b9\\u1780\",\n    \"kn\": \"\\u0caa\\u0cc2\\u0cb0\\u0ccd\\u0cb5\\u0cbe\\u0cb9\\u0ccd\\u0ca8\",\n    \"ko\": \"\\uc624\\uc804\",\n    \"kr\": \"AM\",\n    \"ks\": \"AM\",\n    \"ku\": \"\\u067e.\\u0646\",\n    \"kv\": \"AM\",\n    \"kw\": \"a.m.\",\n    \"ky\": \"\",\n    \"la\": \"\",\n    \"lb\": \"\",\n    \"lg\": \"AM\",\n    \"li\": \"AM\",\n    \"ln\": \"nt\\u0254\\u0301ng\\u0254\\u0301\",\n    \"lo\": \"\\u0e81\\u0ec8\\u0ead\\u0e99\\u0e97\\u0ec8\\u0ebd\\u0e87\",\n    \"lt\": \"prie\\u0161piet\",\n    \"lu\": \"Dinda\",\n    \"lv\": \"priek\\u0161p.\",\n    \"mg\": \"AM\",\n    \"mh\": \"AM\",\n    \"mi\": \"a.m.\",\n    \"mk\": \"\\u043f\\u0440\\u0435\\u0442\\u043f\\u043b.\",\n    \"ml\": \"AM\",\n    \"mn\": \"??\",\n    \"mo\": \"AM\",\n    \"mr\": \"\\u092e.\\u092a\\u0942.\",\n    \"ms\": \"PG\",\n    \"mt\": \"AM\",\n    \"my\": \"\\u1014\\u1036\\u1014\\u1000\\u103a\",\n    \"na\": \"AM\",\n    \"nb\": \"a.m.\",\n    \"nd\": \"AM\",\n    \"ne\": \"\\u092a\\u0942\\u0930\\u094d\\u0935\\u093e\\u0939\\u094d\\u0928\",\n    \"ng\": \"AM\",\n    \"nl\": \"\",\n    \"nn\": \"f.m.\",\n    \"no\": \"a.m.\",\n    \"nr\": \"AM\",\n    \"nv\": \"AM\",\n    \"ny\": \"AM\",\n    \"oc\": \"AM\",\n    \"oj\": \"AM\",\n    \"om\": \"WD\",\n    \"or\": \"AM\",\n    \"os\": \"AM\",\n    \"pa\": \"\\u0a38\\u0a35\\u0a47\\u0a30\",\n    \"pi\": \"AM\",\n    \"pl\": \"AM\",\n    \"ps\": \"\\u063a.\\u0645.\",\n    \"pt\": \"\",\n    \"qu\": \"a.m.\",\n    \"rc\": \"AM\",\n    \"rm\": \"AM\",\n    \"rn\": \"Z.MU.\",\n    \"ro\": \"a.m.\",\n    \"ru\": \"\",\n    \"rw\": \"AM\",\n    \"sa\": \"\\u092e\\u0927\\u094d\\u092f\\u093e\\u0928\\u092a\\u0942\\u0930\\u094d\\u0935\",\n    \"sc\": \"AM\",\n    \"sd\": \"AM\",\n    \"se\": \"i.b.\",\n    \"sg\": \"ND\",\n    \"sh\": \"AM\",\n    \"si\": \"\\u0db4\\u0dd9.\\u0dc0.\",\n    \"sk\": \"AM\",\n    \"sl\": \"dop.\",\n    \"sm\": \"AM\",\n    \"sn\": \"AM\",\n    \"so\": \"sn.\",\n    \"sq\": \"e paradites\",\n    \"sr\": \"pre podne\",\n    \"ss\": \"AM\",\n    \"st\": \"AM\",\n    \"su\": \"AM\",\n    \"sv\": \"\",\n    \"sw\": \"AM\",\n    \"ta\": \"\\u0b95\\u0bbe\\u0bb2\\u0bc8\",\n    \"te\": \"\\u0c2a\\u0c42\\u0c30\\u0c4d\\u0c35\\u0c3e\\u0c39\\u0c4d\\u0c28\",\n    \"tg\": \"\",\n    \"th\": \"AM\",\n    \"ti\": \"\\u1295\\u1309\\u1206 \\u1230\\u12d3\\u1270\",\n    \"tk\": \"\",\n    \"tl\": \"AM\",\n    \"tn\": \"AM\",\n    \"to\": \"AM\",\n    \"tr\": \"\\u00d6\\u00d6\",\n    \"ts\": \"AM\",\n    \"tt\": \"\",\n    \"tw\": \"AM\",\n    \"ty\": \"AM\",\n    \"ug\": \"\\u0686?\\u0634\\u062a\\u0649\\u0646 \\u0628?\\u0631?\\u0646\",\n    \"uk\": \"AM\",\n    \"ur\": \"AM\",\n    \"uz\": \"TO\",\n    \"ve\": \"AM\",\n    \"vi\": \"SA\",\n    \"vo\": \"AM\",\n    \"wa\": \"AM\",\n    \"wo\": \"\",\n    \"xh\": \"AM\",\n    \"yi\": \"\\ua0b5\\ua1aa\\ua20c\\ua210\",\n    \"yo\": \"\\u00c0\\u00e1r?`\",\n    \"za\": \"AM\",\n    \"zh\": \"\\u4e0a\\u5348\",\n    \"zu\": \"AM\"\n}\nvar pm = {\n    \"C\": \"PM\",\n    \"aa\": \"carra\",\n    \"ab\": \"PM\",\n    \"ae\": \"PM\",\n    \"af\": \"nm.\",\n    \"ak\": \"EW\",\n    \"am\": \"\\u12a8\\u1230\\u12d3\\u1275\",\n    \"an\": \"PM\",\n    \"ar\": \"\\u0645\",\n    \"as\": \"\\u0986\\u09ac\\u09c7\\u09b2\\u09bf\",\n    \"av\": \"PM\",\n    \"ay\": \"PM\",\n    \"az\": \"PM\",\n    \"ba\": \"\",\n    \"be\": \"\",\n    \"bg\": \"\",\n    \"bh\": \"PM\",\n    \"bi\": \"PM\",\n    \"bm\": \"PM\",\n    \"bn\": \"PM\",\n    \"bo\": \"\\u0f55\\u0fb1\\u0f72\\u0f0b\\u0f51\\u0fb2\\u0f7c\",\n    \"br\": \"G.M.\",\n    \"bs\": \"popodne\",\n    \"ca\": \"p. m.\",\n    \"ce\": \"PM\",\n    \"ch\": \"PM\",\n    \"co\": \"\",\n    \"cr\": \"PM\",\n    \"cs\": \"odp.\",\n    \"cu\": \"\\u041f\\u041f\",\n    \"cv\": \"PM\",\n    \"cy\": \"yh\",\n    \"da\": \"\",\n    \"de\": \"\",\n    \"dv\": \"\\u0789\\u078a\",\n    \"dz\": \"\\u0f55\\u0fb1\\u0f72\\u0f0b\\u0f46\\u0f0b\",\n    \"ee\": \"\\u0263etr\\u0254\",\n    \"el\": \"\\u03bc\\u03bc\",\n    \"en\": \"PM\",\n    \"eo\": \"ptm\",\n    \"es\": \"\",\n    \"et\": \"PM\",\n    \"eu\": \"PM\",\n    \"fa\": \"\\u0628.\\u0638\",\n    \"ff\": \"\",\n    \"fi\": \"ip.\",\n    \"fj\": \"PM\",\n    \"fo\": \"um sein.\",\n    \"fr\": \"\",\n    \"fy\": \"PM\",\n    \"ga\": \"i.n.\",\n    \"gd\": \"f\",\n    \"gl\": \"p.m.\",\n    \"gn\": \"p.m.\",\n    \"gu\": \"\\u0a89\\u0aa4\\u0acd\\u0aa4\\u0ab0\\u00a0\\u0aae\\u0aa7\\u0acd\\u0aaf\\u0abe\\u0ab9\\u0acd\\u0aa8\",\n    \"gv\": \"p.m.\",\n    \"ha\": \"PM\",\n    \"he\": \"PM\",\n    \"hi\": \"\\u0905\\u092a\\u0930\\u093e\\u0939\\u094d\\u0928\",\n    \"ho\": \"PM\",\n    \"hr\": \"\",\n    \"ht\": \"PM\",\n    \"hu\": \"du.\",\n    \"hy\": \"\",\n    \"hz\": \"PM\",\n    \"ia\": \"p.m.\",\n    \"id\": \"PM\",\n    \"ie\": \"PM\",\n    \"ig\": \"P.M.\",\n    \"ii\": \"\\ua0b5\\ua1aa\\ua20c\\ua248\",\n    \"ik\": \"PM\",\n    \"io\": \"PM\",\n    \"is\": \"e.h.\",\n    \"it\": \"\",\n    \"iu\": \"PM\",\n    \"ja\": \"\\u5348\\u5f8c\",\n    \"jv\": \"\",\n    \"ka\": \"PM\",\n    \"kg\": \"PM\",\n    \"ki\": \"Hwa\\u0129-in\\u0129\",\n    \"kj\": \"PM\",\n    \"kk\": \"PM\",\n    \"kl\": \"\",\n    \"km\": \"\\u179b\\u17d2\\u1784\\u17b6\\u1785\",\n    \"kn\": \"\\u0c85\\u0caa\\u0cb0\\u0cbe\\u0cb9\\u0ccd\\u0ca8\",\n    \"ko\": \"\\uc624\\ud6c4\",\n    \"kr\": \"PM\",\n    \"ks\": \"PM\",\n    \"ku\": \"\\u062f.\\u0646\",\n    \"kv\": \"PM\",\n    \"kw\": \"p.m.\",\n    \"ky\": \"\",\n    \"la\": \"\",\n    \"lb\": \"\",\n    \"lg\": \"PM\",\n    \"li\": \"PM\",\n    \"ln\": \"mp\\u00f3kwa\",\n    \"lo\": \"\\u0eab\\u0ebc\\u0eb1\\u0e87\\u0e97\\u0ec8\\u0ebd\\u0e87\",\n    \"lt\": \"popiet\",\n    \"lu\": \"Dilolo\",\n    \"lv\": \"p\\u0113cp.\",\n    \"mg\": \"PM\",\n    \"mh\": \"PM\",\n    \"mi\": \"p.m.\",\n    \"mk\": \"\\u043f\\u043e\\u043f\\u043b.\",\n    \"ml\": \"PM\",\n    \"mn\": \"?\\u0425\",\n    \"mo\": \"PM\",\n    \"mr\": \"\\u092e.\\u0928\\u0902.\",\n    \"ms\": \"PTG\",\n    \"mt\": \"PM\",\n    \"my\": \"\\u100a\\u1014\\u1031\",\n    \"na\": \"PM\",\n    \"nb\": \"p.m.\",\n    \"nd\": \"PM\",\n    \"ne\": \"\\u0905\\u092a\\u0930\\u093e\\u0939\\u094d\\u0928\",\n    \"ng\": \"PM\",\n    \"nl\": \"\",\n    \"nn\": \"e.m.\",\n    \"no\": \"p.m.\",\n    \"nr\": \"PM\",\n    \"nv\": \"PM\",\n    \"ny\": \"PM\",\n    \"oc\": \"PM\",\n    \"oj\": \"PM\",\n    \"om\": \"WB\",\n    \"or\": \"PM\",\n    \"os\": \"PM\",\n    \"pa\": \"\\u0a36\\u0a3e\\u0a2e\",\n    \"pi\": \"PM\",\n    \"pl\": \"PM\",\n    \"ps\": \"\\u063a.\\u0648.\",\n    \"pt\": \"\",\n    \"qu\": \"p.m.\",\n    \"rc\": \"PM\",\n    \"rm\": \"PM\",\n    \"rn\": \"Z.MW.\",\n    \"ro\": \"p.m.\",\n    \"ru\": \"\",\n    \"rw\": \"PM\",\n    \"sa\": \"\\u092e\\u0927\\u094d\\u092f\\u093e\\u0928\\u092a\\u091a\\u094d\\u092f\\u093e\\u0924\",\n    \"sc\": \"PM\",\n    \"sd\": \"PM\",\n    \"se\": \"e.b.\",\n    \"sg\": \"LK\",\n    \"sh\": \"PM\",\n    \"si\": \"\\u0db4.\\u0dc0.\",\n    \"sk\": \"PM\",\n    \"sl\": \"pop.\",\n    \"sm\": \"PM\",\n    \"sn\": \"PM\",\n    \"so\": \"gn.\",\n    \"sq\": \"e pasdites\",\n    \"sr\": \"po podne\",\n    \"ss\": \"PM\",\n    \"st\": \"PM\",\n    \"su\": \"PM\",\n    \"sv\": \"\",\n    \"sw\": \"PM\",\n    \"ta\": \"\\u0bae\\u0bbe\\u0bb2\\u0bc8\",\n    \"te\": \"\\u0c05\\u0c2a\\u0c30\\u0c3e\\u0c39\\u0c4d\\u0c28\",\n    \"tg\": \"\",\n    \"th\": \"PM\",\n    \"ti\": \"\\u12f5\\u1215\\u122d \\u1230\\u12d3\\u1275\",\n    \"tk\": \"\",\n    \"tl\": \"PM\",\n    \"tn\": \"PM\",\n    \"to\": \"PM\",\n    \"tr\": \"\\u00d6S\",\n    \"ts\": \"PM\",\n    \"tt\": \"\",\n    \"tw\": \"PM\",\n    \"ty\": \"PM\",\n    \"ug\": \"\\u0686?\\u0634\\u062a\\u0649\\u0646 \\u0643?\\u064a\\u0649\\u0646\",\n    \"uk\": \"PM\",\n    \"ur\": \"PM\",\n    \"uz\": \"TK\",\n    \"ve\": \"PM\",\n    \"vi\": \"CH\",\n    \"vo\": \"PM\",\n    \"wa\": \"PM\",\n    \"wo\": \"\",\n    \"xh\": \"PM\",\n    \"yi\": \"\\ua0b5\\ua1aa\\ua20c\\ua248\",\n    \"yo\": \"?`s\\u00e1n\",\n    \"za\": \"PM\",\n    \"zh\": \"\\u4e0b\\u5348\",\n    \"zu\": \"PM\"\n}\n\nvar X_format = {\n    \"%H:%M:%S\": [\n        \"C\",\n        \"ab\",\n        \"ae\",\n        \"af\",\n        \"an\",\n        \"av\",\n        \"ay\",\n        \"az\",\n        \"ba\",\n        \"be\",\n        \"bg\",\n        \"bh\",\n        \"bi\",\n        \"bm\",\n        \"bo\",\n        \"br\",\n        \"bs\",\n        \"ca\",\n        \"ce\",\n        \"ch\",\n        \"co\",\n        \"cr\",\n        \"cs\",\n        \"cu\",\n        \"cv\",\n        \"cy\",\n        \"da\",\n        \"de\",\n        \"dv\",\n        \"eo\",\n        \"es\",\n        \"et\",\n        \"eu\",\n        \"ff\",\n        \"fj\",\n        \"fo\",\n        \"fr\",\n        \"fy\",\n        \"ga\",\n        \"gd\",\n        \"gl\",\n        \"gn\",\n        \"gu\",\n        \"gv\",\n        \"ha\",\n        \"he\",\n        \"hi\",\n        \"ho\",\n        \"hr\",\n        \"ht\",\n        \"hu\",\n        \"hy\",\n        \"hz\",\n        \"ia\",\n        \"ie\",\n        \"ig\",\n        \"ik\",\n        \"io\",\n        \"is\",\n        \"it\",\n        \"ja\",\n        \"ka\",\n        \"kg\",\n        \"ki\",\n        \"kj\",\n        \"kk\",\n        \"kl\",\n        \"km\",\n        \"kn\",\n        \"kv\",\n        \"kw\",\n        \"ky\",\n        \"la\",\n        \"lb\",\n        \"lg\",\n        \"li\",\n        \"ln\",\n        \"lo\",\n        \"lt\",\n        \"lu\",\n        \"lv\",\n        \"mg\",\n        \"mh\",\n        \"mk\",\n        \"mn\",\n        \"mo\",\n        \"mr\",\n        \"mt\",\n        \"my\",\n        \"na\",\n        \"nb\",\n        \"nd\",\n        \"ng\",\n        \"nl\",\n        \"nn\",\n        \"no\",\n        \"nr\",\n        \"nv\",\n        \"ny\",\n        \"oj\",\n        \"or\",\n        \"os\",\n        \"pi\",\n        \"pl\",\n        \"ps\",\n        \"pt\",\n        \"rc\",\n        \"rm\",\n        \"rn\",\n        \"ro\",\n        \"ru\",\n        \"rw\",\n        \"sa\",\n        \"sc\",\n        \"se\",\n        \"sg\",\n        \"sh\",\n        \"sk\",\n        \"sl\",\n        \"sm\",\n        \"sn\",\n        \"sr\",\n        \"ss\",\n        \"st\",\n        \"su\",\n        \"sv\",\n        \"sw\",\n        \"ta\",\n        \"te\",\n        \"tg\",\n        \"th\",\n        \"tk\",\n        \"tl\",\n        \"tn\",\n        \"tr\",\n        \"ts\",\n        \"tt\",\n        \"tw\",\n        \"ty\",\n        \"ug\",\n        \"uk\",\n        \"uz\",\n        \"ve\",\n        \"vo\",\n        \"wa\",\n        \"wo\",\n        \"xh\",\n        \"yo\",\n        \"za\",\n        \"zh\",\n        \"zu\"\n    ],\n    \"%i:%M:%S %p\": [\n        \"aa\",\n        \"ak\",\n        \"am\",\n        \"bn\",\n        \"el\",\n        \"en\",\n        \"iu\",\n        \"kr\",\n        \"ks\",\n        \"mi\",\n        \"ml\",\n        \"ms\",\n        \"ne\",\n        \"om\",\n        \"sd\",\n        \"so\",\n        \"sq\",\n        \"ti\",\n        \"to\",\n        \"ur\",\n        \"vi\"\n    ],\n    \"%I:%M:%S %p\": [\n        \"ar\",\n        \"fa\",\n        \"ku\",\n        \"qu\"\n    ],\n    \"%p %i:%M:%S\": [\n        \"as\",\n        \"ii\",\n        \"ko\",\n        \"yi\"\n    ],\n    \"\\u0f46\\u0f74\\u0f0b\\u0f5a\\u0f7c\\u0f51\\u0f0b%i:%M:%S %p\": [\n        \"dz\"\n    ],\n    \"%p ga %i:%M:%S\": [\n        \"ee\"\n    ],\n    \"%H.%M.%S\": [\n        \"fi\",\n        \"id\",\n        \"jv\",\n        \"oc\",\n        \"si\"\n    ],\n    \"%p %I:%M:%S\": [\n        \"pa\"\n    ]\n}\nvar x_format = {\n    \"%m/%d/%y\": [\n        \"C\"\n    ],\n    \"%d/%m/%Y\": [\n        \"aa\",\n        \"am\",\n        \"bm\",\n        \"bn\",\n        \"ca\",\n        \"co\",\n        \"cy\",\n        \"el\",\n        \"es\",\n        \"ff\",\n        \"fr\",\n        \"ga\",\n        \"gd\",\n        \"gl\",\n        \"gn\",\n        \"gv\",\n        \"ha\",\n        \"he\",\n        \"id\",\n        \"ig\",\n        \"it\",\n        \"iu\",\n        \"jv\",\n        \"ki\",\n        \"kr\",\n        \"kw\",\n        \"la\",\n        \"lg\",\n        \"ln\",\n        \"lo\",\n        \"lu\",\n        \"mi\",\n        \"ml\",\n        \"ms\",\n        \"mt\",\n        \"nd\",\n        \"oc\",\n        \"om\",\n        \"pt\",\n        \"qu\",\n        \"rn\",\n        \"sd\",\n        \"sg\",\n        \"so\",\n        \"sw\",\n        \"ti\",\n        \"to\",\n        \"uk\",\n        \"ur\",\n        \"uz\",\n        \"vi\",\n        \"wo\",\n        \"yo\"\n    ],\n    \"%m/%d/%Y\": [\n        \"ab\",\n        \"ae\",\n        \"an\",\n        \"av\",\n        \"ay\",\n        \"bh\",\n        \"bi\",\n        \"ch\",\n        \"cr\",\n        \"cv\",\n        \"ee\",\n        \"en\",\n        \"fj\",\n        \"ho\",\n        \"ht\",\n        \"hz\",\n        \"ie\",\n        \"ik\",\n        \"io\",\n        \"kg\",\n        \"kj\",\n        \"ks\",\n        \"kv\",\n        \"li\",\n        \"mh\",\n        \"mo\",\n        \"na\",\n        \"ne\",\n        \"ng\",\n        \"nv\",\n        \"ny\",\n        \"oj\",\n        \"pi\",\n        \"rc\",\n        \"sc\",\n        \"sh\",\n        \"sm\",\n        \"su\",\n        \"tl\",\n        \"tw\",\n        \"ty\",\n        \"wa\",\n        \"za\",\n        \"zu\"\n    ],\n    \"%Y-%m-%d\": [\n        \"af\",\n        \"br\",\n        \"ce\",\n        \"dz\",\n        \"eo\",\n        \"ko\",\n        \"lt\",\n        \"mg\",\n        \"nr\",\n        \"rw\",\n        \"se\",\n        \"si\",\n        \"sn\",\n        \"ss\",\n        \"st\",\n        \"sv\",\n        \"tn\",\n        \"ts\",\n        \"ug\",\n        \"ve\",\n        \"vo\",\n        \"xh\"\n    ],\n    \"%Y/%m/%d\": [\n        \"ak\",\n        \"bo\",\n        \"eu\",\n        \"ia\",\n        \"ii\",\n        \"ja\",\n        \"ku\",\n        \"yi\",\n        \"zh\"\n    ],\n    \"null\": [\n        \"ar\",\n        \"fa\",\n        \"ps\",\n        \"th\"\n    ],\n    \"%d-%m-%Y\": [\n        \"as\",\n        \"da\",\n        \"fy\",\n        \"hi\",\n        \"kl\",\n        \"mr\",\n        \"my\",\n        \"nl\",\n        \"rm\",\n        \"sa\",\n        \"ta\"\n    ],\n    \"%d.%m.%Y\": [\n        \"az\",\n        \"cs\",\n        \"de\",\n        \"et\",\n        \"fi\",\n        \"fo\",\n        \"hy\",\n        \"is\",\n        \"ka\",\n        \"kk\",\n        \"lv\",\n        \"mk\",\n        \"nb\",\n        \"nn\",\n        \"no\",\n        \"os\",\n        \"pl\",\n        \"ro\",\n        \"ru\",\n        \"sq\",\n        \"tg\",\n        \"tr\",\n        \"tt\"\n    ],\n    \"%d.%m.%y\": [\n        \"ba\",\n        \"be\",\n        \"lb\"\n    ],\n    \"%d.%m.%Y \\u0433.\": [\n        \"bg\"\n    ],\n    \"%d.%m.%Y.\": [\n        \"bs\",\n        \"hr\",\n        \"sr\"\n    ],\n    \"%Y.%m.%d\": [\n        \"cu\",\n        \"mn\"\n    ],\n    \"%d/%m/%y\": [\n        \"dv\",\n        \"km\"\n    ],\n    \"%d-%m-%y\": [\n        \"gu\",\n        \"kn\",\n        \"or\",\n        \"pa\",\n        \"te\"\n    ],\n    \"%Y. %m. %d.\": [\n        \"hu\"\n    ],\n    \"%d-%b %y\": [\n        \"ky\"\n    ],\n    \"%d. %m. %Y\": [\n        \"sk\",\n        \"sl\"\n    ],\n    \"%d.%m.%y \\u00fd.\": [\n        \"tk\"\n    ]\n}\n\n\n\n__BRYTHON__.imported._locale = (function($B){\n    var _b_ = $B.builtins\n    return {\n        CHAR_MAX: 127,\n        LC_ALL: 6,\n        LC_COLLATE: 3,\n        LC_CTYPE: 0,\n        LC_MESSAGES: 5,\n        LC_MONETARY: 4,\n        LC_NUMERIC: 1,\n        LC_TIME: 2,\n        Error: _b_.ValueError,\n\n        _date_format: function(spec, hour){\n            var t,\n                locale = __BRYTHON__.locale.substr(0, 2)\n\n            if(spec == \"p\"){\n                var res = hours < 12 ? am[locale] : pm[locale]\n                if(res === undefined){\n                    throw _b_.ValueError.$factory(\"no format \" + spec + \" for locale \" +\n                        locale)\n                }\n                return res\n            }\n            else if(spec == \"x\"){\n                t = x_format\n            }else if(spec == \"X\"){\n                t = X_format\n            }else{\n                throw _b_.ValueError.$factory(\"invalid format\", spec)\n            }\n            for(var key in t){\n                if(t[key].indexOf(locale) > -1){\n                    return key\n                }\n            }\n            throw _b_.ValueError.$factory(\"no format \" + spec + \" for locale \" +\n                locale)\n        },\n\n        localeconv: function(){\n            var conv = {'grouping': $B.$list([127]),\n                    'currency_symbol': '',\n                    'n_sign_posn': 127,\n                    'p_cs_precedes': 127,\n                    'n_cs_precedes': 127,\n                    'mon_grouping': $B.$list([]),\n                    'n_sep_by_space': 127,\n                    'decimal_point': '.',\n                    'negative_sign': '',\n                    'positive_sign': '',\n                    'p_sep_by_space': 127,\n                    'int_curr_symbol': '',\n                    'p_sign_posn': 127,\n                    'thousands_sep': '',\n                    'mon_thousands_sep': '',\n                    'frac_digits': 127,\n                    'mon_decimal_point': '',\n                    'int_frac_digits': 127\n             }\n             var res = $B.empty_dict()\n             for(var key in conv){\n                 _b_.dict.$setitem(res, key, conv[key])\n             }\n\n             return res\n         },\n\n        setlocale : function(){\n            var $ = $B.args(\"setlocale\", 2, {category: null, locale: null},\n                [\"category\", \"locale\"], arguments, {locale: _b_.None},\n                null, null)\n            /// XXX category is currently ignored\n            if($.locale == \"\"){\n                // use browser language setting, if it is set\n                var LANG = ($B.language || \"\").substr(0, 2)\n                if(am.hasOwnProperty(LANG)){\n                    $B.locale = LANG\n                    return LANG\n                }else{\n                    console.log(\"Unknown locale: \" + LANG)\n                }\n            }else if($.locale === _b_.None){\n                // return current locale\n                return $B.locale\n            }else{\n                // Only use 2 first characters\n                try{$.locale.substr(0, 2)}\n                catch(err){\n                    throw $module.Error.$factory(\"Invalid locale: \" + $.locale)\n                }\n                if(am.hasOwnProperty($.locale.substr(0, 2))){\n                    $B.locale = $.locale\n                    return $.locale\n                }else{\n                    throw $module.Error.$factory(\"Unknown locale: \" + $.locale)\n                }\n            }\n        }\n    }\n})(__BRYTHON__)\n"], "_multiprocessing": [".js", "// multiprocessing\n(function($B){\n\nvar _b_ = $B.builtins\n\nvar Process = $B.make_class('Process')\n\nvar $convert_args=function(args) {\n    var _list=[]\n    for(var i=0, _len_i = args.length; i < _len_i; i++) {\n      var _a=args[i]\n      if($B.$isinstance(_a, _b_.str)){_list.push(\"'\"+_a+\"'\")} else {_list.push(_a)}\n    }\n\n    return _list.join(',')\n}\n\nProcess.is_alive = function(self){return self.$alive}\n\nProcess.join = function(self, timeout){\n   // need to block until process is complete\n   // could probably use a addEventListener to execute all existing code\n   // after this join statement\n\n   self.$worker.addEventListener('message', function (e) {\n        var data=e.data\n        if (data.stdout != '') { // output stdout from process\n           $B.stdout.write(data.stdout)\n        }\n   }, false);\n}\n\nProcess.run = function(self){\n   //fix me\n}\n\nProcess.start = function(self){\n   self.$worker.postMessage({target: self.$target,\n                             args: $convert_args(self.$args),\n                          //   kwargs: self.$kwargs\n                           })\n   self.$worker.addEventListener('error', function(e) { throw e})\n   self.$alive=true\n}\n\nProcess.terminate = function(self){\n   self.$worker.terminate()\n   self.$alive=false\n}\n\n// variables\n//name\n//daemon\n//pid\n//exitcode\n\nProcess. $factory = function(){\n    //arguments group=None, target=None, name=None, args=(), kwargs=()\n\n    var $ns=$B.args('Process',0,{},[],arguments,{},null,'kw')\n    var kw=$ns['kw']\n\n    var target=_b_.dict.get($ns['kw'],'target', _b_.None)\n    var args=_b_.dict.get($ns['kw'],'args', _b_.tuple.$factory())\n\n    var worker = new Worker('/src/web_workers/multiprocessing.js')\n\n    var res = {\n        __class__: Process,\n        $worker: worker,\n        name: $ns['name'] || _b_.None,\n        $target: target + '',\n        $args: args,\n        $alive: false\n    }\n    return res\n}\n\n$B.set_func_names(Process, \"multiprocessing\")\n\nvar Pool = $B.make_class(\"Pool\")\n\nPool.__enter__ = function(self){}\nPool.__exit__ = function(self){}\n\nPool.__str__ = Pool.toString = Pool.__repr__=function(self){\n   return '<object Pool>'\n}\n\nPool.map = function(){\n\n   var $ns=$B.args('Pool.map', 3,\n       {self:null, func:null, fargs:null}, ['self', 'func', 'fargs'],\n       arguments,{},'args','kw')\n   var func = $ns['func']\n   var fargs = $ns['fargs']\n\n   var _results = []\n\n   fargs = _b_.iter(fargs)\n\n   var _pos = 0\n   var _workers =[]\n   for(var i=0; i < self.$processes; i++) {\n       _workers[i] = new Worker('/src/web_workers/multiprocessing.js')\n       var arg\n\n       try{\n           arg = $B.$getattr(fargs, '__next__')()\n       }catch(err) {\n          if(err.__class__ !== _b_.StopIteration){\n              throw err\n          }\n       }\n       console.log(arg)\n       _workers[i].finished = false\n       _workers[i].postMessage({target: func+'', pos: _pos,\n                             args: $convert_args([arg])})\n       _pos++\n\n       _workers[i].addEventListener('message', function(e) {\n           _results[e.data.pos]=e.data.result\n           if (_results.length == args.length){\n               return _results\n           }\n           try{\n               arg = $B.$getattr(fargs, '__next__')()\n               e.currentTarget.postMessage({target: func+'', pos: _pos,\n                                            args: $convert_args([arg])})\n               _pos++\n           }catch(err){\n               if (err.__class__ !== _b_.StopIteration){\n                   throw err\n               }\n               this.finished = true\n           }\n       }, false);\n   }\n}\n\nPool.apply_async = function(){\n\n   var $ns = $B.$args('apply_async', 3,\n       {self:null, func:null, fargs:null}, ['self', 'func', 'fargs'],\n       arguments,{},'args','kw')\n   var func = $ns['func']\n   var fargs = $ns['fargs']\n\n   fargs = _b_.iter(fargs)\n\n   async_result = {}\n   async_result.get = function(timeout){\n                      console.log(results)\n                      console.log(fargs)\n                      return this.results}\n   async_result.results=[]\n\n   var _pos=0\n\n   _workers=[]\n   for(var i=0; i < self.$processes; i++) {\n       _workers[i] = new Worker('/src/web_workers/multiprocessing.js')\n       var arg\n\n       try{\n           arg = $B.$getattr(fargs, '__next__')()\n       }catch(err) {\n          if (err.__class__ !== _b_.StopIteration){\n              throw err\n          }\n       }\n       _workers[i].postMessage({target: func+'', pos: _pos,\n                             args: $convert_args([arg])})\n       _pos++\n\n       _workers[i].addEventListener('message', function(e) {\n           async_result.results[e.data.pos]=e.data.result\n           //if (_results.length == args.length) return _results\n\n           try {\n               arg = $B.$getattr(fargs, '__next__')()\n               e.currentTarget.postMessage({target: func+'', pos: _pos,\n                                            args: $convert_args([arg])})\n               _pos++\n           } catch(err) {\n               if (err.__class__ !== _b_.StopIteration){\n                   throw err\n               }\n               this.finished=true\n           }\n       }, false);\n   }\n\n   return async_result\n}\n\nPool.$factory = function(){\n    var $ns = $B.args('Pool',1,\n        {processes:null},['processes'],arguments,{},'args','kw')\n\n    var processes = $ns['processes']\n\n    if (processes === _b_.None) {\n       // look to see if we have stored cpu_count in local storage\n       // maybe we should create a brython config file with settings,etc..??\n\n       // if not there use a tool such as Core Estimator to calculate number of cpu's\n       // http://eligrey.com/blog/post/cpu-core-estimation-with-javascript\n    }\n\n    var res = {\n        __class__: Pool,\n        $processes: processes\n    }\n    return res\n}\n\n$B.set_func_names(Pool, \"multiprocessing\")\n\n$B.imported._multiprocessing = {Process, Pool}\n\n})(__BRYTHON__)\n"], "_posixsubprocess": [".js", "(function($B){\n\n    $B.imported._posixsubprocess = {\n       cloexec_pipe: function() {},   // fixme\n       fork_exec: function(){}\n    }\n})(__BRYTHON__)\n"], "_profile": [".js", "// Private interface to the profiling instrumentation implemented in py_utils.js.\n// Uses local a copy of the eval function from py_builtin_functions.js\n\nvar $module=(function($B) {\n    eval($B.InjectBuiltins());\n    return {\n        brython:$B,\n        data:$B.$profile_data,\n        start:$B.$profile.start,\n        stop:$B.$profile.stop,\n        pause:$B.$profile.pause,\n        status:$B.$profile.status,\n        clear:$B.$profile.clear,\n        elapsed:$B.$profile.elapsed,\n        run:function(src,_globals,_locals,nruns) {\n            var current_frame = $B.frames_stack[$B.frames_stack.length-1]\n            if(current_frame!==undefined){\n                var current_locals_id = current_frame[0].replace(/\\./,'_'),\n             current_globals_id = current_frame[2].replace(/\\./,'_')\n            }\n\n            var is_exec = true,\n                leave = false\n\n            // code will be run in a specific block\n            var globals_id = '$profile_'+$B.UUID(),\n             locals_id\n\n             if(_locals===_globals){\n                 locals_id = globals_id\n             }else{\n                 locals_id = '$profile_'+$B.UUID()\n             }\n             // Initialise the object for block namespaces\n             eval('var $locals_'+globals_id+' = {}\\nvar $locals_'+locals_id+' = {}')\n\n             // Initialise block globals\n\n            // A _globals dictionary is provided, set or reuse its attribute\n            // globals_id\n            _globals.globals_id = _globals.globals_id || globals_id\n            globals_id = _globals.globals_id\n\n            if(_locals === _globals || _locals === undefined){\n                locals_id = globals_id\n                parent_scope = $B.builtins_scope\n            }else{\n                // The parent block of locals must be set to globals\n                parent_scope = {\n                    id: globals_id,\n                    parent_block: $B.builtins_scope,\n                    binding: {}\n                }\n                for(var attr of _b_.dict.$keys_string(_globals)){\n                    parent_scope.binding[attr] = true\n                }\n            }\n\n            // Initialise block globals\n            if(_globals.$jsobj){\n                var items = _globals.$jsobj\n            }else{\n                var items = {}\n                for(var key of _b_.dict.$keys_string(_globals)){\n                    items[key] = _b_.dict.$getitem_string(_globals, key)\n                }\n            }\n            for(var item in items){\n                item1 = to_alias(item)\n                try{\n                    eval('$locals_' + globals_id + '[\"' + item1 +\n                        '\"] = items[item]')\n                }catch(err){\n                    console.log(err)\n                    console.log('error setting', item)\n                    break\n                }\n            }\n\n             // Initialise block locals\n            var items = _b_.dict.items(_locals), item\n            if(_locals.$jsobj){\n                var items = _locals.$jsobj\n            }else{\n                var items = {}\n                for(var key of _b_.dict.$keys_string(_locals)){\n                    items[key] = _b_.dict.$getitem_string(_locals, key)\n                }            }\n            for(var item in items){\n                item1 = to_alias(item)\n                try{\n                    eval('$locals_' + locals_id + '[\"' + item[0] + '\"] = item[1]')\n                }catch(err){\n                    console.log(err)\n                    console.log('error setting', item)\n                    break\n                }\n            }\n             //var nb_modules = Object.keys(__BRYTHON__.modules).length\n             //console.log('before exec', nb_modules)\n\n            console.log(\"call py2js\", src, globals_id, locals_id, parent_scope)\n            var root = $B.py2js(src, globals_id, locals_id, parent_scope),\n                js, gns, lns\n\n             try{\n\n                 var js = root.to_js()\n\n                     var i,res,gns;\n                     for(i=0;i<nruns;i++) {\n                         res = eval(js)\n                         gns = eval('$locals_'+globals_id)\n                     }\n\n                     // Update _locals with the namespace after execution\n                     if(_locals!==undefined){\n                         var lns = eval('$locals_'+locals_id)\n                         var setitem = getattr(_locals,'__setitem__')\n                         for(var attr in lns){\n                             if(attr.charAt(0)=='$'){continue}\n                             setitem(attr, lns[attr])\n                         }\n                     }else{\n                         for(var attr in lns){current_frame[1][attr] = lns[attr]}\n                     }\n\n                     if(_globals!==undefined){\n                         // Update _globals with the namespace after execution\n                         var setitem = getattr(_globals,'__setitem__')\n                         for(var attr in gns){\n                             if(attr.charAt(0)=='$'){continue}\n                             setitem(attr, gns[attr])\n                         }\n                     }else{\n                         for(var attr in gns){\n                             current_frame[3][attr] = gns[attr]\n                         }\n                     }\n\n                     // fixme: some extra variables are bleeding into locals...\n                     /*  This also causes issues for unittests */\n                     if(res===undefined) return _b_.None\n                         return res\n             }catch(err){\n                 if(err.$py_error===undefined){throw $B.exception(err)}\n                 throw err\n             }finally{\n\n                 delete __BRYTHON__.modules[globals_id]\n                 delete __BRYTHON__.modules[locals_id]\n                 \n                 if(!is_exec && leave_frame){\n                     // For eval(), the finally clause with \"leave_frame\" was removed\n                     // so we must execute it here\n                     $B.frames_stack.pop()\n                 }\n             }\n        }\n    }\n})(__BRYTHON__)\n"], "_random": [".js", "// Javascript implementation of the _random module\n// Based on Ian Bicking's implementation of the Mersenne twister\n\n(function($B){\n\nvar _b_ = $B.builtins\n\n// Code copied from https://github.com/ianb/whrandom/blob/master/mersenne.js\n// by Ian Bicking\n\n// this program is a JavaScript version of Mersenne Twister,\n// a straight conversion from the original program, mt19937ar.c,\n// translated by y. okada on july 17, 2006.\n// and modified a little at july 20, 2006, but there are not any substantial differences.\n// modularized by Ian Bicking, March 25, 2013 (found original version at http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/VERSIONS/JAVASCRIPT/java-script.html)\n// in this program, procedure descriptions and comments of original source code were not removed.\n// lines commented with //c// were originally descriptions of c procedure. and a few following lines are appropriate JavaScript descriptions.\n// lines commented with /* and */ are original comments.\n// lines commented with // are additional comments in this JavaScript version.\n/*\n   A C-program for MT19937, with initialization improved 2002/1/26.\n   Coded by Takuji Nishimura and Makoto Matsumoto.\n\n   Before using, initialize the state by using init_genrand(seed)\n   or init_by_array(init_key, key_length).\n\n   Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,\n   All rights reserved.\n\n   Redistribution and use in source and binary forms, with or without\n   modification, are permitted provided that the following conditions\n   are met:\n\n     1. Redistributions of source code must retain the above copyright\n        notice, this list of conditions and the following disclaimer.\n\n     2. Redistributions in binary form must reproduce the above copyright\n        notice, this list of conditions and the following disclaimer in the\n        documentation and/or other materials provided with the distribution.\n\n     3. The names of its contributors may not be used to endorse or promote\n        products derived from this software without specific prior written\n        permission.\n\n   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n   \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n   A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n\n   Any feedback is very welcome.\n   http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html\n   email: m-mat @ math.sci.hiroshima-u.ac.jp (remove space)\n*/\n\nfunction RandomStream(seed) {\n    /*jshint bitwise:false */\n    /* Period parameters */\n    //c//#define N 624\n    //c//#define M 397\n    //c//#define MATRIX_A 0x9908b0dfUL   /* constant vector a */\n    //c//#define UPPER_MASK 0x80000000UL /* most significant w-r bits */\n    //c//#define LOWER_MASK 0x7fffffffUL /* least significant r bits */\n    var N = 624\n    var M = 397\n    var MATRIX_A = 0x9908b0df   /* constant vector a */\n    var UPPER_MASK = 0x80000000 /* most significant w-r bits */\n    var LOWER_MASK = 0x7fffffff /* least significant r bits */\n    //c//static unsigned long mt[N]; /* the array for the state vector  */\n    //c//static int mti=N+1; /* mti==N+1 means mt[N] is not initialized */\n    var mt = new Array(N)   /* the array for the state vector  */\n    var mti = N + 1           /* mti==N+1 means mt[N] is not initialized */\n\n    function unsigned32(n1){\n        // returns a 32-bits unsiged integer from an operand to which applied a\n        // bit operator.\n        return n1 < 0 ? (n1 ^ UPPER_MASK) + UPPER_MASK : n1\n    }\n\n    function subtraction32(n1, n2){\n    // emulates lowerflow of a c 32-bits unsiged integer variable, instead of\n    // the operator -. these both arguments must be non-negative integers\n    // expressible using unsigned 32 bits.\n        return n1 < n2 ? unsigned32((0x100000000 - (n2 - n1)) & 0xffffffff) :\n          n1 - n2\n    }\n\n    function addition32(n1, n2){\n        // emulates overflow of a c 32-bits unsiged integer variable, instead of\n        // the operator +. these both arguments must be non-negative integers\n        // expressible using unsigned 32 bits.\n        return unsigned32((n1 + n2) & 0xffffffff)\n    }\n\n    function multiplication32(n1, n2){\n        // emulates overflow of a c 32-bits unsiged integer variable, instead of the\n        // operator *. these both arguments must be non-negative integers\n        // expressible using unsigned 32 bits.\n        var sum = 0\n        for (var i = 0; i < 32; ++i){\n            if((n1 >>> i) & 0x1){\n                sum = addition32(sum, unsigned32(n2 << i))\n            }\n        }\n        return sum\n    }\n\n    /* initializes mt[N] with a seed */\n    //c//void init_genrand(unsigned long s)\n    function init_genrand(s) {\n        //c//mt[0]= s & 0xffffffff;\n        mt[0] = unsigned32(s & 0xffffffff)\n        for(mti = 1; mti < N; mti++){\n            mt[mti] =\n                //c//(1812433253 * (mt[mti-1] ^ (mt[mti-1] >> 30)) + mti);\n                addition32(multiplication32(1812433253,\n                    unsigned32(mt[mti - 1] ^ (mt[mti - 1] >>> 30))), mti)\n            /* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */\n            /* In the previous versions, MSBs of the seed affect   */\n            /* only MSBs of the array mt[].                        */\n            /* 2002/01/09 modified by Makoto Matsumoto             */\n            //c//mt[mti] &= 0xffffffff;\n            mt[mti] = unsigned32(mt[mti] & 0xffffffff);\n            /* for >32 bit machines */\n        }\n    }\n\n    /* initialize by an array with array-length */\n    /* init_key is the array for initializing keys */\n    /* key_length is its length */\n    /* slight change for C++, 2004/2/26 */\n    //c//void init_by_array(unsigned long init_key[], int key_length)\n    function init_by_array(init_key, key_length) {\n        //c//int i, j, k;\n        var i, j, k\n        init_genrand(19650218)\n        i = 1\n        j = 0\n        k = (N > key_length ? N : key_length)\n        for(; k; k--){\n          //c//mt[i] = (mt[i] ^ ((mt[i-1] ^ (mt[i-1] >> 30)) * 1664525))\n          //c// + init_key[j] + j; /* non linear */\n          mt[i] = addition32(\n              addition32(unsigned32(mt[i] ^\n                  multiplication32(unsigned32(mt[i - 1] ^ (mt[i - 1] >>> 30)),\n                  1664525)),\n              init_key[j]), j)\n          mt[i] =\n              //c//mt[i] &= 0xffffffff; /* for WORDSIZE > 32 machines */\n              unsigned32(mt[i] & 0xffffffff)\n          i++\n          j++\n          if(i >= N){mt[0] = mt[N - 1]; i = 1}\n          if(j >= key_length){j = 0}\n        }\n        for(k = N - 1; k; k--){\n            //c//mt[i] = (mt[i] ^ ((mt[i-1] ^ (mt[i-1] >> 30)) * 1566083941))\n            //c//- i; /* non linear */\n            mt[i] = subtraction32(\n                unsigned32(\n                    (mt[i]) ^\n                        multiplication32(\n                            unsigned32(mt[i - 1] ^ (mt[i - 1] >>> 30)),\n                    1566083941)),\n                i\n            )\n            //c//mt[i] &= 0xffffffff; /* for WORDSIZE > 32 machines */\n            mt[i] = unsigned32(mt[i] & 0xffffffff)\n            i++\n            if(i >= N){mt[0] = mt[N - 1]; i = 1}\n        }\n        mt[0] = 0x80000000; /* MSB is 1; assuring non-zero initial array */\n    }\n\n    /* generates a random number on [0,0xffffffff]-interval */\n    //c//unsigned long genrand_int32(void)\n    function genrand_int32() {\n        //c//unsigned long y;\n        //c//static unsigned long mag01[2]={0x0UL, MATRIX_A};\n        var y;\n        var mag01 = [0x0, MATRIX_A];\n        /* mag01[x] = x * MATRIX_A  for x=0,1 */\n\n        if(mti >= N){ /* generate N words at one time */\n            //c//int kk;\n            var kk\n\n            if(mti == N + 1){   /* if init_genrand() has not been called, */\n              init_genrand(Date.now()) /* a default initial seed is used */\n            }\n\n            for(kk = 0; kk < N - M; kk++){\n              //c//y = (mt[kk]&UPPER_MASK)|(mt[kk+1]&LOWER_MASK);\n              //c//mt[kk] = mt[kk+M] ^ (y >> 1) ^ mag01[y & 0x1];\n              y = unsigned32((mt[kk]&UPPER_MASK) | (mt[kk + 1]&LOWER_MASK))\n              mt[kk] = unsigned32(mt[kk + M] ^ (y >>> 1) ^ mag01[y & 0x1])\n            }\n            for(;kk < N - 1; kk++){\n              //c//y = (mt[kk]&UPPER_MASK)|(mt[kk+1]&LOWER_MASK);\n              //c//mt[kk] = mt[kk+(M-N)] ^ (y >> 1) ^ mag01[y & 0x1];\n              y = unsigned32((mt[kk]&UPPER_MASK) | (mt[kk + 1]&LOWER_MASK))\n              mt[kk] = unsigned32(mt[kk + (M - N)] ^ (y >>> 1) ^ mag01[y & 0x1])\n            }\n            //c//y = (mt[N-1]&UPPER_MASK)|(mt[0]&LOWER_MASK);\n            //c//mt[N-1] = mt[M-1] ^ (y >> 1) ^ mag01[y & 0x1];\n            y = unsigned32((mt[N - 1] & UPPER_MASK) | (mt[0] & LOWER_MASK))\n            mt[N - 1] = unsigned32(mt[M - 1] ^ (y >>> 1) ^ mag01[y & 0x1])\n            mti = 0\n        }\n\n        y = mt[mti++]\n\n        /* Tempering */\n        //c//y ^= (y >> 11);\n        //c//y ^= (y << 7) & 0x9d2c5680;\n        //c//y ^= (y << 15) & 0xefc60000;\n        //c//y ^= (y >> 18);\n        y = unsigned32(y ^ (y >>> 11))\n        y = unsigned32(y ^ ((y << 7) & 0x9d2c5680))\n        y = unsigned32(y ^ ((y << 15) & 0xefc60000))\n        y = unsigned32(y ^ (y >>> 18))\n\n        return y\n    }\n\n    /* generates a random number on [0,0x7fffffff]-interval */\n    //c//long genrand_int31(void)\n    function genrand_int31(){\n        //c//return (genrand_int32()>>1);\n        return (genrand_int32()>>>1)\n    }\n\n    /* generates a random number on [0,1]-real-interval */\n    //c//double genrand_real1(void)\n    function genrand_real1(){\n        return genrand_int32()*(1.0/4294967295.0)\n        /* divided by 2^32-1 */\n    }\n\n    /* generates a random number on [0,1)-real-interval */\n    //c//double genrand_real2(void)\n    function genrand_real2(){\n        return genrand_int32() * (1.0 / 4294967296.0)\n        /* divided by 2^32 */\n    }\n\n    /* generates a random number on (0,1)-real-interval */\n    //c//double genrand_real3(void)\n    function genrand_real3() {\n        return ((genrand_int32()) + 0.5) * (1.0 / 4294967296.0)\n        /* divided by 2^32 */\n    }\n\n    /* generates a random number on [0,1) with 53-bit resolution*/\n    //c//double genrand_res53(void)\n    function genrand_res53() {\n        //c//unsigned long a=genrand_int32()>>5, b=genrand_int32()>>6;\n        var a = genrand_int32() >>> 5,\n            b = genrand_int32() >>> 6\n        return (a * 67108864.0 + b) * (1.0 / 9007199254740992.0)\n    }\n    /* These real versions are due to Isaku Wada, 2002/01/09 added */\n\n    var random = genrand_res53\n\n    random.seed = function(seed){\n        if(seed === undefined || $B.is_none(seed)){\n            const entries = new Uint32Array(N)\n            crypto.getRandomValues(entries)\n            init_by_array(Array.from(entries), N)\n            return\n        }\n\n        if(!$B.$isinstance(seed, _b_.int)){\n            seed = _b_.hash(seed)\n        }\n\n        // Transform to long integer\n        if(typeof seed == \"number\"){\n            seed = BigInt(seed)\n        }else if(seed.__class__ === $B.long_int){\n            seed = seed.value\n        }else{\n            return random.seed(seed.$brython_value)\n        }\n\n        // Take abs(seed)\n        seed = seed > 0 ? seed : -seed\n\n        var keys = []\n        var int32_1 = 2n ** 32n - 1n\n\n        // decomposition in factors of 2 ** 32\n        while(seed >= int32_1){\n            var quot = seed / int32_1,\n                rest = seed % int32_1\n            // Rest is a JS number (< 2 ** 32)\n            keys.push(Number(rest))\n            // Quotient is either a JS number or a instance of long_int\n            // but seed must be long_int\n            seed = quot\n        }\n        keys.push(Number(seed))\n\n        init_by_array(keys, keys.length)\n    }\n\n    random.seed(seed)\n\n    random.int31 = genrand_int31\n    random.int32 = genrand_int32\n    random.real1 = genrand_real1\n    random.real2 = genrand_real2\n    random.real3 = genrand_real3\n    random.res53 = genrand_res53\n\n    // Added for compatibility with Python\n    random.getstate = function(){\n        return $B.fast_tuple(mt.concat([mti]))\n    }\n\n    random.setstate = function(state){\n        mt = state.slice(0, state.length - 1)\n        mti = state[state.length - 1]\n    }\n\n    return random\n\n}\n\nvar Random = $B.make_class(\"Random\",\n    function(){\n        return {\n            __class__: Random,\n            _random: RandomStream(Date.now())\n        }\n    }\n)\n\nRandom.getrandbits = function(){\n    var $ = $B.args(\"getrandbits\", 2, {self: null, k:null}, [\"self\", \"k\"],\n        arguments, {}, null, null),\n        self = $.self,\n        k = $B.PyNumber_Index($.k)\n\n    if(k < 0)\n        throw _b_.ValueError.$factory('number of bits must be non-negative')\n\n    if(k === 0)\n        return 0\n\n    const words = Math.floor((k - 1) / 32) + 1\n    const wordarray = new ArrayBuffer(words * 4)\n    const wordarray_view = new DataView(wordarray)\n\n    /* Fill-out bits of long integer, by 32-bit words, from least significant\n       to most significant. */\n    for(i = 0; i < words; i++, k -= 32){\n        r = self._random.int32()\n        if (k < 32)\n            r >>>= (32 - k)  /* Drop least significant bits */\n        wordarray_view.setUint32(i * 4, r, true)\n    }\n\n    return _b_.int.from_bytes(_b_.bytes.$factory(Array.from(new Uint8Array(wordarray))), \"little\")\n}\n\nRandom.getstate = function(){\n    var $ = $B.args('getstate', 1, {self: null},\n        [\"self\"], arguments, {}, null, null),\n        self = $.self\n    return self._random.getstate()\n}\n\nRandom.random = function(){\n    var $ = $B.args('random', 1, {self: null}, [\"self\"],\n        arguments, {}, null, null),\n        self = $.self\n    return $B.fast_float(self._random())\n}\n\nRandom.seed = function(){\n    var $ = $B.args('seed', 2, {self: null, n: null}, ['self', 'n'],\n        arguments, {}, null, null),\n        self = $.self,\n        n = $.n\n\n    if (self._random === undefined){\n        self._random = RandomStream(n)\n    }else{\n        self._random.seed(n)\n    }\n}\n\nRandom.setstate = function(){\n    var $ = $B.args('setstate', 2, {self: null, state:null}, ['self', 'state'],\n        arguments, {}, null, null),\n        self = $.self,\n        state = $.state\n    return self._random.setstate(state)\n}\n\n$B.set_func_names(Random, \"_random\")\n\n$B.imported._random = { Random }\n\n})(__BRYTHON__)\n"], "_sre": [".js", "/*\n * Secret Labs' Regular Expression Engine\n *\n * regular expression matching engine\n *\n * partial history:\n * 1999-10-24 fl   created (based on existing template matcher code)\n * 2000-03-06 fl   first alpha, sort of\n * 2000-08-01 fl   fixes for 1.6b1\n * 2000-08-07 fl   use PyOS_CheckStack() if available\n * 2000-09-20 fl   added expand method\n * 2001-03-20 fl   lots of fixes for 2.1b2\n * 2001-04-15 fl   export copyright as Python attribute, not global\n * 2001-04-28 fl   added __copy__ methods (work in progress)\n * 2001-05-14 fl   fixes for 1.5.2 compatibility\n * 2001-07-01 fl   added BIGCHARSET support (from Martin von Loewis)\n * 2001-10-18 fl   fixed group reset issue (from Matthew Mueller)\n * 2001-10-20 fl   added split primitive; re-enable unicode for 1.6/2.0/2.1\n * 2001-10-21 fl   added sub/subn primitive\n * 2001-10-24 fl   added finditer primitive (for 2.2 only)\n * 2001-12-07 fl   fixed memory leak in sub/subn (Guido van Rossum)\n * 2002-11-09 fl   fixed empty sub/subn return type\n * 2003-04-18 mvl  fully support 4-byte codes\n * 2003-10-17 gn   implemented non recursive scheme\n * 2013-02-04 mrab added fullmatch primitive\n *\n * Copyright (c) 1997-2001 by Secret Labs AB.  All rights reserved.\n *\n * This version of the SRE library can be redistributed under CNRI's\n * Python 1.6 license.  For any other use, please contact Secret Labs\n * AB (info@pythonware.com).\n *\n * Portions of this engine have been developed in cooperation with\n * CNRI.  Hewlett-Packard provided funding for 1.6 integration and\n * other compatibility work.\n */\n\nfunction assert(condition){\n    if(! condition){\n        throw Error('condition is false')\n    }\n}\n\nconst copyright =\n    \" SRE 2.2.2 Copyright (c) 1997-2002 by Secret Labs AB \";\n\n/*\n#define PY_SSIZE_T_CLEAN\n\n#include \"Python.h\"\n#include \"pycore_long.h\"          // _PyLong_GetZero()\n#include \"pycore_moduleobject.h\"  // _PyModule_GetState()\n*/\nfunction _PyModule_GetState(mod) {\n    return mod.md_state;\n}\n// #include \"structmember.h\"         // PyMemberDef\n\n// #include \"sre.h\"\n\nvar SRE_CODE_BITS = 32 // (8 * sizeof(SRE_CODE))\n\n\n/* -------------------------------------------------------------------- */\n\n\n/* error codes */\nconst SRE_ERROR_ILLEGAL = -1, /* illegal opcode */\n      SRE_ERROR_STATE = -2, /* illegal state */\n      SRE_ERROR_RECURSION_LIMIT = -3, /* runaway recursion */\n      SRE_ERROR_MEMORY = -9, /* out of memory */\n      SRE_ERROR_INTERRUPTED = -10 /* signal handler raised exception */\n\nvar VERBOSE = false\nfunction TRACE(v){\n    if(VERBOSE){\n        console.log(v)\n    }\n}\n\n/* -------------------------------------------------------------------- */\n/* search engine state */\n\nfunction SRE_IS_DIGIT(ch){\n    return (ch) <= '9' && Py_ISDIGIT(ch)\n}\nfunction SRE_IS_SPACE(ch){\n    return (ch) <= ' ' && Py_ISSPACE(ch)\n}\nfunction SRE_IS_LINEBREAK(ch){\n    return ch == '\\n'\n}\nfunction SRE_IS_WORD(ch){\n    return ch <= 'z' && (Py_ISALNUM(ch) || ch == '_')\n}\n\nfunction sre_lower_ascii(ch){\n    return ((ch) < 128 ? Py_TOLOWER(ch) : ch);\n}\n\n/* locale-specific character predicates */\n/* !(c & ~N) == (c < N+1) for any unsigned c, this avoids\n * warnings when c's type supports only numbers < N+1 */\nfunction SRE_LOC_IS_ALNUM(ch){\n    return  (!((ch) & ~255) ? isalnum((ch)) : 0)\n}\nfunction SRE_LOC_IS_WORD(ch){\n    return (SRE_LOC_IS_ALNUM((ch)) || (ch) == '_')\n}\nfunction sre_lower_locale(ch){\n    return ((ch) < 256 ? tolower((ch)) : ch);\n}\n\nfunction sre_upper_locale(ch){\n    return ((ch) < 256 ? toupper((ch)) : ch);\n}\n\n/* unicode-specific character predicates */\n\nfunction SRE_UNI_IS_DIGIT(ch){\n    return Py_UNICODE_ISDECIMAL(ch)\n}\nfunction SRE_UNI_IS_SPACE(ch){\n    return Py_UNICODE_ISSPACE(ch)\n}\nfunction SRE_UNI_IS_LINEBREAK(ch){\n    return Py_UNICODE_ISLINEBREAK(ch)\n}\nfunction SRE_UNI_IS_ALNUM(ch){\n    return Py_UNICODE_ISALNUM(ch)\n}\nfunction SRE_UNI_IS_WORD(ch){\n    return (SRE_UNI_IS_ALNUM(ch) || (ch) == '_')\n}\nfunction sre_lower_unicode(ch)\n{\n    return Py_UNICODE_TOLOWER(ch);\n}\n\nfunction sre_upper_unicode(ch){\n    return Py_UNICODE_TOUPPER(ch);\n}\n\nfunction sre_category(category, ch){\n    switch (category) {\n\n    case SRE_CATEGORY_DIGIT:\n        return SRE_IS_DIGIT(ch);\n    case SRE_CATEGORY_NOT_DIGIT:\n        return !SRE_IS_DIGIT(ch);\n    case SRE_CATEGORY_SPACE:\n        return SRE_IS_SPACE(ch);\n    case SRE_CATEGORY_NOT_SPACE:\n        return !SRE_IS_SPACE(ch);\n    case SRE_CATEGORY_WORD:\n        return SRE_IS_WORD(ch);\n    case SRE_CATEGORY_NOT_WORD:\n        return !SRE_IS_WORD(ch);\n    case SRE_CATEGORY_LINEBREAK:\n        return SRE_IS_LINEBREAK(ch);\n    case SRE_CATEGORY_NOT_LINEBREAK:\n        return !SRE_IS_LINEBREAK(ch);\n\n    case SRE_CATEGORY_LOC_WORD:\n        return SRE_LOC_IS_WORD(ch);\n    case SRE_CATEGORY_LOC_NOT_WORD:\n        return !SRE_LOC_IS_WORD(ch);\n\n    case SRE_CATEGORY_UNI_DIGIT:\n        return SRE_UNI_IS_DIGIT(ch);\n    case SRE_CATEGORY_UNI_NOT_DIGIT:\n        return !SRE_UNI_IS_DIGIT(ch);\n    case SRE_CATEGORY_UNI_SPACE:\n        return SRE_UNI_IS_SPACE(ch);\n    case SRE_CATEGORY_UNI_NOT_SPACE:\n        return !SRE_UNI_IS_SPACE(ch);\n    case SRE_CATEGORY_UNI_WORD:\n        return SRE_UNI_IS_WORD(ch);\n    case SRE_CATEGORY_UNI_NOT_WORD:\n        return !SRE_UNI_IS_WORD(ch);\n    case SRE_CATEGORY_UNI_LINEBREAK:\n        return SRE_UNI_IS_LINEBREAK(ch);\n    case SRE_CATEGORY_UNI_NOT_LINEBREAK:\n        return !SRE_UNI_IS_LINEBREAK(ch);\n    }\n    return 0;\n}\n\nfunction char_loc_ignore(pattern, ch){\n    return ch == pattern\n        || sre_lower_locale(ch) == pattern\n        || sre_upper_locale(ch) == pattern;\n}\n\n\n/* helpers */\n\nfunction data_stack_dealloc(state)\n{\n    if (state.data_stack) {\n        PyMem_Free(state.data_stack);\n        state.data_stack = NULL;\n    }\n    state.data_stack_size = state.data_stack_base = 0;\n}\n\nfunction data_stack_grow(state, size){\n    var minsize, cursize;\n    minsize = state.data_stack_base + size;\n    cursize = state.data_stack_size;\n    if (cursize < minsize) {\n        var stack;\n        cursize = minsize + minsize / 4 + 1024;\n        TRACE((\"allocate/grow stack %zd\\n\", cursize));\n        stack = PyMem_Realloc(state.data_stack, cursize);\n        if (!stack) {\n            data_stack_dealloc(state);\n            return SRE_ERROR_MEMORY;\n        }\n        state.data_stack = stack;\n        state.data_stack_size = cursize;\n    }\n    return 0;\n}\n\n/* generate 8-bit version */\n/*\nconst SRE_CHAR = Py_UCS1,\n    SIZEOF_SRE_CHAR = 1\n\nfunction SRE(F){\n    return sre_ucs1_ //##F\n}\n*/\n/* #include \"sre_lib.h\" */\n\n/* generate 16-bit unicode version */\n/*\nconst SRE_CHAR = Py_UCS2,\n      SIZEOF_SRE_CHAR = 2\nfunction SRE(F){\n    return sre_ucs2_ // ##F\n}\n*/\n/* #include \"sre_lib.h\" */\n\n/* generate 32-bit unicode version */\n\n//const SRE_CHAR = Py_UCS4,\n//      SIZEOF_SRE_CHAR = 4\nfunction SRE(F){\n    return 4 //sre_ucs4_ //##F\n}\n/* #include \"sre_lib.h\" */\n\n/* -------------------------------------------------------------------- */\n/* factories and destructors */\n\n/* module state */\nfunction _sremodulestate(PatternType, MatchType, ScannerType){\n    this.Pattern_Type = Pattern_Type;\n    this.Match_Type = Match_Type;\n    this.Scanner_Type = Scanner_Type;\n}\n\nfunction get_sre_module_state(m){\n    console.log('get module state', m)\n    var state = _PyModule_GetState(m);\n    assert(state);\n    return state;\n}\n\nfunction get_sre_module_state_by_class(cls){\n    return get_sre_module_state(PyType_GetModule(cls))\n}\n\n/* see sre.h for object declarations */\n/*\nstatic PyObject*pattern_new_match(_sremodulestate *, PatternObject*, SRE_STATE*, Py_ssize_t);\nstatic PyObject *pattern_scanner(_sremodulestate *, PatternObject *, PyObject *, Py_ssize_t, Py_ssize_t);\n*/\n\n/*[clinic input]\nmodule _sre\nclass _sre.SRE_Pattern \"PatternObject *\" \"get_sre_module_state_by_class(tp)->Pattern_Type\"\nclass _sre.SRE_Match \"MatchObject *\" \"get_sre_module_state_by_class(tp)->Match_Type\"\nclass _sre.SRE_Scanner \"ScannerObject *\" \"get_sre_module_state_by_class(tp)->Scanner_Type\"\n[clinic start generated code]*/\n/*[clinic end generated code: output=da39a3ee5e6b4b0d input=fe2966e32b66a231]*/\n\n/*[clinic input]\n_sre.getcodesize -> int\n[clinic start generated code]*/\n\nfunction _sre_getcodesize_impl(module){\n    return sizeof(SRE_CODE);\n}\n\n/*[clinic input]\n_sre.ascii_iscased -> bool\n\n    character: int\n    /\n\n[clinic start generated code]*/\n\nfunction _sre_ascii_iscased_impl(module,  character){\n    var ch = character;\n    return ch < 128 && Py_ISALPHA(ch);\n}\n\n/*[clinic input]\n_sre.unicode_iscased -> bool\n\n    character: int\n    /\n\n[clinic start generated code]*/\n\nfunction _sre_unicode_iscased_impl(module, character){\n    var ch = character;\n    return ch != sre_lower_unicode(ch) || ch != sre_upper_unicode(ch);\n}\n\n/*[clinic input]\n_sre.ascii_tolower -> int\n\n    character: int\n    /\n\n[clinic start generated code]*/\n\nfunction _sre_ascii_tolower_impl(module, character){\n    return sre_lower_ascii(character);\n}\n\n/*[clinic input]\n_sre.unicode_tolower -> int\n\n    character: int\n    /\n\n[clinic start generated code]*/\n\nfunction _sre_unicode_tolower_impl(module, character){\n    return sre_lower_unicode(character);\n}\n\nfunction state_reset(state){\n    /* state->mark will be set to 0 in SRE_OP_MARK dynamically. */\n    /*memset(state->mark, 0, sizeof(*state->mark) * SRE_MARK_SIZE);*/\n\n    state.lastmark = -1;\n    state.lastindex = -1;\n\n    state.repeat = NULL;\n\n    data_stack_dealloc(state);\n}\n\nfunction getstring(string, p_length, p_isbytes, p_charsize, view){\n    /* given a python object, return a data pointer, a length (in\n       characters), and a character size.  return NULL if the object\n       is not a string (or not compatible) */\n\n    /* Unicode objects do not support the buffer API. So, get the data\n       directly instead. */\n    if (PyUnicode_Check(string)) {\n        if (PyUnicode_READY(string) == -1){\n            return NULL;\n        }\n        p_length = PyUnicode_GET_LENGTH(string);\n        p_charsize = PyUnicode_KIND(string);\n        p_isbytes = 0;\n        return PyUnicode_DATA(string);\n    }\n\n    /* get pointer to byte string buffer */\n    if (PyObject_GetBuffer(string, view, PyBUF_SIMPLE) != 0) {\n        PyErr_Format(PyExc_TypeError,\n            \"expected string or bytes-like object, got '%.200s'\",\n            Py_TYPE(string).tp_name);\n        return NULL;\n    }\n\n    p_length = view.len;\n    p_charsize = 1;\n    p_isbytes = 1;\n\n    if (view.buf == NULL) {\n        PyErr_SetString(PyExc_ValueError, \"Buffer is NULL\");\n        PyBuffer_Release(view);\n        view.buf = NULL;\n        return NULL;\n    }\n    return view.buf;\n}\n\nfunction state_init(state, pattern, string, start, end){\n    /* prepare state object */\n\n    var length,\n        isbytes,\n        charsize,\n        ptr;\n\n    memset(state, 0, sizeof(SRE_STATE));\n\n    state.mark = PyMem_New(pattern.groups * 2);\n    if (! state.mark) {\n        PyErr_NoMemory();\n        throw err;\n    }\n    state.lastmark = -1;\n    state.lastindex = -1;\n\n    state.buffer.buf = NULL;\n    ptr = getstring(string, length, isbytes, charsize, state.buffer);\n    if (!ptr){\n        throw err;\n    }\n\n    if (isbytes && pattern.isbytes == 0) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"cannot use a string pattern on a bytes-like object\");\n        throw err;\n    }\n    if (!isbytes && pattern.isbytes > 0) {\n        PyErr_SetString(PyExc_TypeError,\n                        \"cannot use a bytes pattern on a string-like object\");\n        throw err;\n    }\n\n    /* adjust boundaries */\n    if (start < 0){\n        start = 0;\n    }else if (start > length){\n        start = length;\n    }\n    if (end < 0){\n        end = 0;\n    }else if (end > length){\n        end = length;\n    }\n    state.isbytes = isbytes;\n    state.charsize = charsize;\n    state.match_all = 0;\n    state.must_advance = 0;\n\n    state.beginning = ptr;\n\n    state.start = ptr + start * state.charsize\n    state.end =  ptr + end * state.charsize\n\n    Py_INCREF(string);\n    state.string = string;\n    state.pos = start;\n    state.endpos = end;\n\n    return string;\n}\n\nfunction state_fini(state){\n    if (state.buffer.buf){\n        PyBuffer_Release(state.buffer);\n    }\n    Py_XDECREF(state.string);\n    data_stack_dealloc(state);\n    /* See above PyMem_Del for why we explicitly cast here. */\n    PyMem_Free(state.mark);\n    state.mark = NULL;\n}\n\n/* calculate offset from start of string */\nfunction STATE_OFFSET(state, member){\n    return (member - state.beginning) / state.charsize\n}\n\nfunction getslice(isbytes, ptr, string, start, end){\n    if (isbytes) {\n        if (PyBytes_CheckExact(string) &&\n            start == 0 && end == PyBytes_GET_SIZE(string)) {\n            Py_INCREF(string);\n            return string;\n        }\n        return PyBytes_FromStringAndSize(\n                ptr + start, end - start);\n    }else {\n        return PyUnicode_Substring(string, start, end);\n    }\n}\n\nfunction state_getslice(state, index, string, empty){\n    var i, j;\n\n    index = (index - 1) * 2;\n\n    if (string == _b_.None ||\n            index >= state.lastmark ||\n            ! state.mark[index] ||\n            ! state.mark[index + 1]) {\n        if (empty){\n            /* want empty string */\n            i = j = 0;\n        }else {\n            Py_RETURN_NONE;\n        }\n    } else {\n        i = STATE_OFFSET(state, state.mark[index]);\n        j = STATE_OFFSET(state, state.mark[index + 1]);\n    }\n\n    return getslice(state.isbytes, state.beginning, string, i, j);\n}\n\nfunction pattern_error(status){\n    switch (status) {\n    case SRE_ERROR_RECURSION_LIMIT:\n        /* This error code seems to be unused. */\n        PyErr_SetString(\n            PyExc_RecursionError,\n            \"maximum recursion limit exceeded\"\n            );\n        break;\n    case SRE_ERROR_MEMORY:\n        PyErr_NoMemory();\n        break;\n    case SRE_ERROR_INTERRUPTED:\n    /* An exception has already been raised, so let it fly */\n        break;\n    default:\n        /* other error codes indicate compiler/engine bugs */\n        PyErr_SetString(\n            PyExc_RuntimeError,\n            \"internal error in regular expression engine\"\n            );\n    }\n}\n\nfunction pattern_traverse(self, visit, arg){\n    Py_VISIT(Py_TYPE(self));\n    Py_VISIT(self.groupindex);\n    Py_VISIT(self.indexgroup);\n    Py_VISIT(self.pattern);\n    return 0;\n}\n\nfunction pattern_clear(self){\n    Py_CLEAR(self.groupindex);\n    Py_CLEAR(self.indexgroup);\n    Py_CLEAR(self.pattern);\n    return 0;\n}\n\nfunction pattern_dealloc(self){\n    var tp = Py_TYPE(self);\n\n    PyObject_GC_UnTrack(self);\n    if (self.weakreflist != NULL) {\n        PyObject_ClearWeakRefs(self);\n    }\n    pattern_clear(self);\n    tp.tp_free(self);\n    Py_DECREF(tp);\n}\n\nfunction sre_match(state, pattern){\n    if (state.charsize == 1){\n        return sre_ucs1_match(state, pattern, 1);\n    }\n    if (state.charsize == 2){\n        return sre_ucs2_match(state, pattern, 1);\n    }\n    assert(state.charsize == 4);\n    return sre_ucs4_match(state, pattern, 1);\n}\n\nfunction sre_search(state, pattern){\n    if (state.charsize == 1){\n        return sre_ucs1_search(state, pattern);\n    }\n    if (state.charsize == 2){\n        return sre_ucs2_search(state, pattern);\n    }\n    assert(state.charsize == 4);\n    return sre_ucs4_search(state, pattern);\n}\n\n/*[clinic input]\n_sre.SRE_Pattern.match\n\n    cls: defining_class\n    /\n    string: object\n    pos: Py_ssize_t = 0\n    endpos: Py_ssize_t(c_default=\"PY_SSIZE_T_MAX\") = sys.maxsize\n\nMatches zero or more characters at the beginning of the string.\n[clinic start generated code]*/\n\nfunction _sre_SRE_Pattern_match_impl(self, cls,\n                            string, pos,\n                            endpos){\n    var module_state = get_sre_module_state_by_class(cls);\n    var state,\n        status,\n        match;\n\n    if (!state_init(state, self, string, pos, endpos)){\n        return NULL;\n    }\n    state.ptr = state.start;\n\n    TRACE((\"|%p|%p|MATCH\\n\", PatternObject_GetCode(self), state.ptr));\n\n    status = sre_match(state, PatternObject_GetCode(self));\n\n    TRACE((\"|%p|%p|END\\n\", PatternObject_GetCode(self), state.ptr));\n    if (PyErr_Occurred()) {\n        state_fini(state);\n        return NULL;\n    }\n\n    match = pattern_new_match(module_state, self, state, status);\n    state_fini(state);\n    return match;\n}\n\n/*[clinic input]\n_sre.SRE_Pattern.fullmatch\n\n    cls: defining_class\n    /\n    string: object\n    pos: Py_ssize_t = 0\n    endpos: Py_ssize_t(c_default=\"PY_SSIZE_T_MAX\") = sys.maxsize\n\nMatches against all of the string.\n[clinic start generated code]*/\n\nfunction _sre_SRE_Pattern_fullmatch_impl(self, cls,\n                                string, pos,\n                                endpos){\n    var module_state = get_sre_module_state_by_class(cls),\n        state,\n        status,\n        match;\n\n    if (!state_init(state, self, string, pos, endpos)){\n        return NULL;\n    }\n    state.ptr = state.start;\n\n    TRACE((\"|%p|%p|FULLMATCH\\n\", PatternObject_GetCode(self), state.ptr));\n\n    state.match_all = 1;\n    status = sre_match(state, PatternObject_GetCode(self));\n\n    TRACE((\"|%p|%p|END\\n\", PatternObject_GetCode(self), state.ptr));\n    if (PyErr_Occurred()) {\n        state_fini(state);\n        return NULL;\n    }\n\n    match = pattern_new_match(module_state, self, state, status);\n    state_fini(state);\n    return match;\n}\n\n/*[clinic input]\n_sre.SRE_Pattern.search\n\n    cls: defining_class\n    /\n    string: object\n    pos: Py_ssize_t = 0\n    endpos: Py_ssize_t(c_default=\"PY_SSIZE_T_MAX\") = sys.maxsize\n\nScan through string looking for a match, and return a corresponding match object instance.\n\nReturn None if no position in the string matches.\n[clinic start generated code]*/\n\nfunction _sre_SRE_Pattern_search_impl(self, cls,\n                             string, pos,\n                             endpos){\n    var module_state = get_sre_module_state_by_class(cls),\n        state,\n        status,\n        match;\n\n    if (!state_init(state, self, string, pos, endpos)){\n        return NULL\n    }\n\n    TRACE((\"|%p|%p|SEARCH\\n\", PatternObject_GetCode(self), state.ptr));\n\n    status = sre_search(state, PatternObject_GetCode(self));\n\n    TRACE((\"|%p|%p|END\\n\", PatternObject_GetCode(self), state.ptr));\n\n    if (PyErr_Occurred()) {\n        state_fini(state);\n        return NULL;\n    }\n\n    match = pattern_new_match(module_state, self, state, status);\n    state_fini(state);\n    return match;\n}\n\nfunction call(module, _function, args){\n    var name,\n        mod,\n        func,\n        result;\n\n    if (!args){\n        return NULL;\n    }\n    name = PyUnicode_FromString(module);\n    if (!name){\n        return NULL;\n    }\n    mod = PyImport_Import(name);\n    Py_DECREF(name);\n    if (!mod){\n        return NULL;\n    }\n    func = PyObject_GetAttrString(mod, _function);\n    Py_DECREF(mod);\n    if (!func){\n        return NULL;\n    }\n    result = PyObject_CallObject(func, args);\n    Py_DECREF(func);\n    Py_DECREF(args);\n    return result;\n}\n\n/*[clinic input]\n_sre.SRE_Pattern.findall\n\n    string: object\n    pos: Py_ssize_t = 0\n    endpos: Py_ssize_t(c_default=\"PY_SSIZE_T_MAX\") = sys.maxsize\n\nReturn a list of all non-overlapping matches of pattern in string.\n[clinic start generated code]*/\n\nfunction _sre_SRE_Pattern_findall_impl(self, string,\n                              pos, endpos){\n    var state,\n        list,\n        status,\n        i, b, e;\n\n    if (!state_init(state, self, string, pos, endpos)){\n        return NULL;\n    }\n    list = PyList_New(0);\n    if (!list) {\n        state_fini(state);\n        return NULL;\n    }\n\n    while (state.start <= state.end) {\n\n        var item;\n\n        state_reset(state);\n\n        state.ptr = state.start;\n\n        status = sre_search(state, PatternObject_GetCode(self));\n        if (PyErr_Occurred()){\n            throw error;\n        }\n        if (status <= 0) {\n            if (status == 0){\n                break;\n            }\n            pattern_error(status);\n            throw error;\n        }\n\n        /* don't bother to build a match object */\n        switch (self.groups) {\n        case 0:\n            b = STATE_OFFSET(state, state.start);\n            e = STATE_OFFSET(state, state.ptr);\n            item = getslice(state.isbytes, state.beginning,\n                            string, b, e);\n            if (!item){\n                throw error;\n            }\n            break;\n        case 1:\n            item = state_getslice(state, 1, string, 1);\n            if (!item){\n                throw error;\n            }\n            break;\n        default:\n            item = PyTuple_New(self.groups);\n            if (!item){\n                throw error;\n            }\n            for (i = 0; i < self.groups; i++) {\n                var o = state_getslice(state, i+1, string, 1);\n                if (!o) {\n                    Py_DECREF(item);\n                    throw error;\n                }\n                PyTuple_SET_ITEM(item, i, o);\n            }\n            break;\n        }\n\n        status = PyList_Append(list, item);\n        Py_DECREF(item);\n        if (status < 0){\n            throw error;\n        }\n        state.must_advance = (state.ptr == state.start);\n        state.start = state.ptr;\n    }\n\n    state_fini(state);\n    return list;\n/*\nerror:\n    Py_DECREF(list);\n    state_fini(&state);\n    return NULL;\n*/\n}\n\n/*[clinic input]\n_sre.SRE_Pattern.finditer\n\n    cls: defining_class\n    /\n    string: object\n    pos: Py_ssize_t = 0\n    endpos: Py_ssize_t(c_default=\"PY_SSIZE_T_MAX\") = sys.maxsize\n\nReturn an iterator over all non-overlapping matches for the RE pattern in string.\n\nFor each match, the iterator returns a match object.\n[clinic start generated code]*/\n\nfunction _sre_SRE_Pattern_finditer_impl(self, cls,\n                               string, pos,\n                               endpos){\n    var module_state = get_sre_module_state_by_class(cls),\n        scanner,\n        search,\n        iterator;\n\n    scanner = pattern_scanner(module_state, self, string, pos, endpos);\n    if (!scanner){\n        return NULL;\n    }\n    search = PyObject_GetAttrString(scanner, \"search\");\n    Py_DECREF(scanner);\n    if (!search){\n        return NULL;\n    }\n    iterator = PyCallIter_New(search, Py_None);\n    Py_DECREF(search);\n\n    return iterator;\n}\n\n/*[clinic input]\n_sre.SRE_Pattern.scanner\n\n    cls: defining_class\n    /\n    string: object\n    pos: Py_ssize_t = 0\n    endpos: Py_ssize_t(c_default=\"PY_SSIZE_T_MAX\") = sys.maxsize\n\n[clinic start generated code]*/\n\nfunction _sre_SRE_Pattern_scanner_impl(self, cls,\n                              string, pos,\n                              endpos){\n    var module_state = get_sre_module_state_by_class(cls);\n\n    return pattern_scanner(module_state, self, string, pos, endpos);\n}\n\n/*[clinic input]\n_sre.SRE_Pattern.split\n\n    string: object\n    maxsplit: Py_ssize_t = 0\n\nSplit string by the occurrences of pattern.\n[clinic start generated code]*/\n\nfunction _sre_SRE_Pattern_split_impl(self, string, maxsplit){\n    var state,\n        list,\n        item,\n        status,\n        n,\n        i,\n        last;\n\n    assert(self.codesize != 0);\n\n    if (!state_init(state, self, string, 0, PY_SSIZE_T_MAX)){\n        return NULL;\n    }\n    list = PyList_New(0);\n    if (!list) {\n        state_fini(state);\n        return NULL;\n    }\n\n    n = 0;\n    last = state.start;\n\n    while (!maxsplit || n < maxsplit) {\n\n        state_reset(state);\n\n        state.ptr = state.start;\n\n        status = sre_search(state, PatternObject_GetCode(self));\n        if (PyErr_Occurred()){\n            throw error;\n        }\n        if (status <= 0) {\n            if (status == 0){\n                break;\n            }\n            pattern_error(status);\n            throw error;\n        }\n\n        /* get segment before this match */\n        item = getslice(state.isbytes, state.beginning,\n            string, STATE_OFFSET(state, last),\n            STATE_OFFSET(state, state.start)\n            );\n        if (!item){\n            throw error;\n        }\n        status = PyList_Append(list, item);\n        Py_DECREF(item);\n        if (status < 0){\n            throw error;\n        }\n        /* add groups (if any) */\n        for (i = 0; i < self.groups; i++) {\n            item = state_getslice(state, i + 1, string, 0);\n            if (!item){\n                throw error;\n            }\n            status = PyList_Append(list, item);\n            Py_DECREF(item);\n            if (status < 0){\n                throw error;\n            }\n        }\n\n        n = n + 1;\n        state.must_advance = (state.ptr == state.start);\n        last = state.start = state.ptr;\n\n    }\n\n    /* get segment following last match (even if empty) */\n    item = getslice(state.isbytes, state.beginning,\n        string, STATE_OFFSET(state, last), state.endpos\n        );\n    if (!item){\n        throw error;\n    }\n    status = PyList_Append(list, item);\n    Py_DECREF(item);\n    if (status < 0){\n        throw error;\n    }\n    state_fini(state);\n    return list;\n/*\nerror:\n    Py_DECREF(list);\n    state_fini(&state);\n    return NULL;\n*/\n}\n\nfunction pattern_subx(module_state, self, ptemplate, string, count, subn){\n    var state,\n        list,\n        joiner,\n        item,\n        filter,\n        match,\n        ptr,\n        status,\n        n,\n        i, b, e\n        isbytes, charsize,\n        filter_is_callable,\n        view;\n\n    if (PyCallable_Check(ptemplate)) {\n        /* sub/subn takes either a function or a template */\n        filter = ptemplate;\n        Py_INCREF(filter);\n        filter_is_callable = 1;\n    } else {\n        /* if not callable, check if it's a literal string */\n        var literal;\n        view.buf = NULL;\n        ptr = getstring(ptemplate, n, isbytes, charsize, view);\n        if (ptr) {\n            if (charsize == 1){\n                literal = memchr(ptr, '\\\\', n) == NULL;\n            }else{\n                literal = PyUnicode_FindChar(ptemplate, '\\\\', 0, n, 1) == -1;\n            }\n        } else {\n            PyErr_Clear();\n            literal = 0;\n        }\n        if (view.buf){\n            PyBuffer_Release(view);\n        }\n        if (literal) {\n            filter = ptemplate;\n            Py_INCREF(filter);\n            filter_is_callable = 0;\n        } else {\n            /* not a literal; hand it over to the template compiler */\n            filter = call(\n                SRE_PY_MODULE, \"_subx\",\n                PyTuple_Pack(2, self, ptemplate)\n                );\n            if (!filter){\n                return NULL;\n            }\n            filter_is_callable = PyCallable_Check(filter);\n        }\n    }\n\n    if (!state_init(state, self, string, 0, PY_SSIZE_T_MAX)) {\n        Py_DECREF(filter);\n        return NULL;\n    }\n\n    list = PyList_New(0);\n    if (!list) {\n        Py_DECREF(filter);\n        state_fini(state);\n        return NULL;\n    }\n\n    n = i = 0;\n\n    while (!count || n < count) {\n\n        state_reset(state);\n\n        state.ptr = state.start;\n\n        status = sre_search(state, PatternObject_GetCode(self));\n        if (PyErr_Occurred()){\n            throw error;\n        }\n        if (status <= 0) {\n            if (status == 0){\n                break;\n            }\n            pattern_error(status);\n            throw error;\n        }\n\n        b = STATE_OFFSET(state, state.start);\n        e = STATE_OFFSET(state, state.ptr);\n\n        if (i < b) {\n            /* get segment before this match */\n            item = getslice(state.isbytes, state.beginning,\n                string, i, b);\n            if (!item){\n                throw error;\n            }\n            status = PyList_Append(list, item);\n            Py_DECREF(item);\n            if (status < 0){\n                throw error;\n            }\n        }\n\n        if (filter_is_callable) {\n            /* pass match object through filter */\n            match = pattern_new_match(module_state, self, state, 1);\n            if (!match){\n                throw error;\n            }\n            item = PyObject_CallOneArg(filter, match);\n            Py_DECREF(match);\n            if (!item){\n                throw error;\n            }\n        } else {\n            /* filter is literal string */\n            item = filter;\n            Py_INCREF(item);\n        }\n\n        /* add to list */\n        if (item != Py_None) {\n            status = PyList_Append(list, item);\n            Py_DECREF(item);\n            if (status < 0){\n                throw error;\n            }\n        }\n\n        i = e;\n        n = n + 1;\n        state.must_advance = (state.ptr == state.start);\n        state.start = state.ptr;\n    }\n\n    /* get segment following last match */\n    if (i < state.endpos) {\n        item = getslice(state.isbytes, state.beginning,\n                        string, i, state.endpos);\n        if (!item){\n            throw error;\n        }\n        status = PyList_Append(list, item);\n        Py_DECREF(item);\n        if (status < 0){\n            throw error;\n        }\n    }\n\n    state_fini(state);\n\n    Py_DECREF(filter);\n\n    /* convert list to single string (also removes list) */\n    joiner = getslice(state.isbytes, state.beginning, string, 0, 0);\n    if (!joiner) {\n        Py_DECREF(list);\n        return NULL;\n    }\n    if (PyList_GET_SIZE(list) == 0) {\n        Py_DECREF(list);\n        item = joiner;\n    }else {\n        if (state.isbytes){\n            item = _PyBytes_Join(joiner, list);\n        }else{\n            item = PyUnicode_Join(joiner, list);\n        }\n        Py_DECREF(joiner);\n        Py_DECREF(list);\n        if (!item){\n            return NULL;\n        }\n    }\n\n    if (subn){\n        return Py_BuildValue(\"Nn\", item, n);\n    }\n    return item;\n/*\nerror:\n    Py_DECREF(list);\n    state_fini(&state);\n    Py_DECREF(filter);\n    return NULL;\n*/\n}\n\n/*[clinic input]\n_sre.SRE_Pattern.sub\n\n    cls: defining_class\n    /\n    repl: object\n    string: object\n    count: Py_ssize_t = 0\n\nReturn the string obtained by replacing the leftmost non-overlapping occurrences of pattern in string by the replacement repl.\n[clinic start generated code]*/\n\nfunction _sre_SRE_Pattern_sub_impl(self, cls,\n                          repl, string, count){\n    var module_state = get_sre_module_state_by_class(cls);\n\n    return pattern_subx(module_state, self, repl, string, count, 0);\n}\n\n/*[clinic input]\n_sre.SRE_Pattern.subn\n\n    cls: defining_class\n    /\n    repl: object\n    string: object\n    count: Py_ssize_t = 0\n\nReturn the tuple (new_string, number_of_subs_made) found by replacing the leftmost non-overlapping occurrences of pattern with the replacement repl.\n[clinic start generated code]*/\n\nfunction _sre_SRE_Pattern_subn_impl(self, cls,\n                           repl, string,\n                           count){\n    var module_state = get_sre_module_state_by_class(cls);\n\n    return pattern_subx(module_state, self, repl, string, count, 1);\n}\n\n/*[clinic input]\n_sre.SRE_Pattern.__copy__\n\n[clinic start generated code]*/\n\nfunction _sre_SRE_Pattern___copy___impl(self){\n    Py_INCREF(self);\n    return self;\n}\n\n/*[clinic input]\n_sre.SRE_Pattern.__deepcopy__\n\n    memo: object\n    /\n\n[clinic start generated code]*/\n\nfunction _sre_SRE_Pattern___deepcopy__(self, memo){\n    Py_INCREF(self);\n    return self;\n}\n\nfunction pattern_repr(obj){\n    var flag_names = [\n        {name: \"re.TEMPLATE\", value: SRE_FLAG_TEMPLATE},\n        {name: \"re.IGNORECASE\", value: SRE_FLAG_IGNORECASE},\n        {name: \"re.LOCALE\", value: SRE_FLAG_LOCALE},\n        {name: \"re.MULTILINE\", value: SRE_FLAG_MULTILINE},\n        {name: \"re.DOTALL\", value: SRE_FLAG_DOTALL},\n        {name: \"re.UNICODE\", value: SRE_FLAG_UNICODE},\n        {name: \"re.VERBOSE\", value: SRE_FLAG_VERBOSE},\n        {name: \"re.DEBUG\", value: SRE_FLAG_DEBUG},\n        {name: \"re.ASCII\", value: SRE_FLAG_ASCII}\n    ];\n    var result = NULL,\n        flag_items,\n        i,\n        flags = obj.flags;\n\n    /* Omit re.UNICODE for valid string patterns. */\n    if (obj.isbytes == 0 &&\n        (flags & (SRE_FLAG_LOCALE|SRE_FLAG_UNICODE|SRE_FLAG_ASCII)) ==\n         SRE_FLAG_UNICODE)\n        flags &= ~SRE_FLAG_UNICODE;\n\n    flag_items = PyList_New(0);\n    if (!flag_items){\n        return NULL;\n    }\n    for (i = 0; i < Py_ARRAY_LENGTH(flag_names); i++) {\n        if (flags & flag_names[i].value) {\n            var item = PyUnicode_FromString(flag_names[i].name);\n            if (!item){\n                return done();\n            }\n            if (PyList_Append(flag_items, item) < 0) {\n                Py_DECREF(item);\n                return done();\n            }\n            Py_DECREF(item);\n            flags &= ~flag_names[i].value;\n        }\n    }\n    if (flags) {\n        var item = PyUnicode_FromFormat(\"0x%x\", flags);\n        if (!item){\n            return done();\n        }\n        if (PyList_Append(flag_items, item) < 0) {\n            Py_DECREF(item);\n            return done();\n        }\n        Py_DECREF(item);\n    }\n\n    if (PyList_Size(flag_items) > 0) {\n        var flags_result,\n            sep = PyUnicode_FromString(\"|\");\n        if (!sep){\n            return done();\n        }\n        flags_result = PyUnicode_Join(sep, flag_items);\n        Py_DECREF(sep);\n        if (!flags_result){\n            return done();\n        }\n        result = PyUnicode_FromFormat(\"re.compile(%.200R, %S)\",\n                                      obj.pattern, flags_result);\n        Py_DECREF(flags_result);\n    }\n    else {\n        result = PyUnicode_FromFormat(\"re.compile(%.200R)\", obj.pattern);\n    }\n\n    function done(){\n        Py_DECREF(flag_items);\n        return result;\n    }\n}\n\nvar pattern_doc = \"Compiled regular expression object.\";\n\n/* PatternObject's 'groupindex' method. */\nfunction pattern_groupindex(self, ignored){\n    if (self.groupindex == NULL){\n        return PyDict_New();\n    }\n    return PyDictProxy_New(self.groupindex);\n}\n\n// static int _validate(PatternObject *self); /* Forward */\n\n/*[clinic input]\n_sre.compile\n\n    pattern: object\n    flags: int\n    code: object(subclass_of='&PyList_Type')\n    groups: Py_ssize_t\n    groupindex: object(subclass_of='&PyDict_Type')\n    indexgroup: object(subclass_of='&PyTuple_Type')\n\n[clinic start generated code]*/\n\nfunction _sre_compile_impl(pattern, flags,\n                  code, groups, groupindex,\n                  indexgroup){\n    console.log('arguments', arguments)\n    /* \"compile\" pattern descriptor to pattern object */\n\n    var module_state = get_sre_module_state($module),\n        self,\n        i, n;\n\n    n = PyList_GET_SIZE(code);\n    /* coverity[ampersand_in_size] */\n    self = PyObject_GC_NewVar(PatternObject, module_state.Pattern_Type, n);\n    if (!self){\n        return NULL;\n    }\n    self.weakreflist = NULL;\n    self.pattern = NULL;\n    self.groupindex = NULL;\n    self.indexgroup = NULL;\n\n    self.codesize = n;\n\n    for (i = 0; i < n; i++) {\n        var o = PyList_GET_ITEM(code, i),\n            value = PyLong_AsUnsignedLong(o);\n        self.code[i] = value;\n        if (self.code[i] != value) {\n            PyErr_SetString(PyExc_OverflowError,\n                            \"regular expression code size limit exceeded\");\n            break;\n        }\n    }\n    PyObject_GC_Track(self);\n\n    if (PyErr_Occurred()) {\n        Py_DECREF(self);\n        return NULL;\n    }\n\n    if (pattern == _b_.None) {\n        self.isbytes = -1;\n    }else {\n        var p_length,\n            charsize,\n            view = {};\n        view.buf = NULL;\n        if (!getstring(pattern, p_length, self.isbytes,\n                       charsize, view)) {\n            Py_DECREF(self);\n            return NULL;\n        }\n        if (view.buf){\n            PyBuffer_Release(view);\n        }\n    }\n\n    Py_INCREF(pattern);\n    self.pattern = pattern;\n\n    self.flags = flags;\n\n    self.groups = groups;\n\n    if (PyDict_GET_SIZE(groupindex) > 0) {\n        Py_INCREF(groupindex);\n        self.groupindex = groupindex;\n        if (PyTuple_GET_SIZE(indexgroup) > 0) {\n            Py_INCREF(indexgroup);\n            self.indexgroup = indexgroup;\n        }\n    }\n\n    if (!_validate(self)) {\n        Py_DECREF(self);\n        return NULL;\n    }\n\n    return self;\n}\n\n/* -------------------------------------------------------------------- */\n/* Code validation */\n\n/* To learn more about this code, have a look at the _compile() function in\n   Lib/sre_compile.py.  The validation functions below checks the code array\n   for conformance with the code patterns generated there.\n\n   The nice thing about the generated code is that it is position-independent:\n   all jumps are relative jumps forward.  Also, jumps don't cross each other:\n   the target of a later jump is always earlier than the target of an earlier\n   jump.  IOW, this is okay:\n\n   J---------J-------T--------T\n    \\         \\_____/        /\n     \\______________________/\n\n   but this is not:\n\n   J---------J-------T--------T\n    \\_________\\_____/        /\n               \\____________/\n\n   It also helps that SRE_CODE is always an unsigned type.\n*/\n\n/* Defining this one enables tracing of the validator */\nvar VVERBOSE\n\n/* Trace macro for the validator */\nfunction VTRACE(v){\n    if(VVERBOSE){\n        console.log(v)\n    }\n}\n\n/* Report failure */\nfunction FAIL(){\n    VTRACE((\"FAIL: %d\\n\", __LINE__));\n    return 0;\n}\n\n/* Extract opcode, argument, or skip count from code array */\nfunction GET_OP(){\n    VTRACE((\"%p: \", code))\n    if (code >= end){\n        FAIL\n    }\n    op = code++\n    VTRACE((\"%lu (op)\\n\", op))\n}\n\nfunction GET_ARG(){\n    VTRACE((\"%p= \", code))\n    if (code >= end){\n        FAIL\n    }\n    arg = code++\n    VTRACE(\"%lu (arg)\\n\", arg)\n}\n\nfunction GET_SKIP_ADJ(adj){\n    VTRACE((\"%p= \", code))\n    if (code >= end){\n        FAIL\n    }\n    skip = code\n    VTRACE((\"%lu (skip to %p)\\n\",\n           skip, code+skip));\n    if (skip-adj > (end - code)){\n        FAIL\n    }\n    code++\n}\n\n// #define GET_SKIP GET_SKIP_ADJ(0)\n\nfunction _validate_charset(code, end){\n    /* Some variables are manipulated by the macros above */\n    var op,\n        arg,\n        offset,\n        i;\n\n    while (code < end) {\n        GET_OP;\n        switch (op) {\n\n        case SRE_OP_NEGATE:\n            break;\n\n        case SRE_OP_LITERAL:\n            GET_ARG;\n            break;\n\n        case SRE_OP_RANGE:\n        case SRE_OP_RANGE_UNI_IGNORE:\n            GET_ARG;\n            GET_ARG;\n            break;\n\n        case SRE_OP_CHARSET:\n            offset = 256/SRE_CODE_BITS; /* 256-bit bitmap */\n            if (offset > (end - code)){\n                FAIL;\n            }\n            code += offset;\n            break;\n\n        case SRE_OP_BIGCHARSET:\n            GET_ARG; /* Number of blocks */\n            offset = 256/sizeof(SRE_CODE); /* 256-byte table */\n            if (offset > (end - code)){\n                FAIL;\n            }\n            /* Make sure that each byte points to a valid block */\n            for (i = 0; i < 256; i++) {\n                if (code[i] >= arg){\n                    FAIL;\n                }\n            }\n            code += offset;\n            offset = arg * (256 / SRE_CODE_BITS); /* 256-bit bitmap times arg */\n            if (offset > (end - code)){\n                FAIL;\n            }\n            code += offset;\n            break;\n\n        case SRE_OP_CATEGORY:\n            GET_ARG;\n            switch (arg) {\n            case SRE_CATEGORY_DIGIT:\n            case SRE_CATEGORY_NOT_DIGIT:\n            case SRE_CATEGORY_SPACE:\n            case SRE_CATEGORY_NOT_SPACE:\n            case SRE_CATEGORY_WORD:\n            case SRE_CATEGORY_NOT_WORD:\n            case SRE_CATEGORY_LINEBREAK:\n            case SRE_CATEGORY_NOT_LINEBREAK:\n            case SRE_CATEGORY_LOC_WORD:\n            case SRE_CATEGORY_LOC_NOT_WORD:\n            case SRE_CATEGORY_UNI_DIGIT:\n            case SRE_CATEGORY_UNI_NOT_DIGIT:\n            case SRE_CATEGORY_UNI_SPACE:\n            case SRE_CATEGORY_UNI_NOT_SPACE:\n            case SRE_CATEGORY_UNI_WORD:\n            case SRE_CATEGORY_UNI_NOT_WORD:\n            case SRE_CATEGORY_UNI_LINEBREAK:\n            case SRE_CATEGORY_UNI_NOT_LINEBREAK:\n                break;\n            default:\n                FAIL;\n            }\n            break;\n\n        default:\n            FAIL;\n\n        }\n    }\n\n    return 1;\n}\n\nfunction _validate_inner(code, end, groups){\n    /* Some variables are manipulated by the macros above */\n    var op,\n        arg,\n        skip;\n\n    VTRACE((\"code=%p, end=%p\\n\", code, end));\n\n    if (code > end){\n        FAIL;\n    }\n    while (code < end) {\n        GET_OP;\n        switch (op) {\n\n        case SRE_OP_MARK:\n            /* We don't check whether marks are properly nested; the\n               sre_match() code is robust even if they don't, and the worst\n               you can get is nonsensical match results. */\n            GET_ARG;\n            if (arg > 2 * groups + 1) {\n                VTRACE((\"arg=%d, groups=%d\\n\", arg, groups));\n                FAIL;\n            }\n            break;\n\n        case SRE_OP_LITERAL:\n        case SRE_OP_NOT_LITERAL:\n        case SRE_OP_LITERAL_IGNORE:\n        case SRE_OP_NOT_LITERAL_IGNORE:\n        case SRE_OP_LITERAL_UNI_IGNORE:\n        case SRE_OP_NOT_LITERAL_UNI_IGNORE:\n        case SRE_OP_LITERAL_LOC_IGNORE:\n        case SRE_OP_NOT_LITERAL_LOC_IGNORE:\n            GET_ARG;\n            /* The arg is just a character, nothing to check */\n            break;\n\n        case SRE_OP_SUCCESS:\n        case SRE_OP_FAILURE:\n            /* Nothing to check; these normally end the matching process */\n            break;\n\n        case SRE_OP_AT:\n            GET_ARG;\n            switch (arg) {\n            case SRE_AT_BEGINNING:\n            case SRE_AT_BEGINNING_STRING:\n            case SRE_AT_BEGINNING_LINE:\n            case SRE_AT_END:\n            case SRE_AT_END_LINE:\n            case SRE_AT_END_STRING:\n            case SRE_AT_BOUNDARY:\n            case SRE_AT_NON_BOUNDARY:\n            case SRE_AT_LOC_BOUNDARY:\n            case SRE_AT_LOC_NON_BOUNDARY:\n            case SRE_AT_UNI_BOUNDARY:\n            case SRE_AT_UNI_NON_BOUNDARY:\n                break;\n            default:\n                FAIL;\n            }\n            break;\n\n        case SRE_OP_ANY:\n        case SRE_OP_ANY_ALL:\n            /* These have no operands */\n            break;\n\n        case SRE_OP_IN:\n        case SRE_OP_IN_IGNORE:\n        case SRE_OP_IN_UNI_IGNORE:\n        case SRE_OP_IN_LOC_IGNORE:\n            GET_SKIP;\n            /* Stop 1 before the end; we check the FAILURE below */\n            if (!_validate_charset(code, code+skip-2)){\n                FAIL;\n            }\n            if (code[skip-2] != SRE_OP_FAILURE){\n                FAIL;\n            }\n            code += skip-1;\n            break;\n\n        case SRE_OP_INFO:\n            {\n                /* A minimal info field is\n                   <INFO> <1=skip> <2=flags> <3=min> <4=max>;\n                   If SRE_INFO_PREFIX or SRE_INFO_CHARSET is in the flags,\n                   more follows. */\n                var flags, i, newcode;\n                GET_SKIP;\n                newcode = code + skip - 1;\n                GET_ARG;\n                flags = arg;\n                GET_ARG;\n                GET_ARG;\n                /* Check that only valid flags are present */\n                if ((flags & ~(SRE_INFO_PREFIX |\n                               SRE_INFO_LITERAL |\n                               SRE_INFO_CHARSET)) != 0){\n                    FAIL;\n                }\n                /* PREFIX and CHARSET are mutually exclusive */\n                if ((flags & SRE_INFO_PREFIX) &&\n                    (flags & SRE_INFO_CHARSET)){\n                    FAIL;\n                }\n                /* LITERAL implies PREFIX */\n                if ((flags & SRE_INFO_LITERAL) &&\n                    !(flags & SRE_INFO_PREFIX)){\n                    FAIL;\n                }\n                /* Validate the prefix */\n                if (flags & SRE_INFO_PREFIX) {\n                    var prefix_len;\n                    GET_ARG; prefix_len = arg;\n                    GET_ARG;\n                    /* Here comes the prefix string */\n                    if (prefix_len > (newcode - code)){\n                        FAIL;\n                    }\n                    code += prefix_len;\n                    /* And here comes the overlap table */\n                    if (prefix_len > (newcode - code)){\n                        FAIL;\n                    }\n                    /* Each overlap value should be < prefix_len */\n                    for (i = 0; i < prefix_len; i++) {\n                        if (code[i] >= prefix_len)\n                            FAIL;\n                    }\n                    code += prefix_len;\n                }\n                /* Validate the charset */\n                if (flags & SRE_INFO_CHARSET) {\n                    if (!_validate_charset(code, newcode-1)){\n                        FAIL;\n                    }\n                    if (newcode[-1] != SRE_OP_FAILURE){\n                        FAIL;\n                    }\n                    code = newcode;\n                }else if (code != newcode) {\n                  VTRACE((\"code=%p, newcode=%p\\n\", code, newcode));\n                    FAIL;\n                }\n            }\n            break;\n\n        case SRE_OP_BRANCH:\n            {\n                var target = NULL;\n                for (;;) {\n                    GET_SKIP;\n                    if (skip == 0){\n                        break;\n                    }\n                    /* Stop 2 before the end; we check the JUMP below */\n                    if (!_validate_inner(code, code+skip-3, groups)){\n                        FAIL;\n                    }\n                    code += skip-3;\n                    /* Check that it ends with a JUMP, and that each JUMP\n                       has the same target */\n                    GET_OP;\n                    if (op != SRE_OP_JUMP){\n                        FAIL;\n                    }\n                    GET_SKIP;\n                    if (target == NULL){\n                        target = code+skip-1;\n                    }else if (code+skip-1 != target){\n                        FAIL;\n                    }\n                }\n            }\n            break;\n\n        case SRE_OP_REPEAT_ONE:\n        case SRE_OP_MIN_REPEAT_ONE:\n            {\n                var min, max;\n                GET_SKIP;\n                GET_ARG; min = arg;\n                GET_ARG; max = arg;\n                if (min > max){\n                    FAIL;\n                }\n                if (max > SRE_MAXREPEAT){\n                    FAIL;\n                }\n                if (!_validate_inner(code, code+skip-4, groups)){\n                    FAIL;\n                }\n                code += skip-4;\n                GET_OP;\n                if (op != SRE_OP_SUCCESS){\n                    FAIL;\n                }\n            }\n            break;\n\n        case SRE_OP_REPEAT:\n            {\n                var min, max;\n                GET_SKIP;\n                GET_ARG; min = arg;\n                GET_ARG; max = arg;\n                if (min > max){\n                    FAIL;\n                }\n                if (max > SRE_MAXREPEAT){\n                    FAIL;\n                }\n                if (!_validate_inner(code, code+skip-3, groups)){\n                    FAIL;\n                }\n                code += skip-3;\n                GET_OP;\n                if (op != SRE_OP_MAX_UNTIL && op != SRE_OP_MIN_UNTIL){\n                    FAIL;\n                }\n            }\n            break;\n\n        case SRE_OP_GROUPREF:\n        case SRE_OP_GROUPREF_IGNORE:\n        case SRE_OP_GROUPREF_UNI_IGNORE:\n        case SRE_OP_GROUPREF_LOC_IGNORE:\n            GET_ARG;\n            if (arg >= groups){\n                FAIL;\n            }\n            break;\n\n        case SRE_OP_GROUPREF_EXISTS:\n            /* The regex syntax for this is: '(?(group)then|else)', where\n               'group' is either an integer group number or a group name,\n               'then' and 'else' are sub-regexes, and 'else' is optional. */\n            GET_ARG;\n            if (arg >= groups){\n                FAIL;\n            }\n            GET_SKIP_ADJ(1);\n            code--; /* The skip is relative to the first arg! */\n            /* There are two possibilities here: if there is both a 'then'\n               part and an 'else' part, the generated code looks like:\n\n               GROUPREF_EXISTS\n               <group>\n               <skipyes>\n               ...then part...\n               JUMP\n               <skipno>\n               (<skipyes> jumps here)\n               ...else part...\n               (<skipno> jumps here)\n\n               If there is only a 'then' part, it looks like:\n\n               GROUPREF_EXISTS\n               <group>\n               <skip>\n               ...then part...\n               (<skip> jumps here)\n\n               There is no direct way to decide which it is, and we don't want\n               to allow arbitrary jumps anywhere in the code; so we just look\n               for a JUMP opcode preceding our skip target.\n            */\n            if (skip >= 3 && skip-3 < (end - code) &&\n                    code[skip-3] == SRE_OP_JUMP){\n                VTRACE((\"both then and else parts present\\n\"));\n                if (!_validate_inner(code+1, code+skip-3, groups)){\n                    FAIL;\n                }\n                code += skip-2; /* Position after JUMP, at <skipno> */\n                GET_SKIP;\n                if (!_validate_inner(code, code+skip-1, groups)){\n                    FAIL;\n                }\n                code += skip-1;\n            }else {\n                VTRACE((\"only a then part present\\n\"));\n                if (!_validate_inner(code+1, code+skip-1, groups)){\n                    FAIL;\n                }\n                code += skip-1;\n            }\n            break;\n\n        case SRE_OP_ASSERT:\n        case SRE_OP_ASSERT_NOT:\n            GET_SKIP;\n            GET_ARG; /* 0 for lookahead, width for lookbehind */\n            code--; /* Back up over arg to simplify math below */\n            if (arg & 0x80000000){\n                FAIL; /* Width too large */\n            }\n            /* Stop 1 before the end; we check the SUCCESS below */\n            if (!_validate_inner(code+1, code+skip-2, groups)){\n                FAIL;\n            }\n            code += skip-2;\n            GET_OP;\n            if (op != SRE_OP_SUCCESS){\n                FAIL;\n            }\n            break;\n\n        default:\n            FAIL;\n\n        }\n    }\n\n    VTRACE((\"okay\\n\"));\n    return 1;\n}\n\nfunction _validate_outer(code, end, groups){\n    if (groups < 0 || groups > SRE_MAXGROUPS ||\n            code >= end || end[-1] != SRE_OP_SUCCESS){\n        FAIL;\n    }\n    return _validate_inner(code, end-1, groups);\n}\n\nfunction _validate(self){\n    if (!_validate_outer(self.code, self.code+self.codesize, self.groups)){\n        PyErr_SetString(PyExc_RuntimeError, \"invalid SRE code\");\n        return 0;\n    }else{\n        VTRACE((\"Success!\\n\"));\n    }\n    return 1;\n}\n\n/* -------------------------------------------------------------------- */\n/* match methods */\n\nfunction match_traverse(self, visit, arg){\n    Py_VISIT(Py_TYPE(self));\n    Py_VISIT(self.string);\n    Py_VISIT(self.regs);\n    Py_VISIT(self.pattern);\n    return 0;\n}\n\nfunction match_clear(self){\n    Py_CLEAR(self.string);\n    Py_CLEAR(self.regs);\n    Py_CLEAR(self.pattern);\n    return 0;\n}\n\nfunction match_dealloc(self){\n    var tp = Py_TYPE(self);\n\n    PyObject_GC_UnTrack(self);\n    match_clear(self);\n    tp.tp_free(self);\n    Py_DECREF(tp);\n}\n\nfunction match_getslice_by_index(self, index, def){\n    var length,\n        isbytes, charsize,\n        view,\n        result,\n        ptr,\n        i, j;\n\n    assert(0 <= index && index < self.groups);\n    index *= 2;\n\n    if (self.string == Py_None || self.mark[index] < 0) {\n        /* return default value if the string or group is undefined */\n        Py_INCREF(def);\n        return def;\n    }\n\n    ptr = getstring(self.string, length, isbytes, charsize, view);\n    if (ptr == NULL){\n        return NULL;\n    }\n    i = self.mark[index];\n    j = self.mark[index + 1];\n    i = Py_MIN(i, length);\n    j = Py_MIN(j, length);\n    result = getslice(isbytes, ptr, self.string, i, j);\n    if (isbytes && view.buf != NULL){\n        PyBuffer_Release(view);\n    }\n    return result;\n}\n\nfunction match_getindex(self, index){\n    var i;\n\n    if (index == NULL){\n        /* Default value */\n        return 0;\n    }\n    if (PyIndex_Check(index)) {\n        i = PyNumber_AsSsize_t(index, NULL);\n    }else {\n        i = -1;\n\n        if (self.pattern.groupindex) {\n            index = PyDict_GetItemWithError(self.pattern.groupindex, index);\n            if (index && PyLong_Check(index)) {\n                i = PyLong_AsSsize_t(index);\n            }\n        }\n    }\n    if (i < 0 || i >= self.groups) {\n        /* raise IndexError if we were given a bad group number */\n        if (!PyErr_Occurred()) {\n            PyErr_SetString(PyExc_IndexError, \"no such group\");\n        }\n        return -1;\n    }\n\n    return i;\n}\n\nfunction match_getslice(self, index, def){\n    var i = match_getindex(self, index);\n\n    if (i < 0) {\n        return NULL;\n    }\n\n    return match_getslice_by_index(self, i, def);\n}\n\n/*[clinic input]\n_sre.SRE_Match.expand\n\n    template: object\n\nReturn the string obtained by doing backslash substitution on the string template, as done by the sub() method.\n[clinic start generated code]*/\n\nfunction _sre_SRE_Match_expand_impl(self, template){\n    /* delegate to Python code */\n    return call(\n        SRE_PY_MODULE, \"_expand\",\n        PyTuple_Pack(3, self.pattern, self, template)\n        );\n}\n\nfunction match_group(self, args){\n    var result,\n        i, size;\n\n    size = PyTuple_GET_SIZE(args);\n\n    switch (size) {\n    case 0:\n        result = match_getslice(self, _PyLong_GetZero(), _b_.None);\n        break;\n    case 1:\n        result = match_getslice(self, PyTuple_GET_ITEM(args, 0), _b_.None);\n        break;\n    default:\n        /* fetch multiple items */\n        result = PyTuple_New(size);\n        if (!result){\n            return NULL;\n        }\n        for (i = 0; i < size; i++) {\n            var item = match_getslice(\n                self, PyTuple_GET_ITEM(args, i), _b_.None\n                );\n            if (!item) {\n                Py_DECREF(result);\n                return NULL;\n            }\n            PyTuple_SET_ITEM(result, i, item);\n        }\n        break;\n    }\n    return result;\n}\n\nfunction match_getitem(self, name){\n    return match_getslice(self, name, _b_.None);\n}\n\n/*[clinic input]\n_sre.SRE_Match.groups\n\n    default: object = None\n        Is used for groups that did not participate in the match.\n\nReturn a tuple containing all the subgroups of the match, from 1.\n[clinic start generated code]*/\n\nfunction _sre_SRE_Match_groups_impl(self, default_value){\n    var result,\n        index;\n\n    result = PyTuple_New(self.groups-1);\n    if (!result){\n        return NULL;\n    }\n    for (index = 1; index < self.groups; index++) {\n        var item;\n        item = match_getslice_by_index(self, index, default_value);\n        if (!item) {\n            Py_DECREF(result);\n            return NULL;\n        }\n        PyTuple_SET_ITEM(result, index-1, item);\n    }\n\n    return result;\n}\n\n/*[clinic input]\n_sre.SRE_Match.groupdict\n\n    default: object = None\n        Is used for groups that did not participate in the match.\n\nReturn a dictionary containing all the named subgroups of the match, keyed by the subgroup name.\n[clinic start generated code]*/\n\nfunction _sre_SRE_Match_groupdict_impl(self, default_value){\n    var result,\n        key,\n        value,\n        pos = 0,\n        hash;\n\n    result = PyDict_New();\n    if (!result || !self.pattern.groupindex){\n        return result;\n    }\n    while (_PyDict_Next(self.pattern.groupindex, pos, key, value, hash)) {\n        var status;\n        Py_INCREF(key);\n        value = match_getslice(self, key, default_value);\n        if (!value) {\n            Py_DECREF(key);\n            throw failed;\n        }\n        status = _PyDict_SetItem_KnownHash(result, key, value, hash);\n        Py_DECREF(value);\n        Py_DECREF(key);\n        if (status < 0){\n            throw failed;\n        }\n    }\n\n    return result;\n\n    var failed = function(){\n        Py_DECREF(result);\n        return NULL;\n    }\n}\n\n/*[clinic input]\n_sre.SRE_Match.start -> Py_ssize_t\n\n    group: object(c_default=\"NULL\") = 0\n    /\n\nReturn index of the start of the substring matched by group.\n[clinic start generated code]*/\n\nfunction _sre_SRE_Match_start_impl(self, group){\n    var index = match_getindex(self, group);\n\n    if (index < 0) {\n        return -1;\n    }\n\n    /* mark is -1 if group is undefined */\n    return self.mark[index * 2];\n}\n\n/*[clinic input]\n_sre.SRE_Match.end -> Py_ssize_t\n\n    group: object(c_default=\"NULL\") = 0\n    /\n\nReturn index of the end of the substring matched by group.\n[clinic start generated code]*/\n\nfunction _sre_SRE_Match_end_impl(self, group){\n    var index = match_getindex(self, group);\n\n    if (index < 0) {\n        return -1;\n    }\n\n    /* mark is -1 if group is undefined */\n    return self.mark[index * 2 + 1];\n}\n\nfunction _pair(i1, i2){\n    var pair,\n        item;\n\n    pair = PyTuple_New(2);\n    if (!pair){\n        return NULL;\n    }\n    item = PyLong_FromSsize_t(i1);\n    if (!item){\n        throw error;\n    }\n    PyTuple_SET_ITEM(pair, 0, item);\n\n    item = PyLong_FromSsize_t(i2);\n    if (!item){\n        throw error;\n    }\n    PyTuple_SET_ITEM(pair, 1, item);\n\n    return pair;\n\n}\n\n/*[clinic input]\n_sre.SRE_Match.span\n\n    group: object(c_default=\"NULL\") = 0\n    /\n\nFor match object m, return the 2-tuple (m.start(group), m.end(group)).\n[clinic start generated code]*/\n\nfunction _sre_SRE_Match_span_impl(self, group){\n    var index = match_getindex(self, group);\n\n    if (index < 0) {\n        return NULL;\n    }\n\n    /* marks are -1 if group is undefined */\n    return _pair(self.mark[index * 2], self.mark[index * 2 + 1]);\n}\n\nfunction match_regs(self){\n    var regs,\n        item,\n        index;\n\n    regs = PyTuple_New(self.groups);\n    if (!regs){\n        return NULL;\n    }\n    for (index = 0; index < self.groups; index++) {\n        item = _pair(self.mark[index * 2], self.mark[index * 2 + 1]);\n        if (!item) {\n            Py_DECREF(regs);\n            return NULL;\n        }\n        PyTuple_SET_ITEM(regs, index, item);\n    }\n\n    Py_INCREF(regs);\n    self.regs = regs;\n\n    return regs;\n}\n\n/*[clinic input]\n_sre.SRE_Match.__copy__\n\n[clinic start generated code]*/\n\nfunction _sre_SRE_Match___copy___impl(self){\n    Py_INCREF(self);\n    return self;\n}\n\n/*[clinic input]\n_sre.SRE_Match.__deepcopy__\n\n    memo: object\n    /\n\n[clinic start generated code]*/\n\nfunction _sre_SRE_Match___deepcopy__(self, memo){\n    Py_INCREF(self);\n    return self;\n}\n\nvar match_doc =\n\"The result of re.match() and re.search().\\n\\\nMatch objects always have a boolean value of True.\";\n\nvar match_group_doc =\n\"group([group1, ...]) -> str or tuple.\\n\\\n    Return subgroup(s) of the match by indices or names.\\n\\\n    For 0 returns the entire match.\";\n\nfunction match_lastindex_get(self, ignored){\n    if (self.lastindex >= 0){\n        return PyLong_FromSsize_t(self.lastindex);\n    }\n    Py_RETURN_NONE;\n}\n\nfunction match_lastgroup_get(self, ignored){\n    if (self.pattern.indexgroup &&\n            self.lastindex >= 0 &&\n            self.lastindex < PyTuple_GET_SIZE(self.pattern.indexgroup)){\n        var result = PyTuple_GET_ITEM(self.pattern.indexgroup,\n                                            self.lastindex);\n        Py_INCREF(result);\n        return result;\n    }\n    Py_RETURN_NONE;\n}\n\nfunction match_regs_get(self, ignored){\n    if (self.regs) {\n        Py_INCREF(self.regs);\n        return self.regs;\n    } else{\n        return match_regs(self);\n    }\n}\n\nfunction match_repr(self){\n    var result,\n        group0 = match_getslice_by_index(self, 0, _b_.None);\n    if (group0 == NULL){\n        return NULL;\n    }\n    result = PyUnicode_FromFormat(\n            \"<%s object; span=(%zd, %zd), match=%.50R>\",\n            Py_TYPE(self).tp_name,\n            self.mark[0], self.mark[1], group0);\n    Py_DECREF(group0);\n    return result;\n}\n\n\nfunction pattern_new_match(module_state,\n                  pattern,\n                  state,\n                  status){\n    /* create match object (from state object) */\n\n    var match,\n        i, j,\n        base,\n        n;\n\n    if (status > 0) {\n\n        /* create match object (with room for extra group marks) */\n        /* coverity[ampersand_in_size] */\n        match = PyObject_GC_NewVar(MatchObject,\n                                   module_state.Match_Type,\n                                   2 * (pattern.groups + 1));\n        if (!match){\n            return NULL;\n        }\n        Py_INCREF(pattern);\n        match.pattern = pattern;\n\n        Py_INCREF(state.string);\n        match.string = state.string;\n\n        match.regs = NULL;\n        match.groups = pattern.groups + 1;\n\n        /* fill in group slices */\n\n        base = state.beginning;\n        n = state.charsize;\n\n        match.mark[0] = (state.start - base) / n;\n        match.mark[1] = (state.ptr - base) / n;\n\n        for (i = j = 0; i < pattern.groups; i++, j+=2){\n            if (j  +1 <= state.lastmark && state.mark[j] && state.mark[j + 1]) {\n                match.mark[j + 2] = (state.mark[j] - base) / n;\n                match.mark[j + 3] = (state.mark[j + 1] - base) / n;\n            } else{\n                match.mark[j + 2] = match.mark[j + 3] = -1; /* undefined */\n            }\n        }\n        match.pos = state.pos;\n        match.endpos = state.endpos;\n\n        match.lastindex = state.lastindex;\n\n        PyObject_GC_Track(match);\n        return match;\n\n    } else if (status == 0) {\n\n        /* no match */\n        Py_RETURN_NONE;\n\n    }\n\n    /* internal error */\n    pattern_error(status);\n    return NULL;\n}\n\n\n/* -------------------------------------------------------------------- */\n/* scanner methods (experimental) */\n\nfunction scanner_traverse(self, visit, arg){\n    Py_VISIT(Py_TYPE(self));\n    Py_VISIT(self.pattern);\n    return 0;\n}\n\nfunction scanner_clear(self){\n    Py_CLEAR(self.pattern);\n    return 0;\n}\n\nfunction scanner_dealloc(self){\n    var tp = Py_TYPE(self);\n\n    PyObject_GC_UnTrack(self);\n    state_fini(self.state);\n    scanner_clear(self);\n    tp.tp_free(self);\n    Py_DECREF(tp);\n}\n\n/*[clinic input]\n_sre.SRE_Scanner.match\n\n    cls: defining_class\n    /\n\n[clinic start generated code]*/\n\nfunction _sre_SRE_Scanner_match_impl(self, cls){\n    var module_state = get_sre_module_state_by_class(cls),\n        state = self.state,\n        match,\n        status;\n\n    if (state.start == NULL){\n        Py_RETURN_NONE;\n    }\n    state_reset(state);\n\n    state.ptr = state.start;\n\n    status = sre_match(state, PatternObject_GetCode(self.pattern));\n    if (PyErr_Occurred()){\n        return NULL;\n    }\n    match = pattern_new_match(module_state, self.pattern,\n                              state, status);\n\n    if (status == 0){\n        state.start = NULL;\n    }else {\n        state.must_advance = (state.ptr == state.start);\n        state.start = state.ptr;\n    }\n\n    return match;\n}\n\n\n/*[clinic input]\n_sre.SRE_Scanner.search\n\n    cls: defining_class\n    /\n\n[clinic start generated code]*/\n\nfunction _sre_SRE_Scanner_search_impl(self, cls){\n    var module_state = get_sre_module_state_by_class(cls),\n        state = self.state,\n        match,\n        status;\n\n    if (state.start == NULL){\n        Py_RETURN_NONE;\n    }\n    state_reset(state);\n\n    state.ptr = state.start;\n\n    status = sre_search(state, PatternObject_GetCode(self.pattern));\n    if (PyErr_Occurred()){\n        return NULL;\n    }\n\n    match = pattern_new_match(module_state, self.pattern,\n                              state, status);\n\n    if (status == 0){\n        state.start = NULL;\n    }else {\n        state.must_advance = (state.ptr == state.start);\n        state.start = state.ptr;\n    }\n\n    return match;\n}\n\nfunction pattern_scanner(module_state,\n                self,\n                string,\n                pos,\n                endpos){\n    var scanner;\n\n    /* create scanner object */\n    scanner = PyObject_GC_New(ScannerObject, module_state.Scanner_Type);\n    if (!scanner){\n        return NULL;\n    }\n    scanner.pattern = NULL;\n\n    /* create search state object */\n    if (!state_init(scanner.state, self, string, pos, endpos)) {\n        Py_DECREF(scanner);\n        return NULL;\n    }\n\n    Py_INCREF(self);\n    scanner.pattern = self;\n\n    PyObject_GC_Track(scanner);\n    return scanner;\n}\n\nfunction pattern_hash(self){\n    var hash, hash2;\n\n    hash = PyObject_Hash(self.pattern);\n    if (hash == -1) {\n        return -1;\n    }\n\n    hash2 = _Py_HashBytes(self.code, sizeof(self.code[0]) * self.codesize);\n    hash ^= hash2;\n\n    hash ^= self.flags;\n    hash ^= self.isbytes;\n    hash ^= self.codesize;\n\n    if (hash == -1) {\n        hash = -2;\n    }\n    return hash;\n}\n\nfunction pattern_richcompare(lefto, righto, op){\n    var tp = Py_TYPE(lefto),\n        module_state = get_sre_module_state_by_class(tp),\n        left, right,\n        cmp;\n\n    if (op != Py_EQ && op != Py_NE) {\n        Py_RETURN_NOTIMPLEMENTED;\n    }\n\n    if (!Py_IS_TYPE(righto, module_state.Pattern_Type))\n    {\n        Py_RETURN_NOTIMPLEMENTED;\n    }\n\n    if (lefto == righto) {\n        /* a pattern is equal to itself */\n        return PyBool_FromLong(op == Py_EQ);\n    }\n\n    left = lefto;\n    right = righto;\n\n    cmp = (left.flags == right.flags\n           && left.isbytes == right.isbytes\n           && left.codesize == right.codesize);\n    if (cmp) {\n        /* Compare the code and the pattern because the same pattern can\n           produce different codes depending on the locale used to compile the\n           pattern when the re.LOCALE flag is used. Don't compare groups,\n           indexgroup nor groupindex: they are derivated from the pattern. */\n        cmp = (memcmp(left.code, right.code,\n                      sizeof(left.code[0]) * left.codesize) == 0);\n    }\n    if (cmp) {\n        cmp = PyObject_RichCompareBool(left.pattern, right.pattern,\n                                       Py_EQ);\n        if (cmp < 0) {\n            return NULL;\n        }\n    }\n    if (op == Py_NE) {\n        cmp = !cmp;\n    }\n    return PyBool_FromLong(cmp);\n}\n\n// #include \"clinic/_sre.c.h\"\n\nvar pattern_methods = []\n\n/*\nstatic PyMethodDef pattern_methods[] = {\n    _SRE_SRE_PATTERN_MATCH_METHODDEF\n    _SRE_SRE_PATTERN_FULLMATCH_METHODDEF\n    _SRE_SRE_PATTERN_SEARCH_METHODDEF\n    _SRE_SRE_PATTERN_SUB_METHODDEF\n    _SRE_SRE_PATTERN_SUBN_METHODDEF\n    _SRE_SRE_PATTERN_FINDALL_METHODDEF\n    _SRE_SRE_PATTERN_SPLIT_METHODDEF\n    _SRE_SRE_PATTERN_FINDITER_METHODDEF\n    _SRE_SRE_PATTERN_SCANNER_METHODDEF\n    _SRE_SRE_PATTERN___COPY___METHODDEF\n    _SRE_SRE_PATTERN___DEEPCOPY___METHODDEF\n    {\"__class_getitem__\", Py_GenericAlias, METH_O|METH_CLASS,\n     PyDoc_STR(\"See PEP 585\")},\n    {NULL, NULL}\n};\n*/\n\nvar pattern_getset = []\n\n/*\nstatic PyGetSetDef pattern_getset[] = {\n    {\"groupindex\", (getter)pattern_groupindex, (setter)NULL,\n      \"A dictionary mapping group names to group numbers.\"},\n    {NULL}  // Sentinel\n};\n*/\n\nfunction PAT_OFF(x) {\n    return offsetof(PatternObject, x)\n}\nvar pattern_members = []\n/*\nstatic PyMemberDef pattern_members[] = {\n    {\"pattern\",    T_OBJECT,    PAT_OFF(pattern),       READONLY,\n     \"The pattern string from which the RE object was compiled.\"},\n    {\"flags\",      T_INT,       PAT_OFF(flags),         READONLY,\n     \"The regex matching flags.\"},\n    {\"groups\",     T_PYSSIZET,  PAT_OFF(groups),        READONLY,\n     \"The number of capturing groups in the pattern.\"},\n    {\"__weaklistoffset__\", T_PYSSIZET, offsetof(PatternObject, weakreflist), READONLY},\n    {NULL}  //\n};\n*/\n\nvar pattern_slots = []\n/*\nstatic PyType_Slot pattern_slots[] = {\n    {Py_tp_dealloc, (destructor)pattern_dealloc},\n    {Py_tp_repr, (reprfunc)pattern_repr},\n    {Py_tp_hash, (hashfunc)pattern_hash},\n    {Py_tp_doc, (void *)pattern_doc},\n    {Py_tp_richcompare, pattern_richcompare},\n    {Py_tp_methods, pattern_methods},\n    {Py_tp_members, pattern_members},\n    {Py_tp_getset, pattern_getset},\n    {Py_tp_traverse, pattern_traverse},\n    {Py_tp_clear, pattern_clear},\n    {0, NULL},\n};\n*/\n\nvar pattern_spec = {\n    name: \"re.Pattern\",\n    basicsize: 0,\n    itemsize: 0,\n    flags: 0,\n    slots: pattern_slots\n}\n/*\nstatic PyType_Spec pattern_spec = {\n    .name = \"re.Pattern\",\n    .basicsize = sizeof(PatternObject),\n    .itemsize = sizeof(SRE_CODE),\n    .flags = (Py_TPFLAGS_DEFAULT | Py_TPFLAGS_IMMUTABLETYPE |\n              Py_TPFLAGS_DISALLOW_INSTANTIATION | Py_TPFLAGS_HAVE_GC),\n    .slots = pattern_slots,\n};\n*/\n\nvar match_methods = []\n/*\nstatic PyMethodDef match_methods[] = {\n    {\"group\", (PyCFunction) match_group, METH_VARARGS, match_group_doc},\n    _SRE_SRE_MATCH_START_METHODDEF\n    _SRE_SRE_MATCH_END_METHODDEF\n    _SRE_SRE_MATCH_SPAN_METHODDEF\n    _SRE_SRE_MATCH_GROUPS_METHODDEF\n    _SRE_SRE_MATCH_GROUPDICT_METHODDEF\n    _SRE_SRE_MATCH_EXPAND_METHODDEF\n    _SRE_SRE_MATCH___COPY___METHODDEF\n    _SRE_SRE_MATCH___DEEPCOPY___METHODDEF\n    {\"__class_getitem__\", Py_GenericAlias, METH_O|METH_CLASS,\n     PyDoc_STR(\"See PEP 585\")},\n    {NULL, NULL}\n};\n*/\n\nvar match_getset = []\n/*\nstatic PyGetSetDef match_getset[] = {\n    {\"lastindex\", (getter)match_lastindex_get, (setter)NULL,\n     \"The integer index of the last matched capturing group.\"},\n    {\"lastgroup\", (getter)match_lastgroup_get, (setter)NULL,\n     \"The name of the last matched capturing group.\"},\n    {\"regs\",      (getter)match_regs_get,      (setter)NULL},\n    {NULL}\n};\n*/\n\nfunction MATCH_OFF(x) {\n    return offsetof(MatchObject, x)\n}\n\nvar match_members = []\n\n/*\nstatic PyMemberDef match_members[] = {\n    {\"string\",  T_OBJECT,   MATCH_OFF(string),  READONLY,\n     \"The string passed to match() or search().\"},\n    {\"re\",      T_OBJECT,   MATCH_OFF(pattern), READONLY,\n     \"The regular expression object.\"},\n    {\"pos\",     T_PYSSIZET, MATCH_OFF(pos),     READONLY,\n     \"The index into the string at which the RE engine started looking for a match.\"},\n    {\"endpos\",  T_PYSSIZET, MATCH_OFF(endpos),  READONLY,\n     \"The index into the string beyond which the RE engine will not go.\"},\n    {NULL}\n};\n*/\n\n/* FIXME: implement setattr(\"string\", None) as a special case (to\n   detach the associated string, if any */\n\nvar match_slots = []\n\n/*\nstatic PyType_Slot match_slots[] = {\n    {Py_tp_dealloc, match_dealloc},\n    {Py_tp_repr, match_repr},\n    {Py_tp_doc, (void *)match_doc},\n    {Py_tp_methods, match_methods},\n    {Py_tp_members, match_members},\n    {Py_tp_getset, match_getset},\n    {Py_tp_traverse, match_traverse},\n    {Py_tp_clear, match_clear},\n*/\n    /* As mapping.\n     *\n     * Match objects do not support length or assignment, but do support\n     * __getitem__.\n     */\n/*\n    {Py_mp_subscript, match_getitem},\n\n    {0, NULL},\n};\n*/\n\nvar match_spec = {\n    name: 're.Match',\n    basicsizie: 0,\n    itemsize: 0,\n    flags: 0,\n    slots: match_slots\n}\n/*\nstatic PyType_Spec match_spec = {\n    .name = \"re.Match\",\n    .basicsize = sizeof(MatchObject),\n    .itemsize = sizeof(Py_ssize_t),\n    .flags = (Py_TPFLAGS_DEFAULT | Py_TPFLAGS_IMMUTABLETYPE |\n              Py_TPFLAGS_DISALLOW_INSTANTIATION | Py_TPFLAGS_HAVE_GC),\n    .slots = match_slots,\n};\n*/\n\nvar scanner_methods = []\n\n/*\nstatic PyMethodDef scanner_methods[] = {\n    _SRE_SRE_SCANNER_MATCH_METHODDEF\n    _SRE_SRE_SCANNER_SEARCH_METHODDEF\n    {NULL, NULL}\n};\n*/\n\nfunction SCAN_OFF(x) {\n    return offsetof(ScannerObject, x)\n}\n\nvar scanner_members = []\n/*\nstatic PyMemberDef scanner_members[] = {\n    {\"pattern\", T_OBJECT, SCAN_OFF(pattern), READONLY},\n    {NULL}  // Sentinel\n};\n*/\n\nvar scanner_slots = []\n/*\nstatic PyType_Slot scanner_slots[] = {\n    {Py_tp_dealloc, scanner_dealloc},\n    {Py_tp_methods, scanner_methods},\n    {Py_tp_members, scanner_members},\n    {Py_tp_traverse, scanner_traverse},\n    {Py_tp_clear, scanner_clear},\n    {0, NULL},\n};\n*/\n\nvar scanner_spec = {\n    name: '',\n    basicsize: 0,\n    flags: 0,\n    slots: scanner_slots\n}\n\n/*\nstatic PyType_Spec scanner_spec = {\n    .name = \"_\" SRE_MODULE \".SRE_Scanner\",\n    .basicsize = sizeof(ScannerObject),\n    .flags = (Py_TPFLAGS_DEFAULT | Py_TPFLAGS_IMMUTABLETYPE |\n              Py_TPFLAGS_DISALLOW_INSTANTIATION | Py_TPFLAGS_HAVE_GC),\n    .slots = scanner_slots,\n};\n*/\n\n/*\nstatic PyMethodDef _functions[] = {\n    _SRE_COMPILE_METHODDEF\n    _SRE_GETCODESIZE_METHODDEF\n    _SRE_ASCII_ISCASED_METHODDEF\n    _SRE_UNICODE_ISCASED_METHODDEF\n    _SRE_ASCII_TOLOWER_METHODDEF\n    _SRE_UNICODE_TOLOWER_METHODDEF\n    {NULL, NULL}\n};\n*/\n\nfunction sre_traverse(module, visit, arg){\n    var state = get_sre_module_state(module);\n\n    Py_VISIT(state.Pattern_Type);\n    Py_VISIT(state.Match_Type);\n    Py_VISIT(state.Scanner_Type);\n\n    return 0;\n}\n\nfunction sre_clear(module){\n    var state = get_sre_module_state(module);\n\n    Py_CLEAR(state.Pattern_Type);\n    Py_CLEAR(state.Match_Type);\n    Py_CLEAR(state.Scanner_Type);\n\n    return 0;\n}\n\nfunction sre_free(module){\n    sre_clear(module);\n}\n\nfunction CREATE_TYPE(m, type, spec){\n    type = PyType_FromModuleAndSpec(m, spec, NULL);\n    if (type == NULL) {\n        throw error;\n    }\n}\n\nfunction ADD_ULONG_CONSTANT(module, name, value){\n    var o = PyLong_FromUnsignedLong(value);\n    if (!o) {\n        throw error\n    }\n    var res = PyModule_AddObjectRef(module, name, o)\n    Py_DECREF(o)\n    if (res < 0) {\n        throw error\n    }\n}\n\nfunction sre_exec(m){\n    var state;\n\n    /* Create heap types */\n    state = get_sre_module_state(m);\n    CREATE_TYPE(m, state.Pattern_Type, pattern_spec);\n    CREATE_TYPE(m, state.Match_Type, match_spec);\n    CREATE_TYPE(m, state.Scanner_Type, scanner_spec);\n\n    if (PyModule_AddIntConstant(m, \"MAGIC\", SRE_MAGIC) < 0) {\n        throw error;\n    }\n\n    if (PyModule_AddIntConstant(m, \"CODESIZE\", sizeof(SRE_CODE)) < 0) {\n        throw error;\n    }\n\n    ADD_ULONG_CONSTANT(m, \"MAXREPEAT\", SRE_MAXREPEAT);\n    ADD_ULONG_CONSTANT(m, \"MAXGROUPS\", SRE_MAXGROUPS);\n\n    if (PyModule_AddStringConstant(m, \"copyright\", copyright) < 0) {\n        throw error;\n    }\n\n    return 0;\n/*\nerror:\n    return -1;\n    */\n}\n\nvar sre_slots = []\n/*\nvar sre_slots = [\n    {Py_mod_exec, sre_exec},\n    {0, NULL},\n];\n*/\n\n/*\nstatic struct PyModuleDef sremodule = {\n    .m_base = PyModuleDef_HEAD_INIT,\n    .m_name = \"_\" SRE_MODULE,\n    .m_size = sizeof(_sremodulestate),\n    .m_methods = _functions,\n    .m_slots = sre_slots,\n    .m_traverse = sre_traverse,\n    .m_free = sre_free,\n    .m_clear = sre_clear,\n};\n*/\n\n/*\nPyMODINIT_FUNC\nPyInit__sre(void)\n{\n    return PyModuleDef_Init(sremodule);\n}\n*/\n/* vim:ts=4:sw=4:et\n*/\n\nvar $module = {\n    compile: _sre_compile_impl,\n    CODESIZE: 4,\n    MAGIC: 20171005,\n    MAXGROUPS: 2147483647,\n    MAXREPEAT: 2147483648\n}"], "_sre_utils": [".js", "var $module=(function($B){\n\n    function unicode_iscased(cp){\n        // cp : Unicode code point\n        var letter = String.fromCodePoint(cp)\n        return (letter != letter.toLowerCase() ||\n            letter != letter.toUpperCase())\n    }\n\n    function ascii_iscased(cp){\n        if(cp > 255){return false}\n        return unicode_iscased(cp)\n    }\n\n    function unicode_tolower(cp){\n        var letter = String.fromCodePoint(cp),\n            lower = letter.toLowerCase()\n        return lower.charCodeAt(0)\n    }\n\n    function ascii_tolower(cp){\n        return unicode_tolower(cp)\n    }\n\nreturn {\n    unicode_iscased: unicode_iscased,\n    ascii_iscased: ascii_iscased,\n    unicode_tolower: unicode_tolower,\n    ascii_tolower: ascii_tolower\n}\n\n}\n\n)(__BRYTHON__)"], "_string": [".js", "(function($B){\n\nvar _b_ = $B.builtins\n\nfunction parts(format_string){\n    var result = [],\n        _parts = $B.split_format(format_string) // defined in py_string.js\n    for(var i = 0; i < _parts.length; i+= 2){\n        result.push({pre: _parts[i], fmt: _parts[i + 1]})\n    }\n    return result\n}\n\nfunction Tuple(){\n    var args = []\n    for(var i=0, len=arguments.length; i < len; i++){\n        args.push(arguments[i])\n    }\n    return _b_.tuple.$factory(args)\n}\n\n$B.imported._string = {\n\n    formatter_field_name_split: function(fieldname){\n        // Split the argument as a field name\n        var parsed = $B.parse_format(fieldname),\n            first = parsed.name,\n            rest = []\n        if(first.match(/\\d+/)){first = parseInt(first)}\n        parsed.name_ext.forEach(function(ext){\n            if(ext.startsWith(\"[\")){\n                var item = ext.substr(1, ext.length - 2)\n                if(item.match(/\\d+/)){\n                    rest.push(Tuple(false, parseInt(item)))\n                }else{\n                    rest.push(Tuple(false, item))\n                }\n            }else{\n                rest.push(Tuple(true, ext.substr(1)))\n            }\n        })\n        return Tuple(first, _b_.iter(rest))\n    },\n    formatter_parser: function(format_string){\n        // Parse the argument as a format string\n\n        if(! _b_.isinstance(format_string, _b_.str)){\n            throw _b_.ValueError.$factory(\"Invalid format string type: \" +\n                $B.class_name(format_string))\n        }\n\n        var result  = []\n        parts(format_string).forEach(function(item){\n            var pre = item.pre === undefined ? \"\" : item.pre,\n                fmt = item.fmt\n            if(fmt === undefined){\n               result.push(Tuple(pre, _b_.None, _b_.None, _b_.None))\n            }else if(fmt.string == ''){\n               result.push(Tuple(pre, '', '', _b_.None))\n            }else{\n               result.push(Tuple(pre,\n                   fmt.raw_name + fmt.name_ext.join(\"\"),\n                   fmt.raw_spec,\n                   fmt.conv || _b_.None))\n           }\n        })\n        return result\n    }\n}\n})(__BRYTHON__)"], "_strptime": [".js", "\n(function($B){\n    var _b_ = __BRYTHON__.builtins\n    $B.imported._strptime = {\n        _strptime_datetime: function(cls, s, fmt){\n            var pos_s = 0,\n                pos_fmt = 0,\n                dt = {}\n            function error(time_data, format){\n                throw _b_.ValueError.$factory(\n                    `time data '${time_data}' does not match format '${format}'`)\n            }\n\n            if(! $B.$isinstance(s, _b_.str)){\n                throw _b_.TypeError.$factory(\n                    `strptime() argument 1 must be str, not ${$B.class_name(s)}`)\n            }\n\n            var locale = __BRYTHON__.locale,\n                shortdays = [],\n                longdays = [],\n                conv_func = locale == \"C\" ?\n                    function(d, options){\n                        return d.toLocaleDateString('en-EN', options)\n                    } :\n                    function(d, options){\n                        return d.toLocaleDateString(locale, options)\n                    }\n\n            for(var day = 16; day < 23; day++){\n                var d = new Date(Date.UTC(2012, 11, day, 3, 0, 0))\n                shortdays.push(conv_func(d, {weekday: 'short'}))\n                longdays.push(conv_func(d, {weekday: 'long'}))\n            }\n\n            var shortmonths = [],\n                longmonths = []\n\n            for(var month = 0; month < 12; month++){\n                var d = new Date(Date.UTC(2012, month, 11, 3, 0, 0))\n                shortmonths.push(conv_func(d, {month: 'short'}))\n                longmonths.push(conv_func(d, {month: 'long'}))\n            }\n\n            var shortdays_re = new RegExp(shortdays.join(\"|\").replace(\".\", \"\\\\.\")),\n                longdays_re = new RegExp(longdays.join(\"|\")),\n                shortmonths_re = new RegExp(shortmonths.join(\"|\").replace(\".\", \"\\\\.\")),\n                longmonths_re = new RegExp(longmonths.join(\"|\"))\n\n            var regexps = {\n                d: [\"day\", new RegExp(\"^[123][0-9]|0?[1-9]\")],\n                f: [\"microsecond\", new RegExp(\"^\\\\d{1,6}\")],\n                H: [\"hour\", new RegExp(\"^[01][0-9]|2[0-3]|\\\\d\")],\n                I: [\"hour\", new RegExp(\"^1[0-2]|0?[0-9]\")],\n                m: [\"month\", new RegExp(\"^1[012]|0?[1-9]\")],\n                M: [\"minute\", new RegExp(\"^[1-5][0-9]|0?[0-9]\")],\n                S: [\"second\", new RegExp(\"^[1-5]\\\\d|0?\\\\d\")],\n                y: [\"year\", new RegExp(\"^0{0,2}\\\\d{2}\")],\n                Y: [\"year\", new RegExp(\"^\\\\d{4}\")],\n                z: [\"tzinfo\", new RegExp(\"^Z|([+-]\\\\d{2}[0-5]\\\\d)([0-5]\\\\d(\\.\\\\d{1,6})?)?\")],\n                Z: [\"timezone\", new RegExp(\"UTC|GMT\")]\n            }\n\n            for(var key in regexps){\n                var re = new RegExp('%' + key, \"g\"),\n                    mo = fmt.match(re)\n                if(mo && mo.length > 1){\n                    throw _b_.ValueError.$factory('strptime directive %' +\n                        key + ' defined more than once')\n                }\n            }\n\n            while(pos_fmt < fmt.length){\n                var car = fmt.charAt(pos_fmt)\n                if(car == \"%\"){\n                    var spec = fmt.charAt(pos_fmt + 1),\n                        regexp = regexps[spec]\n                    if(regexp !== undefined){\n                        var re = regexp[1],\n                            attr = regexp[0],\n                            res = re.exec(s.substr(pos_s))\n                        if(res === null){\n                            error(s, fmt)\n                        }else{\n                            dt[attr] = parseInt(res[0])\n                            if(attr == \"microsecond\"){\n                                var ms = res[0]\n                                ms += '0'.repeat(6 - ms.length)\n                                dt[attr] = parseInt(ms)\n                            }else if(attr == \"timezone\"){\n                                var dt_module = $B.imported[cls.__module__]\n                                dt.tzinfo = dt_module.timezone[res[0].toLowerCase()]\n                            }else if(attr == \"tzinfo\"){\n                                var seconds = 0,\n                                    microseconds = 0\n\n                                if(res[0] != 'Z'){\n                                    let HHMM = res[1]\n                                    let sign = HHMM[0] == '+' ? 1 : -1\n                                    let hh = parseInt(HHMM.substr(1, 2))\n                                    let mm = parseInt(HHMM.substr(3))\n                                    seconds = 3600 * hh + 60 * mm\n                                    if(res[2]){\n                                        seconds += parseInt(res[2])\n                                    }\n                                    seconds = sign * seconds\n                                    if(res[3]){\n                                        let ms = res[3].substr(1)\n                                        ms += '0'.repeat(6 - ms.length)\n                                        microseconds = sign * parseInt(ms)\n                                    }\n                                }\n                                var dt_module = $B.imported[cls.__module__]\n                                let timedelta = dt_module.timedelta.$factory(0,\n                                    seconds, microseconds)\n                                let days = $B.$getattr(timedelta, 'days')\n                                if(Math.abs(days) > 1){\n                                    throw _b_.ValueError.$factory(\"offset \" +\n                                        \"must be a timedelta strictly between\" +\n                                        \" -timedelta(hours=24) and timedelta\" +\n                                        \"(hours=24), not \" +\n                                        _b_.repr(timedelta))\n                                }\n                                let tz = dt_module.timezone\n                                dt.tzinfo = tz.__new__(tz, timedelta)\n                            }\n                            pos_fmt += 2\n                            pos_s += res[0].length\n                        }\n                    }else if(spec == \"a\" || spec == \"A\"){\n                        // Locale's abbreviated (a) or full (A) weekday name\n                        var attr = \"weekday\",\n                            re = spec == \"a\" ? shortdays_re : longdays_re,\n                            t = spec == \"a\" ? shortdays : longdays\n                            res = re.exec(s.substr(pos_s))\n                        if(res === null){\n                            console.log('error', re, 'string', s.substr(pos_s), 'fmt', fmt)\n                            error(s, fmt)\n                        }else{\n                            var match = res[0],\n                                ix = t.indexOf(match)\n                        }\n                        dt.weekday = ix\n                        pos_fmt += 2\n                        pos_s += match.length\n                    }else if(spec == \"b\" || spec == \"B\"){\n                        // Locales's abbreviated (b) or full (B) month\n                        var attr = \"month\",\n                            re = spec == \"b\" ? shortmonths_re : longmonths_re,\n                            t = spec == \"b\" ? shortmonths : longmonths,\n                            res = re.exec(s.substr(pos_s))\n                        if(res === null){\n                            error(s, fmt)\n                        }else{\n                            var match = res[0],\n                                ix = t.indexOf(match)\n                        }\n                        dt.month = ix + 1\n                        pos_fmt += 2\n                        pos_s += match.length\n                    }else if(spec == \"c\"){\n                        // Locale's appropriate date and time representation\n                        var fmt1 = fmt.substr(0, pos_fmt - 1) + _locale_c_format() +\n                            fmt.substr(pos_fmt + 2)\n                        fmt = fmt1\n                    }else if(spec == \"%\"){\n                        if(s.charAt(pos_s) == \"%\"){\n                            pos_fmt++\n                            pos_s++\n                        }else{\n                            error(s, fmt)\n                        }\n                    }else if(spec == 'p'){\n                        // AM or PM\n                        var next2 = s.substr(pos_s, 2)\n                        if(next2.toUpperCase() == 'AM'){\n                            if(dt.hasOwnProperty('hour')){\n                                if(dt.hour > 0 && dt.hour < 12){\n                                    // ok\n                                }else if(dt.hour == 12){\n                                    dt.hour = 0\n                                }else{\n                                    error(s, fmt)\n                                }\n                            }else{\n                                error(s, fmt)\n                            }\n                        }else if(next2.toUpperCase() == 'PM'){\n                            if(dt.hasOwnProperty('hour')){\n                                if(dt.hour > 0 && dt.hour < 12){\n                                    dt.hour += 12\n                                }else if(dt.hour == 12){\n                                    dt.hour = 12\n                                }else{\n                                    error(s, fmt)\n                                }\n                            }else{\n                                error(s, fmt)\n                            }\n                        }else{\n                            error(s, fmt)\n                        }\n                        pos_fmt += 2\n                        pos_s += 2\n                    }else{\n                        pos_fmt++\n                    }\n                }else{\n                    if(car == s.charAt(pos_s)){\n                        pos_fmt++\n                        pos_s++\n                    }else{\n                        error(s, fmt)\n                    }\n                }\n            }\n\n            if(pos_s < s.length){\n                throw _b_.ValueError.$factory('unconverted data remains: ' +\n                    s.substr(pos_s))\n            }\n\n            return $B.$call(cls)(dt.year ?? 1900, dt.month ?? 1,\n                dt.day ?? 1,\n                dt.hour || 0, dt.minute || 0, dt.second || 0,\n                dt.microsecond || 0, dt.tzinfo || _b_.None)\n        }\n    }\n})(__BRYTHON__)\n"], "_svg": [".js", "// creation of a SVG element\n(function($B){\n\nvar _b_ = $B.builtins\nvar TagSum = $B.TagSum // defined in py_dom.js\n\nvar $svgNS = \"http://www.w3.org/2000/svg\"\nvar $xlinkNS = \"http://www.w3.org/1999/xlink\"\n\nfunction makeTagDict(tagName){\n    // return the dictionary for the class associated with tagName\n    var dict = $B.make_class(tagName)\n\n    dict.__init__ = function(){\n        var $ns = $B.args('__init__', 1, {self: null}, ['self'],\n            arguments, {}, 'args', 'kw'),\n            self = $ns['self'],\n            args = $ns['args']\n        if(args.length == 1){\n            var first = args[0]\n            if($B.$isinstance(first, [_b_.str, _b_.int, _b_.float])){\n                self.appendChild(document.createTextNode(_b_.str.$factory(first)))\n            }else if(first.__class__ === TagSum){\n                for(var i = 0, len = first.children.length; i < len; i++){\n                    self.appendChild(first.children[i].elt)\n                }\n            }else{ // argument is another DOMNode instance\n                try{self.appendChild(first.elt)}\n                catch(err){throw _b_.ValueError.$factory('wrong element ' + first)}\n            }\n        }\n\n        // attributes\n        var items = _b_.list.$factory(_b_.dict.items($ns['kw']))\n        for(var item of _b_.dict.$iter_items($ns.kw)){\n            // keyword arguments\n            var arg = item.key,\n                value = $B.py_immutable_to_js(item.value)\n            if(arg.toLowerCase().substr(0,2) == \"on\"){\n                // Event binding passed as argument \"onclick\", \"onfocus\"...\n                // Better use method bind of DOMNode objects\n                $B.DOMNode.bind(self,\n                                arg.toLowerCase().substr(2),\n                                value)\n            }else if(arg.toLowerCase() == \"style\"){\n                $B.DOMNode.set_style(self, value)\n            }else if(arg.toLowerCase().indexOf(\"href\") !== -1){ // xlink:href\n                self.setAttributeNS( \"http://www.w3.org/1999/xlink\",\n                    \"href\",value)\n            }else{\n                if(value !== false){\n                    // option.selected=false sets it to true :-)\n                    try{\n                        arg = arg.replace('_', '-')\n                        self.setAttributeNS(null, arg, value)\n                    }catch(err){\n                        throw _b_.ValueError.$factory(\"can't set attribute \" + arg)\n                    }\n                }\n            }\n        }\n    }\n\n    dict.__mro__ = [$B.DOMNode, $B.builtins.object]\n\n    dict.__new__ = function(cls){\n        var res = $B.DOMNode.$factory(document.createElementNS($svgNS, tagName))\n        res.__class__ = cls\n        return res\n    }\n\n    dict.$factory = function(){\n        var res = $B.DOMNode.$factory(\n            document.createElementNS($svgNS, tagName))\n        res.__class__ = dict\n        // apply __init__\n        dict.__init__(res, ...arguments)\n        return res\n    }\n\n    $B.set_func_names(dict, \"browser.svg\")\n\n    return dict\n}\n\n\n// SVG\nvar $svg_tags = ['a',\n'altGlyph',\n'altGlyphDef',\n'altGlyphItem',\n'animate',\n'animateColor',\n'animateMotion',\n'animateTransform',\n'circle',\n'clipPath',\n'color_profile', // instead of color-profile\n'cursor',\n'defs',\n'desc',\n'ellipse',\n'feBlend',\n'foreignObject', //patch to enable foreign objects\n'g',\n'image',\n'line',\n'linearGradient',\n'marker',\n'mask',\n'path',\n'pattern',\n'polygon',\n'polyline',\n'radialGradient',\n'rect',\n'set',\n'stop',\n'svg',\n'text',\n'tref',\n'tspan',\n'use']\n\n// create classes\nvar obj = new Object()\nvar dicts = {}\nfor(var i = 0, len = $svg_tags.length; i < len; i++){\n    var tag = $svg_tags[i]\n    obj[tag] = makeTagDict(tag)\n}\n\n$B.imported._svg = obj\n})(__BRYTHON__)\n"], "_symtable": [".js", "(function($B){\n\nvar _b_ = $B.builtins\n\nvar module = $B.SYMBOL_FLAGS // in brython_builtins.js\n\nmodule.symtable = function(){\n    var $ = $B.args('symtable', 3,\n        {code: null, filename: null, compile_type: null},\n        ['code', 'filename', 'compile_type'], arguments,\n        {}, null, null)\n    var ast = _b_.compile($.code, $.filename, $.compile_type,\n        $B.PyCF_ONLY_AST)\n    // ast is an instance of Python class\n    // _Py_Symtable_Build in symtable.js uses the underlying JS object\n    return $B._PySymtable_Build(ast.$js_ast, $.filename)\n}\n\n\n$B.addToImported('_symtable', module)\n\n})(__BRYTHON__)"], "_tokenize": [".js", "(function($B){\n\nvar _b_ = $B.builtins\n\n$B.$import('token')\n\nvar TokenizerIter = $B.make_class('TokenizerIter',\n    function(it){\n        return {\n            __class__: TokenizerIter,\n            it\n        }\n    }\n)\n\nTokenizerIter.__iter__ = function(self){\n    var js_iter = function*(){\n        var line_num = 0\n        while(true){\n            try{\n                var bytes = self.it()\n            }catch(err){\n                if($B.is_exc(err, [_b_.StopIteration])){\n                    token = endmarker\n                    token.lineno++\n                    token.end_lineno++\n                    yield $B.fast_tuple([token.num_type, token.string,\n                                         $B.fast_tuple([token.lineno, token.col_offset]),\n                                         $B.fast_tuple([token.end_lineno, token.end_col_offset]),\n                                         token.line])\n                }\n                throw err\n            }\n            line_num++\n            var line = _b_.bytes.decode(bytes, 'utf-8')\n            for(var token of $B.tokenizer(line, 'test')){\n                if(token.num_type == $B.py_tokens.ENCODING){ // skip encoding token\n                    continue\n                }else if(token.num_type == $B.py_tokens.ENDMARKER){\n                    var endmarker = token\n                    continue\n                }\n                token.type = token.num_type\n                token.lineno = line_num\n                token.end_lineno = line_num\n                yield $B.fast_tuple([token.num_type, token.string,\n                                     $B.fast_tuple([token.lineno, token.col_offset]),\n                                     $B.fast_tuple([token.end_lineno, token.end_col_offset]),\n                                     token.line])\n            }\n        }\n\n    }\n    return $B.generator.$factory(js_iter)()\n}\n\nTokenizerIter.__next__ = function*(self){\n\n}\n\n$B.set_func_names(TokenizerIter, '_tokenize')\n\n$B.addToImported('_tokenize', {TokenizerIter})\n\n\n})(__BRYTHON__)"], "_webcomponent": [".js", "// module for Web Components\n(function($B){\n\nvar _b_ = $B.builtins\n\nfunction define(tag_name, cls, options){\n    var $ = $B.args(\"define\", 3, {tag_name: null, cls: null, options: null},\n            [\"tag_name\", \"cls\", \"options\"], arguments, {options: _b_.None},\n            null, null),\n        tag_name = $.tag_name,\n        cls = $.cls,\n        options = $.options,\n        _extends,\n        extend_dom_name = 'HTMLElement'\n    if(options !== _b_.None){\n        if(! $B.$isinstance(options, _b_.dict)){\n            throw _b_.TypeError.$factory('options can only be None or a ' +\n                `dict, not '${$B.class_name(options)}'`)\n        }\n        try{\n            _extends = _b_.dict.$getitem(options, 'extends')\n        }catch(err){\n            // ignore\n        }\n    }else{\n        let stack = [...cls.__bases__];\n        while(stack.length) {\n            base = stack.pop();\n        if(base.__module__ === 'browser.html'){\n                _extends = base.__name__.toLowerCase()\n                break\n        }\n\n        stack.push(...base.__bases__);\n    }\n    }\n\n    if(_extends){\n        if(typeof _extends != 'string'){\n            throw _b_.TypeError.$factory('value for extends must be a ' +\n                `string, not '${$B.class_name(_extends)}'`)\n        }\n        var elt = document.createElement(_extends)\n        if(elt instanceof HTMLUnknownElement){\n            throw _b_.ValueError.$factory(`'${_extends}' is not a valid ` +\n                'tag name')\n        }\n        var extend_tag = _extends.toLowerCase()\n        extend_dom_name = Object.getPrototypeOf(elt).constructor.name\n    }\n    if(typeof tag_name != \"string\"){\n        throw _b_.TypeError.$factory(\"first argument of define() \" +\n            \"must be a string, not '\" + $B.class_name(tag_name) + \"'\")\n    }else if(tag_name.indexOf(\"-\") == -1){\n        throw _b_.ValueError.$factory(\"custom tag name must \" +\n            \"contain a hyphen (-)\")\n    }\n    if(!$B.$isinstance(cls, _b_.type)){\n        throw _b_.TypeError.$factory(\"second argument of define() \" +\n            \"must be a class, not '\" + $B.class_name(tag_name) + \"'\")\n    }\n    cls.$webcomponent = true\n\n    // Create the Javascript class used for the component. It must have\n    // the same name as the Python class\n    var src = String.raw`var WebComponent = class extends HTMLElement {\n      constructor(){\n        // Always call super first in constructor\n        super()\n        var html = $B.imported['browser.html']\n        // Create tag in module html\n        if(html['tag_name'] === undefined){\n            html.maketag('tag_name', WebComponent)\n        }\n        var init = $B.$getattr(cls, \"__init__\", _b_.None)\n        if(init !== _b_.None){\n            try{\n                var _self = $B.DOMNode.$factory(this),\n                    attrs_before_init = []\n                for(var i = 0, len = _self.attributes.length; i < len; i++){\n                    attrs_before_init.push(_self.attributes.item(i))\n                }\n                _self.__class__ = cls\n                _self.__dict__ = $B.empty_dict()\n                $B.$call(init)(_self)\n                if(WebComponent.initialized){\n                    // Check that init() did not introduce new attributes,\n                    // which is illegal\n                    // cf. https://html.spec.whatwg.org/multipage/custom-elements.html#custom-element-conformance\n                    for(var i = 0, len = _self.attributes.length; i < len; i++){\n                        var item = _self.attributes.item(i)\n                        if(attrs_before_init.indexOf(item) == -1){\n                            throw _b_.TypeError.$factory(\"Custom element \" +\n                                \"must not create attributes, found: \" +\n                                item.name + '=\"' + item.value + '\"')\n                        }\n                    }\n                }\n            }catch(err){\n                $B.handle_error(err)\n            }\n        }\n      }\n        static get observedAttributes(){\n            var obs_attr = $B.$getattr(cls, \"observedAttributes\", null)\n            if(obs_attr === null){\n                return []\n            }\n            if($B.$isinstance(obs_attr, _b_.property)){ // issue 2454\n                obs_attr = obs_attr.fget(cls)\n            }\n            if(obs_attr === null){\n                return []\n            }else if(typeof obs_attr == \"function\"){\n                var warning = _b_.DeprecationWarning.$factory(\n                    \"Setting observedAttributes as a method \" +\n                    \"is deprecated. Set it as a class attribute.\")\n                // module _warning is in builtin_modules.js\n                $B.imported._warnings.warn(warning)\n                return $B.$call(obs_attr)(this)\n            }else if(Array.isArray(obs_attr)){\n                return obs_attr\n            }else{\n                throw _b_.TypeError.$factory(\n                    \"wrong type for observedAttributes: \" +\n                    $B.class_name(obs_attr))\n            }\n        }\n    }\n    `\n    var name = cls.__name__,\n        code = src.replace(/WebComponent/g, name).\n                   replace(/tag_name/g, tag_name).\n                   replace(/HTMLElement/, extend_dom_name)\n    var src = eval(code)\n    var webcomp = eval(name) // JS class for component\n    webcomp.$cls = cls\n\n    // Override __getattribute__ to handle DOMNode attributes such as\n    // attachShadow\n    cls.__getattribute__ = function(self, attr){\n        try{\n            return $B.DOMNode.__getattribute__(self, attr)\n        }catch(err){\n            if($B.DOMNode[attr]){\n                if(typeof $B.DOMNode[attr] == 'function'){\n                    return function(){\n                        var args = [self]\n                        for(var i = 0, len = arguments.length; i < len; i++){\n                            args.push(arguments[i])\n                        }\n                        return $B.DOMNode[attr].apply(null, args)\n                    }\n                }else{\n                    return $B.DOMNode[attr]\n                }\n            }\n            throw err\n        }\n    }\n\n    var mro = [cls].concat(cls.__mro__).reverse()\n    for(var i = 0, len = mro.length; i < len; i++){\n        var pcls = mro[i]\n        for(var key in pcls){\n            if((! webcomp.hasOwnProperty(key)) &&\n                    typeof pcls[key] == \"function\" &&\n                    // don't set $factory (would make it a class)\n                    key !== '$factory'\n                    ){\n                webcomp.prototype[key] = (function(attr, klass){\n                    return function(){\n                        try{\n                            return $B.$call(klass[attr])($B.DOMNode.$factory(this), ...arguments)\n                        }catch(err){\n                            $B.show_error(err)\n                        }\n                    }\n                })(key, pcls)\n            }\n        }\n    }\n\n    // define WebComp as the class to use for the specified tag name\n    if(_extends){\n        customElements.define(tag_name, webcomp, {extends: extend_tag})\n    }else{\n        customElements.define(tag_name, webcomp)\n    }\n    webcomp.initialized = true\n}\n\nfunction get(name){\n    var ce = customElements.get(name)\n    if(ce && ce.$cls){return ce.$cls}\n    return _b_.None\n}\n\nvar module = {\n    define: define,\n    get: get\n}\n\n$B.addToImported('_webcomponent', module)\n\n})(__BRYTHON__)\n"], "_webworker": [".js", "// Web Worker implementation\n\n(function($B){\n\nvar _b_ = $B.builtins\n\nvar VFS = $B.brython_modules ? 'brython_modules' :\n            $B.use_VFS ? 'brython_stdlib' : null\n\nfunction scripts_to_load(debug_level){\n    if(debug_level > 2){\n        var brython_scripts = [\n            'brython_builtins',\n\n            'py_ast_classes',\n            'stdlib_paths',\n            'unicode_data',\n            'version_info',\n\n            'py_tokens',\n            'python_tokenizer',\n            'py_ast',\n            'py2js',\n            'loaders',\n            'py_utils',\n            'py_object',\n            'py_type',\n            'py_builtin_functions',\n            'py_sort',\n            'py_exceptions',\n            'py_range_slice',\n            'py_bytes',\n            'py_set',\n            'py_import',\n            'py_string',\n            'py_int',\n            'py_long_int',\n            'py_float',\n            'py_complex',\n            'py_dict',\n            'py_list',\n            'js_objects',\n            'py_generator',\n            'py_dom',\n            'py_pattern_matching',\n            'async',\n            'py_flags',\n            'builtin_modules',\n            'ast_to_js',\n            'symtable',\n\n            'action_helpers_generated_version',\n            'string_parser',\n            'number_parser',\n            'python_parser_peg_version',\n            'pegen',\n            'gen_parse',\n            'brython_ready'\n        ]\n    }else{\n        var brython_scripts = ['brython']\n    }\n\n    if(VFS !== null){\n        brython_scripts.push(VFS)\n    }\n    return brython_scripts\n}\n\nvar wclass = $B.make_class(\"Worker\",\n    function(worker){\n        return {\n            __class__: wclass,\n            worker\n        }\n    }\n)\n\nwclass.send = function(){\n    var $ = $B.args('send', 2, {self: null, message: null}, ['self', 'message'],\n            arguments, {}, 'args', null)\n    var message = $B.pyobj2structuredclone($.message)\n    return $.self.worker.postMessage(message, ...$.args)\n}\n\nwclass.__mro__ = [$B.JSObj, _b_.object]\n\n$B.set_func_names(wclass, \"browser.worker\")\n\n\nvar _Worker = $B.make_class(\"Worker\", function(id, onmessage, onerror){\n    $B.warn(_b_.DeprecationWarning,\n        \"worker.Worker is deprecated in version 3.12. \" +\n        \"Use worker.create_worker instead\")\n    var $ = $B.args(\"__init__\", 3, {id: null, onmessage: null, onerror: null},\n            ['id', 'onmessage', 'onerror'], arguments,\n            {onmessage: _b_.None, onerror: _b_.None}, null, null),\n        id = $.id,\n        worker_script = $B.webworkers[id]\n\n    if(worker_script === undefined){\n        throw _b_.KeyError.$factory(id)\n    }\n    var filepath = worker_script.src ? worker_script.src : $B.script_path + \"#\" + id,\n        filename = $B.strip_host(filepath),\n        src = $B.file_cache[filename]\n\n    var indexedDB = worker_script.attributes &&\n            worker_script.attributes.getNamedItem('indexedDB')\n    var script_id = \"worker\" + $B.UUID(),\n        filename = $B.script_path + \"#\" + id\n    $B.url2name[filename] = script_id\n\n    var js = $B.py2js({src, filename}, script_id).to_js(),\n        header = '';\n    var brython_scripts = scripts_to_load(\n        $B.get_option_from_filename('debug', filename))\n    brython_scripts.forEach(function(script){\n        if(script != VFS || VFS == \"brython_stdlib\"){\n            var url = $B.brython_path + script + \".js\"\n        }else{\n            // attribute $B.brython_modules is set to the path of\n            // brython_modules.js by the script itself\n            var url = $B.brython_modules\n        }\n        if(! $B.get_option('cache')){ // cf. issue 1954\n            url += '?' + (new Date()).getTime()\n        }\n        header += 'importScripts(\"' + url + '\")\\n'\n    })\n    // set __BRYTHON__.imported[script_id]\n    header += `\n    var $B = __BRYTHON__,\n        _b_ = $B.builtins\n    var module = $B.module.$factory(\"${script_id}\")\n    module.__file__ = \"${filename}\"\n    module.__doc__ = _b_.None\n    $B.imported[\"${script_id}\"] = module\\n`\n    // restore brython_path\n    header += `$B.brython_path = \"${$B.brython_path}\"\\n`\n    // restore path for imports (cf. issue #1305)\n    header += `$B.make_import_paths(\"${filename}\")\\n`\n    // Call brython() to initialize internal Brython values\n    header += `brython(${JSON.stringify($B.$options)})\\n`\n    js = header + js\n    js = `try{${js}}catch(err){$B.handle_error(err)}`\n\n    var blob = new Blob([js], {type: \"application/js\"}),\n        url = URL.createObjectURL(blob),\n        w = new Worker(url),\n        res = wclass.$factory(w)\n    return res\n})\n\nfunction create_worker(){\n    var $ = $B.args(\"__init__\", 4,\n                    {id: null, onready: null, onmessage: null, onerror: null},\n                    ['id', 'onready', 'onmessage', 'onerror'], arguments,\n                    {onready: _b_.None, onmessage: _b_.None, onerror: _b_.None},\n                    null, null),\n        id = $.id,\n        worker_script = $B.webworkers[id],\n        onready = $.onready === _b_.None ? _b_.None : $B.$call($.onready),\n        onmessage = $.onmessage === _b_.None ? _b_.None : $B.$call($.onmessage),\n        onerror = $.onerror === _b_.None ? _b_.None : $B.$call($.onerror)\n\n    if(worker_script === undefined){\n        throw _b_.RuntimeError.$factory(`No webworker with id '${id}'`)\n    }\n    var script_id = \"worker\" + $B.UUID(),\n        filepath = worker_script.src ? worker_script.src : $B.script_path + \"#\" + id,\n        filename = $B.strip_host(filepath),\n        src = $B.file_cache[filename]\n    $B.url2name[filename] = script_id\n\n    var brython_scripts = scripts_to_load(\n            $B.get_option_from_filename('debug', filename))\n\n    var js = $B.py2js({src, filename}, script_id).to_js(),\n        header = '';\n    for(var script of brython_scripts){\n        if(script != VFS || VFS == \"brython_stdlib\"){\n            var url = $B.brython_path + script + \".js\"\n        }else{\n            // attribute $B.brython_modules is set to the path of\n            // brython_modules.js by the script itself\n            var url = $B.brython_modules\n        }\n        if(! $B.get_option('cache')){ // cf. issue 1954\n            url += '?' + (new Date()).getTime()\n        }\n        header += 'importScripts(\"' + url + '\")\\n'\n    }\n    // set __BRYTHON__.imported[script_id]\n    header += `\n    var $B = __BRYTHON__,\n        _b_ = $B.builtins\n    var module = $B.module.$factory(\"${script_id}\")\n    module.__file__ = \"${filename}\"\n    module.__doc__ = _b_.None\n    $B.script_domain = \"${$B.script_domain}\"\n    $B.imported[\"${script_id}\"] = module\\n`\n\n    header += '$B.file_cache[module.__file__] = `' + src + '`\\n'\n    // restore brython_path\n    header += `$B.brython_path = \"${$B.brython_path}\"\\n`\n    // inject script attributes to get options\n    header += `var script = $B.scripts[\"${filename}\"] = new $B.fakeScript()\\n`\n    for(var key in $B.brython_options){\n        var value = $B.brython_options[key]\n        if(Array.isArray(value)){\n            value = `[${value.map(x => '\"' + x + '\"')}]`\n        }else{\n            value = `\"${value}\"`\n        }\n        header += `script.options[\"${key}\"] = ${value}\\n`\n    }\n\n    for(var attr of worker_script.attributes){\n        header += `script.options[\"${attr.name}\"] = \"${attr.value}\"\\n`\n    }\n\n    // restore path for imports (cf. issue #1305)\n    header += `$B.make_import_paths(\"${filename}\")\\n`\n\n    // Call brython() to initialize internal Brython values\n    var save_option = JSON.stringify($B.brython_options)\n    header += `brython(${save_option})\\n`\n\n    // send dummy message to trigger resolution of Promise\n    var ok_token = Math.random().toString(36).substr(2, 8),\n        error_token = Math.random().toString(36).substr(2, 8)\n\n    // open indexedDB cache before running worker code\n    js = `$B.idb_open_promise().then(function(){\\n` +\n         `try{\\n` +\n             `${js}\\n` +\n             `self.postMessage('${ok_token}')\\n` +\n         `}catch(err){\\n` +\n             `self.postMessage('${error_token}Error in worker \"${id}\"\\\\n'` +\n             ` + $B.error_trace(err))\\n` +\n         `}\\n})`\n    js = header + js\n\n    var p = new Promise(function(resolve, reject){\n        try{\n            var blob = new Blob([js], {type: \"application/js\"}),\n                url = URL.createObjectURL(blob),\n                w = new Worker(url),\n                res = wclass.$factory(w)\n        }catch(err){\n            reject(err)\n        }\n\n        w.onmessage = function(ev){\n            if(ev.data == ok_token){\n                resolve(res)\n            }else if(typeof ev.data == 'string' &&\n                    ev.data.startsWith(error_token)){\n                reject(_b_.Exception.$factory(ev.data.substr(error_token.length)))\n            }else{\n                if(onmessage !== _b_.None){\n                    onmessage(ev)\n                }\n                try{\n                    resolve(res)\n                }catch(err){\n                    reject(err)\n                }\n            }\n        }\n\n        return res\n    })\n\n    var error_func = onerror === _b_.None ? $B.handle_error : onerror\n\n    if(onready !== _b_.None){\n        p.then(onready).catch(error_func)\n    }else{\n        p.catch(error_func)\n    }\n    return _b_.None\n}\n\nvar module = {\n    Worker: _Worker,\n    create_worker\n}\n\n$B.addToImported('_webworker', module)\n\n})(__BRYTHON__)\n"], "_zlib_utils": [".js", "\n\n(function($B){\n\nvar _b_ = $B.builtins\n\nfunction clone(obj){\n    var res = {}\n    for(var key in obj){\n        res[key] = obj[key]\n    }\n    return res\n}\n\nfunction BitWriter(){\n    return new _BitWriter()\n}\n\nfunction _BitWriter(){\n    this.current = []\n    this.bits = 0\n    this.position = 0\n}\n\n_BitWriter.prototype.writeBit = function(v){\n    this.bits |= (v << this.position)\n    this.position++\n    if(this.position >= 8){\n        this.flush()\n    }\n}\n\n_BitWriter.prototype.flush = function(){\n    this.position = 0\n    this.current.push(this.bits)\n    this.bits = 0\n}\n\n_BitWriter.prototype.writeInt = function(v, nb, order){\n    order = order ?? 'lsf'\n    switch(order){\n        case 'msf':\n            var coef = 1 << (nb - 1)\n            var n = 0\n            while(coef > v){\n                this.writeBit(0)\n                coef >>= 1\n                n++\n            }\n            while(coef > 0){\n                this.writeBit(v & coef ? 1 : 0)\n                coef >>= 1\n            }\n            break\n        case 'lsf':\n            var coef = 1\n            var b = 0\n            var n = 0\n            while(coef <= v){\n                this.writeBit(v & coef ? 1 : 0)\n                coef <<= 1\n                n++\n            }\n            while(n < nb){\n                this.writeBit(0)\n                coef <<= 1\n                n++\n            }\n            if(n != nb){\n                console.log('n', n, 'nb', nb)\n                throw Error()\n            }\n    }\n}\n\n_BitWriter.prototype.padLast = function(){\n    if(this.position != 0){\n        this.flush()\n    }\n}\n\nfunction BitReader(bytes){\n    return new _BitReader(bytes)\n}\n\nfunction _BitReader(bytes){\n    this.bytes = bytes.source\n    this.index = 0\n    this.position = 0\n    this.byte = this.bytes[0]\n}\n\n_BitReader.prototype.readBit = function(){\n    if(this.position == 8){\n        this.byte = this.bytes[++this.index]\n        if(this.byte === undefined){\n            throw Error('end of steam')\n        }\n        this.position = 0\n    }\n    var res = this.byte & 1\n    this.byte >>= 1\n    this.position++\n    return res\n}\n\n_BitReader.prototype.read = function(nb, order){\n    // read nb bits, convert to int\n    order = order ?? 'lsf'\n    var result = 0\n    switch(order){\n        case 'lsf':\n            var coef = 0\n            for(var i = 0; i < nb; i++){\n                var bit = this.readBit()\n                result += bit << coef\n                coef += 1\n            }\n            break\n        case 'msf':\n            var coef = nb - 1\n            for(var i = 0; i < nb; i++){\n                result += this.readBit() << coef\n                coef -= 1\n            }\n            break\n    }\n    return result\n}\n\nvar c\nvar crcTable = []\nfor(var n = 0; n < 256; n++){\n    c = n\n    for(var k = 0; k < 8; k++){\n        c = ((c&1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1))\n    }\n    crcTable[n] = c\n}\n\nfunction best_match(bytes, match, pos, start, min_len){\n    var nb_matches = 0,\n        best_match_length = min_len,\n        best_match = match,\n        text_length = bytes.length\n    while(match && nb_matches < 512){\n        var mpos = match.pos + min_len,\n            npos = pos + min_len,\n            match_len = min_len\n        while(++match_len < 258 && npos < text_length &&\n                bytes[mpos] == bytes[npos]){\n            mpos++\n            npos++\n        }\n        if(npos - pos > best_match_length){\n            best_match_length = npos - pos\n            best_match = match\n        }\n        if(match.previous && match.previous.pos < start){\n            match.previous = null\n        }\n        match = match.previous\n        nb_matches++\n    }\n    return {match: best_match, length: best_match_length}\n}\n\nfunction divmod(x, y){\n    return [Math.floor(x / y), x % y]\n}\n\nfunction length_to_code(length){\n    var a, b\n    if(length < 11){\n        return [254 + length, 0, 0]\n    }else if(length < 19){\n        [a, b] = divmod(length - 11, 2)\n        return [265 + a, b, 1]\n    }else if(length < 35){\n        [a, b] = divmod(length - 19, 4)\n        return [269 + a, b, 2]\n    }else if(length < 67){\n        [a, b] = divmod(length - 35, 8)\n        return [273 + a, b, 3]\n    }else if(length < 131){\n        [a, b] = divmod(length - 67, 16)\n        return [277 + a, b, 4]\n    }else if(length < 258){\n        [a, b] = divmod(length - 131, 32)\n        return [281 + a, b, 5]\n    }else if(length == 258){\n        return [285, 0, 0]\n    }\n}\n\nfunction distance_to_code(distance){\n    if(distance < 5){\n        return [distance - 1, 0, 0]\n    }else{\n        let d = distance\n        let coef = 2\n        let p = 2\n        while(2 ** (p + 1) < d){\n            p += 1\n        }\n        let d0 = 2 ** p + 1\n        let a, b\n        [a, b] = divmod(d - d0, 2 ** (p - 1))\n        return [2 * p + a, b, p - 1]\n    }\n}\n\nfunction normalized(codelengths){\n    let [car, codelength] = codelengths[0]\n    let v = 0\n    let codes = {}\n    codes[car] = [0, codelength]\n\n    for(let [newcar, nbits] of codelengths.slice(1)){\n        v += 1\n        if(nbits > codelength){\n            v <<= nbits - codelength\n            codelength = nbits\n        }\n        codes[newcar] = [v, codelength]\n    }\n    return codes\n}\n\nfunction Node(char=null, weight=0, level=0){\n    this.char = char\n    this.is_leaf = char !== null\n    this.level = level\n    this.weight = weight\n}\n\nNode.prototype.add = function(children){\n    this.children = children\n    for(let child of children){\n        child.parent = this\n        child.level = this.level + 1\n    }\n}\n\nNode.prototype.toString = function(){\n    return `<Node char=${this.char} level=${this.level} weight=${this.weight}>`\n}\n\n$B.counter = 0\n\nfunction make_tree(node, codes){\n    $B.counter++\n    if(! node.hasOwnProperty(\"parent\")){\n        node.code = ''\n    }\n    let children = []\n    let child\n    for(let bit of '01'){\n        let next_code = node.code + bit\n        if(codes.hasOwnProperty(next_code)){\n            child = new Node(codes[next_code])\n        }else{\n            child = new Node()\n        }\n        child.code = next_code\n        children.push(child)\n    }\n    node.add(children)\n    for(child of children){\n        if(! child.is_leaf){\n            make_tree(child, codes)\n        }\n    }\n}\n\nfunction _read_literal_or_length(reader, root){\n    let node = root\n\n    while(true){\n        let code = reader.read(1)\n        let child = node.children[code]\n        let length\n        if(child.is_leaf){\n            if(child.char < 256){\n                // literal\n                return [\"literal\", child.char]\n            }else if(child.char == 256){\n                return [\"eob\", _b_.None]\n            }else{\n                // length (number of bytes to copy from a previous location)\n                if(child.char < 265){\n                    length = child.char - 254\n                }else if(child.char < 269){\n                    length = 11 + 2 * (child.char - 265) + reader.read(1)\n                }else if(child.char < 273){\n                    length = 19 + 4 * (child.char - 269) + reader.read(2)\n                }else if(child.char < 277){\n                    length = 35 + 8 * (child.char - 273) + reader.read(3)\n                }else if(child.char < 281){\n                    length = 67 + 16 * (child.char - 277) + reader.read(4)\n                }else if(child.char < 285){\n                    length = 131 + 32 * (child.char - 281) + reader.read(5)\n                }else if(child.char == 285){\n                    length = 258\n                }\n                return [\"length\", length]\n            }\n        }else{\n            node = child\n        }\n    }\n}\n\nfunction read_codelengths(reader, root, num){\n    /*\n    Read the num codelengths from the bits in reader, using the Huffman\n    tree specified by root.\n    */\n    let node = root\n    let lengths = []\n    let nb = 0\n    var t = []\n    function pr(){\n        t.append(...arguments)\n    }\n    while(lengths.length < num){\n        let code = reader.read(1)\n        let child = node.children[code]\n        if(child.is_leaf){\n            if(child.char < 16){\n                lengths.push(child.char)\n            }else if(child.char == 16){\n                repeat = 3 + reader.read(2)\n                let last = lengths[lengths.length - 1]\n                lengths = lengths.concat(Array(repeat).fill(last, 0, repeat))\n            }else if(child.char == 17){\n                repeat = 3 + reader.read(3)\n                lengths = lengths.concat(Array(repeat).fill(0, 0, repeat))\n            }else if(child.char == 18){\n                repeat = 11 + reader.read(7)\n                lengths = lengths.concat(Array(repeat).fill(0, 0, repeat))\n            }\n            node = root\n        }else{\n            node = child\n        }\n    }\n    return lengths\n}\n\nfunction _read_distance(reader, root){\n    // Read distance value.\n    let node = root\n\n    while(true){\n        let code = reader.read(1)\n        let child = node.children[code]\n        if(child.is_leaf){\n            let dist_code = child.char\n            let distance\n            if(dist_code < 3){\n                distance = dist_code + 1\n            }else{\n                let nb = Math.floor(dist_code / 2) - 1\n                let extra = reader.read(nb);\n                let [half, delta] = divmod(dist_code, 2)\n                distance = 1 + (2 ** half) + delta * (2 ** (half - 1)) + extra\n            }\n            return distance\n        }else{\n            node = child\n        }\n    }\n}\n\nfunction _decomp_dynamic(reader, result){\n    let [lit_len_tree, distance_tree] = _dynamic_trees(reader)\n    var start_index = reader.index\n    var start_position = reader.position\n    var len = 0\n    while(true){\n        // read a literal or length\n        let [_type, value] = _read_literal_or_length(reader, lit_len_tree)\n        if(_type == 'eob'){\n            break\n        }else if(_type == 'literal'){\n            result.push(value)\n            len++\n        }else if(_type == 'length'){\n            // read a distance\n            let length = value\n            let distance = _read_distance(reader, distance_tree)\n            for(var i = 0; i < length; i++){\n                result.push(result[result.length - distance])\n            }\n            len += length\n        }\n    }\n    if(0){\n        console.log('bits read', 8 * (reader.index - start_index) + reader.position - start_position)\n        console.log('decoded length', len)\n    }\n    return $B.$list(result)\n}\n\nfunction pprint(x){\n    if(Array.isArray(x)){\n        var t = []\n        for(var item of x){\n            t.push(pprint(item))\n        }\n        return `[${t.join(', ')}]`\n    }else{\n        return x\n    }\n}\n\nfunction _decompresser(codelengths){\n    let lengths = []\n    if($B.$isinstance(codelengths, _b_.dict)){\n        for(var entry of _b_.dict.$iter_items(codelengths)){\n            lengths.push([entry.key, entry.value])\n        }\n    }else{\n        for(var [key, value] of Object.entries(codelengths)){\n            lengths.push([parseInt(key), value])\n        }\n    }\n    // remove items with value = 0\n    lengths = lengths.filter(x => x[1] > 0)\n    // sort by second item, then first item\n    lengths.sort(function(a, b){\n        if(a[1] < b[1]){\n            return -1\n        }else if(a[1] == b[1]){\n            return a[0] < b[0] ? -1 :\n                   a[0] == b[0] ? 0 : 1\n        }else{\n            return 1\n        }\n    })\n    let codes1 = normalized(lengths)\n    let codes2 = {}\n    for(var key in codes1){\n        let [value, length] = codes1[key]\n        let b = value.toString(2)\n        codes2[\"0\".repeat(length - b.length) + b] = parseInt(key)\n    }\n    let root = new Node()\n    make_tree(root, codes2)\n    return {root, codes: codes2}\n}\n\nfunction tree_from_codelengths(codelengths){\n    return _decompresser(codelengths)[\"root\"]\n}\n\nfunction* range(start, stop){\n    if(stop === undefined){\n        stop = start\n        start = 0\n    }\n    for(var i = start; i < stop; i++){\n        yield i\n    }\n}\n\nlet fixed_codelengths = {}\nfor(let car of range(144)){\n    fixed_codelengths[car] = 8\n}\nfor(let car of range(144, 256)){\n    fixed_codelengths[car] = 9\n}\nfor(let car of range(256, 280)){\n    fixed_codelengths[car] = 7\n}\nfor(let car of range(280, 288)){\n    fixed_codelengths[car] = 8\n}\n\nlet fixed_decomp = _decompresser(fixed_codelengths)\nvar fixed_lit_len_tree = fixed_decomp[\"root\"]\n\nfunction _decomp_fixed(reader){\n    let root = fixed_lit_len_tree\n    let result = []\n\n    while(true){\n        // read a literal or length\n        let [_type, value] = _read_literal_or_length(reader, root)\n        if(_type == 'eob'){\n            break\n        }else if(_type == 'literal'){\n            result.push(value)\n        }else if(_type == 'length'){\n            let length = value\n            // next five bits are the distance code\n            let dist_code = reader.read(5, \"msf\"),\n                distance\n            if(dist_code < 3){\n                distance = dist_code + 1\n            }else{\n                let nb = Math.floor(dist_code / 2) - 1\n                let extra = reader.read(nb)\n                let [half, delta] = divmod(dist_code, 2)\n                distance = (1 + (2 ** half) +\n                    delta * (2 ** (half - 1)) + extra)\n            }\n            for(var i = 0; i < length; i++){\n                result.push(result[result.length - distance])\n            }\n            node = root\n        }else{\n            node = child\n        }\n    }\n    return result\n}\n\nfunction _dynamic_trees(reader){\n    /*\n    reader is at the beginning of the dynamic Huffman tree.\n    We have to get the code length for values from 0 to 287 included.\n    */\n    let HLIT = reader.read(5)\n    let HDIST = reader.read(5)\n    let HCLEN = reader.read(4)\n    // read codes for lengths\n    let alphabet = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2,\n                    14, 1, 15]\n    let clen = {}\n    let c = []\n    for(var j = 0, len = HCLEN + 4; j < len; j++){\n        let length = alphabet[j]\n        c.push(reader.read(3))\n        clen[length] = c[c.length - 1]\n    }\n\n    // tree used to decode code lengths\n    let clen_root = tree_from_codelengths(clen)\n\n    // code lengths for the literal / length alphabet\n    let lit_len_array = read_codelengths(reader, clen_root, HLIT + 257)\n    let lit_len = {}\n    for(var i = 0, len = lit_len_array.length; i < len; i++){\n        lit_len[i] = lit_len_array[i]\n    }\n    let lit_len_tree = tree_from_codelengths(lit_len)\n\n    // code lengths for the distances alphabet\n    let distances_array = read_codelengths(reader, clen_root, HDIST + 1)\n    let distances = {}\n    for(var i = 0, len = distances_array.length; i < len; i++){\n        distances[i] = distances_array[i]\n    }\n    let distances_tree = tree_from_codelengths(distances)\n\n    return [lit_len_tree, distances_tree]\n}\n\nfunction _write_items(writer, store, lit_len_dict, distance_dict){\n    var lit_len_codes = {}\n    for(var entry of _b_.dict.$iter_items(lit_len_dict)){\n        lit_len_codes[entry.key] = entry.value\n    }\n    var distance_codes = {}\n    for(var entry of _b_.dict.$iter_items(distance_dict)){\n        distance_codes[entry.key] = entry.value\n    }\n    var value,\n        nb,\n        length, extra_length, distance, extra_distance,\n        lit_len,\n        dist\n    for(let item of store){\n        if(Array.isArray(item)){\n            [length, extra_length, distance, extra_distance] = item\n            // Length code\n            lit_len = lit_len_codes[length]; // semicolon required !\n                // otherwise the destructuring assignment below is\n                // interpreted as a subscription...\n            [value, nb] = lit_len\n            writer.writeInt(value, nb, 'msf');\n            // Extra bits for length\n            [value, nb] = extra_length\n            if(nb > 0){\n                writer.writeInt(value, nb)\n            };\n            // Distance code\n            [value, nb] = distance_codes[distance]\n            writer.writeInt(value, nb, 'msf');\n            // Extra bits for distance\n            [value, nb] = extra_distance\n            if(nb > 0){\n                writer.writeInt(value, nb)\n            }\n        }else{\n            [value, nb] = lit_len_codes[item]\n            writer.writeInt(value, nb, 'msf')\n        }\n    }\n}\n\nfunction record(is_final, store, lit_len_count, distance_count, replaced, nb_tuples){\n    // Transform JS results into Python structures used in zlib.py\n    // mark block end\n    store.push(256)\n\n    // transform to Python structures for zlib.py\n    let lit_len_dict = $B.empty_dict()\n    for(let key in lit_len_count){\n        _b_.dict.$setitem(lit_len_dict, parseInt(key), lit_len_count[key])\n    }\n    let distance_dict = $B.empty_dict()\n    for(let key in distance_count){\n        _b_.dict.$setitem(distance_dict, parseInt(key), distance_count[key])\n    }\n\n    return [is_final, $B.$list(store), lit_len_dict, distance_dict, replaced,\n        nb_tuples]\n}\n\nfunction* lz_generator(text, size){\n    /*\n    Apply the LZ algorithm to the text with the specified window size.\n\n    'text' is an instance of Python 'bytes' class, the actual bytes are in\n    text.source.\n\n    Returns a list of:\n    - store : the list of items produced by the LZ algorithm (bytes, or\n      length / distance information), ended by byte 256\n    - a dictionary mapping literal or length code to their number of\n      occurrences\n    - a dictionary mapping distance code to its number of occurrences\n    - the sum of lengths of text parts replaced by a (length, distance)\n    */\n    var bytes = new Uint8Array(text.source)\n    var text_length = bytes.length\n    var min_len = 3\n    var lit_len_count = {}\n    var distance_count = {}\n    var store = []\n    var replaced = 0\n    var nb_tuples = 0\n    var pos = 0, // position in text\n        start,\n        h,\n        hashes = {}\n    var nb_blocks = 0\n    var deflate_block_size = (1 << 14) - 1\n    var deflate_block_limit = deflate_block_size\n    var is_final\n\n    function store_literal(lit){\n        lit_len_count[lit] = (lit_len_count[lit] ?? 0) + 1\n        store.push(lit)\n    }\n\n    function store_length_distance(length, distance){\n        replaced += length\n        nb_tuples += 1\n        let lcode = length_to_code(length)\n        let length_code = lcode[0]\n        let extra_length = lcode.slice(1)\n        lit_len_count[length_code] = (lit_len_count[length_code] ?? 0) + 1\n        let dcode = distance_to_code(distance)\n        let distance_code = dcode[0]\n        let extra_dist = dcode.slice(1)\n        // Increment distances counter\n        distance_count[distance_code] =\n            (distance_count[distance_code] ?? 0) + 1\n        // Add to store for use in next steps\n        store.push($B.fast_tuple([length_code, extra_length, distance_code,\n                      extra_dist]))\n    }\n\n    var t0 = globalThis.performance.now()\n    while(pos < text_length){\n        if(pos > text_length - min_len){\n            // Last items in text\n            for(var i = pos; i < text_length; i++){\n                store_literal(bytes[i])\n            }\n            break\n        }\n        // Search the sequence in the 'size' previous bytes\n        start = Math.max(0, pos - size)\n        h = bytes[pos] + (bytes[pos + 1] << 8) + (bytes[pos + 2] << 16)\n        if((! hashes[h]) || hashes[h].pos < start){\n            // Not found, or too far back : emit a byte\n            hashes[h] = {pos, previous: null}\n            store_literal(bytes[pos])\n            pos += 1\n        }else{\n            var match = hashes[h]\n            var best = best_match(bytes, match, pos, start, min_len)\n            // Lazy matching: if there is a match at position pos + 1\n            // and its length is at least 1 byte longer than the match at\n            // pos, it is more efficient to emit the byte at pos and\n            // emit [length, distance] for the match at pos + 1\n            var next_h = bytes[pos + 1] + (bytes[pos + 2] << 8) +\n                    (bytes[pos + 3] << 16)\n            var next_match = hashes[next_h]\n            if(next_match && next_match.pos > start + 1){\n                var next_best = best_match(bytes, next_match, pos + 1,\n                        start + 1, min_len)\n                if(next_best.length > best.length + 1){\n                    // emit current byte\n                    store_literal(bytes[pos])\n                    hashes[h] = {pos, previous: hashes[h]}\n                    // use the match at pos + 1\n                    pos += 1\n                    best = next_best\n                    h = next_h\n                }\n            }\n            var distance = pos - best.match.pos\n            store_length_distance(best.length, distance)\n            // store hashes at positions between pos + 1 and next pos\n            for(var i = 1; i < best.length; i++){\n                var ih = bytes[pos + i] + (bytes[pos + i + 1] << 8) +\n                         (bytes[pos + i + 2] << 16)\n                if(hashes[ih] && hashes[ih].pos > start){\n                    hashes[ih] = {pos: pos + i, previous: hashes[ih]}\n                }else{\n                    hashes[ih] =  {pos: pos + i, previous: null}\n                }\n            }\n            hashes[h] = {pos, previous: hashes[h]}\n            pos += best.length\n        }\n        if(store.length > deflate_block_limit){\n            is_final = pos == text.length - 1\n            yield record(is_final, store, lit_len_count, distance_count, replaced,\n                nb_tuples)\n            store = []\n            lit_len_count = {}\n            distance_count = {}\n            replaced = 0\n            nb_tuples = 0\n            nb_blocks++\n            deflate_block_limit = deflate_block_size * nb_blocks\n        }\n    }\n    if(store.length > 0){\n        is_final = 1\n        yield record(is_final, store, lit_len_count, distance_count, replaced,\n                nb_tuples)\n    }\n}\n\nvar mod = {\n    adler32: function(bytes, a, b){\n        var adler = {a: a ?? 1, b: b ?? 0}\n        for(var b of bytes.source){\n            adler.a += b\n            adler.a %= 65521\n            adler.b += adler.a\n            adler.b %= 65521\n        }\n        return adler\n    },\n    BitReader,\n    BitWriter,\n    crc32: function(bytes, crc) {\n        var crc = crc ^ (-1)\n\n        for (var byte of bytes.source) {\n            crc = (crc >>> 8) ^ crcTable[(crc ^ byte) & 0xFF]\n        }\n\n        return (crc ^ (-1)) >>> 0\n    },\n    lz_generator,\n    _decomp_dynamic,\n    _decomp_fixed,\n    _decompresser,\n    _dynamic_trees,\n    _write_items\n}\n\n$B.addToImported('_zlib_utils', mod)\n\n})(__BRYTHON__)\n"], "crypto_js": [".py", "", [], 1], "crypto_js.rollups": [".py", "", [], 1], "crypto_js.rollups.md5": [".js", "/*\nCryptoJS v3.1.2\ncode.google.com/p/crypto-js\n(c) 2009-2013 by Jeff Mott. All rights reserved.\ncode.google.com/p/crypto-js/wiki/License\n*/\nvar CryptoJS=CryptoJS||function(s,p){var m={},l=m.lib={},n=function(){},r=l.Base={extend:function(b){n.prototype=this;var h=new n;b&&h.mixIn(b);h.hasOwnProperty(\"init\")||(h.init=function(){h.$super.init.apply(this,arguments)});h.init.prototype=h;h.$super=this;return h},create:function(){var b=this.extend();b.init.apply(b,arguments);return b},init:function(){},mixIn:function(b){for(var h in b)b.hasOwnProperty(h)&&(this[h]=b[h]);b.hasOwnProperty(\"toString\")&&(this.toString=b.toString)},clone:function(){return this.init.prototype.extend(this)}},\nq=l.WordArray=r.extend({init:function(b,h){b=this.words=b||[];this.sigBytes=h!=p?h:4*b.length},toString:function(b){return(b||t).stringify(this)},concat:function(b){var h=this.words,a=b.words,j=this.sigBytes;b=b.sigBytes;this.clamp();if(j%4)for(var g=0;g<b;g++)h[j+g>>>2]|=(a[g>>>2]>>>24-8*(g%4)&255)<<24-8*((j+g)%4);else if(65535<a.length)for(g=0;g<b;g+=4)h[j+g>>>2]=a[g>>>2];else h.push.apply(h,a);this.sigBytes+=b;return this},clamp:function(){var b=this.words,h=this.sigBytes;b[h>>>2]&=4294967295<<\n32-8*(h%4);b.length=s.ceil(h/4)},clone:function(){var b=r.clone.call(this);b.words=this.words.slice(0);return b},random:function(b){for(var h=[],a=0;a<b;a+=4)h.push(4294967296*s.random()|0);return new q.init(h,b)}}),v=m.enc={},t=v.Hex={stringify:function(b){var a=b.words;b=b.sigBytes;for(var g=[],j=0;j<b;j++){var k=a[j>>>2]>>>24-8*(j%4)&255;g.push((k>>>4).toString(16));g.push((k&15).toString(16))}return g.join(\"\")},parse:function(b){for(var a=b.length,g=[],j=0;j<a;j+=2)g[j>>>3]|=parseInt(b.substr(j,\n2),16)<<24-4*(j%8);return new q.init(g,a/2)}},a=v.Latin1={stringify:function(b){var a=b.words;b=b.sigBytes;for(var g=[],j=0;j<b;j++)g.push(String.fromCharCode(a[j>>>2]>>>24-8*(j%4)&255));return g.join(\"\")},parse:function(b){for(var a=b.length,g=[],j=0;j<a;j++)g[j>>>2]|=(b.charCodeAt(j)&255)<<24-8*(j%4);return new q.init(g,a)}},u=v.Utf8={stringify:function(b){try{return decodeURIComponent(escape(a.stringify(b)))}catch(g){throw Error(\"Malformed UTF-8 data\");}},parse:function(b){return a.parse(unescape(encodeURIComponent(b)))}},\ng=l.BufferedBlockAlgorithm=r.extend({reset:function(){this._data=new q.init;this._nDataBytes=0},_append:function(b){\"string\"==typeof b&&(b=u.parse(b));this._data.concat(b);this._nDataBytes+=b.sigBytes},_process:function(b){var a=this._data,g=a.words,j=a.sigBytes,k=this.blockSize,m=j/(4*k),m=b?s.ceil(m):s.max((m|0)-this._minBufferSize,0);b=m*k;j=s.min(4*b,j);if(b){for(var l=0;l<b;l+=k)this._doProcessBlock(g,l);l=g.splice(0,b);a.sigBytes-=j}return new q.init(l,j)},clone:function(){var b=r.clone.call(this);\nb._data=this._data.clone();return b},_minBufferSize:0});l.Hasher=g.extend({cfg:r.extend(),init:function(b){this.cfg=this.cfg.extend(b);this.reset()},reset:function(){g.reset.call(this);this._doReset()},update:function(b){this._append(b);this._process();return this},finalize:function(b){b&&this._append(b);return this._doFinalize()},blockSize:16,_createHelper:function(b){return function(a,g){return(new b.init(g)).finalize(a)}},_createHmacHelper:function(b){return function(a,g){return(new k.HMAC.init(b,\ng)).finalize(a)}}});var k=m.algo={};return m}(Math);\n(function(s){function p(a,k,b,h,l,j,m){a=a+(k&b|~k&h)+l+m;return(a<<j|a>>>32-j)+k}function m(a,k,b,h,l,j,m){a=a+(k&h|b&~h)+l+m;return(a<<j|a>>>32-j)+k}function l(a,k,b,h,l,j,m){a=a+(k^b^h)+l+m;return(a<<j|a>>>32-j)+k}function n(a,k,b,h,l,j,m){a=a+(b^(k|~h))+l+m;return(a<<j|a>>>32-j)+k}for(var r=CryptoJS,q=r.lib,v=q.WordArray,t=q.Hasher,q=r.algo,a=[],u=0;64>u;u++)a[u]=4294967296*s.abs(s.sin(u+1))|0;q=q.MD5=t.extend({_doReset:function(){this._hash=new v.init([1732584193,4023233417,2562383102,271733878])},\n_doProcessBlock:function(g,k){for(var b=0;16>b;b++){var h=k+b,w=g[h];g[h]=(w<<8|w>>>24)&16711935|(w<<24|w>>>8)&4278255360}var b=this._hash.words,h=g[k+0],w=g[k+1],j=g[k+2],q=g[k+3],r=g[k+4],s=g[k+5],t=g[k+6],u=g[k+7],v=g[k+8],x=g[k+9],y=g[k+10],z=g[k+11],A=g[k+12],B=g[k+13],C=g[k+14],D=g[k+15],c=b[0],d=b[1],e=b[2],f=b[3],c=p(c,d,e,f,h,7,a[0]),f=p(f,c,d,e,w,12,a[1]),e=p(e,f,c,d,j,17,a[2]),d=p(d,e,f,c,q,22,a[3]),c=p(c,d,e,f,r,7,a[4]),f=p(f,c,d,e,s,12,a[5]),e=p(e,f,c,d,t,17,a[6]),d=p(d,e,f,c,u,22,a[7]),\nc=p(c,d,e,f,v,7,a[8]),f=p(f,c,d,e,x,12,a[9]),e=p(e,f,c,d,y,17,a[10]),d=p(d,e,f,c,z,22,a[11]),c=p(c,d,e,f,A,7,a[12]),f=p(f,c,d,e,B,12,a[13]),e=p(e,f,c,d,C,17,a[14]),d=p(d,e,f,c,D,22,a[15]),c=m(c,d,e,f,w,5,a[16]),f=m(f,c,d,e,t,9,a[17]),e=m(e,f,c,d,z,14,a[18]),d=m(d,e,f,c,h,20,a[19]),c=m(c,d,e,f,s,5,a[20]),f=m(f,c,d,e,y,9,a[21]),e=m(e,f,c,d,D,14,a[22]),d=m(d,e,f,c,r,20,a[23]),c=m(c,d,e,f,x,5,a[24]),f=m(f,c,d,e,C,9,a[25]),e=m(e,f,c,d,q,14,a[26]),d=m(d,e,f,c,v,20,a[27]),c=m(c,d,e,f,B,5,a[28]),f=m(f,c,\nd,e,j,9,a[29]),e=m(e,f,c,d,u,14,a[30]),d=m(d,e,f,c,A,20,a[31]),c=l(c,d,e,f,s,4,a[32]),f=l(f,c,d,e,v,11,a[33]),e=l(e,f,c,d,z,16,a[34]),d=l(d,e,f,c,C,23,a[35]),c=l(c,d,e,f,w,4,a[36]),f=l(f,c,d,e,r,11,a[37]),e=l(e,f,c,d,u,16,a[38]),d=l(d,e,f,c,y,23,a[39]),c=l(c,d,e,f,B,4,a[40]),f=l(f,c,d,e,h,11,a[41]),e=l(e,f,c,d,q,16,a[42]),d=l(d,e,f,c,t,23,a[43]),c=l(c,d,e,f,x,4,a[44]),f=l(f,c,d,e,A,11,a[45]),e=l(e,f,c,d,D,16,a[46]),d=l(d,e,f,c,j,23,a[47]),c=n(c,d,e,f,h,6,a[48]),f=n(f,c,d,e,u,10,a[49]),e=n(e,f,c,d,\nC,15,a[50]),d=n(d,e,f,c,s,21,a[51]),c=n(c,d,e,f,A,6,a[52]),f=n(f,c,d,e,q,10,a[53]),e=n(e,f,c,d,y,15,a[54]),d=n(d,e,f,c,w,21,a[55]),c=n(c,d,e,f,v,6,a[56]),f=n(f,c,d,e,D,10,a[57]),e=n(e,f,c,d,t,15,a[58]),d=n(d,e,f,c,B,21,a[59]),c=n(c,d,e,f,r,6,a[60]),f=n(f,c,d,e,z,10,a[61]),e=n(e,f,c,d,j,15,a[62]),d=n(d,e,f,c,x,21,a[63]);b[0]=b[0]+c|0;b[1]=b[1]+d|0;b[2]=b[2]+e|0;b[3]=b[3]+f|0},_doFinalize:function(){var a=this._data,k=a.words,b=8*this._nDataBytes,h=8*a.sigBytes;k[h>>>5]|=128<<24-h%32;var l=s.floor(b/\n4294967296);k[(h+64>>>9<<4)+15]=(l<<8|l>>>24)&16711935|(l<<24|l>>>8)&4278255360;k[(h+64>>>9<<4)+14]=(b<<8|b>>>24)&16711935|(b<<24|b>>>8)&4278255360;a.sigBytes=4*(k.length+1);this._process();a=this._hash;k=a.words;for(b=0;4>b;b++)h=k[b],k[b]=(h<<8|h>>>24)&16711935|(h<<24|h>>>8)&4278255360;return a},clone:function(){var a=t.clone.call(this);a._hash=this._hash.clone();return a}});r.MD5=t._createHelper(q);r.HmacMD5=t._createHmacHelper(q)})(Math);\n"], "crypto_js.rollups.sha1": [".js", "/*\nCryptoJS v3.1.2\ncode.google.com/p/crypto-js\n(c) 2009-2013 by Jeff Mott. All rights reserved.\ncode.google.com/p/crypto-js/wiki/License\n*/\nvar CryptoJS=CryptoJS||function(e,m){var p={},j=p.lib={},l=function(){},f=j.Base={extend:function(a){l.prototype=this;var c=new l;a&&c.mixIn(a);c.hasOwnProperty(\"init\")||(c.init=function(){c.$super.init.apply(this,arguments)});c.init.prototype=c;c.$super=this;return c},create:function(){var a=this.extend();a.init.apply(a,arguments);return a},init:function(){},mixIn:function(a){for(var c in a)a.hasOwnProperty(c)&&(this[c]=a[c]);a.hasOwnProperty(\"toString\")&&(this.toString=a.toString)},clone:function(){return this.init.prototype.extend(this)}},\nn=j.WordArray=f.extend({init:function(a,c){a=this.words=a||[];this.sigBytes=c!=m?c:4*a.length},toString:function(a){return(a||h).stringify(this)},concat:function(a){var c=this.words,q=a.words,d=this.sigBytes;a=a.sigBytes;this.clamp();if(d%4)for(var b=0;b<a;b++)c[d+b>>>2]|=(q[b>>>2]>>>24-8*(b%4)&255)<<24-8*((d+b)%4);else if(65535<q.length)for(b=0;b<a;b+=4)c[d+b>>>2]=q[b>>>2];else c.push.apply(c,q);this.sigBytes+=a;return this},clamp:function(){var a=this.words,c=this.sigBytes;a[c>>>2]&=4294967295<<\n32-8*(c%4);a.length=e.ceil(c/4)},clone:function(){var a=f.clone.call(this);a.words=this.words.slice(0);return a},random:function(a){for(var c=[],b=0;b<a;b+=4)c.push(4294967296*e.random()|0);return new n.init(c,a)}}),b=p.enc={},h=b.Hex={stringify:function(a){var c=a.words;a=a.sigBytes;for(var b=[],d=0;d<a;d++){var f=c[d>>>2]>>>24-8*(d%4)&255;b.push((f>>>4).toString(16));b.push((f&15).toString(16))}return b.join(\"\")},parse:function(a){for(var c=a.length,b=[],d=0;d<c;d+=2)b[d>>>3]|=parseInt(a.substr(d,\n2),16)<<24-4*(d%8);return new n.init(b,c/2)}},g=b.Latin1={stringify:function(a){var c=a.words;a=a.sigBytes;for(var b=[],d=0;d<a;d++)b.push(String.fromCharCode(c[d>>>2]>>>24-8*(d%4)&255));return b.join(\"\")},parse:function(a){for(var c=a.length,b=[],d=0;d<c;d++)b[d>>>2]|=(a.charCodeAt(d)&255)<<24-8*(d%4);return new n.init(b,c)}},r=b.Utf8={stringify:function(a){try{return decodeURIComponent(escape(g.stringify(a)))}catch(c){throw Error(\"Malformed UTF-8 data\");}},parse:function(a){return g.parse(unescape(encodeURIComponent(a)))}},\nk=j.BufferedBlockAlgorithm=f.extend({reset:function(){this._data=new n.init;this._nDataBytes=0},_append:function(a){\"string\"==typeof a&&(a=r.parse(a));this._data.concat(a);this._nDataBytes+=a.sigBytes},_process:function(a){var c=this._data,b=c.words,d=c.sigBytes,f=this.blockSize,h=d/(4*f),h=a?e.ceil(h):e.max((h|0)-this._minBufferSize,0);a=h*f;d=e.min(4*a,d);if(a){for(var g=0;g<a;g+=f)this._doProcessBlock(b,g);g=b.splice(0,a);c.sigBytes-=d}return new n.init(g,d)},clone:function(){var a=f.clone.call(this);\na._data=this._data.clone();return a},_minBufferSize:0});j.Hasher=k.extend({cfg:f.extend(),init:function(a){this.cfg=this.cfg.extend(a);this.reset()},reset:function(){k.reset.call(this);this._doReset()},update:function(a){this._append(a);this._process();return this},finalize:function(a){a&&this._append(a);return this._doFinalize()},blockSize:16,_createHelper:function(a){return function(c,b){return(new a.init(b)).finalize(c)}},_createHmacHelper:function(a){return function(b,f){return(new s.HMAC.init(a,\nf)).finalize(b)}}});var s=p.algo={};return p}(Math);\n(function(){var e=CryptoJS,m=e.lib,p=m.WordArray,j=m.Hasher,l=[],m=e.algo.SHA1=j.extend({_doReset:function(){this._hash=new p.init([1732584193,4023233417,2562383102,271733878,3285377520])},_doProcessBlock:function(f,n){for(var b=this._hash.words,h=b[0],g=b[1],e=b[2],k=b[3],j=b[4],a=0;80>a;a++){if(16>a)l[a]=f[n+a]|0;else{var c=l[a-3]^l[a-8]^l[a-14]^l[a-16];l[a]=c<<1|c>>>31}c=(h<<5|h>>>27)+j+l[a];c=20>a?c+((g&e|~g&k)+1518500249):40>a?c+((g^e^k)+1859775393):60>a?c+((g&e|g&k|e&k)-1894007588):c+((g^e^\nk)-899497514);j=k;k=e;e=g<<30|g>>>2;g=h;h=c}b[0]=b[0]+h|0;b[1]=b[1]+g|0;b[2]=b[2]+e|0;b[3]=b[3]+k|0;b[4]=b[4]+j|0},_doFinalize:function(){var f=this._data,e=f.words,b=8*this._nDataBytes,h=8*f.sigBytes;e[h>>>5]|=128<<24-h%32;e[(h+64>>>9<<4)+14]=Math.floor(b/4294967296);e[(h+64>>>9<<4)+15]=b;f.sigBytes=4*e.length;this._process();return this._hash},clone:function(){var e=j.clone.call(this);e._hash=this._hash.clone();return e}});e.SHA1=j._createHelper(m);e.HmacSHA1=j._createHmacHelper(m)})();\n"], "crypto_js.rollups.sha224": [".js", "/*\nCryptoJS v3.1.2\ncode.google.com/p/crypto-js\n(c) 2009-2013 by Jeff Mott. All rights reserved.\ncode.google.com/p/crypto-js/wiki/License\n*/\nvar CryptoJS=CryptoJS||function(g,l){var f={},k=f.lib={},h=function(){},m=k.Base={extend:function(a){h.prototype=this;var c=new h;a&&c.mixIn(a);c.hasOwnProperty(\"init\")||(c.init=function(){c.$super.init.apply(this,arguments)});c.init.prototype=c;c.$super=this;return c},create:function(){var a=this.extend();a.init.apply(a,arguments);return a},init:function(){},mixIn:function(a){for(var c in a)a.hasOwnProperty(c)&&(this[c]=a[c]);a.hasOwnProperty(\"toString\")&&(this.toString=a.toString)},clone:function(){return this.init.prototype.extend(this)}},\nq=k.WordArray=m.extend({init:function(a,c){a=this.words=a||[];this.sigBytes=c!=l?c:4*a.length},toString:function(a){return(a||s).stringify(this)},concat:function(a){var c=this.words,d=a.words,b=this.sigBytes;a=a.sigBytes;this.clamp();if(b%4)for(var e=0;e<a;e++)c[b+e>>>2]|=(d[e>>>2]>>>24-8*(e%4)&255)<<24-8*((b+e)%4);else if(65535<d.length)for(e=0;e<a;e+=4)c[b+e>>>2]=d[e>>>2];else c.push.apply(c,d);this.sigBytes+=a;return this},clamp:function(){var a=this.words,c=this.sigBytes;a[c>>>2]&=4294967295<<\n32-8*(c%4);a.length=g.ceil(c/4)},clone:function(){var a=m.clone.call(this);a.words=this.words.slice(0);return a},random:function(a){for(var c=[],d=0;d<a;d+=4)c.push(4294967296*g.random()|0);return new q.init(c,a)}}),t=f.enc={},s=t.Hex={stringify:function(a){var c=a.words;a=a.sigBytes;for(var d=[],b=0;b<a;b++){var e=c[b>>>2]>>>24-8*(b%4)&255;d.push((e>>>4).toString(16));d.push((e&15).toString(16))}return d.join(\"\")},parse:function(a){for(var c=a.length,d=[],b=0;b<c;b+=2)d[b>>>3]|=parseInt(a.substr(b,\n2),16)<<24-4*(b%8);return new q.init(d,c/2)}},n=t.Latin1={stringify:function(a){var c=a.words;a=a.sigBytes;for(var d=[],b=0;b<a;b++)d.push(String.fromCharCode(c[b>>>2]>>>24-8*(b%4)&255));return d.join(\"\")},parse:function(a){for(var c=a.length,d=[],b=0;b<c;b++)d[b>>>2]|=(a.charCodeAt(b)&255)<<24-8*(b%4);return new q.init(d,c)}},j=t.Utf8={stringify:function(a){try{return decodeURIComponent(escape(n.stringify(a)))}catch(c){throw Error(\"Malformed UTF-8 data\");}},parse:function(a){return n.parse(unescape(encodeURIComponent(a)))}},\nw=k.BufferedBlockAlgorithm=m.extend({reset:function(){this._data=new q.init;this._nDataBytes=0},_append:function(a){\"string\"==typeof a&&(a=j.parse(a));this._data.concat(a);this._nDataBytes+=a.sigBytes},_process:function(a){var c=this._data,d=c.words,b=c.sigBytes,e=this.blockSize,f=b/(4*e),f=a?g.ceil(f):g.max((f|0)-this._minBufferSize,0);a=f*e;b=g.min(4*a,b);if(a){for(var u=0;u<a;u+=e)this._doProcessBlock(d,u);u=d.splice(0,a);c.sigBytes-=b}return new q.init(u,b)},clone:function(){var a=m.clone.call(this);\na._data=this._data.clone();return a},_minBufferSize:0});k.Hasher=w.extend({cfg:m.extend(),init:function(a){this.cfg=this.cfg.extend(a);this.reset()},reset:function(){w.reset.call(this);this._doReset()},update:function(a){this._append(a);this._process();return this},finalize:function(a){a&&this._append(a);return this._doFinalize()},blockSize:16,_createHelper:function(a){return function(c,d){return(new a.init(d)).finalize(c)}},_createHmacHelper:function(a){return function(c,d){return(new v.HMAC.init(a,\nd)).finalize(c)}}});var v=f.algo={};return f}(Math);\n(function(g){for(var l=CryptoJS,f=l.lib,k=f.WordArray,h=f.Hasher,f=l.algo,m=[],q=[],t=function(a){return 4294967296*(a-(a|0))|0},s=2,n=0;64>n;){var j;a:{j=s;for(var w=g.sqrt(j),v=2;v<=w;v++)if(!(j%v)){j=!1;break a}j=!0}j&&(8>n&&(m[n]=t(g.pow(s,0.5))),q[n]=t(g.pow(s,1/3)),n++);s++}var a=[],f=f.SHA256=h.extend({_doReset:function(){this._hash=new k.init(m.slice(0))},_doProcessBlock:function(c,d){for(var b=this._hash.words,e=b[0],f=b[1],g=b[2],k=b[3],h=b[4],l=b[5],m=b[6],n=b[7],p=0;64>p;p++){if(16>p)a[p]=\nc[d+p]|0;else{var j=a[p-15],r=a[p-2];a[p]=((j<<25|j>>>7)^(j<<14|j>>>18)^j>>>3)+a[p-7]+((r<<15|r>>>17)^(r<<13|r>>>19)^r>>>10)+a[p-16]}j=n+((h<<26|h>>>6)^(h<<21|h>>>11)^(h<<7|h>>>25))+(h&l^~h&m)+q[p]+a[p];r=((e<<30|e>>>2)^(e<<19|e>>>13)^(e<<10|e>>>22))+(e&f^e&g^f&g);n=m;m=l;l=h;h=k+j|0;k=g;g=f;f=e;e=j+r|0}b[0]=b[0]+e|0;b[1]=b[1]+f|0;b[2]=b[2]+g|0;b[3]=b[3]+k|0;b[4]=b[4]+h|0;b[5]=b[5]+l|0;b[6]=b[6]+m|0;b[7]=b[7]+n|0},_doFinalize:function(){var a=this._data,d=a.words,b=8*this._nDataBytes,e=8*a.sigBytes;\nd[e>>>5]|=128<<24-e%32;d[(e+64>>>9<<4)+14]=g.floor(b/4294967296);d[(e+64>>>9<<4)+15]=b;a.sigBytes=4*d.length;this._process();return this._hash},clone:function(){var a=h.clone.call(this);a._hash=this._hash.clone();return a}});l.SHA256=h._createHelper(f);l.HmacSHA256=h._createHmacHelper(f)})(Math);\n(function(){var g=CryptoJS,l=g.lib.WordArray,f=g.algo,k=f.SHA256,f=f.SHA224=k.extend({_doReset:function(){this._hash=new l.init([3238371032,914150663,812702999,4144912697,4290775857,1750603025,1694076839,3204075428])},_doFinalize:function(){var f=k._doFinalize.call(this);f.sigBytes-=4;return f}});g.SHA224=k._createHelper(f);g.HmacSHA224=k._createHmacHelper(f)})();\n"], "crypto_js.rollups.sha256": [".js", "/*\nCryptoJS v3.1.2\ncode.google.com/p/crypto-js\n(c) 2009-2013 by Jeff Mott. All rights reserved.\ncode.google.com/p/crypto-js/wiki/License\n*/\nvar CryptoJS=CryptoJS||function(h,s){var f={},t=f.lib={},g=function(){},j=t.Base={extend:function(a){g.prototype=this;var c=new g;a&&c.mixIn(a);c.hasOwnProperty(\"init\")||(c.init=function(){c.$super.init.apply(this,arguments)});c.init.prototype=c;c.$super=this;return c},create:function(){var a=this.extend();a.init.apply(a,arguments);return a},init:function(){},mixIn:function(a){for(var c in a)a.hasOwnProperty(c)&&(this[c]=a[c]);a.hasOwnProperty(\"toString\")&&(this.toString=a.toString)},clone:function(){return this.init.prototype.extend(this)}},\nq=t.WordArray=j.extend({init:function(a,c){a=this.words=a||[];this.sigBytes=c!=s?c:4*a.length},toString:function(a){return(a||u).stringify(this)},concat:function(a){var c=this.words,d=a.words,b=this.sigBytes;a=a.sigBytes;this.clamp();if(b%4)for(var e=0;e<a;e++)c[b+e>>>2]|=(d[e>>>2]>>>24-8*(e%4)&255)<<24-8*((b+e)%4);else if(65535<d.length)for(e=0;e<a;e+=4)c[b+e>>>2]=d[e>>>2];else c.push.apply(c,d);this.sigBytes+=a;return this},clamp:function(){var a=this.words,c=this.sigBytes;a[c>>>2]&=4294967295<<\n32-8*(c%4);a.length=h.ceil(c/4)},clone:function(){var a=j.clone.call(this);a.words=this.words.slice(0);return a},random:function(a){for(var c=[],d=0;d<a;d+=4)c.push(4294967296*h.random()|0);return new q.init(c,a)}}),v=f.enc={},u=v.Hex={stringify:function(a){var c=a.words;a=a.sigBytes;for(var d=[],b=0;b<a;b++){var e=c[b>>>2]>>>24-8*(b%4)&255;d.push((e>>>4).toString(16));d.push((e&15).toString(16))}return d.join(\"\")},parse:function(a){for(var c=a.length,d=[],b=0;b<c;b+=2)d[b>>>3]|=parseInt(a.substr(b,\n2),16)<<24-4*(b%8);return new q.init(d,c/2)}},k=v.Latin1={stringify:function(a){var c=a.words;a=a.sigBytes;for(var d=[],b=0;b<a;b++)d.push(String.fromCharCode(c[b>>>2]>>>24-8*(b%4)&255));return d.join(\"\")},parse:function(a){for(var c=a.length,d=[],b=0;b<c;b++)d[b>>>2]|=(a.charCodeAt(b)&255)<<24-8*(b%4);return new q.init(d,c)}},l=v.Utf8={stringify:function(a){try{return decodeURIComponent(escape(k.stringify(a)))}catch(c){throw Error(\"Malformed UTF-8 data\");}},parse:function(a){return k.parse(unescape(encodeURIComponent(a)))}},\nx=t.BufferedBlockAlgorithm=j.extend({reset:function(){this._data=new q.init;this._nDataBytes=0},_append:function(a){\"string\"==typeof a&&(a=l.parse(a));this._data.concat(a);this._nDataBytes+=a.sigBytes},_process:function(a){var c=this._data,d=c.words,b=c.sigBytes,e=this.blockSize,f=b/(4*e),f=a?h.ceil(f):h.max((f|0)-this._minBufferSize,0);a=f*e;b=h.min(4*a,b);if(a){for(var m=0;m<a;m+=e)this._doProcessBlock(d,m);m=d.splice(0,a);c.sigBytes-=b}return new q.init(m,b)},clone:function(){var a=j.clone.call(this);\na._data=this._data.clone();return a},_minBufferSize:0});t.Hasher=x.extend({cfg:j.extend(),init:function(a){this.cfg=this.cfg.extend(a);this.reset()},reset:function(){x.reset.call(this);this._doReset()},update:function(a){this._append(a);this._process();return this},finalize:function(a){a&&this._append(a);return this._doFinalize()},blockSize:16,_createHelper:function(a){return function(c,d){return(new a.init(d)).finalize(c)}},_createHmacHelper:function(a){return function(c,d){return(new w.HMAC.init(a,\nd)).finalize(c)}}});var w=f.algo={};return f}(Math);\n(function(h){for(var s=CryptoJS,f=s.lib,t=f.WordArray,g=f.Hasher,f=s.algo,j=[],q=[],v=function(a){return 4294967296*(a-(a|0))|0},u=2,k=0;64>k;){var l;a:{l=u;for(var x=h.sqrt(l),w=2;w<=x;w++)if(!(l%w)){l=!1;break a}l=!0}l&&(8>k&&(j[k]=v(h.pow(u,0.5))),q[k]=v(h.pow(u,1/3)),k++);u++}var a=[],f=f.SHA256=g.extend({_doReset:function(){this._hash=new t.init(j.slice(0))},_doProcessBlock:function(c,d){for(var b=this._hash.words,e=b[0],f=b[1],m=b[2],h=b[3],p=b[4],j=b[5],k=b[6],l=b[7],n=0;64>n;n++){if(16>n)a[n]=\nc[d+n]|0;else{var r=a[n-15],g=a[n-2];a[n]=((r<<25|r>>>7)^(r<<14|r>>>18)^r>>>3)+a[n-7]+((g<<15|g>>>17)^(g<<13|g>>>19)^g>>>10)+a[n-16]}r=l+((p<<26|p>>>6)^(p<<21|p>>>11)^(p<<7|p>>>25))+(p&j^~p&k)+q[n]+a[n];g=((e<<30|e>>>2)^(e<<19|e>>>13)^(e<<10|e>>>22))+(e&f^e&m^f&m);l=k;k=j;j=p;p=h+r|0;h=m;m=f;f=e;e=r+g|0}b[0]=b[0]+e|0;b[1]=b[1]+f|0;b[2]=b[2]+m|0;b[3]=b[3]+h|0;b[4]=b[4]+p|0;b[5]=b[5]+j|0;b[6]=b[6]+k|0;b[7]=b[7]+l|0},_doFinalize:function(){var a=this._data,d=a.words,b=8*this._nDataBytes,e=8*a.sigBytes;\nd[e>>>5]|=128<<24-e%32;d[(e+64>>>9<<4)+14]=h.floor(b/4294967296);d[(e+64>>>9<<4)+15]=b;a.sigBytes=4*d.length;this._process();return this._hash},clone:function(){var a=g.clone.call(this);a._hash=this._hash.clone();return a}});s.SHA256=g._createHelper(f);s.HmacSHA256=g._createHmacHelper(f)})(Math);\n"], "crypto_js.rollups.sha3": [".js", "/*\nCryptoJS v3.1.2\ncode.google.com/p/crypto-js\n(c) 2009-2013 by Jeff Mott. All rights reserved.\ncode.google.com/p/crypto-js/wiki/License\n*/\nvar CryptoJS=CryptoJS||function(v,p){var d={},u=d.lib={},r=function(){},f=u.Base={extend:function(a){r.prototype=this;var b=new r;a&&b.mixIn(a);b.hasOwnProperty(\"init\")||(b.init=function(){b.$super.init.apply(this,arguments)});b.init.prototype=b;b.$super=this;return b},create:function(){var a=this.extend();a.init.apply(a,arguments);return a},init:function(){},mixIn:function(a){for(var b in a)a.hasOwnProperty(b)&&(this[b]=a[b]);a.hasOwnProperty(\"toString\")&&(this.toString=a.toString)},clone:function(){return this.init.prototype.extend(this)}},\ns=u.WordArray=f.extend({init:function(a,b){a=this.words=a||[];this.sigBytes=b!=p?b:4*a.length},toString:function(a){return(a||y).stringify(this)},concat:function(a){var b=this.words,c=a.words,j=this.sigBytes;a=a.sigBytes;this.clamp();if(j%4)for(var n=0;n<a;n++)b[j+n>>>2]|=(c[n>>>2]>>>24-8*(n%4)&255)<<24-8*((j+n)%4);else if(65535<c.length)for(n=0;n<a;n+=4)b[j+n>>>2]=c[n>>>2];else b.push.apply(b,c);this.sigBytes+=a;return this},clamp:function(){var a=this.words,b=this.sigBytes;a[b>>>2]&=4294967295<<\n32-8*(b%4);a.length=v.ceil(b/4)},clone:function(){var a=f.clone.call(this);a.words=this.words.slice(0);return a},random:function(a){for(var b=[],c=0;c<a;c+=4)b.push(4294967296*v.random()|0);return new s.init(b,a)}}),x=d.enc={},y=x.Hex={stringify:function(a){var b=a.words;a=a.sigBytes;for(var c=[],j=0;j<a;j++){var n=b[j>>>2]>>>24-8*(j%4)&255;c.push((n>>>4).toString(16));c.push((n&15).toString(16))}return c.join(\"\")},parse:function(a){for(var b=a.length,c=[],j=0;j<b;j+=2)c[j>>>3]|=parseInt(a.substr(j,\n2),16)<<24-4*(j%8);return new s.init(c,b/2)}},e=x.Latin1={stringify:function(a){var b=a.words;a=a.sigBytes;for(var c=[],j=0;j<a;j++)c.push(String.fromCharCode(b[j>>>2]>>>24-8*(j%4)&255));return c.join(\"\")},parse:function(a){for(var b=a.length,c=[],j=0;j<b;j++)c[j>>>2]|=(a.charCodeAt(j)&255)<<24-8*(j%4);return new s.init(c,b)}},q=x.Utf8={stringify:function(a){try{return decodeURIComponent(escape(e.stringify(a)))}catch(b){throw Error(\"Malformed UTF-8 data\");}},parse:function(a){return e.parse(unescape(encodeURIComponent(a)))}},\nt=u.BufferedBlockAlgorithm=f.extend({reset:function(){this._data=new s.init;this._nDataBytes=0},_append:function(a){\"string\"==typeof a&&(a=q.parse(a));this._data.concat(a);this._nDataBytes+=a.sigBytes},_process:function(a){var b=this._data,c=b.words,j=b.sigBytes,n=this.blockSize,e=j/(4*n),e=a?v.ceil(e):v.max((e|0)-this._minBufferSize,0);a=e*n;j=v.min(4*a,j);if(a){for(var f=0;f<a;f+=n)this._doProcessBlock(c,f);f=c.splice(0,a);b.sigBytes-=j}return new s.init(f,j)},clone:function(){var a=f.clone.call(this);\na._data=this._data.clone();return a},_minBufferSize:0});u.Hasher=t.extend({cfg:f.extend(),init:function(a){this.cfg=this.cfg.extend(a);this.reset()},reset:function(){t.reset.call(this);this._doReset()},update:function(a){this._append(a);this._process();return this},finalize:function(a){a&&this._append(a);return this._doFinalize()},blockSize:16,_createHelper:function(a){return function(b,c){return(new a.init(c)).finalize(b)}},_createHmacHelper:function(a){return function(b,c){return(new w.HMAC.init(a,\nc)).finalize(b)}}});var w=d.algo={};return d}(Math);\n(function(v){var p=CryptoJS,d=p.lib,u=d.Base,r=d.WordArray,p=p.x64={};p.Word=u.extend({init:function(f,s){this.high=f;this.low=s}});p.WordArray=u.extend({init:function(f,s){f=this.words=f||[];this.sigBytes=s!=v?s:8*f.length},toX32:function(){for(var f=this.words,s=f.length,d=[],p=0;p<s;p++){var e=f[p];d.push(e.high);d.push(e.low)}return r.create(d,this.sigBytes)},clone:function(){for(var f=u.clone.call(this),d=f.words=this.words.slice(0),p=d.length,r=0;r<p;r++)d[r]=d[r].clone();return f}})})();\n(function(v){for(var p=CryptoJS,d=p.lib,u=d.WordArray,r=d.Hasher,f=p.x64.Word,d=p.algo,s=[],x=[],y=[],e=1,q=0,t=0;24>t;t++){s[e+5*q]=(t+1)*(t+2)/2%64;var w=(2*e+3*q)%5,e=q%5,q=w}for(e=0;5>e;e++)for(q=0;5>q;q++)x[e+5*q]=q+5*((2*e+3*q)%5);e=1;for(q=0;24>q;q++){for(var a=w=t=0;7>a;a++){if(e&1){var b=(1<<a)-1;32>b?w^=1<<b:t^=1<<b-32}e=e&128?e<<1^113:e<<1}y[q]=f.create(t,w)}for(var c=[],e=0;25>e;e++)c[e]=f.create();d=d.SHA3=r.extend({cfg:r.cfg.extend({outputLength:512}),_doReset:function(){for(var a=this._state=\n[],b=0;25>b;b++)a[b]=new f.init;this.blockSize=(1600-2*this.cfg.outputLength)/32},_doProcessBlock:function(a,b){for(var e=this._state,f=this.blockSize/2,h=0;h<f;h++){var l=a[b+2*h],m=a[b+2*h+1],l=(l<<8|l>>>24)&16711935|(l<<24|l>>>8)&4278255360,m=(m<<8|m>>>24)&16711935|(m<<24|m>>>8)&4278255360,g=e[h];g.high^=m;g.low^=l}for(f=0;24>f;f++){for(h=0;5>h;h++){for(var d=l=0,k=0;5>k;k++)g=e[h+5*k],l^=g.high,d^=g.low;g=c[h];g.high=l;g.low=d}for(h=0;5>h;h++){g=c[(h+4)%5];l=c[(h+1)%5];m=l.high;k=l.low;l=g.high^\n(m<<1|k>>>31);d=g.low^(k<<1|m>>>31);for(k=0;5>k;k++)g=e[h+5*k],g.high^=l,g.low^=d}for(m=1;25>m;m++)g=e[m],h=g.high,g=g.low,k=s[m],32>k?(l=h<<k|g>>>32-k,d=g<<k|h>>>32-k):(l=g<<k-32|h>>>64-k,d=h<<k-32|g>>>64-k),g=c[x[m]],g.high=l,g.low=d;g=c[0];h=e[0];g.high=h.high;g.low=h.low;for(h=0;5>h;h++)for(k=0;5>k;k++)m=h+5*k,g=e[m],l=c[m],m=c[(h+1)%5+5*k],d=c[(h+2)%5+5*k],g.high=l.high^~m.high&d.high,g.low=l.low^~m.low&d.low;g=e[0];h=y[f];g.high^=h.high;g.low^=h.low}},_doFinalize:function(){var a=this._data,\nb=a.words,c=8*a.sigBytes,e=32*this.blockSize;b[c>>>5]|=1<<24-c%32;b[(v.ceil((c+1)/e)*e>>>5)-1]|=128;a.sigBytes=4*b.length;this._process();for(var a=this._state,b=this.cfg.outputLength/8,c=b/8,e=[],h=0;h<c;h++){var d=a[h],f=d.high,d=d.low,f=(f<<8|f>>>24)&16711935|(f<<24|f>>>8)&4278255360,d=(d<<8|d>>>24)&16711935|(d<<24|d>>>8)&4278255360;e.push(d);e.push(f)}return new u.init(e,b)},clone:function(){for(var a=r.clone.call(this),b=a._state=this._state.slice(0),c=0;25>c;c++)b[c]=b[c].clone();return a}});\np.SHA3=r._createHelper(d);p.HmacSHA3=r._createHmacHelper(d)})(Math);\n"], "crypto_js.rollups.sha384": [".js", "/*\nCryptoJS v3.1.2\ncode.google.com/p/crypto-js\n(c) 2009-2013 by Jeff Mott. All rights reserved.\ncode.google.com/p/crypto-js/wiki/License\n*/\nvar CryptoJS=CryptoJS||function(a,c){var d={},j=d.lib={},f=function(){},m=j.Base={extend:function(a){f.prototype=this;var b=new f;a&&b.mixIn(a);b.hasOwnProperty(\"init\")||(b.init=function(){b.$super.init.apply(this,arguments)});b.init.prototype=b;b.$super=this;return b},create:function(){var a=this.extend();a.init.apply(a,arguments);return a},init:function(){},mixIn:function(a){for(var b in a)a.hasOwnProperty(b)&&(this[b]=a[b]);a.hasOwnProperty(\"toString\")&&(this.toString=a.toString)},clone:function(){return this.init.prototype.extend(this)}},\nB=j.WordArray=m.extend({init:function(a,b){a=this.words=a||[];this.sigBytes=b!=c?b:4*a.length},toString:function(a){return(a||y).stringify(this)},concat:function(a){var b=this.words,g=a.words,e=this.sigBytes;a=a.sigBytes;this.clamp();if(e%4)for(var k=0;k<a;k++)b[e+k>>>2]|=(g[k>>>2]>>>24-8*(k%4)&255)<<24-8*((e+k)%4);else if(65535<g.length)for(k=0;k<a;k+=4)b[e+k>>>2]=g[k>>>2];else b.push.apply(b,g);this.sigBytes+=a;return this},clamp:function(){var n=this.words,b=this.sigBytes;n[b>>>2]&=4294967295<<\n32-8*(b%4);n.length=a.ceil(b/4)},clone:function(){var a=m.clone.call(this);a.words=this.words.slice(0);return a},random:function(n){for(var b=[],g=0;g<n;g+=4)b.push(4294967296*a.random()|0);return new B.init(b,n)}}),v=d.enc={},y=v.Hex={stringify:function(a){var b=a.words;a=a.sigBytes;for(var g=[],e=0;e<a;e++){var k=b[e>>>2]>>>24-8*(e%4)&255;g.push((k>>>4).toString(16));g.push((k&15).toString(16))}return g.join(\"\")},parse:function(a){for(var b=a.length,g=[],e=0;e<b;e+=2)g[e>>>3]|=parseInt(a.substr(e,\n2),16)<<24-4*(e%8);return new B.init(g,b/2)}},F=v.Latin1={stringify:function(a){var b=a.words;a=a.sigBytes;for(var g=[],e=0;e<a;e++)g.push(String.fromCharCode(b[e>>>2]>>>24-8*(e%4)&255));return g.join(\"\")},parse:function(a){for(var b=a.length,g=[],e=0;e<b;e++)g[e>>>2]|=(a.charCodeAt(e)&255)<<24-8*(e%4);return new B.init(g,b)}},ha=v.Utf8={stringify:function(a){try{return decodeURIComponent(escape(F.stringify(a)))}catch(b){throw Error(\"Malformed UTF-8 data\");}},parse:function(a){return F.parse(unescape(encodeURIComponent(a)))}},\nZ=j.BufferedBlockAlgorithm=m.extend({reset:function(){this._data=new B.init;this._nDataBytes=0},_append:function(a){\"string\"==typeof a&&(a=ha.parse(a));this._data.concat(a);this._nDataBytes+=a.sigBytes},_process:function(n){var b=this._data,g=b.words,e=b.sigBytes,k=this.blockSize,m=e/(4*k),m=n?a.ceil(m):a.max((m|0)-this._minBufferSize,0);n=m*k;e=a.min(4*n,e);if(n){for(var c=0;c<n;c+=k)this._doProcessBlock(g,c);c=g.splice(0,n);b.sigBytes-=e}return new B.init(c,e)},clone:function(){var a=m.clone.call(this);\na._data=this._data.clone();return a},_minBufferSize:0});j.Hasher=Z.extend({cfg:m.extend(),init:function(a){this.cfg=this.cfg.extend(a);this.reset()},reset:function(){Z.reset.call(this);this._doReset()},update:function(a){this._append(a);this._process();return this},finalize:function(a){a&&this._append(a);return this._doFinalize()},blockSize:16,_createHelper:function(a){return function(b,g){return(new a.init(g)).finalize(b)}},_createHmacHelper:function(a){return function(b,g){return(new ia.HMAC.init(a,\ng)).finalize(b)}}});var ia=d.algo={};return d}(Math);\n(function(a){var c=CryptoJS,d=c.lib,j=d.Base,f=d.WordArray,c=c.x64={};c.Word=j.extend({init:function(a,c){this.high=a;this.low=c}});c.WordArray=j.extend({init:function(c,d){c=this.words=c||[];this.sigBytes=d!=a?d:8*c.length},toX32:function(){for(var a=this.words,c=a.length,d=[],j=0;j<c;j++){var F=a[j];d.push(F.high);d.push(F.low)}return f.create(d,this.sigBytes)},clone:function(){for(var a=j.clone.call(this),c=a.words=this.words.slice(0),d=c.length,f=0;f<d;f++)c[f]=c[f].clone();return a}})})();\n(function(){function a(){return f.create.apply(f,arguments)}for(var c=CryptoJS,d=c.lib.Hasher,j=c.x64,f=j.Word,m=j.WordArray,j=c.algo,B=[a(1116352408,3609767458),a(1899447441,602891725),a(3049323471,3964484399),a(3921009573,2173295548),a(961987163,4081628472),a(1508970993,3053834265),a(2453635748,2937671579),a(2870763221,3664609560),a(3624381080,2734883394),a(310598401,1164996542),a(607225278,1323610764),a(1426881987,3590304994),a(1925078388,4068182383),a(2162078206,991336113),a(2614888103,633803317),\na(3248222580,3479774868),a(3835390401,2666613458),a(4022224774,944711139),a(264347078,2341262773),a(604807628,2007800933),a(770255983,1495990901),a(1249150122,1856431235),a(1555081692,3175218132),a(1996064986,2198950837),a(2554220882,3999719339),a(2821834349,766784016),a(2952996808,2566594879),a(3210313671,3203337956),a(3336571891,1034457026),a(3584528711,2466948901),a(113926993,3758326383),a(338241895,168717936),a(666307205,1188179964),a(773529912,1546045734),a(1294757372,1522805485),a(1396182291,\n2643833823),a(1695183700,2343527390),a(1986661051,1014477480),a(2177026350,1206759142),a(2456956037,344077627),a(2730485921,1290863460),a(2820302411,3158454273),a(3259730800,3505952657),a(3345764771,106217008),a(3516065817,3606008344),a(3600352804,1432725776),a(4094571909,1467031594),a(275423344,851169720),a(430227734,3100823752),a(506948616,1363258195),a(659060556,3750685593),a(883997877,3785050280),a(958139571,3318307427),a(1322822218,3812723403),a(1537002063,2003034995),a(1747873779,3602036899),\na(1955562222,1575990012),a(2024104815,1125592928),a(2227730452,2716904306),a(2361852424,442776044),a(2428436474,593698344),a(2756734187,3733110249),a(3204031479,2999351573),a(3329325298,3815920427),a(3391569614,3928383900),a(3515267271,566280711),a(3940187606,3454069534),a(4118630271,4000239992),a(116418474,1914138554),a(174292421,2731055270),a(289380356,3203993006),a(460393269,320620315),a(685471733,587496836),a(852142971,1086792851),a(1017036298,365543100),a(1126000580,2618297676),a(1288033470,\n3409855158),a(1501505948,4234509866),a(1607167915,987167468),a(1816402316,1246189591)],v=[],y=0;80>y;y++)v[y]=a();j=j.SHA512=d.extend({_doReset:function(){this._hash=new m.init([new f.init(1779033703,4089235720),new f.init(3144134277,2227873595),new f.init(1013904242,4271175723),new f.init(2773480762,1595750129),new f.init(1359893119,2917565137),new f.init(2600822924,725511199),new f.init(528734635,4215389547),new f.init(1541459225,327033209)])},_doProcessBlock:function(a,c){for(var d=this._hash.words,\nf=d[0],j=d[1],b=d[2],g=d[3],e=d[4],k=d[5],m=d[6],d=d[7],y=f.high,M=f.low,$=j.high,N=j.low,aa=b.high,O=b.low,ba=g.high,P=g.low,ca=e.high,Q=e.low,da=k.high,R=k.low,ea=m.high,S=m.low,fa=d.high,T=d.low,s=y,p=M,G=$,D=N,H=aa,E=O,W=ba,I=P,t=ca,q=Q,U=da,J=R,V=ea,K=S,X=fa,L=T,u=0;80>u;u++){var z=v[u];if(16>u)var r=z.high=a[c+2*u]|0,h=z.low=a[c+2*u+1]|0;else{var r=v[u-15],h=r.high,w=r.low,r=(h>>>1|w<<31)^(h>>>8|w<<24)^h>>>7,w=(w>>>1|h<<31)^(w>>>8|h<<24)^(w>>>7|h<<25),C=v[u-2],h=C.high,l=C.low,C=(h>>>19|l<<\n13)^(h<<3|l>>>29)^h>>>6,l=(l>>>19|h<<13)^(l<<3|h>>>29)^(l>>>6|h<<26),h=v[u-7],Y=h.high,A=v[u-16],x=A.high,A=A.low,h=w+h.low,r=r+Y+(h>>>0<w>>>0?1:0),h=h+l,r=r+C+(h>>>0<l>>>0?1:0),h=h+A,r=r+x+(h>>>0<A>>>0?1:0);z.high=r;z.low=h}var Y=t&U^~t&V,A=q&J^~q&K,z=s&G^s&H^G&H,ja=p&D^p&E^D&E,w=(s>>>28|p<<4)^(s<<30|p>>>2)^(s<<25|p>>>7),C=(p>>>28|s<<4)^(p<<30|s>>>2)^(p<<25|s>>>7),l=B[u],ka=l.high,ga=l.low,l=L+((q>>>14|t<<18)^(q>>>18|t<<14)^(q<<23|t>>>9)),x=X+((t>>>14|q<<18)^(t>>>18|q<<14)^(t<<23|q>>>9))+(l>>>0<\nL>>>0?1:0),l=l+A,x=x+Y+(l>>>0<A>>>0?1:0),l=l+ga,x=x+ka+(l>>>0<ga>>>0?1:0),l=l+h,x=x+r+(l>>>0<h>>>0?1:0),h=C+ja,z=w+z+(h>>>0<C>>>0?1:0),X=V,L=K,V=U,K=J,U=t,J=q,q=I+l|0,t=W+x+(q>>>0<I>>>0?1:0)|0,W=H,I=E,H=G,E=D,G=s,D=p,p=l+h|0,s=x+z+(p>>>0<l>>>0?1:0)|0}M=f.low=M+p;f.high=y+s+(M>>>0<p>>>0?1:0);N=j.low=N+D;j.high=$+G+(N>>>0<D>>>0?1:0);O=b.low=O+E;b.high=aa+H+(O>>>0<E>>>0?1:0);P=g.low=P+I;g.high=ba+W+(P>>>0<I>>>0?1:0);Q=e.low=Q+q;e.high=ca+t+(Q>>>0<q>>>0?1:0);R=k.low=R+J;k.high=da+U+(R>>>0<J>>>0?1:0);\nS=m.low=S+K;m.high=ea+V+(S>>>0<K>>>0?1:0);T=d.low=T+L;d.high=fa+X+(T>>>0<L>>>0?1:0)},_doFinalize:function(){var a=this._data,c=a.words,d=8*this._nDataBytes,f=8*a.sigBytes;c[f>>>5]|=128<<24-f%32;c[(f+128>>>10<<5)+30]=Math.floor(d/4294967296);c[(f+128>>>10<<5)+31]=d;a.sigBytes=4*c.length;this._process();return this._hash.toX32()},clone:function(){var a=d.clone.call(this);a._hash=this._hash.clone();return a},blockSize:32});c.SHA512=d._createHelper(j);c.HmacSHA512=d._createHmacHelper(j)})();\n(function(){var a=CryptoJS,c=a.x64,d=c.Word,j=c.WordArray,c=a.algo,f=c.SHA512,c=c.SHA384=f.extend({_doReset:function(){this._hash=new j.init([new d.init(3418070365,3238371032),new d.init(1654270250,914150663),new d.init(2438529370,812702999),new d.init(355462360,4144912697),new d.init(1731405415,4290775857),new d.init(2394180231,1750603025),new d.init(3675008525,1694076839),new d.init(1203062813,3204075428)])},_doFinalize:function(){var a=f._doFinalize.call(this);a.sigBytes-=16;return a}});a.SHA384=\nf._createHelper(c);a.HmacSHA384=f._createHmacHelper(c)})();\n"], "crypto_js.rollups.sha512": [".js", "/*\nCryptoJS v3.1.2\ncode.google.com/p/crypto-js\n(c) 2009-2013 by Jeff Mott. All rights reserved.\ncode.google.com/p/crypto-js/wiki/License\n*/\nvar CryptoJS=CryptoJS||function(a,m){var r={},f=r.lib={},g=function(){},l=f.Base={extend:function(a){g.prototype=this;var b=new g;a&&b.mixIn(a);b.hasOwnProperty(\"init\")||(b.init=function(){b.$super.init.apply(this,arguments)});b.init.prototype=b;b.$super=this;return b},create:function(){var a=this.extend();a.init.apply(a,arguments);return a},init:function(){},mixIn:function(a){for(var b in a)a.hasOwnProperty(b)&&(this[b]=a[b]);a.hasOwnProperty(\"toString\")&&(this.toString=a.toString)},clone:function(){return this.init.prototype.extend(this)}},\np=f.WordArray=l.extend({init:function(a,b){a=this.words=a||[];this.sigBytes=b!=m?b:4*a.length},toString:function(a){return(a||q).stringify(this)},concat:function(a){var b=this.words,d=a.words,c=this.sigBytes;a=a.sigBytes;this.clamp();if(c%4)for(var j=0;j<a;j++)b[c+j>>>2]|=(d[j>>>2]>>>24-8*(j%4)&255)<<24-8*((c+j)%4);else if(65535<d.length)for(j=0;j<a;j+=4)b[c+j>>>2]=d[j>>>2];else b.push.apply(b,d);this.sigBytes+=a;return this},clamp:function(){var n=this.words,b=this.sigBytes;n[b>>>2]&=4294967295<<\n32-8*(b%4);n.length=a.ceil(b/4)},clone:function(){var a=l.clone.call(this);a.words=this.words.slice(0);return a},random:function(n){for(var b=[],d=0;d<n;d+=4)b.push(4294967296*a.random()|0);return new p.init(b,n)}}),y=r.enc={},q=y.Hex={stringify:function(a){var b=a.words;a=a.sigBytes;for(var d=[],c=0;c<a;c++){var j=b[c>>>2]>>>24-8*(c%4)&255;d.push((j>>>4).toString(16));d.push((j&15).toString(16))}return d.join(\"\")},parse:function(a){for(var b=a.length,d=[],c=0;c<b;c+=2)d[c>>>3]|=parseInt(a.substr(c,\n2),16)<<24-4*(c%8);return new p.init(d,b/2)}},G=y.Latin1={stringify:function(a){var b=a.words;a=a.sigBytes;for(var d=[],c=0;c<a;c++)d.push(String.fromCharCode(b[c>>>2]>>>24-8*(c%4)&255));return d.join(\"\")},parse:function(a){for(var b=a.length,d=[],c=0;c<b;c++)d[c>>>2]|=(a.charCodeAt(c)&255)<<24-8*(c%4);return new p.init(d,b)}},fa=y.Utf8={stringify:function(a){try{return decodeURIComponent(escape(G.stringify(a)))}catch(b){throw Error(\"Malformed UTF-8 data\");}},parse:function(a){return G.parse(unescape(encodeURIComponent(a)))}},\nh=f.BufferedBlockAlgorithm=l.extend({reset:function(){this._data=new p.init;this._nDataBytes=0},_append:function(a){\"string\"==typeof a&&(a=fa.parse(a));this._data.concat(a);this._nDataBytes+=a.sigBytes},_process:function(n){var b=this._data,d=b.words,c=b.sigBytes,j=this.blockSize,l=c/(4*j),l=n?a.ceil(l):a.max((l|0)-this._minBufferSize,0);n=l*j;c=a.min(4*n,c);if(n){for(var h=0;h<n;h+=j)this._doProcessBlock(d,h);h=d.splice(0,n);b.sigBytes-=c}return new p.init(h,c)},clone:function(){var a=l.clone.call(this);\na._data=this._data.clone();return a},_minBufferSize:0});f.Hasher=h.extend({cfg:l.extend(),init:function(a){this.cfg=this.cfg.extend(a);this.reset()},reset:function(){h.reset.call(this);this._doReset()},update:function(a){this._append(a);this._process();return this},finalize:function(a){a&&this._append(a);return this._doFinalize()},blockSize:16,_createHelper:function(a){return function(b,d){return(new a.init(d)).finalize(b)}},_createHmacHelper:function(a){return function(b,d){return(new ga.HMAC.init(a,\nd)).finalize(b)}}});var ga=r.algo={};return r}(Math);\n(function(a){var m=CryptoJS,r=m.lib,f=r.Base,g=r.WordArray,m=m.x64={};m.Word=f.extend({init:function(a,p){this.high=a;this.low=p}});m.WordArray=f.extend({init:function(l,p){l=this.words=l||[];this.sigBytes=p!=a?p:8*l.length},toX32:function(){for(var a=this.words,p=a.length,f=[],q=0;q<p;q++){var G=a[q];f.push(G.high);f.push(G.low)}return g.create(f,this.sigBytes)},clone:function(){for(var a=f.clone.call(this),p=a.words=this.words.slice(0),g=p.length,q=0;q<g;q++)p[q]=p[q].clone();return a}})})();\n(function(){function a(){return g.create.apply(g,arguments)}for(var m=CryptoJS,r=m.lib.Hasher,f=m.x64,g=f.Word,l=f.WordArray,f=m.algo,p=[a(1116352408,3609767458),a(1899447441,602891725),a(3049323471,3964484399),a(3921009573,2173295548),a(961987163,4081628472),a(1508970993,3053834265),a(2453635748,2937671579),a(2870763221,3664609560),a(3624381080,2734883394),a(310598401,1164996542),a(607225278,1323610764),a(1426881987,3590304994),a(1925078388,4068182383),a(2162078206,991336113),a(2614888103,633803317),\na(3248222580,3479774868),a(3835390401,2666613458),a(4022224774,944711139),a(264347078,2341262773),a(604807628,2007800933),a(770255983,1495990901),a(1249150122,1856431235),a(1555081692,3175218132),a(1996064986,2198950837),a(2554220882,3999719339),a(2821834349,766784016),a(2952996808,2566594879),a(3210313671,3203337956),a(3336571891,1034457026),a(3584528711,2466948901),a(113926993,3758326383),a(338241895,168717936),a(666307205,1188179964),a(773529912,1546045734),a(1294757372,1522805485),a(1396182291,\n2643833823),a(1695183700,2343527390),a(1986661051,1014477480),a(2177026350,1206759142),a(2456956037,344077627),a(2730485921,1290863460),a(2820302411,3158454273),a(3259730800,3505952657),a(3345764771,106217008),a(3516065817,3606008344),a(3600352804,1432725776),a(4094571909,1467031594),a(275423344,851169720),a(430227734,3100823752),a(506948616,1363258195),a(659060556,3750685593),a(883997877,3785050280),a(958139571,3318307427),a(1322822218,3812723403),a(1537002063,2003034995),a(1747873779,3602036899),\na(1955562222,1575990012),a(2024104815,1125592928),a(2227730452,2716904306),a(2361852424,442776044),a(2428436474,593698344),a(2756734187,3733110249),a(3204031479,2999351573),a(3329325298,3815920427),a(3391569614,3928383900),a(3515267271,566280711),a(3940187606,3454069534),a(4118630271,4000239992),a(116418474,1914138554),a(174292421,2731055270),a(289380356,3203993006),a(460393269,320620315),a(685471733,587496836),a(852142971,1086792851),a(1017036298,365543100),a(1126000580,2618297676),a(1288033470,\n3409855158),a(1501505948,4234509866),a(1607167915,987167468),a(1816402316,1246189591)],y=[],q=0;80>q;q++)y[q]=a();f=f.SHA512=r.extend({_doReset:function(){this._hash=new l.init([new g.init(1779033703,4089235720),new g.init(3144134277,2227873595),new g.init(1013904242,4271175723),new g.init(2773480762,1595750129),new g.init(1359893119,2917565137),new g.init(2600822924,725511199),new g.init(528734635,4215389547),new g.init(1541459225,327033209)])},_doProcessBlock:function(a,f){for(var h=this._hash.words,\ng=h[0],n=h[1],b=h[2],d=h[3],c=h[4],j=h[5],l=h[6],h=h[7],q=g.high,m=g.low,r=n.high,N=n.low,Z=b.high,O=b.low,$=d.high,P=d.low,aa=c.high,Q=c.low,ba=j.high,R=j.low,ca=l.high,S=l.low,da=h.high,T=h.low,v=q,s=m,H=r,E=N,I=Z,F=O,W=$,J=P,w=aa,t=Q,U=ba,K=R,V=ca,L=S,X=da,M=T,x=0;80>x;x++){var B=y[x];if(16>x)var u=B.high=a[f+2*x]|0,e=B.low=a[f+2*x+1]|0;else{var u=y[x-15],e=u.high,z=u.low,u=(e>>>1|z<<31)^(e>>>8|z<<24)^e>>>7,z=(z>>>1|e<<31)^(z>>>8|e<<24)^(z>>>7|e<<25),D=y[x-2],e=D.high,k=D.low,D=(e>>>19|k<<13)^\n(e<<3|k>>>29)^e>>>6,k=(k>>>19|e<<13)^(k<<3|e>>>29)^(k>>>6|e<<26),e=y[x-7],Y=e.high,C=y[x-16],A=C.high,C=C.low,e=z+e.low,u=u+Y+(e>>>0<z>>>0?1:0),e=e+k,u=u+D+(e>>>0<k>>>0?1:0),e=e+C,u=u+A+(e>>>0<C>>>0?1:0);B.high=u;B.low=e}var Y=w&U^~w&V,C=t&K^~t&L,B=v&H^v&I^H&I,ha=s&E^s&F^E&F,z=(v>>>28|s<<4)^(v<<30|s>>>2)^(v<<25|s>>>7),D=(s>>>28|v<<4)^(s<<30|v>>>2)^(s<<25|v>>>7),k=p[x],ia=k.high,ea=k.low,k=M+((t>>>14|w<<18)^(t>>>18|w<<14)^(t<<23|w>>>9)),A=X+((w>>>14|t<<18)^(w>>>18|t<<14)^(w<<23|t>>>9))+(k>>>0<M>>>\n0?1:0),k=k+C,A=A+Y+(k>>>0<C>>>0?1:0),k=k+ea,A=A+ia+(k>>>0<ea>>>0?1:0),k=k+e,A=A+u+(k>>>0<e>>>0?1:0),e=D+ha,B=z+B+(e>>>0<D>>>0?1:0),X=V,M=L,V=U,L=K,U=w,K=t,t=J+k|0,w=W+A+(t>>>0<J>>>0?1:0)|0,W=I,J=F,I=H,F=E,H=v,E=s,s=k+e|0,v=A+B+(s>>>0<k>>>0?1:0)|0}m=g.low=m+s;g.high=q+v+(m>>>0<s>>>0?1:0);N=n.low=N+E;n.high=r+H+(N>>>0<E>>>0?1:0);O=b.low=O+F;b.high=Z+I+(O>>>0<F>>>0?1:0);P=d.low=P+J;d.high=$+W+(P>>>0<J>>>0?1:0);Q=c.low=Q+t;c.high=aa+w+(Q>>>0<t>>>0?1:0);R=j.low=R+K;j.high=ba+U+(R>>>0<K>>>0?1:0);S=l.low=\nS+L;l.high=ca+V+(S>>>0<L>>>0?1:0);T=h.low=T+M;h.high=da+X+(T>>>0<M>>>0?1:0)},_doFinalize:function(){var a=this._data,f=a.words,h=8*this._nDataBytes,g=8*a.sigBytes;f[g>>>5]|=128<<24-g%32;f[(g+128>>>10<<5)+30]=Math.floor(h/4294967296);f[(g+128>>>10<<5)+31]=h;a.sigBytes=4*f.length;this._process();return this._hash.toX32()},clone:function(){var a=r.clone.call(this);a._hash=this._hash.clone();return a},blockSize:32});m.SHA512=r._createHelper(f);m.HmacSHA512=r._createHmacHelper(f)})();\n"], "ast": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport sys\nimport re\nfrom _ast import *\nfrom contextlib import contextmanager,nullcontext\nfrom enum import IntEnum,auto,_simple_enum\n\n\ndef parse(source,filename='<unknown>',mode='exec',*,\ntype_comments=False,feature_version=None,optimize=-1):\n ''\n\n\n\n \n flags=PyCF_ONLY_AST\n if optimize >0:\n  flags |=PyCF_OPTIMIZED_AST\n if type_comments:\n  flags |=PyCF_TYPE_COMMENTS\n if feature_version is None:\n  feature_version=-1\n elif isinstance(feature_version,tuple):\n  major,minor=feature_version\n  if major !=3:\n   raise ValueError(f\"Unsupported major version: {major}\")\n  feature_version=minor\n  \n return compile(source,filename,mode,flags,\n _feature_version=feature_version,optimize=optimize)\n \n \ndef literal_eval(node_or_string):\n ''\n\n\n\n\n\n\n \n if isinstance(node_or_string,str):\n  node_or_string=parse(node_or_string.lstrip(\" \\t\"),mode='eval')\n if isinstance(node_or_string,Expression):\n  node_or_string=node_or_string.body\n def _raise_malformed_node(node):\n  msg=\"malformed node or string\"\n  if lno :=getattr(node,'lineno',None):\n   msg +=f' on line {lno}'\n  raise ValueError(msg+f': {node !r}')\n def _convert_num(node):\n  if not isinstance(node,Constant)or type(node.value)not in(int,float,complex):\n   _raise_malformed_node(node)\n  return node.value\n def _convert_signed_num(node):\n  if isinstance(node,UnaryOp)and isinstance(node.op,(UAdd,USub)):\n   operand=_convert_num(node.operand)\n   if isinstance(node.op,UAdd):\n    return+operand\n   else:\n    return -operand\n  return _convert_num(node)\n def _convert(node):\n  if isinstance(node,Constant):\n   return node.value\n  elif isinstance(node,Tuple):\n   return tuple(map(_convert,node.elts))\n  elif isinstance(node,List):\n   return list(map(_convert,node.elts))\n  elif isinstance(node,Set):\n   return set(map(_convert,node.elts))\n  elif(isinstance(node,Call)and isinstance(node.func,Name)and\n  node.func.id =='set'and node.args ==node.keywords ==[]):\n   return set()\n  elif isinstance(node,Dict):\n   if len(node.keys)!=len(node.values):\n    _raise_malformed_node(node)\n   return dict(zip(map(_convert,node.keys),\n   map(_convert,node.values)))\n  elif isinstance(node,BinOp)and isinstance(node.op,(Add,Sub)):\n   left=_convert_signed_num(node.left)\n   right=_convert_num(node.right)\n   if isinstance(left,(int,float))and isinstance(right,complex):\n    if isinstance(node.op,Add):\n     return left+right\n    else:\n     return left -right\n  return _convert_signed_num(node)\n return _convert(node_or_string)\n \n \ndef dump(\nnode,annotate_fields=True,include_attributes=False,\n*,\nindent=None,show_empty=False,\n):\n ''\n\n\n\n\n\n\n\n\n\n\n\n \n def _format(node,level=0):\n  if indent is not None:\n   level +=1\n   prefix='\\n'+indent *level\n   sep=',\\n'+indent *level\n  else:\n   prefix=''\n   sep=', '\n  if isinstance(node,AST):\n   cls=type(node)\n   args=[]\n   args_buffer=[]\n   allsimple=True\n   keywords=annotate_fields\n   for name in node._fields:\n    try:\n     value=getattr(node,name)\n    except AttributeError:\n     keywords=True\n     continue\n    if value is None and getattr(cls,name,...)is None:\n     keywords=True\n     continue\n    if(\n    not show_empty\n    and(value is None or value ==[])\n    \n    \n    and not isinstance(node,(Constant,MatchSingleton))\n    ):\n     args_buffer.append(repr(value))\n     continue\n    elif not keywords:\n     args.extend(args_buffer)\n     args_buffer=[]\n    value,simple=_format(value,level)\n    allsimple=allsimple and simple\n    if keywords:\n     args.append('%s=%s'%(name,value))\n    else:\n     args.append(value)\n   if include_attributes and node._attributes:\n    for name in node._attributes:\n     try:\n      value=getattr(node,name)\n     except AttributeError:\n      continue\n     if value is None and getattr(cls,name,...)is None:\n      continue\n     value,simple=_format(value,level)\n     allsimple=allsimple and simple\n     args.append('%s=%s'%(name,value))\n   if allsimple and len(args)<=3:\n    return '%s(%s)'%(node.__class__.__name__,', '.join(args)),not args\n   return '%s(%s%s)'%(node.__class__.__name__,prefix,sep.join(args)),False\n  elif isinstance(node,list):\n   if not node:\n    return '[]',True\n   return '[%s%s]'%(prefix,sep.join(_format(x,level)[0]for x in node)),False\n  return repr(node),True\n  \n if not isinstance(node,AST):\n  raise TypeError('expected AST, got %r'%node.__class__.__name__)\n if indent is not None and not isinstance(indent,str):\n  indent=' '*indent\n return _format(node)[0]\n \n \ndef copy_location(new_node,old_node):\n ''\n\n\n \n for attr in 'lineno','col_offset','end_lineno','end_col_offset':\n  if attr in old_node._attributes and attr in new_node._attributes:\n   value=getattr(old_node,attr,None)\n   \n   \n   if value is not None or(\n   hasattr(old_node,attr)and attr.startswith(\"end_\")\n   ):\n    setattr(new_node,attr,value)\n return new_node\n \n \ndef fix_missing_locations(node):\n ''\n\n\n\n\n\n \n def _fix(node,lineno,col_offset,end_lineno,end_col_offset):\n  if 'lineno'in node._attributes:\n   if not hasattr(node,'lineno'):\n    node.lineno=lineno\n   else:\n    lineno=node.lineno\n  if 'end_lineno'in node._attributes:\n   if getattr(node,'end_lineno',None)is None:\n    node.end_lineno=end_lineno\n   else:\n    end_lineno=node.end_lineno\n  if 'col_offset'in node._attributes:\n   if not hasattr(node,'col_offset'):\n    node.col_offset=col_offset\n   else:\n    col_offset=node.col_offset\n  if 'end_col_offset'in node._attributes:\n   if getattr(node,'end_col_offset',None)is None:\n    node.end_col_offset=end_col_offset\n   else:\n    end_col_offset=node.end_col_offset\n  for child in iter_child_nodes(node):\n   _fix(child,lineno,col_offset,end_lineno,end_col_offset)\n _fix(node,1,0,1,0)\n return node\n \n \ndef increment_lineno(node,n=1):\n ''\n\n\n\n \n for child in walk(node):\n \n \n  if isinstance(child,TypeIgnore):\n   child.lineno=getattr(child,'lineno',0)+n\n   continue\n   \n  if 'lineno'in child._attributes:\n   child.lineno=getattr(child,'lineno',0)+n\n  if(\n  \"end_lineno\"in child._attributes\n  and(end_lineno :=getattr(child,\"end_lineno\",0))is not None\n  ):\n   child.end_lineno=end_lineno+n\n return node\n \n \ndef iter_fields(node):\n ''\n\n\n \n for field in node._fields:\n  try:\n   yield field,getattr(node,field)\n  except AttributeError:\n   pass\n   \n   \ndef iter_child_nodes(node):\n ''\n\n\n \n for name,field in iter_fields(node):\n  if isinstance(field,AST):\n   yield field\n  elif isinstance(field,list):\n   for item in field:\n    if isinstance(item,AST):\n     yield item\n     \n     \ndef get_docstring(node,clean=True):\n ''\n\n\n\n\n\n\n \n if not isinstance(node,(AsyncFunctionDef,FunctionDef,ClassDef,Module)):\n  raise TypeError(\"%r can't have docstrings\"%node.__class__.__name__)\n if not(node.body and isinstance(node.body[0],Expr)):\n  return None\n node=node.body[0].value\n if isinstance(node,Constant)and isinstance(node.value,str):\n  text=node.value\n else:\n  return None\n if clean:\n  import inspect\n  text=inspect.cleandoc(text)\n return text\n \n \n_line_pattern=re.compile(r\"(.*?(?:\\r\\n|\\n|\\r|$))\")\ndef _splitlines_no_ff(source,maxlines=None):\n ''\n\n\n \n lines=[]\n for lineno,match in enumerate(_line_pattern.finditer(source),1):\n  if maxlines is not None and lineno >maxlines:\n   break\n  lines.append(match[0])\n return lines\n \n \ndef _pad_whitespace(source):\n ''\n result=''\n for c in source:\n  if c in '\\f\\t':\n   result +=c\n  else:\n   result +=' '\n return result\n \n \ndef get_source_segment(source,node,*,padded=False):\n ''\n\n\n\n\n\n\n \n try:\n  if node.end_lineno is None or node.end_col_offset is None:\n   return None\n  lineno=node.lineno -1\n  end_lineno=node.end_lineno -1\n  col_offset=node.col_offset\n  end_col_offset=node.end_col_offset\n except AttributeError:\n  return None\n  \n lines=_splitlines_no_ff(source,maxlines=end_lineno+1)\n if end_lineno ==lineno:\n  return lines[lineno].encode()[col_offset:end_col_offset].decode()\n  \n if padded:\n  padding=_pad_whitespace(lines[lineno].encode()[:col_offset].decode())\n else:\n  padding=''\n  \n first=padding+lines[lineno].encode()[col_offset:].decode()\n last=lines[end_lineno].encode()[:end_col_offset].decode()\n lines=lines[lineno+1:end_lineno]\n \n lines.insert(0,first)\n lines.append(last)\n return ''.join(lines)\n \n \ndef walk(node):\n ''\n\n\n\n \n from collections import deque\n todo=deque([node])\n while todo:\n  node=todo.popleft()\n  todo.extend(iter_child_nodes(node))\n  yield node\n  \n  \nclass NodeVisitor(object):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n def visit(self,node):\n  ''\n  method='visit_'+node.__class__.__name__\n  visitor=getattr(self,method,self.generic_visit)\n  return visitor(node)\n  \n def generic_visit(self,node):\n  ''\n  for field,value in iter_fields(node):\n   if isinstance(value,list):\n    for item in value:\n     if isinstance(item,AST):\n      self.visit(item)\n   elif isinstance(value,AST):\n    self.visit(value)\n    \n def visit_Constant(self,node):\n  value=node.value\n  type_name=_const_node_type_names.get(type(value))\n  if type_name is None:\n   for cls,name in _const_node_type_names.items():\n    if isinstance(value,cls):\n     type_name=name\n     break\n  if type_name is not None:\n   method='visit_'+type_name\n   try:\n    visitor=getattr(self,method)\n   except AttributeError:\n    pass\n   else:\n    import warnings\n    warnings.warn(f\"{method} is deprecated; add visit_Constant\",\n    DeprecationWarning,2)\n    return visitor(node)\n  return self.generic_visit(node)\n  \n  \nclass NodeTransformer(NodeVisitor):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n def generic_visit(self,node):\n  for field,old_value in iter_fields(node):\n   if isinstance(old_value,list):\n    new_values=[]\n    for value in old_value:\n     if isinstance(value,AST):\n      value=self.visit(value)\n      if value is None:\n       continue\n      elif not isinstance(value,AST):\n       new_values.extend(value)\n       continue\n     new_values.append(value)\n    old_value[:]=new_values\n   elif isinstance(old_value,AST):\n    new_node=self.visit(old_value)\n    if new_node is None:\n     delattr(node,field)\n    else:\n     setattr(node,field,new_node)\n  return node\n  \n  \n_DEPRECATED_VALUE_ALIAS_MESSAGE=(\n\"{name} is deprecated and will be removed in Python {remove}; use value instead\"\n)\n_DEPRECATED_CLASS_MESSAGE=(\n\"{name} is deprecated and will be removed in Python {remove}; \"\n\"use ast.Constant instead\"\n)\n\n\n\nif not hasattr(Constant,'n'):\n\n\n\n def _n_getter(self):\n  ''\n  import warnings\n  warnings._deprecated(\n  \"Attribute n\",message=_DEPRECATED_VALUE_ALIAS_MESSAGE,remove=(3,14)\n  )\n  return self.value\n  \n def _n_setter(self,value):\n  import warnings\n  warnings._deprecated(\n  \"Attribute n\",message=_DEPRECATED_VALUE_ALIAS_MESSAGE,remove=(3,14)\n  )\n  self.value=value\n  \n def _s_getter(self):\n  ''\n  import warnings\n  warnings._deprecated(\n  \"Attribute s\",message=_DEPRECATED_VALUE_ALIAS_MESSAGE,remove=(3,14)\n  )\n  return self.value\n  \n def _s_setter(self,value):\n  import warnings\n  warnings._deprecated(\n  \"Attribute s\",message=_DEPRECATED_VALUE_ALIAS_MESSAGE,remove=(3,14)\n  )\n  self.value=value\n  \n Constant.n=property(_n_getter,_n_setter)\n Constant.s=property(_s_getter,_s_setter)\n \nclass _ABC(type):\n\n def __init__(cls,*args):\n  cls.__doc__=\"\"\"Deprecated AST node class. Use ast.Constant instead\"\"\"\n  \n def __instancecheck__(cls,inst):\n  if cls in _const_types:\n   import warnings\n   warnings._deprecated(\n   f\"ast.{cls.__qualname__}\",\n   message=_DEPRECATED_CLASS_MESSAGE,\n   remove=(3,14)\n   )\n  if not isinstance(inst,Constant):\n   return False\n  if cls in _const_types:\n   try:\n    value=inst.value\n   except AttributeError:\n    return False\n   else:\n    return(\n    isinstance(value,_const_types[cls])and\n    not isinstance(value,_const_types_not.get(cls,()))\n    )\n  return type.__instancecheck__(cls,inst)\n  \ndef _new(cls,*args,**kwargs):\n for key in kwargs:\n  if key not in cls._fields:\n  \n   continue\n  pos=cls._fields.index(key)\n  if pos <len(args):\n   raise TypeError(f\"{cls.__name__} got multiple values for argument {key !r}\")\n if cls in _const_types:\n  import warnings\n  warnings._deprecated(\n  f\"ast.{cls.__qualname__}\",message=_DEPRECATED_CLASS_MESSAGE,remove=(3,14)\n  )\n  return Constant(*args,**kwargs)\n return Constant.__new__(cls,*args,**kwargs)\n \nclass Num(Constant,metaclass=_ABC):\n _fields=('n',)\n __new__=_new\n \nclass Str(Constant,metaclass=_ABC):\n _fields=('s',)\n __new__=_new\n \nclass Bytes(Constant,metaclass=_ABC):\n _fields=('s',)\n __new__=_new\n \nclass NameConstant(Constant,metaclass=_ABC):\n __new__=_new\n \nclass Ellipsis(Constant,metaclass=_ABC):\n _fields=()\n \n def __new__(cls,*args,**kwargs):\n  if cls is _ast_Ellipsis:\n   import warnings\n   warnings._deprecated(\n   \"ast.Ellipsis\",message=_DEPRECATED_CLASS_MESSAGE,remove=(3,14)\n   )\n   return Constant(...,*args,**kwargs)\n  return Constant.__new__(cls,*args,**kwargs)\n  \n  \n  \n  \n_ast_Ellipsis=Ellipsis\n\n_const_types={\nNum:(int,float,complex),\nStr:(str,),\nBytes:(bytes,),\nNameConstant:(type(None),bool),\nEllipsis:(type(...),),\n}\n_const_types_not={\nNum:(bool,),\n}\n\n_const_node_type_names={\nbool:'NameConstant',\ntype(None):'NameConstant',\nint:'Num',\nfloat:'Num',\ncomplex:'Num',\nstr:'Str',\nbytes:'Bytes',\ntype(...):'Ellipsis',\n}\n\nclass slice(AST):\n ''\n \nclass Index(slice):\n ''\n def __new__(cls,value,**kwargs):\n  return value\n  \nclass ExtSlice(slice):\n ''\n def __new__(cls,dims=(),**kwargs):\n  return Tuple(list(dims),Load(),**kwargs)\n  \n  \nif not hasattr(Tuple,'dims'):\n\n\n\n def _dims_getter(self):\n  ''\n  return self.elts\n  \n def _dims_setter(self,value):\n  self.elts=value\n  \n Tuple.dims=property(_dims_getter,_dims_setter)\n \nclass Suite(mod):\n ''\n \nclass AugLoad(expr_context):\n ''\n \nclass AugStore(expr_context):\n ''\n \nclass Param(expr_context):\n ''\n \n \n \n \n_INFSTR=\"1e\"+repr(sys.float_info.max_10_exp+1)\n\n@_simple_enum(IntEnum)\nclass _Precedence:\n ''\n \n NAMED_EXPR=auto()\n TUPLE=auto()\n YIELD=auto()\n TEST=auto()\n OR=auto()\n AND=auto()\n NOT=auto()\n CMP=auto()\n \n EXPR=auto()\n BOR=EXPR\n BXOR=auto()\n BAND=auto()\n SHIFT=auto()\n ARITH=auto()\n TERM=auto()\n FACTOR=auto()\n POWER=auto()\n AWAIT=auto()\n ATOM=auto()\n \n def next(self):\n  try:\n   return self.__class__(self+1)\n  except ValueError:\n   return self\n   \n   \n_SINGLE_QUOTES=(\"'\",'\"')\n_MULTI_QUOTES=('\"\"\"',\"'''\")\n_ALL_QUOTES=(*_SINGLE_QUOTES,*_MULTI_QUOTES)\n\nclass _Unparser(NodeVisitor):\n ''\n\n \n \n def __init__(self):\n  self._source=[]\n  self._precedences={}\n  self._type_ignores={}\n  self._indent=0\n  self._in_try_star=False\n  \n def interleave(self,inter,f,seq):\n  ''\n  seq=iter(seq)\n  try:\n   f(next(seq))\n  except StopIteration:\n   pass\n  else:\n   for x in seq:\n    inter()\n    f(x)\n    \n def items_view(self,traverser,items):\n  ''\n\n  \n  if len(items)==1:\n   traverser(items[0])\n   self.write(\",\")\n  else:\n   self.interleave(lambda:self.write(\", \"),traverser,items)\n   \n def maybe_newline(self):\n  ''\n  if self._source:\n   self.write(\"\\n\")\n   \n def fill(self,text=\"\"):\n  ''\n  \n  self.maybe_newline()\n  self.write(\"    \"*self._indent+text)\n  \n def write(self,*text):\n  ''\n  self._source.extend(text)\n  \n @contextmanager\n def buffered(self,buffer=None):\n  if buffer is None:\n   buffer=[]\n   \n  original_source=self._source\n  self._source=buffer\n  yield buffer\n  self._source=original_source\n  \n @contextmanager\n def block(self,*,extra=None):\n  ''\n\n\n\n  \n  self.write(\":\")\n  if extra:\n   self.write(extra)\n  self._indent +=1\n  yield\n  self._indent -=1\n  \n @contextmanager\n def delimit(self,start,end):\n  ''\n  \n  \n  self.write(start)\n  yield\n  self.write(end)\n  \n def delimit_if(self,start,end,condition):\n  if condition:\n   return self.delimit(start,end)\n  else:\n   return nullcontext()\n   \n def require_parens(self,precedence,node):\n  ''\n  return self.delimit_if(\"(\",\")\",self.get_precedence(node)>precedence)\n  \n def get_precedence(self,node):\n  return self._precedences.get(node,_Precedence.TEST)\n  \n def set_precedence(self,precedence,*nodes):\n  for node in nodes:\n   self._precedences[node]=precedence\n   \n def get_raw_docstring(self,node):\n  ''\n\n\n  \n  if not isinstance(\n  node,(AsyncFunctionDef,FunctionDef,ClassDef,Module)\n  )or len(node.body)<1:\n   return None\n  node=node.body[0]\n  if not isinstance(node,Expr):\n   return None\n  node=node.value\n  if isinstance(node,Constant)and isinstance(node.value,str):\n   return node\n   \n def get_type_comment(self,node):\n  comment=self._type_ignores.get(node.lineno)or node.type_comment\n  if comment is not None:\n   return f\" # type: {comment}\"\n   \n def traverse(self,node):\n  if isinstance(node,list):\n   for item in node:\n    self.traverse(item)\n  else:\n   super().visit(node)\n   \n   \n   \n   \n def visit(self,node):\n  ''\n  \n  self._source=[]\n  self.traverse(node)\n  return \"\".join(self._source)\n  \n def _write_docstring_and_traverse_body(self,node):\n  if(docstring :=self.get_raw_docstring(node)):\n   self._write_docstring(docstring)\n   self.traverse(node.body[1:])\n  else:\n   self.traverse(node.body)\n   \n def visit_Module(self,node):\n  self._type_ignores={\n  ignore.lineno:f\"ignore{ignore.tag}\"\n  for ignore in node.type_ignores\n  }\n  self._write_docstring_and_traverse_body(node)\n  self._type_ignores.clear()\n  \n def visit_FunctionType(self,node):\n  with self.delimit(\"(\",\")\"):\n   self.interleave(\n   lambda:self.write(\", \"),self.traverse,node.argtypes\n   )\n   \n  self.write(\" -> \")\n  self.traverse(node.returns)\n  \n def visit_Expr(self,node):\n  self.fill()\n  self.set_precedence(_Precedence.YIELD,node.value)\n  self.traverse(node.value)\n  \n def visit_NamedExpr(self,node):\n  with self.require_parens(_Precedence.NAMED_EXPR,node):\n   self.set_precedence(_Precedence.ATOM,node.target,node.value)\n   self.traverse(node.target)\n   self.write(\" := \")\n   self.traverse(node.value)\n   \n def visit_Import(self,node):\n  self.fill(\"import \")\n  self.interleave(lambda:self.write(\", \"),self.traverse,node.names)\n  \n def visit_ImportFrom(self,node):\n  self.fill(\"from \")\n  self.write(\".\"*(node.level or 0))\n  if node.module:\n   self.write(node.module)\n  self.write(\" import \")\n  self.interleave(lambda:self.write(\", \"),self.traverse,node.names)\n  \n def visit_Assign(self,node):\n  self.fill()\n  for target in node.targets:\n   self.set_precedence(_Precedence.TUPLE,target)\n   self.traverse(target)\n   self.write(\" = \")\n  self.traverse(node.value)\n  if type_comment :=self.get_type_comment(node):\n   self.write(type_comment)\n   \n def visit_AugAssign(self,node):\n  self.fill()\n  self.traverse(node.target)\n  self.write(\" \"+self.binop[node.op.__class__.__name__]+\"= \")\n  self.traverse(node.value)\n  \n def visit_AnnAssign(self,node):\n  self.fill()\n  with self.delimit_if(\"(\",\")\",not node.simple and isinstance(node.target,Name)):\n   self.traverse(node.target)\n  self.write(\": \")\n  self.traverse(node.annotation)\n  if node.value:\n   self.write(\" = \")\n   self.traverse(node.value)\n   \n def visit_Return(self,node):\n  self.fill(\"return\")\n  if node.value:\n   self.write(\" \")\n   self.traverse(node.value)\n   \n def visit_Pass(self,node):\n  self.fill(\"pass\")\n  \n def visit_Break(self,node):\n  self.fill(\"break\")\n  \n def visit_Continue(self,node):\n  self.fill(\"continue\")\n  \n def visit_Delete(self,node):\n  self.fill(\"del \")\n  self.interleave(lambda:self.write(\", \"),self.traverse,node.targets)\n  \n def visit_Assert(self,node):\n  self.fill(\"assert \")\n  self.traverse(node.test)\n  if node.msg:\n   self.write(\", \")\n   self.traverse(node.msg)\n   \n def visit_Global(self,node):\n  self.fill(\"global \")\n  self.interleave(lambda:self.write(\", \"),self.write,node.names)\n  \n def visit_Nonlocal(self,node):\n  self.fill(\"nonlocal \")\n  self.interleave(lambda:self.write(\", \"),self.write,node.names)\n  \n def visit_Await(self,node):\n  with self.require_parens(_Precedence.AWAIT,node):\n   self.write(\"await\")\n   if node.value:\n    self.write(\" \")\n    self.set_precedence(_Precedence.ATOM,node.value)\n    self.traverse(node.value)\n    \n def visit_Yield(self,node):\n  with self.require_parens(_Precedence.YIELD,node):\n   self.write(\"yield\")\n   if node.value:\n    self.write(\" \")\n    self.set_precedence(_Precedence.ATOM,node.value)\n    self.traverse(node.value)\n    \n def visit_YieldFrom(self,node):\n  with self.require_parens(_Precedence.YIELD,node):\n   self.write(\"yield from \")\n   if not node.value:\n    raise ValueError(\"Node can't be used without a value attribute.\")\n   self.set_precedence(_Precedence.ATOM,node.value)\n   self.traverse(node.value)\n   \n def visit_Raise(self,node):\n  self.fill(\"raise\")\n  if not node.exc:\n   if node.cause:\n    raise ValueError(f\"Node can't use cause without an exception.\")\n   return\n  self.write(\" \")\n  self.traverse(node.exc)\n  if node.cause:\n   self.write(\" from \")\n   self.traverse(node.cause)\n   \n def do_visit_try(self,node):\n  self.fill(\"try\")\n  with self.block():\n   self.traverse(node.body)\n  for ex in node.handlers:\n   self.traverse(ex)\n  if node.orelse:\n   self.fill(\"else\")\n   with self.block():\n    self.traverse(node.orelse)\n  if node.finalbody:\n   self.fill(\"finally\")\n   with self.block():\n    self.traverse(node.finalbody)\n    \n def visit_Try(self,node):\n  prev_in_try_star=self._in_try_star\n  try:\n   self._in_try_star=False\n   self.do_visit_try(node)\n  finally:\n   self._in_try_star=prev_in_try_star\n   \n def visit_TryStar(self,node):\n  prev_in_try_star=self._in_try_star\n  try:\n   self._in_try_star=True\n   self.do_visit_try(node)\n  finally:\n   self._in_try_star=prev_in_try_star\n   \n def visit_ExceptHandler(self,node):\n  self.fill(\"except*\"if self._in_try_star else \"except\")\n  if node.type:\n   self.write(\" \")\n   self.traverse(node.type)\n  if node.name:\n   self.write(\" as \")\n   self.write(node.name)\n  with self.block():\n   self.traverse(node.body)\n   \n def visit_ClassDef(self,node):\n  self.maybe_newline()\n  for deco in node.decorator_list:\n   self.fill(\"@\")\n   self.traverse(deco)\n  self.fill(\"class \"+node.name)\n  if hasattr(node,\"type_params\"):\n   self._type_params_helper(node.type_params)\n  with self.delimit_if(\"(\",\")\",condition=node.bases or node.keywords):\n   comma=False\n   for e in node.bases:\n    if comma:\n     self.write(\", \")\n    else:\n     comma=True\n    self.traverse(e)\n   for e in node.keywords:\n    if comma:\n     self.write(\", \")\n    else:\n     comma=True\n    self.traverse(e)\n    \n  with self.block():\n   self._write_docstring_and_traverse_body(node)\n   \n def visit_FunctionDef(self,node):\n  self._function_helper(node,\"def\")\n  \n def visit_AsyncFunctionDef(self,node):\n  self._function_helper(node,\"async def\")\n  \n def _function_helper(self,node,fill_suffix):\n  self.maybe_newline()\n  for deco in node.decorator_list:\n   self.fill(\"@\")\n   self.traverse(deco)\n  def_str=fill_suffix+\" \"+node.name\n  self.fill(def_str)\n  if hasattr(node,\"type_params\"):\n   self._type_params_helper(node.type_params)\n  with self.delimit(\"(\",\")\"):\n   self.traverse(node.args)\n  if node.returns:\n   self.write(\" -> \")\n   self.traverse(node.returns)\n  with self.block(extra=self.get_type_comment(node)):\n   self._write_docstring_and_traverse_body(node)\n   \n def _type_params_helper(self,type_params):\n  if type_params is not None and len(type_params)>0:\n   with self.delimit(\"[\",\"]\"):\n    self.interleave(lambda:self.write(\", \"),self.traverse,type_params)\n    \n def visit_TypeVar(self,node):\n  self.write(node.name)\n  if node.bound:\n   self.write(\": \")\n   self.traverse(node.bound)\n  if node.default_value:\n   self.write(\" = \")\n   self.traverse(node.default_value)\n   \n def visit_TypeVarTuple(self,node):\n  self.write(\"*\"+node.name)\n  if node.default_value:\n   self.write(\" = \")\n   self.traverse(node.default_value)\n   \n def visit_ParamSpec(self,node):\n  self.write(\"**\"+node.name)\n  if node.default_value:\n   self.write(\" = \")\n   self.traverse(node.default_value)\n   \n def visit_TypeAlias(self,node):\n  self.fill(\"type \")\n  self.traverse(node.name)\n  self._type_params_helper(node.type_params)\n  self.write(\" = \")\n  self.traverse(node.value)\n  \n def visit_For(self,node):\n  self._for_helper(\"for \",node)\n  \n def visit_AsyncFor(self,node):\n  self._for_helper(\"async for \",node)\n  \n def _for_helper(self,fill,node):\n  self.fill(fill)\n  self.set_precedence(_Precedence.TUPLE,node.target)\n  self.traverse(node.target)\n  self.write(\" in \")\n  self.traverse(node.iter)\n  with self.block(extra=self.get_type_comment(node)):\n   self.traverse(node.body)\n  if node.orelse:\n   self.fill(\"else\")\n   with self.block():\n    self.traverse(node.orelse)\n    \n def visit_If(self,node):\n  self.fill(\"if \")\n  self.traverse(node.test)\n  with self.block():\n   self.traverse(node.body)\n   \n  while node.orelse and len(node.orelse)==1 and isinstance(node.orelse[0],If):\n   node=node.orelse[0]\n   self.fill(\"elif \")\n   self.traverse(node.test)\n   with self.block():\n    self.traverse(node.body)\n    \n  if node.orelse:\n   self.fill(\"else\")\n   with self.block():\n    self.traverse(node.orelse)\n    \n def visit_While(self,node):\n  self.fill(\"while \")\n  self.traverse(node.test)\n  with self.block():\n   self.traverse(node.body)\n  if node.orelse:\n   self.fill(\"else\")\n   with self.block():\n    self.traverse(node.orelse)\n    \n def visit_With(self,node):\n  self.fill(\"with \")\n  self.interleave(lambda:self.write(\", \"),self.traverse,node.items)\n  with self.block(extra=self.get_type_comment(node)):\n   self.traverse(node.body)\n   \n def visit_AsyncWith(self,node):\n  self.fill(\"async with \")\n  self.interleave(lambda:self.write(\", \"),self.traverse,node.items)\n  with self.block(extra=self.get_type_comment(node)):\n   self.traverse(node.body)\n   \n def _str_literal_helper(\n self,string,*,quote_types=_ALL_QUOTES,escape_special_whitespace=False\n ):\n  ''\n\n  \n  def escape_char(c):\n  \n  \n   if not escape_special_whitespace and c in \"\\n\\t\":\n    return c\n    \n   if c ==\"\\\\\"or not c.isprintable():\n    return c.encode(\"unicode_escape\").decode(\"ascii\")\n   return c\n   \n  escaped_string=\"\".join(map(escape_char,string))\n  possible_quotes=quote_types\n  if \"\\n\"in escaped_string:\n   possible_quotes=[q for q in possible_quotes if q in _MULTI_QUOTES]\n  possible_quotes=[q for q in possible_quotes if q not in escaped_string]\n  if not possible_quotes:\n  \n  \n  \n   string=repr(string)\n   quote=next((q for q in quote_types if string[0]in q),string[0])\n   return string[1:-1],[quote]\n  if escaped_string:\n  \n   possible_quotes.sort(key=lambda q:q[0]==escaped_string[-1])\n   \n   \n   if possible_quotes[0][0]==escaped_string[-1]:\n    assert len(possible_quotes[0])==3\n    escaped_string=escaped_string[:-1]+\"\\\\\"+escaped_string[-1]\n  return escaped_string,possible_quotes\n  \n def _write_str_avoiding_backslashes(self,string,*,quote_types=_ALL_QUOTES):\n  ''\n  string,quote_types=self._str_literal_helper(string,quote_types=quote_types)\n  quote_type=quote_types[0]\n  self.write(f\"{quote_type}{string}{quote_type}\")\n  \n def visit_JoinedStr(self,node):\n  self.write(\"f\")\n  \n  fstring_parts=[]\n  for value in node.values:\n   with self.buffered()as buffer:\n    self._write_fstring_inner(value)\n   fstring_parts.append(\n   (\"\".join(buffer),isinstance(value,Constant))\n   )\n   \n  new_fstring_parts=[]\n  quote_types=list(_ALL_QUOTES)\n  fallback_to_repr=False\n  for value,is_constant in fstring_parts:\n   if is_constant:\n    value,new_quote_types=self._str_literal_helper(\n    value,\n    quote_types=quote_types,\n    escape_special_whitespace=True,\n    )\n    if set(new_quote_types).isdisjoint(quote_types):\n     fallback_to_repr=True\n     break\n    quote_types=new_quote_types\n   elif \"\\n\"in value:\n    quote_types=[q for q in quote_types if q in _MULTI_QUOTES]\n    assert quote_types\n   new_fstring_parts.append(value)\n   \n  if fallback_to_repr:\n  \n  \n   quote_types=[\"'''\"]\n   new_fstring_parts.clear()\n   for value,is_constant in fstring_parts:\n    if is_constant:\n     value=repr('\"'+value)\n     expected_prefix=\"'\\\"\"\n     assert value.startswith(expected_prefix),repr(value)\n     value=value[len(expected_prefix):-1]\n    new_fstring_parts.append(value)\n    \n  value=\"\".join(new_fstring_parts)\n  quote_type=quote_types[0]\n  self.write(f\"{quote_type}{value}{quote_type}\")\n  \n def _write_fstring_inner(self,node,is_format_spec=False):\n  if isinstance(node,JoinedStr):\n  \n   for value in node.values:\n    self._write_fstring_inner(value,is_format_spec=is_format_spec)\n  elif isinstance(node,Constant)and isinstance(node.value,str):\n   value=node.value.replace(\"{\",\"{{\").replace(\"}\",\"}}\")\n   \n   if is_format_spec:\n    value=value.replace(\"\\\\\",\"\\\\\\\\\")\n    value=value.replace(\"'\",\"\\\\'\")\n    value=value.replace('\"','\\\\\"')\n    value=value.replace(\"\\n\",\"\\\\n\")\n   self.write(value)\n  elif isinstance(node,FormattedValue):\n   self.visit_FormattedValue(node)\n  else:\n   raise ValueError(f\"Unexpected node inside JoinedStr, {node !r}\")\n   \n def visit_FormattedValue(self,node):\n  def unparse_inner(inner):\n   unparser=type(self)()\n   unparser.set_precedence(_Precedence.TEST.next(),inner)\n   return unparser.visit(inner)\n   \n  with self.delimit(\"{\",\"}\"):\n   expr=unparse_inner(node.value)\n   if expr.startswith(\"{\"):\n   \n    self.write(\" \")\n   self.write(expr)\n   if node.conversion !=-1:\n    self.write(f\"!{chr(node.conversion)}\")\n   if node.format_spec:\n    self.write(\":\")\n    self._write_fstring_inner(node.format_spec,is_format_spec=True)\n    \n def visit_Name(self,node):\n  self.write(node.id)\n  \n def _write_docstring(self,node):\n  self.fill()\n  if node.kind ==\"u\":\n   self.write(\"u\")\n  self._write_str_avoiding_backslashes(node.value,quote_types=_MULTI_QUOTES)\n  \n def _write_constant(self,value):\n  if isinstance(value,(float,complex)):\n  \n  \n   self.write(\n   repr(value)\n   .replace(\"inf\",_INFSTR)\n   .replace(\"nan\",f\"({_INFSTR}-{_INFSTR})\")\n   )\n  else:\n   self.write(repr(value))\n   \n def visit_Constant(self,node):\n  value=node.value\n  if isinstance(value,tuple):\n   with self.delimit(\"(\",\")\"):\n    self.items_view(self._write_constant,value)\n  elif value is ...:\n   self.write(\"...\")\n  else:\n   if node.kind ==\"u\":\n    self.write(\"u\")\n   self._write_constant(node.value)\n   \n def visit_List(self,node):\n  with self.delimit(\"[\",\"]\"):\n   self.interleave(lambda:self.write(\", \"),self.traverse,node.elts)\n   \n def visit_ListComp(self,node):\n  with self.delimit(\"[\",\"]\"):\n   self.traverse(node.elt)\n   for gen in node.generators:\n    self.traverse(gen)\n    \n def visit_GeneratorExp(self,node):\n  with self.delimit(\"(\",\")\"):\n   self.traverse(node.elt)\n   for gen in node.generators:\n    self.traverse(gen)\n    \n def visit_SetComp(self,node):\n  with self.delimit(\"{\",\"}\"):\n   self.traverse(node.elt)\n   for gen in node.generators:\n    self.traverse(gen)\n    \n def visit_DictComp(self,node):\n  with self.delimit(\"{\",\"}\"):\n   self.traverse(node.key)\n   self.write(\": \")\n   self.traverse(node.value)\n   for gen in node.generators:\n    self.traverse(gen)\n    \n def visit_comprehension(self,node):\n  if node.is_async:\n   self.write(\" async for \")\n  else:\n   self.write(\" for \")\n  self.set_precedence(_Precedence.TUPLE,node.target)\n  self.traverse(node.target)\n  self.write(\" in \")\n  self.set_precedence(_Precedence.TEST.next(),node.iter,*node.ifs)\n  self.traverse(node.iter)\n  for if_clause in node.ifs:\n   self.write(\" if \")\n   self.traverse(if_clause)\n   \n def visit_IfExp(self,node):\n  with self.require_parens(_Precedence.TEST,node):\n   self.set_precedence(_Precedence.TEST.next(),node.body,node.test)\n   self.traverse(node.body)\n   self.write(\" if \")\n   self.traverse(node.test)\n   self.write(\" else \")\n   self.set_precedence(_Precedence.TEST,node.orelse)\n   self.traverse(node.orelse)\n   \n def visit_Set(self,node):\n  if node.elts:\n   with self.delimit(\"{\",\"}\"):\n    self.interleave(lambda:self.write(\", \"),self.traverse,node.elts)\n  else:\n  \n  \n   self.write('{*()}')\n   \n def visit_Dict(self,node):\n  def write_key_value_pair(k,v):\n   self.traverse(k)\n   self.write(\": \")\n   self.traverse(v)\n   \n  def write_item(item):\n   k,v=item\n   if k is None:\n   \n   \n    self.write(\"**\")\n    self.set_precedence(_Precedence.EXPR,v)\n    self.traverse(v)\n   else:\n    write_key_value_pair(k,v)\n    \n  with self.delimit(\"{\",\"}\"):\n   self.interleave(\n   lambda:self.write(\", \"),write_item,zip(node.keys,node.values)\n   )\n   \n def visit_Tuple(self,node):\n  with self.delimit_if(\n  \"(\",\n  \")\",\n  len(node.elts)==0 or self.get_precedence(node)>_Precedence.TUPLE\n  ):\n   self.items_view(self.traverse,node.elts)\n   \n unop={\"Invert\":\"~\",\"Not\":\"not\",\"UAdd\":\"+\",\"USub\":\"-\"}\n unop_precedence={\n \"not\":_Precedence.NOT,\n \"~\":_Precedence.FACTOR,\n \"+\":_Precedence.FACTOR,\n \"-\":_Precedence.FACTOR,\n }\n \n def visit_UnaryOp(self,node):\n  operator=self.unop[node.op.__class__.__name__]\n  operator_precedence=self.unop_precedence[operator]\n  with self.require_parens(operator_precedence,node):\n   self.write(operator)\n   \n   \n   if operator_precedence is not _Precedence.FACTOR:\n    self.write(\" \")\n   self.set_precedence(operator_precedence,node.operand)\n   self.traverse(node.operand)\n   \n binop={\n \"Add\":\"+\",\n \"Sub\":\"-\",\n \"Mult\":\"*\",\n \"MatMult\":\"@\",\n \"Div\":\"/\",\n \"Mod\":\"%\",\n \"LShift\":\"<<\",\n \"RShift\":\">>\",\n \"BitOr\":\"|\",\n \"BitXor\":\"^\",\n \"BitAnd\":\"&\",\n \"FloorDiv\":\"//\",\n \"Pow\":\"**\",\n }\n \n binop_precedence={\n \"+\":_Precedence.ARITH,\n \"-\":_Precedence.ARITH,\n \"*\":_Precedence.TERM,\n \"@\":_Precedence.TERM,\n \"/\":_Precedence.TERM,\n \"%\":_Precedence.TERM,\n \"<<\":_Precedence.SHIFT,\n \">>\":_Precedence.SHIFT,\n \"|\":_Precedence.BOR,\n \"^\":_Precedence.BXOR,\n \"&\":_Precedence.BAND,\n \"//\":_Precedence.TERM,\n \"**\":_Precedence.POWER,\n }\n \n binop_rassoc=frozenset((\"**\",))\n def visit_BinOp(self,node):\n  operator=self.binop[node.op.__class__.__name__]\n  operator_precedence=self.binop_precedence[operator]\n  with self.require_parens(operator_precedence,node):\n   if operator in self.binop_rassoc:\n    left_precedence=operator_precedence.next()\n    right_precedence=operator_precedence\n   else:\n    left_precedence=operator_precedence\n    right_precedence=operator_precedence.next()\n    \n   self.set_precedence(left_precedence,node.left)\n   self.traverse(node.left)\n   self.write(f\" {operator} \")\n   self.set_precedence(right_precedence,node.right)\n   self.traverse(node.right)\n   \n cmpops={\n \"Eq\":\"==\",\n \"NotEq\":\"!=\",\n \"Lt\":\"<\",\n \"LtE\":\"<=\",\n \"Gt\":\">\",\n \"GtE\":\">=\",\n \"Is\":\"is\",\n \"IsNot\":\"is not\",\n \"In\":\"in\",\n \"NotIn\":\"not in\",\n }\n \n def visit_Compare(self,node):\n  with self.require_parens(_Precedence.CMP,node):\n   self.set_precedence(_Precedence.CMP.next(),node.left,*node.comparators)\n   self.traverse(node.left)\n   for o,e in zip(node.ops,node.comparators):\n    self.write(\" \"+self.cmpops[o.__class__.__name__]+\" \")\n    self.traverse(e)\n    \n boolops={\"And\":\"and\",\"Or\":\"or\"}\n boolop_precedence={\"and\":_Precedence.AND,\"or\":_Precedence.OR}\n \n def visit_BoolOp(self,node):\n  operator=self.boolops[node.op.__class__.__name__]\n  operator_precedence=self.boolop_precedence[operator]\n  \n  def increasing_level_traverse(node):\n   nonlocal operator_precedence\n   operator_precedence=operator_precedence.next()\n   self.set_precedence(operator_precedence,node)\n   self.traverse(node)\n   \n  with self.require_parens(operator_precedence,node):\n   s=f\" {operator} \"\n   self.interleave(lambda:self.write(s),increasing_level_traverse,node.values)\n   \n def visit_Attribute(self,node):\n  self.set_precedence(_Precedence.ATOM,node.value)\n  self.traverse(node.value)\n  \n  \n  \n  if isinstance(node.value,Constant)and isinstance(node.value.value,int):\n   self.write(\" \")\n  self.write(\".\")\n  self.write(node.attr)\n  \n def visit_Call(self,node):\n  self.set_precedence(_Precedence.ATOM,node.func)\n  self.traverse(node.func)\n  with self.delimit(\"(\",\")\"):\n   comma=False\n   for e in node.args:\n    if comma:\n     self.write(\", \")\n    else:\n     comma=True\n    self.traverse(e)\n   for e in node.keywords:\n    if comma:\n     self.write(\", \")\n    else:\n     comma=True\n    self.traverse(e)\n    \n def visit_Subscript(self,node):\n  def is_non_empty_tuple(slice_value):\n   return(\n   isinstance(slice_value,Tuple)\n   and slice_value.elts\n   )\n   \n  self.set_precedence(_Precedence.ATOM,node.value)\n  self.traverse(node.value)\n  with self.delimit(\"[\",\"]\"):\n   if is_non_empty_tuple(node.slice):\n   \n    self.items_view(self.traverse,node.slice.elts)\n   else:\n    self.traverse(node.slice)\n    \n def visit_Starred(self,node):\n  self.write(\"*\")\n  self.set_precedence(_Precedence.EXPR,node.value)\n  self.traverse(node.value)\n  \n def visit_Ellipsis(self,node):\n  self.write(\"...\")\n  \n def visit_Slice(self,node):\n  if node.lower:\n   self.traverse(node.lower)\n  self.write(\":\")\n  if node.upper:\n   self.traverse(node.upper)\n  if node.step:\n   self.write(\":\")\n   self.traverse(node.step)\n   \n def visit_Match(self,node):\n  self.fill(\"match \")\n  self.traverse(node.subject)\n  with self.block():\n   for case in node.cases:\n    self.traverse(case)\n    \n def visit_arg(self,node):\n  self.write(node.arg)\n  if node.annotation:\n   self.write(\": \")\n   self.traverse(node.annotation)\n   \n def visit_arguments(self,node):\n  first=True\n  \n  all_args=node.posonlyargs+node.args\n  defaults=[None]*(len(all_args)-len(node.defaults))+node.defaults\n  for index,elements in enumerate(zip(all_args,defaults),1):\n   a,d=elements\n   if first:\n    first=False\n   else:\n    self.write(\", \")\n   self.traverse(a)\n   if d:\n    self.write(\"=\")\n    self.traverse(d)\n   if index ==len(node.posonlyargs):\n    self.write(\", /\")\n    \n    \n  if node.vararg or node.kwonlyargs:\n   if first:\n    first=False\n   else:\n    self.write(\", \")\n   self.write(\"*\")\n   if node.vararg:\n    self.write(node.vararg.arg)\n    if node.vararg.annotation:\n     self.write(\": \")\n     self.traverse(node.vararg.annotation)\n     \n     \n  if node.kwonlyargs:\n   for a,d in zip(node.kwonlyargs,node.kw_defaults):\n    self.write(\", \")\n    self.traverse(a)\n    if d:\n     self.write(\"=\")\n     self.traverse(d)\n     \n     \n  if node.kwarg:\n   if first:\n    first=False\n   else:\n    self.write(\", \")\n   self.write(\"**\"+node.kwarg.arg)\n   if node.kwarg.annotation:\n    self.write(\": \")\n    self.traverse(node.kwarg.annotation)\n    \n def visit_keyword(self,node):\n  if node.arg is None:\n   self.write(\"**\")\n  else:\n   self.write(node.arg)\n   self.write(\"=\")\n  self.traverse(node.value)\n  \n def visit_Lambda(self,node):\n  with self.require_parens(_Precedence.TEST,node):\n   self.write(\"lambda\")\n   with self.buffered()as buffer:\n    self.traverse(node.args)\n   if buffer:\n    self.write(\" \",*buffer)\n   self.write(\": \")\n   self.set_precedence(_Precedence.TEST,node.body)\n   self.traverse(node.body)\n   \n def visit_alias(self,node):\n  self.write(node.name)\n  if node.asname:\n   self.write(\" as \"+node.asname)\n   \n def visit_withitem(self,node):\n  self.traverse(node.context_expr)\n  if node.optional_vars:\n   self.write(\" as \")\n   self.traverse(node.optional_vars)\n   \n def visit_match_case(self,node):\n  self.fill(\"case \")\n  self.traverse(node.pattern)\n  if node.guard:\n   self.write(\" if \")\n   self.traverse(node.guard)\n  with self.block():\n   self.traverse(node.body)\n   \n def visit_MatchValue(self,node):\n  self.traverse(node.value)\n  \n def visit_MatchSingleton(self,node):\n  self._write_constant(node.value)\n  \n def visit_MatchSequence(self,node):\n  with self.delimit(\"[\",\"]\"):\n   self.interleave(\n   lambda:self.write(\", \"),self.traverse,node.patterns\n   )\n   \n def visit_MatchStar(self,node):\n  name=node.name\n  if name is None:\n   name=\"_\"\n  self.write(f\"*{name}\")\n  \n def visit_MatchMapping(self,node):\n  def write_key_pattern_pair(pair):\n   k,p=pair\n   self.traverse(k)\n   self.write(\": \")\n   self.traverse(p)\n   \n  with self.delimit(\"{\",\"}\"):\n   keys=node.keys\n   self.interleave(\n   lambda:self.write(\", \"),\n   write_key_pattern_pair,\n   zip(keys,node.patterns,strict=True),\n   )\n   rest=node.rest\n   if rest is not None:\n    if keys:\n     self.write(\", \")\n    self.write(f\"**{rest}\")\n    \n def visit_MatchClass(self,node):\n  self.set_precedence(_Precedence.ATOM,node.cls)\n  self.traverse(node.cls)\n  with self.delimit(\"(\",\")\"):\n   patterns=node.patterns\n   self.interleave(\n   lambda:self.write(\", \"),self.traverse,patterns\n   )\n   attrs=node.kwd_attrs\n   if attrs:\n    def write_attr_pattern(pair):\n     attr,pattern=pair\n     self.write(f\"{attr}=\")\n     self.traverse(pattern)\n     \n    if patterns:\n     self.write(\", \")\n    self.interleave(\n    lambda:self.write(\", \"),\n    write_attr_pattern,\n    zip(attrs,node.kwd_patterns,strict=True),\n    )\n    \n def visit_MatchAs(self,node):\n  name=node.name\n  pattern=node.pattern\n  if name is None:\n   self.write(\"_\")\n  elif pattern is None:\n   self.write(node.name)\n  else:\n   with self.require_parens(_Precedence.TEST,node):\n    self.set_precedence(_Precedence.BOR,node.pattern)\n    self.traverse(node.pattern)\n    self.write(f\" as {node.name}\")\n    \n def visit_MatchOr(self,node):\n  with self.require_parens(_Precedence.BOR,node):\n   self.set_precedence(_Precedence.BOR.next(),*node.patterns)\n   self.interleave(lambda:self.write(\" | \"),self.traverse,node.patterns)\n   \ndef unparse(ast_obj):\n unparser=_Unparser()\n return unparser.visit(ast_obj)\n \n \n_deprecated_globals={\nname:globals().pop(name)\nfor name in('Num','Str','Bytes','NameConstant','Ellipsis')\n}\n\ndef __getattr__(name):\n if name in _deprecated_globals:\n  globals()[name]=value=_deprecated_globals[name]\n  import warnings\n  warnings._deprecated(\n  f\"ast.{name}\",message=_DEPRECATED_CLASS_MESSAGE,remove=(3,14)\n  )\n  return value\n raise AttributeError(f\"module 'ast' has no attribute '{name}'\")\n \n \ndef main():\n import argparse\n \n parser=argparse.ArgumentParser(prog='python -m ast')\n parser.add_argument('infile',nargs='?',default='-',\n help='the file to parse; defaults to stdin')\n parser.add_argument('-m','--mode',default='exec',\n choices=('exec','single','eval','func_type'),\n help='specify what kind of code must be parsed')\n parser.add_argument('--no-type-comments',default=True,action='store_false',\n help=\"don't add information about type comments\")\n parser.add_argument('-a','--include-attributes',action='store_true',\n help='include attributes such as line numbers and '\n 'column offsets')\n parser.add_argument('-i','--indent',type=int,default=3,\n help='indentation of nodes (number of spaces)')\n args=parser.parse_args()\n \n if args.infile =='-':\n  name='<stdin>'\n  source=sys.stdin.buffer.read()\n else:\n  name=args.infile\n  with open(args.infile,'rb')as infile:\n   source=infile.read()\n tree=parse(source,name,args.mode,type_comments=args.no_type_comments)\n print(dump(tree,include_attributes=args.include_attributes,indent=args.indent))\n \nif __name__ =='__main__':\n main()\n", ["_ast", "argparse", "collections", "contextlib", "enum", "inspect", "re", "sys", "warnings"]], "binascii": [".py", "''\n\n\n\n\n\n\n\nimport _base64\n\nfrom _binascii import *\n\nclass Error(ValueError):\n def __init__(self,msg=''):\n  self._msg=msg\n  \n def __str__(self):\n  return \" binascii.Error: \"+self._msg\n  \n  \nclass Done(Exception):\n pass\n \nclass Incomplete(Error):\n pass\n \ndef a2b_uu(s):\n if not s:\n  return ''\n  \n length=(ord(s[0])-0x20)%64\n \n def quadruplets_gen(s):\n  while s:\n   try:\n    yield ord(s[0]),ord(s[1]),ord(s[2]),ord(s[3])\n   except IndexError:\n    s +='   '\n    yield ord(s[0]),ord(s[1]),ord(s[2]),ord(s[3])\n    return\n   s=s[4:]\n   \n try:\n  result=[''.join(\n  [chr((A -0x20)<<2 |(((B -0x20)>>4)&0x3)),\n  chr(((B -0x20)&0xf)<<4 |(((C -0x20)>>2)&0xf)),\n  chr(((C -0x20)&0x3)<<6 |((D -0x20)&0x3f))\n  ])for A,B,C,D in quadruplets_gen(s[1:].rstrip())]\n except ValueError:\n  raise Error('Illegal char')\n result=''.join(result)\n trailingdata=result[length:]\n if trailingdata.strip('\\x00'):\n  raise Error('Trailing garbage')\n result=result[:length]\n if len(result)<length:\n  result +=((length -len(result))*'\\x00')\n return bytes(result,__BRYTHON__.charset)\n \n \ntable_a2b_base64={\n'A':0,\n'B':1,\n'C':2,\n'D':3,\n'E':4,\n'F':5,\n'G':6,\n'H':7,\n'I':8,\n'J':9,\n'K':10,\n'L':11,\n'M':12,\n'N':13,\n'O':14,\n'P':15,\n'Q':16,\n'R':17,\n'S':18,\n'T':19,\n'U':20,\n'V':21,\n'W':22,\n'X':23,\n'Y':24,\n'Z':25,\n'a':26,\n'b':27,\n'c':28,\n'd':29,\n'e':30,\n'f':31,\n'g':32,\n'h':33,\n'i':34,\n'j':35,\n'k':36,\n'l':37,\n'm':38,\n'n':39,\n'o':40,\n'p':41,\n'q':42,\n'r':43,\n's':44,\n't':45,\n'u':46,\n'v':47,\n'w':48,\n'x':49,\n'y':50,\n'z':51,\n'0':52,\n'1':53,\n'2':54,\n'3':55,\n'4':56,\n'5':57,\n'6':58,\n'7':59,\n'8':60,\n'9':61,\n'+':62,\n'/':63,\n'=':0,\n}\n\n\ndef XXXa2b_base64(s):\n return _base64.Base64.decode(s)\n \ntable_b2a_base64=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\\\n\"0123456789+/\"\n\ndef XXXb2a_base64(s,newline=True):\n length=len(s)\n final_length=length %3\n \n def triples_gen(s):\n  while s:\n   try:\n    yield s[0],s[1],s[2]\n   except IndexError:\n    s +=b'\\0\\0'\n    yield s[0],s[1],s[2]\n    return\n   s=s[3:]\n   \n a=triples_gen(s[:length -final_length])\n \n result=[''.join(\n [table_b2a_base64[(A >>2)&0x3F],\n table_b2a_base64[((A <<4)|((B >>4)&0xF))&0x3F],\n table_b2a_base64[((B <<2)|((C >>6)&0x3))&0x3F],\n table_b2a_base64[(C)&0x3F]])\n for A,B,C in a]\n \n final=s[length -final_length:]\n if final_length ==0:\n  snippet=''\n elif final_length ==1:\n  a=final[0]\n  snippet=table_b2a_base64[(a >>2)&0x3F]+\\\n  table_b2a_base64[(a <<4)&0x3F]+'=='\n else:\n  a=final[0]\n  b=final[1]\n  snippet=table_b2a_base64[(a >>2)&0x3F]+\\\n  table_b2a_base64[((a <<4)|(b >>4)&0xF)&0x3F]+\\\n  table_b2a_base64[(b <<2)&0x3F]+'='\n  \n result=''.join(result)+snippet\n if newline:\n  result +='\\n'\n return bytes(result,__BRYTHON__.charset)\n \ndef a2b_qp(s,header=False):\n inp=0\n odata=[]\n while inp <len(s):\n  if s[inp]=='=':\n   inp +=1\n   if inp >=len(s):\n    break\n    \n   if(s[inp]=='\\n')or(s[inp]=='\\r'):\n    if s[inp]!='\\n':\n     while inp <len(s)and s[inp]!='\\n':\n      inp +=1\n    if inp <len(s):\n     inp +=1\n   elif s[inp]=='=':\n   \n    odata.append('=')\n    inp +=1\n   elif s[inp]in hex_numbers and s[inp+1]in hex_numbers:\n    ch=chr(int(s[inp:inp+2],16))\n    inp +=2\n    odata.append(ch)\n   else:\n    odata.append('=')\n  elif header and s[inp]=='_':\n   odata.append(' ')\n   inp +=1\n  else:\n   odata.append(s[inp])\n   inp +=1\n return bytes(''.join(odata),__BRYTHON__.charset)\n \ndef b2a_qp(data,quotetabs=False,istext=True,header=False):\n ''\n\n\n\n\n \n MAXLINESIZE=76\n \n \n lf=data.find('\\n')\n crlf=lf >0 and data[lf -1]=='\\r'\n \n inp=0\n linelen=0\n odata=[]\n while inp <len(data):\n  c=data[inp]\n  if(c >'~'or\n  c =='='or\n  (header and c =='_')or\n  (c =='.'and linelen ==0 and(inp+1 ==len(data)or\n  data[inp+1]=='\\n'or\n  data[inp+1]=='\\r'))or\n  (not istext and(c =='\\r'or c =='\\n'))or\n  ((c =='\\t'or c ==' ')and(inp+1 ==len(data)))or\n  (c <=' 'and c !='\\r'and c !='\\n'and\n  (quotetabs or(not quotetabs and(c !='\\t'and c !=' '))))):\n   linelen +=3\n   if linelen >=MAXLINESIZE:\n    odata.append('=')\n    if crlf:odata.append('\\r')\n    odata.append('\\n')\n    linelen=3\n   odata.append('='+two_hex_digits(ord(c)))\n   inp +=1\n  else:\n   if(istext and\n   (c =='\\n'or(inp+1 <len(data)and c =='\\r'and\n   data[inp+1]=='\\n'))):\n    linelen=0\n    \n    if(len(odata)>0 and\n    (odata[-1]==' 'or odata[-1]=='\\t')):\n     ch=ord(odata[-1])\n     odata[-1]='='\n     odata.append(two_hex_digits(ch))\n     \n    if crlf:odata.append('\\r')\n    odata.append('\\n')\n    if c =='\\r':\n     inp +=2\n    else:\n     inp +=1\n   else:\n    if(inp+1 <len(data)and\n    data[inp+1]!='\\n'and\n    (linelen+1)>=MAXLINESIZE):\n     odata.append('=')\n     if crlf:odata.append('\\r')\n     odata.append('\\n')\n     linelen=0\n     \n    linelen +=1\n    if header and c ==' ':\n     c='_'\n    odata.append(c)\n    inp +=1\n return ''.join(odata)\n \nhex_numbers='0123456789ABCDEF'\ndef hex(n):\n if n ==0:\n  return '0'\n  \n if n <0:\n  n=-n\n  sign='-'\n else:\n  sign=''\n arr=[]\n \n def hex_gen(n):\n  ''\n  while n:\n   yield n %0x10\n   n=n /0x10\n   \n for nibble in hex_gen(n):\n  arr=[hex_numbers[nibble]]+arr\n return sign+''.join(arr)\n \ndef two_hex_digits(n):\n return hex_numbers[n /0x10]+hex_numbers[n %0x10]\n \n \ndef strhex_to_int(s):\n i=0\n for c in s:\n  i=i *0x10+hex_numbers.index(c)\n return i\n \nhqx_encoding='!\"#$%&\\'()*+,-012345689@ABCDEFGHIJKLMNPQRSTUVXYZ[`abcdefhijklmpqr'\n\nDONE=0x7f\nSKIP=0x7e\nFAIL=0x7d\n\ntable_a2b_hqx=[\n\nFAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,\n\nFAIL,FAIL,SKIP,FAIL,FAIL,SKIP,FAIL,FAIL,\n\nFAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,\n\nFAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,\n\nFAIL,0x00,0x01,0x02,0x03,0x04,0x05,0x06,\n\n0x07,0x08,0x09,0x0A,0x0B,0x0C,FAIL,FAIL,\n\n0x0D,0x0E,0x0F,0x10,0x11,0x12,0x13,FAIL,\n\n0x14,0x15,DONE,FAIL,FAIL,FAIL,FAIL,FAIL,\n\n0x16,0x17,0x18,0x19,0x1A,0x1B,0x1C,0x1D,\n\n0x1E,0x1F,0x20,0x21,0x22,0x23,0x24,FAIL,\n\n0x25,0x26,0x27,0x28,0x29,0x2A,0x2B,FAIL,\n\n0x2C,0x2D,0x2E,0x2F,FAIL,FAIL,FAIL,FAIL,\n\n0x30,0x31,0x32,0x33,0x34,0x35,0x36,FAIL,\n\n0x37,0x38,0x39,0x3A,0x3B,0x3C,FAIL,FAIL,\n\n0x3D,0x3E,0x3F,FAIL,FAIL,FAIL,FAIL,FAIL,\n\nFAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,\nFAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,\nFAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,\nFAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,\nFAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,\nFAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,\nFAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,\nFAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,\nFAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,\nFAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,\nFAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,\nFAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,\nFAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,\nFAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,\nFAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,\nFAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,\nFAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,\n]\n\ndef a2b_hqx(s):\n result=[]\n \n def quadruples_gen(s):\n  t=[]\n  for c in s:\n   res=table_a2b_hqx[ord(c)]\n   if res ==SKIP:\n    continue\n   elif res ==FAIL:\n    raise Error('Illegal character')\n   elif res ==DONE:\n    yield t\n    raise Done\n   else:\n    t.append(res)\n   if len(t)==4:\n    yield t\n    t=[]\n  yield t\n  \n done=0\n try:\n  for snippet in quadruples_gen(s):\n   length=len(snippet)\n   if length ==4:\n    result.append(chr(((snippet[0]&0x3f)<<2)|(snippet[1]>>4)))\n    result.append(chr(((snippet[1]&0x0f)<<4)|(snippet[2]>>2)))\n    result.append(chr(((snippet[2]&0x03)<<6)|(snippet[3])))\n   elif length ==3:\n    result.append(chr(((snippet[0]&0x3f)<<2)|(snippet[1]>>4)))\n    result.append(chr(((snippet[1]&0x0f)<<4)|(snippet[2]>>2)))\n   elif length ==2:\n    result.append(chr(((snippet[0]&0x3f)<<2)|(snippet[1]>>4)))\n except Done:\n  done=1\n except Error:\n  raise\n return(''.join(result),done)\n \n \n \ndef b2a_hqx(s):\n result=[]\n \n def triples_gen(s):\n  while s:\n   try:\n    yield ord(s[0]),ord(s[1]),ord(s[2])\n   except IndexError:\n    yield tuple([ord(c)for c in s])\n   s=s[3:]\n   \n for snippet in triples_gen(s):\n  length=len(snippet)\n  if length ==3:\n   result.append(\n   hqx_encoding[(snippet[0]&0xfc)>>2])\n   result.append(hqx_encoding[\n   ((snippet[0]&0x03)<<4)|((snippet[1]&0xf0)>>4)])\n   result.append(hqx_encoding[\n   (snippet[1]&0x0f)<<2 |((snippet[2]&0xc0)>>6)])\n   result.append(hqx_encoding[snippet[2]&0x3f])\n  elif length ==2:\n   result.append(\n   hqx_encoding[(snippet[0]&0xfc)>>2])\n   result.append(hqx_encoding[\n   ((snippet[0]&0x03)<<4)|((snippet[1]&0xf0)>>4)])\n   result.append(hqx_encoding[\n   (snippet[1]&0x0f)<<2])\n  elif length ==1:\n   result.append(\n   hqx_encoding[(snippet[0]&0xfc)>>2])\n   result.append(hqx_encoding[\n   ((snippet[0]&0x03)<<4)])\n return ''.join(result)\n \ncrctab_hqx=[\n0x0000,0x1021,0x2042,0x3063,0x4084,0x50a5,0x60c6,0x70e7,\n0x8108,0x9129,0xa14a,0xb16b,0xc18c,0xd1ad,0xe1ce,0xf1ef,\n0x1231,0x0210,0x3273,0x2252,0x52b5,0x4294,0x72f7,0x62d6,\n0x9339,0x8318,0xb37b,0xa35a,0xd3bd,0xc39c,0xf3ff,0xe3de,\n0x2462,0x3443,0x0420,0x1401,0x64e6,0x74c7,0x44a4,0x5485,\n0xa56a,0xb54b,0x8528,0x9509,0xe5ee,0xf5cf,0xc5ac,0xd58d,\n0x3653,0x2672,0x1611,0x0630,0x76d7,0x66f6,0x5695,0x46b4,\n0xb75b,0xa77a,0x9719,0x8738,0xf7df,0xe7fe,0xd79d,0xc7bc,\n0x48c4,0x58e5,0x6886,0x78a7,0x0840,0x1861,0x2802,0x3823,\n0xc9cc,0xd9ed,0xe98e,0xf9af,0x8948,0x9969,0xa90a,0xb92b,\n0x5af5,0x4ad4,0x7ab7,0x6a96,0x1a71,0x0a50,0x3a33,0x2a12,\n0xdbfd,0xcbdc,0xfbbf,0xeb9e,0x9b79,0x8b58,0xbb3b,0xab1a,\n0x6ca6,0x7c87,0x4ce4,0x5cc5,0x2c22,0x3c03,0x0c60,0x1c41,\n0xedae,0xfd8f,0xcdec,0xddcd,0xad2a,0xbd0b,0x8d68,0x9d49,\n0x7e97,0x6eb6,0x5ed5,0x4ef4,0x3e13,0x2e32,0x1e51,0x0e70,\n0xff9f,0xefbe,0xdfdd,0xcffc,0xbf1b,0xaf3a,0x9f59,0x8f78,\n0x9188,0x81a9,0xb1ca,0xa1eb,0xd10c,0xc12d,0xf14e,0xe16f,\n0x1080,0x00a1,0x30c2,0x20e3,0x5004,0x4025,0x7046,0x6067,\n0x83b9,0x9398,0xa3fb,0xb3da,0xc33d,0xd31c,0xe37f,0xf35e,\n0x02b1,0x1290,0x22f3,0x32d2,0x4235,0x5214,0x6277,0x7256,\n0xb5ea,0xa5cb,0x95a8,0x8589,0xf56e,0xe54f,0xd52c,0xc50d,\n0x34e2,0x24c3,0x14a0,0x0481,0x7466,0x6447,0x5424,0x4405,\n0xa7db,0xb7fa,0x8799,0x97b8,0xe75f,0xf77e,0xc71d,0xd73c,\n0x26d3,0x36f2,0x0691,0x16b0,0x6657,0x7676,0x4615,0x5634,\n0xd94c,0xc96d,0xf90e,0xe92f,0x99c8,0x89e9,0xb98a,0xa9ab,\n0x5844,0x4865,0x7806,0x6827,0x18c0,0x08e1,0x3882,0x28a3,\n0xcb7d,0xdb5c,0xeb3f,0xfb1e,0x8bf9,0x9bd8,0xabbb,0xbb9a,\n0x4a75,0x5a54,0x6a37,0x7a16,0x0af1,0x1ad0,0x2ab3,0x3a92,\n0xfd2e,0xed0f,0xdd6c,0xcd4d,0xbdaa,0xad8b,0x9de8,0x8dc9,\n0x7c26,0x6c07,0x5c64,0x4c45,0x3ca2,0x2c83,0x1ce0,0x0cc1,\n0xef1f,0xff3e,0xcf5d,0xdf7c,0xaf9b,0xbfba,0x8fd9,0x9ff8,\n0x6e17,0x7e36,0x4e55,0x5e74,0x2e93,0x3eb2,0x0ed1,0x1ef0,\n]\n\ndef crc_hqx(s,crc):\n for c in s:\n  crc=((crc <<8)&0xff00)^crctab_hqx[((crc >>8)&0xff)^ord(c)]\n  \n return crc\n \ndef rlecode_hqx(s):\n ''\n\n\n\n \n if not s:\n  return ''\n result=[]\n prev=s[0]\n count=1\n \n \n \n \n if s[-1]=='!':\n  s=s[1:]+'?'\n else:\n  s=s[1:]+'!'\n  \n for c in s:\n  if c ==prev and count <255:\n   count +=1\n  else:\n   if count ==1:\n    if prev !='\\x90':\n     result.append(prev)\n    else:\n     result.extend(['\\x90','\\x00'])\n   elif count <4:\n    if prev !='\\x90':\n     result.extend([prev]*count)\n    else:\n     result.extend(['\\x90','\\x00']*count)\n   else:\n    if prev !='\\x90':\n     result.extend([prev,'\\x90',chr(count)])\n    else:\n     result.extend(['\\x90','\\x00','\\x90',chr(count)])\n   count=1\n   prev=c\n   \n return ''.join(result)\n \ndef rledecode_hqx(s):\n s=s.split('\\x90')\n result=[s[0]]\n prev=s[0]\n for snippet in s[1:]:\n  count=ord(snippet[0])\n  if count >0:\n   result.append(prev[-1]*(count -1))\n   prev=snippet\n  else:\n   result.append('\\x90')\n   prev='\\x90'\n  result.append(snippet[1:])\n  \n return ''.join(result)\n \ncrc_32_tab=[\n0x00000000,0x77073096,0xee0e612c,0x990951ba,0x076dc419,\n0x706af48f,0xe963a535,0x9e6495a3,0x0edb8832,0x79dcb8a4,\n0xe0d5e91e,0x97d2d988,0x09b64c2b,0x7eb17cbd,0xe7b82d07,\n0x90bf1d91,0x1db71064,0x6ab020f2,0xf3b97148,0x84be41de,\n0x1adad47d,0x6ddde4eb,0xf4d4b551,0x83d385c7,0x136c9856,\n0x646ba8c0,0xfd62f97a,0x8a65c9ec,0x14015c4f,0x63066cd9,\n0xfa0f3d63,0x8d080df5,0x3b6e20c8,0x4c69105e,0xd56041e4,\n0xa2677172,0x3c03e4d1,0x4b04d447,0xd20d85fd,0xa50ab56b,\n0x35b5a8fa,0x42b2986c,0xdbbbc9d6,0xacbcf940,0x32d86ce3,\n0x45df5c75,0xdcd60dcf,0xabd13d59,0x26d930ac,0x51de003a,\n0xc8d75180,0xbfd06116,0x21b4f4b5,0x56b3c423,0xcfba9599,\n0xb8bda50f,0x2802b89e,0x5f058808,0xc60cd9b2,0xb10be924,\n0x2f6f7c87,0x58684c11,0xc1611dab,0xb6662d3d,0x76dc4190,\n0x01db7106,0x98d220bc,0xefd5102a,0x71b18589,0x06b6b51f,\n0x9fbfe4a5,0xe8b8d433,0x7807c9a2,0x0f00f934,0x9609a88e,\n0xe10e9818,0x7f6a0dbb,0x086d3d2d,0x91646c97,0xe6635c01,\n0x6b6b51f4,0x1c6c6162,0x856530d8,0xf262004e,0x6c0695ed,\n0x1b01a57b,0x8208f4c1,0xf50fc457,0x65b0d9c6,0x12b7e950,\n0x8bbeb8ea,0xfcb9887c,0x62dd1ddf,0x15da2d49,0x8cd37cf3,\n0xfbd44c65,0x4db26158,0x3ab551ce,0xa3bc0074,0xd4bb30e2,\n0x4adfa541,0x3dd895d7,0xa4d1c46d,0xd3d6f4fb,0x4369e96a,\n0x346ed9fc,0xad678846,0xda60b8d0,0x44042d73,0x33031de5,\n0xaa0a4c5f,0xdd0d7cc9,0x5005713c,0x270241aa,0xbe0b1010,\n0xc90c2086,0x5768b525,0x206f85b3,0xb966d409,0xce61e49f,\n0x5edef90e,0x29d9c998,0xb0d09822,0xc7d7a8b4,0x59b33d17,\n0x2eb40d81,0xb7bd5c3b,0xc0ba6cad,0xedb88320,0x9abfb3b6,\n0x03b6e20c,0x74b1d29a,0xead54739,0x9dd277af,0x04db2615,\n0x73dc1683,0xe3630b12,0x94643b84,0x0d6d6a3e,0x7a6a5aa8,\n0xe40ecf0b,0x9309ff9d,0x0a00ae27,0x7d079eb1,0xf00f9344,\n0x8708a3d2,0x1e01f268,0x6906c2fe,0xf762575d,0x806567cb,\n0x196c3671,0x6e6b06e7,0xfed41b76,0x89d32be0,0x10da7a5a,\n0x67dd4acc,0xf9b9df6f,0x8ebeeff9,0x17b7be43,0x60b08ed5,\n0xd6d6a3e8,0xa1d1937e,0x38d8c2c4,0x4fdff252,0xd1bb67f1,\n0xa6bc5767,0x3fb506dd,0x48b2364b,0xd80d2bda,0xaf0a1b4c,\n0x36034af6,0x41047a60,0xdf60efc3,0xa867df55,0x316e8eef,\n0x4669be79,0xcb61b38c,0xbc66831a,0x256fd2a0,0x5268e236,\n0xcc0c7795,0xbb0b4703,0x220216b9,0x5505262f,0xc5ba3bbe,\n0xb2bd0b28,0x2bb45a92,0x5cb36a04,0xc2d7ffa7,0xb5d0cf31,\n0x2cd99e8b,0x5bdeae1d,0x9b64c2b0,0xec63f226,0x756aa39c,\n0x026d930a,0x9c0906a9,0xeb0e363f,0x72076785,0x05005713,\n0x95bf4a82,0xe2b87a14,0x7bb12bae,0x0cb61b38,0x92d28e9b,\n0xe5d5be0d,0x7cdcefb7,0x0bdbdf21,0x86d3d2d4,0xf1d4e242,\n0x68ddb3f8,0x1fda836e,0x81be16cd,0xf6b9265b,0x6fb077e1,\n0x18b74777,0x88085ae6,0xff0f6a70,0x66063bca,0x11010b5c,\n0x8f659eff,0xf862ae69,0x616bffd3,0x166ccf45,0xa00ae278,\n0xd70dd2ee,0x4e048354,0x3903b3c2,0xa7672661,0xd06016f7,\n0x4969474d,0x3e6e77db,0xaed16a4a,0xd9d65adc,0x40df0b66,\n0x37d83bf0,0xa9bcae53,0xdebb9ec5,0x47b2cf7f,0x30b5ffe9,\n0xbdbdf21c,0xcabac28a,0x53b39330,0x24b4a3a6,0xbad03605,\n0xcdd70693,0x54de5729,0x23d967bf,0xb3667a2e,0xc4614ab8,\n0x5d681b02,0x2a6f2b94,0xb40bbe37,0xc30c8ea1,0x5a05df1b,\n0x2d02ef8d\n]\n\ndef crc32(s,crc=0):\n result=0\n crc=~int(crc)&0xffffffff\n \n for c in s:\n  crc=crc_32_tab[(crc ^int(ord(c)))&0xff]^(crc >>8)\n  \n  \n  \n result=crc ^0xffffffff\n \n if result >2 **31:\n  result=((result+2 **31)%2 **32)-2 **31\n  \n return result\n", ["_base64", "_binascii"]], "bisect": [".py", "''\n\n\ndef insort_right(a,x,lo=0,hi=None,*,key=None):\n ''\n\n\n\n\n\n\n\n \n if key is None:\n  lo=bisect_right(a,x,lo,hi)\n else:\n  lo=bisect_right(a,key(x),lo,hi,key=key)\n a.insert(lo,x)\n \n \ndef bisect_right(a,x,lo=0,hi=None,*,key=None):\n ''\n\n\n\n\n\n\n\n\n\n \n \n if lo <0:\n  raise ValueError('lo must be non-negative')\n if hi is None:\n  hi=len(a)\n  \n  \n if key is None:\n  while lo <hi:\n   mid=(lo+hi)//2\n   if x <a[mid]:\n    hi=mid\n   else:\n    lo=mid+1\n else:\n  while lo <hi:\n   mid=(lo+hi)//2\n   if x <key(a[mid]):\n    hi=mid\n   else:\n    lo=mid+1\n return lo\n \n \ndef insort_left(a,x,lo=0,hi=None,*,key=None):\n ''\n\n\n\n\n\n\n\n \n \n if key is None:\n  lo=bisect_left(a,x,lo,hi)\n else:\n  lo=bisect_left(a,key(x),lo,hi,key=key)\n a.insert(lo,x)\n \ndef bisect_left(a,x,lo=0,hi=None,*,key=None):\n ''\n\n\n\n\n\n\n\n\n\n \n \n if lo <0:\n  raise ValueError('lo must be non-negative')\n if hi is None:\n  hi=len(a)\n  \n  \n if key is None:\n  while lo <hi:\n   mid=(lo+hi)//2\n   if a[mid]<x:\n    lo=mid+1\n   else:\n    hi=mid\n else:\n  while lo <hi:\n   mid=(lo+hi)//2\n   if key(a[mid])<x:\n    lo=mid+1\n   else:\n    hi=mid\n return lo\n \n \n \ntry:\n from _bisect import *\nexcept ImportError:\n pass\n \n \nbisect=bisect_right\ninsort=insort_right\n", ["_bisect"]], "code": [".py", "''\n\n\n\n\n\n\nimport builtins\nimport sys\nimport traceback\nfrom codeop import CommandCompiler,compile_command\n\n__all__=[\"InteractiveInterpreter\",\"InteractiveConsole\",\"interact\",\n\"compile_command\"]\n\nclass InteractiveInterpreter:\n ''\n\n\n\n\n\n \n \n def __init__(self,locals=None):\n  ''\n\n\n\n\n\n\n  \n  if locals is None:\n   locals={\"__name__\":\"__console__\",\"__doc__\":None}\n  self.locals=locals\n  self.compile=CommandCompiler()\n  \n def runsource(self,source,filename=\"<input>\",symbol=\"single\"):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  try:\n   code=self.compile(source,filename,symbol)\n  except(OverflowError,SyntaxError,ValueError):\n  \n   self.showsyntaxerror(filename)\n   return False\n   \n  if code is None:\n  \n   return True\n   \n   \n  self.runcode(code)\n  return False\n  \n def runcode(self,code):\n  ''\n\n\n\n\n\n\n\n\n\n  \n  try:\n   exec(code,self.locals)\n  except SystemExit:\n   raise\n  except:\n   self.showtraceback()\n   \n def showsyntaxerror(self,filename=None,**kwargs):\n  ''\n\n\n\n\n\n\n\n\n\n  \n  colorize=kwargs.pop('colorize',False)\n  type,value,tb=sys.exc_info()\n  sys.last_exc=value\n  sys.last_type=type\n  sys.last_value=value\n  sys.last_traceback=tb\n  if filename and type is SyntaxError:\n  \n   try:\n    msg,(dummy_filename,lineno,offset,line)=value.args\n   except ValueError:\n   \n    pass\n   else:\n   \n    value=SyntaxError(msg,(filename,lineno,offset,line))\n    sys.last_exc=sys.last_value=value\n  if sys.excepthook is sys.__excepthook__:\n   lines=traceback.format_exception_only(type,value,colorize=colorize)\n   self.write(''.join(lines))\n  else:\n  \n  \n   sys.excepthook(type,value,tb)\n   \n def showtraceback(self,**kwargs):\n  ''\n\n\n\n\n\n  \n  colorize=kwargs.pop('colorize',False)\n  sys.last_type,sys.last_value,last_tb=ei=sys.exc_info()\n  sys.last_traceback=last_tb\n  sys.last_exc=ei[1]\n  try:\n   lines=traceback.format_exception(ei[0],ei[1],last_tb.tb_next,colorize=colorize)\n   if sys.excepthook is sys.__excepthook__:\n    self.write(''.join(lines))\n   else:\n   \n   \n    sys.excepthook(ei[0],ei[1],last_tb)\n  finally:\n   last_tb=ei=None\n   \n def write(self,data):\n  ''\n\n\n\n\n  \n  sys.stderr.write(data)\n  \n  \nclass InteractiveConsole(InteractiveInterpreter):\n ''\n\n\n\n\n \n \n def __init__(self,locals=None,filename=\"<console>\",*,local_exit=False):\n  ''\n\n\n\n\n\n\n\n  \n  InteractiveInterpreter.__init__(self,locals)\n  self.filename=filename\n  self.local_exit=local_exit\n  self.resetbuffer()\n  \n def resetbuffer(self):\n  ''\n  self.buffer=[]\n  \n def interact(self,banner=None,exitmsg=None):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  try:\n   sys.ps1\n  except AttributeError:\n   sys.ps1=\">>> \"\n  try:\n   sys.ps2\n  except AttributeError:\n   sys.ps2=\"... \"\n  cprt='Type \"help\", \"copyright\", \"credits\" or \"license\" for more information.'\n  if banner is None:\n   self.write(\"Python %s on %s\\n%s\\n(%s)\\n\"%\n   (sys.version,sys.platform,cprt,\n   self.__class__.__name__))\n  elif banner:\n   self.write(\"%s\\n\"%str(banner))\n  more=0\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  _exit=None\n  _quit=None\n  \n  if self.local_exit:\n   if hasattr(builtins,\"exit\"):\n    _exit=builtins.exit\n    builtins.exit=Quitter(\"exit\")\n    \n   if hasattr(builtins,\"quit\"):\n    _quit=builtins.quit\n    builtins.quit=Quitter(\"quit\")\n    \n  try:\n   while True:\n    try:\n     if more:\n      prompt=sys.ps2\n     else:\n      prompt=sys.ps1\n     try:\n      line=self.raw_input(prompt)\n     except EOFError:\n      self.write(\"\\n\")\n      break\n     else:\n      more=self.push(line)\n    except KeyboardInterrupt:\n     self.write(\"\\nKeyboardInterrupt\\n\")\n     self.resetbuffer()\n     more=0\n    except SystemExit as e:\n     if self.local_exit:\n      self.write(\"\\n\")\n      break\n     else:\n      raise e\n  finally:\n  \n   if _exit is not None:\n    builtins.exit=_exit\n    \n   if _quit is not None:\n    builtins.quit=_quit\n    \n   if exitmsg is None:\n    self.write('now exiting %s...\\n'%self.__class__.__name__)\n   elif exitmsg !='':\n    self.write('%s\\n'%exitmsg)\n    \n def push(self,line,filename=None,_symbol=\"single\"):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n  \n  self.buffer.append(line)\n  source=\"\\n\".join(self.buffer)\n  if filename is None:\n   filename=self.filename\n  more=self.runsource(source,filename,symbol=_symbol)\n  if not more:\n   self.resetbuffer()\n  return more\n  \n def raw_input(self,prompt=\"\"):\n  ''\n\n\n\n\n\n\n\n\n  \n  return input(prompt)\n  \n  \nclass Quitter:\n def __init__(self,name):\n  self.name=name\n  if sys.platform ==\"win32\":\n   self.eof='Ctrl-Z plus Return'\n  else:\n   self.eof='Ctrl-D (i.e. EOF)'\n   \n def __repr__(self):\n  return f'Use {self.name} or {self.eof} to exit'\n  \n def __call__(self,code=None):\n  raise SystemExit(code)\n  \n  \ndef interact(banner=None,readfunc=None,local=None,exitmsg=None,local_exit=False):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n console=InteractiveConsole(local,local_exit=local_exit)\n if readfunc is not None:\n  console.raw_input=readfunc\n else:\n  try:\n   import readline\n  except ImportError:\n   pass\n console.interact(banner,exitmsg)\n \n \nif __name__ ==\"__main__\":\n import argparse\n \n parser=argparse.ArgumentParser()\n parser.add_argument('-q',action='store_true',\n help=\"don't print version and copyright messages\")\n args=parser.parse_args()\n if args.q or sys.flags.quiet:\n  banner=''\n else:\n  banner=None\n interact(banner)\n", ["argparse", "builtins", "codeop", "readline", "sys", "traceback"]], "copy": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport types\nimport weakref\nfrom copyreg import dispatch_table\n\nclass Error(Exception):\n pass\nerror=Error\n\n__all__=[\"Error\",\"copy\",\"deepcopy\",\"replace\"]\n\ndef copy(x):\n ''\n\n\n \n \n cls=type(x)\n \n copier=_copy_dispatch.get(cls)\n if copier:\n  return copier(x)\n  \n if issubclass(cls,type):\n \n  return _copy_immutable(x)\n  \n copier=getattr(cls,\"__copy__\",None)\n if copier is not None:\n  return copier(x)\n  \n reductor=dispatch_table.get(cls)\n if reductor is not None:\n  rv=reductor(x)\n else:\n  reductor=getattr(x,\"__reduce_ex__\",None)\n  if reductor is not None:\n   rv=reductor(4)\n  else:\n   reductor=getattr(x,\"__reduce__\",None)\n   if reductor:\n    rv=reductor()\n   else:\n    raise Error(\"un(shallow)copyable object of type %s\"%cls)\n    \n if isinstance(rv,str):\n  return x\n return _reconstruct(x,None,*rv)\n \n \n_copy_dispatch=d={}\n\ndef _copy_immutable(x):\n return x\nfor t in(types.NoneType,int,float,bool,complex,str,tuple,\nbytes,frozenset,type,range,slice,property,\ntypes.BuiltinFunctionType,types.EllipsisType,\ntypes.NotImplementedType,types.FunctionType,types.CodeType,\nweakref.ref):\n d[t]=_copy_immutable\n \nd[list]=list.copy\nd[dict]=dict.copy\nd[set]=set.copy\nd[bytearray]=bytearray.copy\n\ndel d,t\n\ndef deepcopy(x,memo=None,_nil=[]):\n ''\n\n\n \n \n d=id(x)\n if memo is None:\n  memo={}\n else:\n  y=memo.get(d,_nil)\n  if y is not _nil:\n   return y\n   \n cls=type(x)\n \n copier=_deepcopy_dispatch.get(cls)\n if copier is not None:\n  y=copier(x,memo)\n else:\n  if issubclass(cls,type):\n   y=_deepcopy_atomic(x,memo)\n  else:\n   copier=getattr(x,\"__deepcopy__\",None)\n   if copier is not None:\n    y=copier(memo)\n   else:\n    reductor=dispatch_table.get(cls)\n    if reductor:\n     rv=reductor(x)\n    else:\n     reductor=getattr(x,\"__reduce_ex__\",None)\n     if reductor is not None:\n      rv=reductor(4)\n     else:\n      reductor=getattr(x,\"__reduce__\",None)\n      if reductor:\n       rv=reductor()\n      else:\n       raise Error(\n       \"un(deep)copyable object of type %s\"%cls)\n    if isinstance(rv,str):\n     y=x\n    else:\n     y=_reconstruct(x,memo,*rv)\n     \n     \n if y is not x:\n  memo[d]=y\n  _keep_alive(x,memo)\n return y\n \n_deepcopy_dispatch=d={}\n\ndef _deepcopy_atomic(x,memo):\n return x\nd[types.NoneType]=_deepcopy_atomic\nd[types.EllipsisType]=_deepcopy_atomic\nd[types.NotImplementedType]=_deepcopy_atomic\nd[int]=_deepcopy_atomic\nd[float]=_deepcopy_atomic\nd[bool]=_deepcopy_atomic\nd[complex]=_deepcopy_atomic\nd[bytes]=_deepcopy_atomic\nd[str]=_deepcopy_atomic\nd[types.CodeType]=_deepcopy_atomic\nd[type]=_deepcopy_atomic\nd[range]=_deepcopy_atomic\nd[types.BuiltinFunctionType]=_deepcopy_atomic\nd[types.FunctionType]=_deepcopy_atomic\nd[weakref.ref]=_deepcopy_atomic\nd[property]=_deepcopy_atomic\n\ndef _deepcopy_list(x,memo,deepcopy=deepcopy):\n y=[]\n memo[id(x)]=y\n append=y.append\n for a in x:\n  append(deepcopy(a,memo))\n return y\nd[list]=_deepcopy_list\n\ndef _deepcopy_tuple(x,memo,deepcopy=deepcopy):\n y=[deepcopy(a,memo)for a in x]\n \n \n try:\n  return memo[id(x)]\n except KeyError:\n  pass\n for k,j in zip(x,y):\n  if k is not j:\n   y=tuple(y)\n   break\n else:\n  y=x\n return y\nd[tuple]=_deepcopy_tuple\n\ndef _deepcopy_dict(x,memo,deepcopy=deepcopy):\n y={}\n memo[id(x)]=y\n for key,value in x.items():\n  y[deepcopy(key,memo)]=deepcopy(value,memo)\n return y\nd[dict]=_deepcopy_dict\n\ndef _deepcopy_method(x,memo):\n return type(x)(x.__func__,deepcopy(x.__self__,memo))\nd[types.MethodType]=_deepcopy_method\n\ndel d\n\ndef _keep_alive(x,memo):\n ''\n\n\n\n\n\n\n\n \n try:\n  memo[id(memo)].append(x)\n except KeyError:\n \n  memo[id(memo)]=[x]\n  \ndef _reconstruct(x,memo,func,args,\nstate=None,listiter=None,dictiter=None,\n*,deepcopy=deepcopy):\n deep=memo is not None\n if deep and args:\n  args=(deepcopy(arg,memo)for arg in args)\n y=func(*args)\n if deep:\n  memo[id(x)]=y\n  \n if state is not None:\n  if deep:\n   state=deepcopy(state,memo)\n  if hasattr(y,'__setstate__'):\n   y.__setstate__(state)\n  else:\n   if isinstance(state,tuple)and len(state)==2:\n    state,slotstate=state\n   else:\n    slotstate=None\n   if state is not None:\n    y.__dict__.update(state)\n   if slotstate is not None:\n    for key,value in slotstate.items():\n     setattr(y,key,value)\n     \n if listiter is not None:\n  if deep:\n   for item in listiter:\n    item=deepcopy(item,memo)\n    y.append(item)\n  else:\n   for item in listiter:\n    y.append(item)\n if dictiter is not None:\n  if deep:\n   for key,value in dictiter:\n    key=deepcopy(key,memo)\n    value=deepcopy(value,memo)\n    y[key]=value\n  else:\n   for key,value in dictiter:\n    y[key]=value\n return y\n \ndel types,weakref\n\n\ndef replace(obj,/,**changes):\n ''\n\n\n\n \n cls=obj.__class__\n func=getattr(cls,'__replace__',None)\n if func is None:\n  raise TypeError(f\"replace() does not support {cls.__name__} objects\")\n return func(obj,**changes)\n", ["copyreg", "types", "weakref"]], "dataclasses": [".py", "import re\nimport sys\nimport copy\nimport types\nimport inspect\nimport keyword\nimport itertools\nimport abc\nfrom reprlib import recursive_repr\n\n\n__all__=['dataclass',\n'field',\n'Field',\n'FrozenInstanceError',\n'InitVar',\n'KW_ONLY',\n'MISSING',\n\n\n'fields',\n'asdict',\n'astuple',\n'make_dataclass',\n'replace',\n'is_dataclass',\n]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass FrozenInstanceError(AttributeError):pass\n\n\n\n\nclass _HAS_DEFAULT_FACTORY_CLASS:\n def __repr__(self):\n  return '<factory>'\n_HAS_DEFAULT_FACTORY=_HAS_DEFAULT_FACTORY_CLASS()\n\n\n\nclass _MISSING_TYPE:\n pass\nMISSING=_MISSING_TYPE()\n\n\n\nclass _KW_ONLY_TYPE:\n pass\nKW_ONLY=_KW_ONLY_TYPE()\n\n\n\n_EMPTY_METADATA=types.MappingProxyType({})\n\n\nclass _FIELD_BASE:\n def __init__(self,name):\n  self.name=name\n def __repr__(self):\n  return self.name\n_FIELD=_FIELD_BASE('_FIELD')\n_FIELD_CLASSVAR=_FIELD_BASE('_FIELD_CLASSVAR')\n_FIELD_INITVAR=_FIELD_BASE('_FIELD_INITVAR')\n\n\n\n_FIELDS='__dataclass_fields__'\n\n\n\n_PARAMS='__dataclass_params__'\n\n\n\n_POST_INIT_NAME='__post_init__'\n\n\n\n\n_MODULE_IDENTIFIER_RE=re.compile(r'^(?:\\s*(\\w+)\\s*\\.)?\\s*(\\w+)')\n\n\n\n_ATOMIC_TYPES=frozenset({\n\ntypes.NoneType,\nbool,\nint,\nfloat,\nstr,\n\ncomplex,\nbytes,\n\ntypes.EllipsisType,\ntypes.NotImplementedType,\ntypes.CodeType,\ntypes.BuiltinFunctionType,\ntypes.FunctionType,\ntype,\nrange,\nproperty,\n})\n\n\nclass InitVar:\n __slots__=('type',)\n \n def __init__(self,type):\n  self.type=type\n  \n def __repr__(self):\n  if isinstance(self.type,type):\n   type_name=self.type.__name__\n  else:\n  \n   type_name=repr(self.type)\n  return f'dataclasses.InitVar[{type_name}]'\n  \n def __class_getitem__(cls,type):\n  return InitVar(type)\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \nclass Field:\n __slots__=('name',\n 'type',\n 'default',\n 'default_factory',\n 'repr',\n 'hash',\n 'init',\n 'compare',\n 'metadata',\n 'kw_only',\n '_field_type',\n )\n \n def __init__(self,default,default_factory,init,repr,hash,compare,\n metadata,kw_only):\n  self.name=None\n  self.type=None\n  self.default=default\n  self.default_factory=default_factory\n  self.init=init\n  self.repr=repr\n  self.hash=hash\n  self.compare=compare\n  self.metadata=(_EMPTY_METADATA\n  if metadata is None else\n  types.MappingProxyType(metadata))\n  self.kw_only=kw_only\n  self._field_type=None\n  \n @recursive_repr()\n def __repr__(self):\n  return('Field('\n  f'name={self.name !r},'\n  f'type={self.type !r},'\n  f'default={self.default !r},'\n  f'default_factory={self.default_factory !r},'\n  f'init={self.init !r},'\n  f'repr={self.repr !r},'\n  f'hash={self.hash !r},'\n  f'compare={self.compare !r},'\n  f'metadata={self.metadata !r},'\n  f'kw_only={self.kw_only !r},'\n  f'_field_type={self._field_type}'\n  ')')\n  \n  \n  \n  \n  \n  \n  \n  \n  \n def __set_name__(self,owner,name):\n  func=getattr(type(self.default),'__set_name__',None)\n  if func:\n  \n  \n   func(self.default,owner,name)\n   \n __class_getitem__=classmethod(types.GenericAlias)\n \n \nclass _DataclassParams:\n __slots__=('init',\n 'repr',\n 'eq',\n 'order',\n 'unsafe_hash',\n 'frozen',\n 'match_args',\n 'kw_only',\n 'slots',\n 'weakref_slot',\n )\n \n def __init__(self,\n init,repr,eq,order,unsafe_hash,frozen,\n match_args,kw_only,slots,weakref_slot):\n  self.init=init\n  self.repr=repr\n  self.eq=eq\n  self.order=order\n  self.unsafe_hash=unsafe_hash\n  self.frozen=frozen\n  self.match_args=match_args\n  self.kw_only=kw_only\n  self.slots=slots\n  self.weakref_slot=weakref_slot\n  \n def __repr__(self):\n  return('_DataclassParams('\n  f'init={self.init !r},'\n  f'repr={self.repr !r},'\n  f'eq={self.eq !r},'\n  f'order={self.order !r},'\n  f'unsafe_hash={self.unsafe_hash !r},'\n  f'frozen={self.frozen !r},'\n  f'match_args={self.match_args !r},'\n  f'kw_only={self.kw_only !r},'\n  f'slots={self.slots !r},'\n  f'weakref_slot={self.weakref_slot !r}'\n  ')')\n  \n  \n  \n  \n  \ndef field(*,default=MISSING,default_factory=MISSING,init=True,repr=True,\nhash=None,compare=True,metadata=None,kw_only=MISSING):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n if default is not MISSING and default_factory is not MISSING:\n  raise ValueError('cannot specify both default and default_factory')\n return Field(default,default_factory,init,repr,hash,compare,\n metadata,kw_only)\n \n \ndef _fields_in_init_order(fields):\n\n\n\n return(tuple(f for f in fields if f.init and not f.kw_only),\n tuple(f for f in fields if f.init and f.kw_only)\n )\n \n \ndef _tuple_str(obj_name,fields):\n\n\n\n\n\n if not fields:\n  return '()'\n  \n return f'({\",\".join([f\"{obj_name}.{f.name}\"for f in fields])},)'\n \n \nclass _FuncBuilder:\n def __init__(self,globals):\n  self.names=[]\n  self.src=[]\n  self.globals=globals\n  self.locals={}\n  self.overwrite_errors={}\n  self.unconditional_adds={}\n  \n def add_fn(self,name,args,body,*,locals=None,return_type=MISSING,\n overwrite_error=False,unconditional_add=False,decorator=None):\n  if locals is not None:\n   self.locals.update(locals)\n   \n   \n   \n   \n   \n   \n   \n  if overwrite_error:\n   self.overwrite_errors[name]=overwrite_error\n   \n   \n   \n   \n  if unconditional_add:\n   self.unconditional_adds[name]=True\n   \n  self.names.append(name)\n  \n  if return_type is not MISSING:\n   self.locals[f'__dataclass_{name}_return_type__']=return_type\n   return_annotation=f'->__dataclass_{name}_return_type__'\n  else:\n   return_annotation=''\n  args=','.join(args)\n  body='\\n'.join(body)\n  \n  \n  self.src.append(f'{f' {decorator}\\n'if decorator else ''} def {name}({args}){return_annotation}:\\n{body}')\n  \n def add_fns_to_class(self,cls):\n \n  fns_src='\\n'.join(self.src)\n  \n  \n  local_vars=','.join(self.locals.keys())\n  \n  \n  \n  if len(self.names)==0:\n   return_names='()'\n  else:\n   return_names=f'({\",\".join(self.names)},)'\n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n  txt=f\"def __create_fn__({local_vars}):\\n{fns_src}\\n return {return_names}\"\n  ns={}\n  exec(txt,self.globals,ns)\n  fns=ns['__create_fn__'](**self.locals)\n  \n  \n  for name,fn in zip(self.names,fns):\n   fn.__qualname__=f\"{cls.__qualname__}.{fn.__name__}\"\n   if self.unconditional_adds.get(name,False):\n    setattr(cls,name,fn)\n   else:\n    already_exists=_set_new_attribute(cls,name,fn)\n    \n    \n    if already_exists and(msg_extra :=self.overwrite_errors.get(name)):\n     error_msg=(f'Cannot overwrite attribute {fn.__name__} '\n     f'in class {cls.__name__}')\n     if not msg_extra is True:\n      error_msg=f'{error_msg} {msg_extra}'\n      \n     raise TypeError(error_msg)\n     \n     \ndef _field_assign(frozen,name,value,self_name):\n\n\n\n\n\n\n if frozen:\n  return f'  __dataclass_builtins_object__.__setattr__({self_name},{name !r},{value})'\n return f'  {self_name}.{name}={value}'\n \n \ndef _field_init(f,frozen,globals,self_name,slots):\n\n\n\n default_name=f'__dataclass_dflt_{f.name}__'\n if f.default_factory is not MISSING:\n  if f.init:\n  \n  \n   globals[default_name]=f.default_factory\n   value=(f'{default_name}() '\n   f'if {f.name} is __dataclass_HAS_DEFAULT_FACTORY__ '\n   f'else {f.name}')\n  else:\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n   globals[default_name]=f.default_factory\n   value=f'{default_name}()'\n else:\n \n  if f.init:\n   if f.default is MISSING:\n   \n    value=f.name\n   elif f.default is not MISSING:\n    globals[default_name]=f.default\n    value=f.name\n  else:\n  \n   if slots and f.default is not MISSING:\n    globals[default_name]=f.default\n    value=default_name\n   else:\n   \n   \n   \n    return None\n    \n    \n    \n    \n if f._field_type is _FIELD_INITVAR:\n  return None\n  \n  \n return _field_assign(frozen,f.name,value,self_name)\n \n \ndef _init_param(f):\n\n\n\n\n if f.default is MISSING and f.default_factory is MISSING:\n \n \n  default=''\n elif f.default is not MISSING:\n \n \n  default=f'=__dataclass_dflt_{f.name}__'\n elif f.default_factory is not MISSING:\n \n  default='=__dataclass_HAS_DEFAULT_FACTORY__'\n return f'{f.name}:__dataclass_type_{f.name}__{default}'\n \n \ndef _init_fn(fields,std_fields,kw_only_fields,frozen,has_post_init,\nself_name,func_builder,slots):\n\n\n\n\n\n\n\n\n seen_default=None\n for f in std_fields:\n \n  if f.init:\n   if not(f.default is MISSING and f.default_factory is MISSING):\n    seen_default=f\n   elif seen_default:\n    raise TypeError(f'non-default argument {f.name !r} '\n    f'follows default argument {seen_default.name !r}')\n    \n locals={**{f'__dataclass_type_{f.name}__':f.type for f in fields},\n **{'__dataclass_HAS_DEFAULT_FACTORY__':_HAS_DEFAULT_FACTORY,\n '__dataclass_builtins_object__':object,\n }\n }\n \n body_lines=[]\n for f in fields:\n  line=_field_init(f,frozen,locals,self_name,slots)\n  \n  \n  if line:\n   body_lines.append(line)\n   \n   \n if has_post_init:\n  params_str=','.join(f.name for f in fields\n  if f._field_type is _FIELD_INITVAR)\n  body_lines.append(f'  {self_name}.{_POST_INIT_NAME}({params_str})')\n  \n  \n if not body_lines:\n  body_lines=['  pass']\n  \n _init_params=[_init_param(f)for f in std_fields]\n if kw_only_fields:\n \n \n \n  _init_params +=['*']\n  _init_params +=[_init_param(f)for f in kw_only_fields]\n func_builder.add_fn('__init__',\n [self_name]+_init_params,\n body_lines,\n locals=locals,\n return_type=None)\n \n \ndef _frozen_get_del_attr(cls,fields,func_builder):\n locals={'cls':cls,\n 'FrozenInstanceError':FrozenInstanceError}\n condition='type(self) is cls'\n if fields:\n  condition +=' or name in {'+', '.join(repr(f.name)for f in fields)+'}'\n  \n func_builder.add_fn('__setattr__',\n ('self','name','value'),\n (f'  if {condition}:',\n '   raise FrozenInstanceError(f\"cannot assign to field {name!r}\")',\n f'  super(cls, self).__setattr__(name, value)'),\n locals=locals,\n overwrite_error=True)\n func_builder.add_fn('__delattr__',\n ('self','name'),\n (f'  if {condition}:',\n '   raise FrozenInstanceError(f\"cannot delete field {name!r}\")',\n f'  super(cls, self).__delattr__(name)'),\n locals=locals,\n overwrite_error=True)\n \n \ndef _is_classvar(a_type,typing):\n\n\n return(a_type is typing.ClassVar\n or(type(a_type)is typing._GenericAlias\n and a_type.__origin__ is typing.ClassVar))\n \n \ndef _is_initvar(a_type,dataclasses):\n\n\n return(a_type is dataclasses.InitVar\n or type(a_type)is dataclasses.InitVar)\n \ndef _is_kw_only(a_type,dataclasses):\n return a_type is dataclasses.KW_ONLY\n \n \ndef _is_type(annotation,cls,a_module,a_type,is_type_predicate):\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n match=_MODULE_IDENTIFIER_RE.match(annotation)\n if match:\n  ns=None\n  module_name=match.group(1)\n  if not module_name:\n  \n  \n   ns=sys.modules.get(cls.__module__).__dict__\n  else:\n  \n   module=sys.modules.get(cls.__module__)\n   if module and module.__dict__.get(module_name)is a_module:\n    ns=sys.modules.get(a_type.__module__).__dict__\n  if ns and is_type_predicate(ns.get(match.group(2)),a_module):\n   return True\n return False\n \n \ndef _get_field(cls,a_name,a_type,default_kw_only):\n\n\n\n\n\n\n\n default=getattr(cls,a_name,MISSING)\n if isinstance(default,Field):\n  f=default\n else:\n  if isinstance(default,types.MemberDescriptorType):\n  \n   default=MISSING\n  f=field(default=default)\n  \n  \n f.name=a_name\n f.type=a_type\n \n \n \n \n f._field_type=_FIELD\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n typing=sys.modules.get('typing')\n if typing:\n  if(_is_classvar(a_type,typing)\n  or(isinstance(f.type,str)\n  and _is_type(f.type,cls,typing,typing.ClassVar,\n  _is_classvar))):\n   f._field_type=_FIELD_CLASSVAR\n   \n   \n   \n if f._field_type is _FIELD:\n \n \n  dataclasses=sys.modules[__name__]\n  if(_is_initvar(a_type,dataclasses)\n  or(isinstance(f.type,str)\n  and _is_type(f.type,cls,dataclasses,dataclasses.InitVar,\n  _is_initvar))):\n   f._field_type=_FIELD_INITVAR\n   \n   \n   \n   \n   \n   \n if f._field_type in(_FIELD_CLASSVAR,_FIELD_INITVAR):\n  if f.default_factory is not MISSING:\n   raise TypeError(f'field {f.name} cannot have a '\n   'default factory')\n   \n   \n   \n   \n   \n   \n   \n if f._field_type in(_FIELD,_FIELD_INITVAR):\n \n \n  if f.kw_only is MISSING:\n   f.kw_only=default_kw_only\n else:\n \n  assert f._field_type is _FIELD_CLASSVAR\n  if f.kw_only is not MISSING:\n   raise TypeError(f'field {f.name} is a ClassVar but specifies '\n   'kw_only')\n   \n   \n   \n   \n if f._field_type is _FIELD and f.default.__class__.__hash__ is None:\n  raise ValueError(f'mutable default {type(f.default)} for field '\n  f'{f.name} is not allowed: use default_factory')\n  \n return f\n \ndef _set_new_attribute(cls,name,value):\n\n\n if name in cls.__dict__:\n  return True\n setattr(cls,name,value)\n return False\n \n \n \n \n \n \n \ndef _hash_set_none(cls,fields,func_builder):\n\n\n\n\n cls.__hash__=None\n \ndef _hash_add(cls,fields,func_builder):\n flds=[f for f in fields if(f.compare if f.hash is None else f.hash)]\n self_tuple=_tuple_str('self',flds)\n func_builder.add_fn('__hash__',\n ('self',),\n [f'  return hash({self_tuple})'],\n unconditional_add=True)\n \ndef _hash_exception(cls,fields,func_builder):\n\n raise TypeError(f'Cannot overwrite attribute __hash__ '\n f'in class {cls.__name__}')\n \n \n \n \n \n \n \n \n \n \n_hash_action={(False,False,False,False):None,\n(False,False,False,True):None,\n(False,False,True,False):None,\n(False,False,True,True):None,\n(False,True,False,False):_hash_set_none,\n(False,True,False,True):None,\n(False,True,True,False):_hash_add,\n(False,True,True,True):None,\n(True,False,False,False):_hash_add,\n(True,False,False,True):_hash_exception,\n(True,False,True,False):_hash_add,\n(True,False,True,True):_hash_exception,\n(True,True,False,False):_hash_add,\n(True,True,False,True):_hash_exception,\n(True,True,True,False):_hash_add,\n(True,True,True,True):_hash_exception,\n}\n\n\n\n\ndef _process_class(cls,init,repr,eq,order,unsafe_hash,frozen,\nmatch_args,kw_only,slots,weakref_slot):\n\n\n\n\n fields={}\n \n if cls.__module__ in sys.modules:\n  globals=sys.modules[cls.__module__].__dict__\n else:\n \n \n \n \n \n  globals={}\n  \n setattr(cls,_PARAMS,_DataclassParams(init,repr,eq,order,\n unsafe_hash,frozen,\n match_args,kw_only,\n slots,weakref_slot))\n \n \n \n \n \n any_frozen_base=False\n \n \n all_frozen_bases=None\n has_dataclass_bases=False\n for b in cls.__mro__[-1:0:-1]:\n \n \n  base_fields=getattr(b,_FIELDS,None)\n  if base_fields is not None:\n   has_dataclass_bases=True\n   for f in base_fields.values():\n    fields[f.name]=f\n   if all_frozen_bases is None:\n    all_frozen_bases=True\n   current_frozen=getattr(b,_PARAMS).frozen\n   all_frozen_bases=all_frozen_bases and current_frozen\n   any_frozen_base=any_frozen_base or current_frozen\n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n cls_annotations=inspect.get_annotations(cls)\n \n \n \n \n cls_fields=[]\n \n KW_ONLY_seen=False\n dataclasses=sys.modules[__name__]\n for name,type in cls_annotations.items():\n \n  if(_is_kw_only(type,dataclasses)\n  or(isinstance(type,str)\n  and _is_type(type,cls,dataclasses,dataclasses.KW_ONLY,\n  _is_kw_only))):\n  \n  \n   if KW_ONLY_seen:\n    raise TypeError(f'{name !r} is KW_ONLY, but KW_ONLY '\n    'has already been specified')\n   KW_ONLY_seen=True\n   kw_only=True\n  else:\n  \n   cls_fields.append(_get_field(cls,name,type,kw_only))\n   \n for f in cls_fields:\n  fields[f.name]=f\n  \n  \n  \n  \n  \n  if isinstance(getattr(cls,f.name,None),Field):\n   if f.default is MISSING:\n   \n   \n   \n   \n   \n   \n    delattr(cls,f.name)\n   else:\n    setattr(cls,f.name,f.default)\n    \n    \n for name,value in cls.__dict__.items():\n  if isinstance(value,Field)and not name in cls_annotations:\n   raise TypeError(f'{name !r} is a field but has no type annotation')\n   \n   \n if has_dataclass_bases:\n \n  if any_frozen_base and not frozen:\n   raise TypeError('cannot inherit non-frozen dataclass from a '\n   'frozen one')\n   \n   \n  if all_frozen_bases is False and frozen:\n   raise TypeError('cannot inherit frozen dataclass from a '\n   'non-frozen one')\n   \n   \n   \n setattr(cls,_FIELDS,fields)\n \n \n \n \n \n \n class_hash=cls.__dict__.get('__hash__',MISSING)\n has_explicit_hash=not(class_hash is MISSING or\n (class_hash is None and '__eq__'in cls.__dict__))\n \n \n \n if order and not eq:\n  raise ValueError('eq must be true if order is true')\n  \n  \n  \n  \n all_init_fields=[f for f in fields.values()\n if f._field_type in(_FIELD,_FIELD_INITVAR)]\n (std_init_fields,\n kw_only_init_fields)=_fields_in_init_order(all_init_fields)\n \n func_builder=_FuncBuilder(globals)\n \n if init:\n \n  has_post_init=hasattr(cls,_POST_INIT_NAME)\n  \n  _init_fn(all_init_fields,\n  std_init_fields,\n  kw_only_init_fields,\n  frozen,\n  has_post_init,\n  \n  \n  \n  '__dataclass_self__'if 'self'in fields\n  else 'self',\n  func_builder,\n  slots,\n  )\n  \n _set_new_attribute(cls,'__replace__',_replace)\n \n \n \n field_list=[f for f in fields.values()if f._field_type is _FIELD]\n \n if repr:\n  flds=[f for f in field_list if f.repr]\n  func_builder.add_fn('__repr__',\n  ('self',),\n  ['  return f\"{self.__class__.__qualname__}('+\n  ', '.join([f\"{f.name}={{self.{f.name}!r}}\"\n  for f in flds])+')\"'],\n  locals={'__dataclasses_recursive_repr':recursive_repr},\n  decorator=\"@__dataclasses_recursive_repr()\")\n  \n if eq:\n \n \n  cmp_fields=(field for field in field_list if field.compare)\n  terms=[f'self.{field.name}==other.{field.name}'for field in cmp_fields]\n  field_comparisons=' and '.join(terms)or 'True'\n  func_builder.add_fn('__eq__',\n  ('self','other'),\n  ['  if self is other:',\n  '   return True',\n  '  if other.__class__ is self.__class__:',\n  f'   return {field_comparisons}',\n  '  return NotImplemented'])\n  \n if order:\n \n  flds=[f for f in field_list if f.compare]\n  self_tuple=_tuple_str('self',flds)\n  other_tuple=_tuple_str('other',flds)\n  for name,op in[('__lt__','<'),\n  ('__le__','<='),\n  ('__gt__','>'),\n  ('__ge__','>='),\n  ]:\n  \n  \n  \n  \n   func_builder.add_fn(name,\n   ('self','other'),\n   ['  if other.__class__ is self.__class__:',\n   f'   return {self_tuple}{op}{other_tuple}',\n   '  return NotImplemented'],\n   overwrite_error='Consider using functools.total_ordering')\n   \n if frozen:\n  _frozen_get_del_attr(cls,field_list,func_builder)\n  \n  \n hash_action=_hash_action[bool(unsafe_hash),\n bool(eq),\n bool(frozen),\n has_explicit_hash]\n if hash_action:\n  cls.__hash__=hash_action(cls,field_list,func_builder)\n  \n  \n  \n  \n func_builder.add_fns_to_class(cls)\n \n if not getattr(cls,'__doc__'):\n \n  try:\n  \n  \n   text_sig=str(inspect.signature(cls)).replace(' -> None','')\n  except(TypeError,ValueError):\n   text_sig=''\n  cls.__doc__=(cls.__name__+text_sig)\n  \n if match_args:\n \n  _set_new_attribute(cls,'__match_args__',\n  tuple(f.name for f in std_init_fields))\n  \n  \n if weakref_slot and not slots:\n  raise TypeError('weakref_slot is True but slots is False')\n if slots:\n  cls=_add_slots(cls,frozen,weakref_slot)\n  \n abc.update_abstractmethods(cls)\n \n return cls\n \n \n \n \n \n \ndef _dataclass_getstate(self):\n return[getattr(self,f.name)for f in fields(self)]\n \n \ndef _dataclass_setstate(self,state):\n for field,value in zip(fields(self),state):\n \n  object.__setattr__(self,field.name,value)\n  \n  \ndef _get_slots(cls):\n match cls.__dict__.get('__slots__'):\n \n \n \n \n  case None:\n   slots=[]\n   if getattr(cls,'__weakrefoffset__',-1)!=0:\n    slots.append('__weakref__')\n   if getattr(cls,'__dictrefoffset__',-1)!=0:\n    slots.append('__dict__')\n   yield from slots\n  case str(slot):\n   yield slot\n   \n   \n  case iterable if not hasattr(iterable,'__next__'):\n   yield from iterable\n  case _:\n   raise TypeError(f\"Slots of '{cls.__name__}' cannot be determined\")\n   \n   \ndef _add_slots(cls,is_frozen,weakref_slot):\n\n\n\n\n if '__slots__'in cls.__dict__:\n  raise TypeError(f'{cls.__name__} already specifies __slots__')\n  \n  \n cls_dict=dict(cls.__dict__)\n field_names=tuple(f.name for f in fields(cls))\n \n inherited_slots=set(\n itertools.chain.from_iterable(map(_get_slots,cls.__mro__[1:-1]))\n )\n \n \n cls_dict[\"__slots__\"]=tuple(\n itertools.filterfalse(\n inherited_slots.__contains__,\n itertools.chain(\n \n \n field_names,('__weakref__',)if weakref_slot else()\n )\n ),\n )\n \n for field_name in field_names:\n \n \n  cls_dict.pop(field_name,None)\n  \n  \n cls_dict.pop('__dict__',None)\n \n \n cls_dict.pop('__weakref__',None)\n \n \n qualname=getattr(cls,'__qualname__',None)\n cls=type(cls)(cls.__name__,cls.__bases__,cls_dict)\n if qualname is not None:\n  cls.__qualname__=qualname\n  \n if is_frozen:\n \n  if '__getstate__'not in cls_dict:\n   cls.__getstate__=_dataclass_getstate\n  if '__setstate__'not in cls_dict:\n   cls.__setstate__=_dataclass_setstate\n   \n return cls\n \n \ndef dataclass(cls=None,/,*,init=True,repr=True,eq=True,order=False,\nunsafe_hash=False,frozen=False,match_args=True,\nkw_only=False,slots=False,weakref_slot=False):\n ''\n\n\n\n\n\n\n\n\n\n\n\n \n \n def wrap(cls):\n  return _process_class(cls,init,repr,eq,order,unsafe_hash,\n  frozen,match_args,kw_only,slots,\n  weakref_slot)\n  \n  \n if cls is None:\n \n  return wrap\n  \n  \n return wrap(cls)\n \n \ndef fields(class_or_instance):\n ''\n\n\n\n \n \n \n try:\n  fields=getattr(class_or_instance,_FIELDS)\n except AttributeError:\n  raise TypeError('must be called with a dataclass type or instance')from None\n  \n  \n  \n return tuple(f for f in fields.values()if f._field_type is _FIELD)\n \n \ndef _is_dataclass_instance(obj):\n ''\n return hasattr(type(obj),_FIELDS)\n \n \ndef is_dataclass(obj):\n ''\n \n cls=obj if isinstance(obj,type)else type(obj)\n return hasattr(cls,_FIELDS)\n \n \ndef asdict(obj,*,dict_factory=dict):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n if not _is_dataclass_instance(obj):\n  raise TypeError(\"asdict() should be called on dataclass instances\")\n return _asdict_inner(obj,dict_factory)\n \n \ndef _asdict_inner(obj,dict_factory):\n obj_type=type(obj)\n if obj_type in _ATOMIC_TYPES:\n  return obj\n elif hasattr(obj_type,_FIELDS):\n \n  if dict_factory is dict:\n   return{\n   f.name:_asdict_inner(getattr(obj,f.name),dict)\n   for f in fields(obj)\n   }\n  else:\n   return dict_factory([\n   (f.name,_asdict_inner(getattr(obj,f.name),dict_factory))\n   for f in fields(obj)\n   ])\n   \n elif obj_type is list:\n  return[_asdict_inner(v,dict_factory)for v in obj]\n elif obj_type is dict:\n  return{\n  _asdict_inner(k,dict_factory):_asdict_inner(v,dict_factory)\n  for k,v in obj.items()\n  }\n elif obj_type is tuple:\n  return tuple([_asdict_inner(v,dict_factory)for v in obj])\n elif issubclass(obj_type,tuple):\n  if hasattr(obj,'_fields'):\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n   return obj_type(*[_asdict_inner(v,dict_factory)for v in obj])\n  else:\n   return obj_type(_asdict_inner(v,dict_factory)for v in obj)\n elif issubclass(obj_type,dict):\n  if hasattr(obj_type,'default_factory'):\n  \n  \n   result=obj_type(obj.default_factory)\n   for k,v in obj.items():\n    result[_asdict_inner(k,dict_factory)]=_asdict_inner(v,dict_factory)\n   return result\n  return obj_type((_asdict_inner(k,dict_factory),\n  _asdict_inner(v,dict_factory))\n  for k,v in obj.items())\n elif issubclass(obj_type,list):\n \n \n  return obj_type(_asdict_inner(v,dict_factory)for v in obj)\n else:\n  return copy.deepcopy(obj)\n  \n  \ndef astuple(obj,*,tuple_factory=tuple):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n if not _is_dataclass_instance(obj):\n  raise TypeError(\"astuple() should be called on dataclass instances\")\n return _astuple_inner(obj,tuple_factory)\n \n \ndef _astuple_inner(obj,tuple_factory):\n if type(obj)in _ATOMIC_TYPES:\n  return obj\n elif _is_dataclass_instance(obj):\n  return tuple_factory([\n  _astuple_inner(getattr(obj,f.name),tuple_factory)\n  for f in fields(obj)\n  ])\n elif isinstance(obj,tuple)and hasattr(obj,'_fields'):\n \n \n \n \n \n \n  return type(obj)(*[_astuple_inner(v,tuple_factory)for v in obj])\n elif isinstance(obj,(list,tuple)):\n \n \n \n  return type(obj)(_astuple_inner(v,tuple_factory)for v in obj)\n elif isinstance(obj,dict):\n  obj_type=type(obj)\n  if hasattr(obj_type,'default_factory'):\n  \n  \n   result=obj_type(getattr(obj,'default_factory'))\n   for k,v in obj.items():\n    result[_astuple_inner(k,tuple_factory)]=_astuple_inner(v,tuple_factory)\n   return result\n  return obj_type((_astuple_inner(k,tuple_factory),_astuple_inner(v,tuple_factory))\n  for k,v in obj.items())\n else:\n  return copy.deepcopy(obj)\n  \n  \ndef make_dataclass(cls_name,fields,*,bases=(),namespace=None,init=True,\nrepr=True,eq=True,order=False,unsafe_hash=False,\nfrozen=False,match_args=True,kw_only=False,slots=False,\nweakref_slot=False,module=None):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n if namespace is None:\n  namespace={}\n  \n  \n  \n seen=set()\n annotations={}\n defaults={}\n for item in fields:\n  if isinstance(item,str):\n   name=item\n   tp='typing.Any'\n  elif len(item)==2:\n   name,tp,=item\n  elif len(item)==3:\n   name,tp,spec=item\n   defaults[name]=spec\n  else:\n   raise TypeError(f'Invalid field: {item !r}')\n   \n  if not isinstance(name,str)or not name.isidentifier():\n   raise TypeError(f'Field names must be valid identifiers: {name !r}')\n  if keyword.iskeyword(name):\n   raise TypeError(f'Field names must not be keywords: {name !r}')\n  if name in seen:\n   raise TypeError(f'Field name duplicated: {name !r}')\n   \n  seen.add(name)\n  annotations[name]=tp\n  \n  \n def exec_body_callback(ns):\n  ns.update(namespace)\n  ns.update(defaults)\n  ns['__annotations__']=annotations\n  \n  \n  \n cls=types.new_class(cls_name,bases,{},exec_body_callback)\n \n \n \n if module is None:\n  try:\n   module=sys._getframemodulename(1)or '__main__'\n  except AttributeError:\n   try:\n    module=sys._getframe(1).f_globals.get('__name__','__main__')\n   except(AttributeError,ValueError):\n    pass\n if module is not None:\n  cls.__module__=module\n  \n  \n return dataclass(cls,init=init,repr=repr,eq=eq,order=order,\n unsafe_hash=unsafe_hash,frozen=frozen,\n match_args=match_args,kw_only=kw_only,slots=slots,\n weakref_slot=weakref_slot)\n \n \ndef replace(obj,/,**changes):\n ''\n\n\n\n\n\n\n\n\n\n\n\n \n if not _is_dataclass_instance(obj):\n  raise TypeError(\"replace() should be called on dataclass instances\")\n return _replace(obj,**changes)\n \n \ndef _replace(self,/,**changes):\n\n\n\n\n\n\n for f in getattr(self,_FIELDS).values():\n \n  if f._field_type is _FIELD_CLASSVAR:\n   continue\n   \n  if not f.init:\n  \n   if f.name in changes:\n    raise TypeError(f'field {f.name} is declared with '\n    f'init=False, it cannot be specified with '\n    f'replace()')\n   continue\n   \n  if f.name not in changes:\n   if f._field_type is _FIELD_INITVAR and f.default is MISSING:\n    raise TypeError(f\"InitVar {f.name !r} \"\n    f'must be specified with replace()')\n   changes[f.name]=getattr(self,f.name)\n   \n   \n   \n   \n   \n   \n return self.__class__(**changes)\n", ["abc", "copy", "inspect", "itertools", "keyword", "re", "reprlib", "sys", "types"]], "datetime": [".py", "try:\n from _datetime import *\n from _datetime import __doc__\nexcept ImportError:\n from _pydatetime import *\n from _pydatetime import __doc__\n \n__all__=(\"date\",\"datetime\",\"time\",\"timedelta\",\"timezone\",\"tzinfo\",\n\"MINYEAR\",\"MAXYEAR\",\"UTC\")\n", ["_datetime", "_pydatetime"]], "doctest": [".py", "\n\n\n\n\n\n\n\nr\"\"\"Module doctest -- a framework for running examples in docstrings.\n\nIn simplest use, end each module M to be tested with:\n\ndef _test():\n    import doctest\n    doctest.testmod()\n\nif __name__ == \"__main__\":\n    _test()\n\nThen running the module as a script will cause the examples in the\ndocstrings to get executed and verified:\n\npython M.py\n\nThis won't display anything unless an example fails, in which case the\nfailing example(s) and the cause(s) of the failure(s) are printed to stdout\n(why not stderr? because stderr is a lame hack <0.2 wink>), and the final\nline of output is \"Test failed.\".\n\nRun it with the -v switch instead:\n\npython M.py -v\n\nand a detailed report of all examples tried is printed to stdout, along\nwith assorted summaries at the end.\n\nYou can force verbose mode by passing \"verbose=True\" to testmod, or prohibit\nit by passing \"verbose=False\".  In either of those cases, sys.argv is not\nexamined by testmod.\n\nThere are a variety of other ways to run doctests, including integration\nwith the unittest framework, and support for running non-Python text\nfiles containing doctests.  There are also many ways to override parts\nof doctest's default behaviors.  See the Library Reference Manual for\ndetails.\n\"\"\"\n\n__docformat__='reStructuredText en'\n\n__all__=[\n\n'register_optionflag',\n'DONT_ACCEPT_TRUE_FOR_1',\n'DONT_ACCEPT_BLANKLINE',\n'NORMALIZE_WHITESPACE',\n'ELLIPSIS',\n'SKIP',\n'IGNORE_EXCEPTION_DETAIL',\n'COMPARISON_FLAGS',\n'REPORT_UDIFF',\n'REPORT_CDIFF',\n'REPORT_NDIFF',\n'REPORT_ONLY_FIRST_FAILURE',\n'REPORTING_FLAGS',\n'FAIL_FAST',\n\n\n'Example',\n'DocTest',\n\n'DocTestParser',\n\n'DocTestFinder',\n\n'DocTestRunner',\n'OutputChecker',\n'DocTestFailure',\n'UnexpectedException',\n'DebugRunner',\n\n'testmod',\n'testfile',\n'run_docstring_examples',\n\n'DocTestSuite',\n'DocFileSuite',\n'set_unittest_reportflags',\n\n'script_from_examples',\n'testsource',\n'debug_src',\n'debug',\n]\n\nimport __future__\nimport difflib\nimport inspect\nimport linecache\nimport os\nimport pdb\nimport re\nimport sys\nimport traceback\nimport unittest\nfrom io import StringIO,IncrementalNewlineDecoder\nfrom collections import namedtuple\nimport _colorize\nfrom _colorize import ANSIColors,can_colorize\n\n\nclass TestResults(namedtuple('TestResults','failed attempted')):\n def __new__(cls,failed,attempted,*,skipped=0):\n  results=super().__new__(cls,failed,attempted)\n  results.skipped=skipped\n  return results\n  \n def __repr__(self):\n  if self.skipped:\n   return(f'TestResults(failed={self.failed}, '\n   f'attempted={self.attempted}, '\n   f'skipped={self.skipped})')\n  else:\n  \n  \n   return super().__repr__()\n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \nOPTIONFLAGS_BY_NAME={}\ndef register_optionflag(name):\n\n return OPTIONFLAGS_BY_NAME.setdefault(name,1 <<len(OPTIONFLAGS_BY_NAME))\n \nDONT_ACCEPT_TRUE_FOR_1=register_optionflag('DONT_ACCEPT_TRUE_FOR_1')\nDONT_ACCEPT_BLANKLINE=register_optionflag('DONT_ACCEPT_BLANKLINE')\nNORMALIZE_WHITESPACE=register_optionflag('NORMALIZE_WHITESPACE')\nELLIPSIS=register_optionflag('ELLIPSIS')\nSKIP=register_optionflag('SKIP')\nIGNORE_EXCEPTION_DETAIL=register_optionflag('IGNORE_EXCEPTION_DETAIL')\n\nCOMPARISON_FLAGS=(DONT_ACCEPT_TRUE_FOR_1 |\nDONT_ACCEPT_BLANKLINE |\nNORMALIZE_WHITESPACE |\nELLIPSIS |\nSKIP |\nIGNORE_EXCEPTION_DETAIL)\n\nREPORT_UDIFF=register_optionflag('REPORT_UDIFF')\nREPORT_CDIFF=register_optionflag('REPORT_CDIFF')\nREPORT_NDIFF=register_optionflag('REPORT_NDIFF')\nREPORT_ONLY_FIRST_FAILURE=register_optionflag('REPORT_ONLY_FIRST_FAILURE')\nFAIL_FAST=register_optionflag('FAIL_FAST')\n\nREPORTING_FLAGS=(REPORT_UDIFF |\nREPORT_CDIFF |\nREPORT_NDIFF |\nREPORT_ONLY_FIRST_FAILURE |\nFAIL_FAST)\n\n\nBLANKLINE_MARKER='<BLANKLINE>'\nELLIPSIS_MARKER='...'\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndef _extract_future_flags(globs):\n ''\n\n\n \n flags=0\n for fname in __future__.all_feature_names:\n  feature=globs.get(fname,None)\n  if feature is getattr(__future__,fname):\n   flags |=feature.compiler_flag\n return flags\n \ndef _normalize_module(module,depth=2):\n ''\n\n\n\n\n\n\n\n \n if inspect.ismodule(module):\n  return module\n elif isinstance(module,str):\n  return __import__(module,globals(),locals(),[\"*\"])\n elif module is None:\n  try:\n   try:\n    return sys.modules[sys._getframemodulename(depth)]\n   except AttributeError:\n    return sys.modules[sys._getframe(depth).f_globals['__name__']]\n  except KeyError:\n   pass\n else:\n  raise TypeError(\"Expected a module, string, or None\")\n  \ndef _newline_convert(data):\n\n return IncrementalNewlineDecoder(None,True).decode(data,True)\n \ndef _load_testfile(filename,package,module_relative,encoding):\n if module_relative:\n  package=_normalize_module(package,3)\n  filename=_module_relative_path(package,filename)\n  if(loader :=getattr(package,'__loader__',None))is None:\n   try:\n    loader=package.__spec__.loader\n   except AttributeError:\n    pass\n  if hasattr(loader,'get_data'):\n   file_contents=loader.get_data(filename)\n   file_contents=file_contents.decode(encoding)\n   \n   \n   return _newline_convert(file_contents),filename\n with open(filename,encoding=encoding)as f:\n  return f.read(),filename\n  \ndef _indent(s,indent=4):\n ''\n\n\n \n \n return re.sub('(?m)^(?!$)',indent *' ',s)\n \ndef _exception_traceback(exc_info):\n ''\n\n\n \n \n excout=StringIO()\n exc_type,exc_val,exc_tb=exc_info\n traceback.print_exception(exc_type,exc_val,exc_tb,file=excout)\n return excout.getvalue()\n \n \nclass _SpoofOut(StringIO):\n def getvalue(self):\n  result=StringIO.getvalue(self)\n  \n  \n  \n  if result and not result.endswith(\"\\n\"):\n   result +=\"\\n\"\n  return result\n  \n def truncate(self,size=None):\n  self.seek(size)\n  StringIO.truncate(self)\n  \n  \ndef _ellipsis_match(want,got):\n ''\n\n\n\n \n if ELLIPSIS_MARKER not in want:\n  return want ==got\n  \n  \n ws=want.split(ELLIPSIS_MARKER)\n assert len(ws)>=2\n \n \n startpos,endpos=0,len(got)\n w=ws[0]\n if w:\n  if got.startswith(w):\n   startpos=len(w)\n   del ws[0]\n  else:\n   return False\n w=ws[-1]\n if w:\n  if got.endswith(w):\n   endpos -=len(w)\n   del ws[-1]\n  else:\n   return False\n   \n if startpos >endpos:\n \n \n  return False\n  \n  \n  \n  \n for w in ws:\n \n \n \n  startpos=got.find(w,startpos,endpos)\n  if startpos <0:\n   return False\n  startpos +=len(w)\n  \n return True\n \ndef _comment_line(line):\n ''\n line=line.rstrip()\n if line:\n  return '# '+line\n else:\n  return '#'\n  \ndef _strip_exception_details(msg):\n\n\n\n\n\n\n\n\n\n\n start,end=0,len(msg)\n \n i=msg.find(\"\\n\")\n if i >=0:\n  end=i\n  \n i=msg.find(':',0,end)\n if i >=0:\n  end=i\n  \n i=msg.rfind('.',0,end)\n if i >=0:\n  start=i+1\n return msg[start:end]\n \nclass _OutputRedirectingPdb(pdb.Pdb):\n ''\n\n\n\n \n def __init__(self,out):\n  self.__out=out\n  self.__debugger_used=False\n  \n  pdb.Pdb.__init__(self,stdout=out,nosigint=True)\n  \n  self.use_rawinput=1\n  \n def set_trace(self,frame=None):\n  self.__debugger_used=True\n  if frame is None:\n   frame=sys._getframe().f_back\n  pdb.Pdb.set_trace(self,frame)\n  \n def set_continue(self):\n \n \n  if self.__debugger_used:\n   pdb.Pdb.set_continue(self)\n   \n def trace_dispatch(self,*args):\n \n  save_stdout=sys.stdout\n  sys.stdout=self.__out\n  \n  try:\n   return pdb.Pdb.trace_dispatch(self,*args)\n  finally:\n   sys.stdout=save_stdout\n   \n   \ndef _module_relative_path(module,test_path):\n if not inspect.ismodule(module):\n  raise TypeError('Expected a module: %r'%module)\n if test_path.startswith('/'):\n  raise ValueError('Module-relative files may not have absolute paths')\n  \n  \n test_path=os.path.join(*(test_path.split('/')))\n \n \n if hasattr(module,'__file__'):\n \n  basedir=os.path.split(module.__file__)[0]\n elif module.__name__ =='__main__':\n \n  if len(sys.argv)>0 and sys.argv[0]!='':\n   basedir=os.path.split(sys.argv[0])[0]\n  else:\n   basedir=os.curdir\n else:\n  if hasattr(module,'__path__'):\n   for directory in module.__path__:\n    fullpath=os.path.join(directory,test_path)\n    if os.path.exists(fullpath):\n     return fullpath\n     \n     \n  raise ValueError(\"Can't resolve paths relative to the module \"\n  \"%r (it has no __file__)\"\n  %module.__name__)\n  \n  \n return os.path.join(basedir,test_path)\n \n \n \n \n \n \n \n \n \n \n \n \n \nclass Example:\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n def __init__(self,source,want,exc_msg=None,lineno=0,indent=0,\n options=None):\n \n  if not source.endswith('\\n'):\n   source +='\\n'\n  if want and not want.endswith('\\n'):\n   want +='\\n'\n  if exc_msg is not None and not exc_msg.endswith('\\n'):\n   exc_msg +='\\n'\n   \n  self.source=source\n  self.want=want\n  self.lineno=lineno\n  self.indent=indent\n  if options is None:options={}\n  self.options=options\n  self.exc_msg=exc_msg\n  \n def __eq__(self,other):\n  if type(self)is not type(other):\n   return NotImplemented\n   \n  return self.source ==other.source and\\\n  self.want ==other.want and\\\n  self.lineno ==other.lineno and\\\n  self.indent ==other.indent and\\\n  self.options ==other.options and\\\n  self.exc_msg ==other.exc_msg\n  \n def __hash__(self):\n  return hash((self.source,self.want,self.lineno,self.indent,\n  self.exc_msg))\n  \nclass DocTest:\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n def __init__(self,examples,globs,name,filename,lineno,docstring):\n  ''\n\n\n  \n  assert not isinstance(examples,str),\\\n  \"DocTest no longer accepts str; use DocTestParser instead\"\n  self.examples=examples\n  self.docstring=docstring\n  self.globs=globs.copy()\n  self.name=name\n  self.filename=filename\n  self.lineno=lineno\n  \n def __repr__(self):\n  if len(self.examples)==0:\n   examples='no examples'\n  elif len(self.examples)==1:\n   examples='1 example'\n  else:\n   examples='%d examples'%len(self.examples)\n  return('<%s %s from %s:%s (%s)>'%\n  (self.__class__.__name__,\n  self.name,self.filename,self.lineno,examples))\n  \n def __eq__(self,other):\n  if type(self)is not type(other):\n   return NotImplemented\n   \n  return self.examples ==other.examples and\\\n  self.docstring ==other.docstring and\\\n  self.globs ==other.globs and\\\n  self.name ==other.name and\\\n  self.filename ==other.filename and\\\n  self.lineno ==other.lineno\n  \n def __hash__(self):\n  return hash((self.docstring,self.name,self.filename,self.lineno))\n  \n  \n def __lt__(self,other):\n  if not isinstance(other,DocTest):\n   return NotImplemented\n  self_lno=self.lineno if self.lineno is not None else -1\n  other_lno=other.lineno if other.lineno is not None else -1\n  return((self.name,self.filename,self_lno,id(self))\n  <\n  (other.name,other.filename,other_lno,id(other)))\n  \n  \n  \n  \n  \nclass DocTestParser:\n ''\n\n \n \n \n \n \n \n _EXAMPLE_RE=re.compile(r'''\n        # Source consists of a PS1 line followed by zero or more PS2 lines.\n        (?P<source>\n            (?:^(?P<indent> [ ]*) >>>    .*)    # PS1 line\n            (?:\\n           [ ]*  \\.\\.\\. .*)*)  # PS2 lines\n        \\n?\n        # Want consists of any non-blank lines that do not start with PS1.\n        (?P<want> (?:(?![ ]*$)    # Not a blank line\n                     (?![ ]*>>>)  # Not a line starting with PS1\n                     .+$\\n?       # But any other line\n                  )*)\n        ''',re.MULTILINE |re.VERBOSE)\n \n \n \n \n \n \n \n \n \n \n _EXCEPTION_RE=re.compile(r\"\"\"\n        # Grab the traceback header.  Different versions of Python have\n        # said different things on the first traceback line.\n        ^(?P<hdr> Traceback\\ \\(\n            (?: most\\ recent\\ call\\ last\n            |   innermost\\ last\n            ) \\) :\n        )\n        \\s* $                # toss trailing whitespace on the header.\n        (?P<stack> .*?)      # don't blink: absorb stuff until...\n        ^ (?P<msg> \\w+ .*)   #     a line *starts* with alphanum.\n        \"\"\",re.VERBOSE |re.MULTILINE |re.DOTALL)\n \n \n \n _IS_BLANK_OR_COMMENT=re.compile(r'^[ ]*(#.*)?$').match\n \n def parse(self,string,name='<string>'):\n  ''\n\n\n\n\n\n  \n  string=string.expandtabs()\n  \n  min_indent=self._min_indent(string)\n  if min_indent >0:\n   string='\\n'.join([l[min_indent:]for l in string.split('\\n')])\n   \n  output=[]\n  charno,lineno=0,0\n  \n  for m in self._EXAMPLE_RE.finditer(string):\n  \n   output.append(string[charno:m.start()])\n   \n   lineno +=string.count('\\n',charno,m.start())\n   \n   (source,options,want,exc_msg)=\\\n   self._parse_example(m,name,lineno)\n   \n   if not self._IS_BLANK_OR_COMMENT(source):\n    output.append(Example(source,want,exc_msg,\n    lineno=lineno,\n    indent=min_indent+len(m.group('indent')),\n    options=options))\n    \n   lineno +=string.count('\\n',m.start(),m.end())\n   \n   charno=m.end()\n   \n  output.append(string[charno:])\n  return output\n  \n def get_doctest(self,string,globs,name,filename,lineno):\n  ''\n\n\n\n\n\n\n  \n  return DocTest(self.get_examples(string,name),globs,\n  name,filename,lineno,string)\n  \n def get_examples(self,string,name='<string>'):\n  ''\n\n\n\n\n\n\n\n\n  \n  return[x for x in self.parse(string,name)\n  if isinstance(x,Example)]\n  \n def _parse_example(self,m,name,lineno):\n  ''\n\n\n\n\n\n\n\n\n  \n  \n  indent=len(m.group('indent'))\n  \n  \n  \n  source_lines=m.group('source').split('\\n')\n  self._check_prompt_blank(source_lines,indent,name,lineno)\n  self._check_prefix(source_lines[1:],' '*indent+'.',name,lineno)\n  source='\\n'.join([sl[indent+4:]for sl in source_lines])\n  \n  \n  \n  \n  want=m.group('want')\n  want_lines=want.split('\\n')\n  if len(want_lines)>1 and re.match(r' *$',want_lines[-1]):\n   del want_lines[-1]\n  self._check_prefix(want_lines,' '*indent,name,\n  lineno+len(source_lines))\n  want='\\n'.join([wl[indent:]for wl in want_lines])\n  \n  \n  m=self._EXCEPTION_RE.match(want)\n  if m:\n   exc_msg=m.group('msg')\n  else:\n   exc_msg=None\n   \n   \n  options=self._find_options(source,name,lineno)\n  \n  return source,options,want,exc_msg\n  \n  \n  \n  \n  \n  \n  \n  \n _OPTION_DIRECTIVE_RE=re.compile(r'#\\s*doctest:\\s*([^\\n\\'\"]*)$',\n re.MULTILINE)\n \n def _find_options(self,source,name,lineno):\n  ''\n\n\n\n\n\n  \n  options={}\n  \n  for m in self._OPTION_DIRECTIVE_RE.finditer(source):\n   option_strings=m.group(1).replace(',',' ').split()\n   for option in option_strings:\n    if(option[0]not in '+-'or\n    option[1:]not in OPTIONFLAGS_BY_NAME):\n     raise ValueError('line %r of the doctest for %s '\n     'has an invalid option: %r'%\n     (lineno+1,name,option))\n    flag=OPTIONFLAGS_BY_NAME[option[1:]]\n    options[flag]=(option[0]=='+')\n  if options and self._IS_BLANK_OR_COMMENT(source):\n   raise ValueError('line %r of the doctest for %s has an option '\n   'directive on a line with no example: %r'%\n   (lineno,name,source))\n  return options\n  \n  \n  \n _INDENT_RE=re.compile(r'^([ ]*)(?=\\S)',re.MULTILINE)\n \n def _min_indent(self,s):\n  ''\n  indents=[len(indent)for indent in self._INDENT_RE.findall(s)]\n  if len(indents)>0:\n   return min(indents)\n  else:\n   return 0\n   \n def _check_prompt_blank(self,lines,indent,name,lineno):\n  ''\n\n\n\n\n  \n  for i,line in enumerate(lines):\n   if len(line)>=indent+4 and line[indent+3]!=' ':\n    raise ValueError('line %r of the docstring for %s '\n    'lacks blank after %s: %r'%\n    (lineno+i+1,name,\n    line[indent:indent+3],line))\n    \n def _check_prefix(self,lines,prefix,name,lineno):\n  ''\n\n\n  \n  for i,line in enumerate(lines):\n   if line and not line.startswith(prefix):\n    raise ValueError('line %r of the docstring for %s has '\n    'inconsistent leading whitespace: %r'%\n    (lineno+i+1,name,line))\n    \n    \n    \n    \n    \n    \nclass DocTestFinder:\n ''\n\n\n\n\n\n \n \n def __init__(self,verbose=False,parser=DocTestParser(),\n recurse=True,exclude_empty=True):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  self._parser=parser\n  self._verbose=verbose\n  self._recurse=recurse\n  self._exclude_empty=exclude_empty\n  \n def find(self,obj,name=None,module=None,globs=None,extraglobs=None):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  if name is None:\n   name=getattr(obj,'__name__',None)\n   if name is None:\n    raise ValueError(\"DocTestFinder.find: name must be given \"\n    \"when obj.__name__ doesn't exist: %r\"%\n    (type(obj),))\n    \n    \n    \n    \n  if module is False:\n   module=None\n  elif module is None:\n   module=inspect.getmodule(obj)\n   \n   \n   \n   \n  try:\n   file=inspect.getsourcefile(obj)\n  except TypeError:\n   source_lines=None\n  else:\n   if not file:\n   \n   \n    file=inspect.getfile(obj)\n    if not file[0]+file[-2:]=='<]>':file=None\n   if file is None:\n    source_lines=None\n   else:\n    if module is not None:\n    \n    \n    \n     source_lines=linecache.getlines(file,module.__dict__)\n    else:\n    \n    \n     source_lines=linecache.getlines(file)\n    if not source_lines:\n     source_lines=None\n     \n     \n  if globs is None:\n   if module is None:\n    globs={}\n   else:\n    globs=module.__dict__.copy()\n  else:\n   globs=globs.copy()\n  if extraglobs is not None:\n   globs.update(extraglobs)\n  if '__name__'not in globs:\n   globs['__name__']='__main__'\n   \n   \n  tests=[]\n  self._find(tests,obj,name,module,source_lines,globs,{})\n  \n  \n  \n  \n  tests.sort()\n  return tests\n  \n def _from_module(self,module,object):\n  ''\n\n\n  \n  if module is None:\n   return True\n  elif inspect.getmodule(object)is not None:\n   return module is inspect.getmodule(object)\n  elif inspect.isfunction(object):\n   return module.__dict__ is object.__globals__\n  elif(inspect.ismethoddescriptor(object)or\n  inspect.ismethodwrapper(object)):\n   if hasattr(object,'__objclass__'):\n    obj_mod=object.__objclass__.__module__\n   elif hasattr(object,'__module__'):\n    obj_mod=object.__module__\n   else:\n    return True\n   return module.__name__ ==obj_mod\n  elif inspect.isclass(object):\n   return module.__name__ ==object.__module__\n  elif hasattr(object,'__module__'):\n   return module.__name__ ==object.__module__\n  elif isinstance(object,property):\n   return True\n  else:\n   raise ValueError(\"object must be a class or function\")\n   \n def _is_routine(self,obj):\n  ''\n\n  \n  maybe_routine=obj\n  try:\n   maybe_routine=inspect.unwrap(maybe_routine)\n  except ValueError:\n   pass\n  return inspect.isroutine(maybe_routine)\n  \n def _find(self,tests,obj,name,module,source_lines,globs,seen):\n  ''\n\n\n  \n  if self._verbose:\n   print('Finding tests in %s'%name)\n   \n   \n  if id(obj)in seen:\n   return\n  seen[id(obj)]=1\n  \n  \n  test=self._get_test(obj,name,module,globs,source_lines)\n  if test is not None:\n   tests.append(test)\n   \n   \n  if inspect.ismodule(obj)and self._recurse:\n   for valname,val in obj.__dict__.items():\n    valname='%s.%s'%(name,valname)\n    \n    \n    if((self._is_routine(val)or inspect.isclass(val))and\n    self._from_module(module,val)):\n     self._find(tests,val,valname,module,source_lines,\n     globs,seen)\n     \n     \n  if inspect.ismodule(obj)and self._recurse:\n   for valname,val in getattr(obj,'__test__',{}).items():\n    if not isinstance(valname,str):\n     raise ValueError(\"DocTestFinder.find: __test__ keys \"\n     \"must be strings: %r\"%\n     (type(valname),))\n    if not(inspect.isroutine(val)or inspect.isclass(val)or\n    inspect.ismodule(val)or isinstance(val,str)):\n     raise ValueError(\"DocTestFinder.find: __test__ values \"\n     \"must be strings, functions, methods, \"\n     \"classes, or modules: %r\"%\n     (type(val),))\n    valname='%s.__test__.%s'%(name,valname)\n    self._find(tests,val,valname,module,source_lines,\n    globs,seen)\n    \n    \n  if inspect.isclass(obj)and self._recurse:\n   for valname,val in obj.__dict__.items():\n   \n    if isinstance(val,(staticmethod,classmethod)):\n     val=val.__func__\n     \n     \n    if((inspect.isroutine(val)or inspect.isclass(val)or\n    isinstance(val,property))and\n    self._from_module(module,val)):\n     valname='%s.%s'%(name,valname)\n     self._find(tests,val,valname,module,source_lines,\n     globs,seen)\n     \n def _get_test(self,obj,name,module,globs,source_lines):\n  ''\n\n\n  \n  \n  \n  if isinstance(obj,str):\n   docstring=obj\n  else:\n   try:\n    if obj.__doc__ is None:\n     docstring=''\n    else:\n     docstring=obj.__doc__\n     if not isinstance(docstring,str):\n      docstring=str(docstring)\n   except(TypeError,AttributeError):\n    docstring=''\n    \n    \n  lineno=self._find_lineno(obj,source_lines)\n  \n  \n  if self._exclude_empty and not docstring:\n   return None\n   \n   \n  if module is None:\n   filename=None\n  else:\n  \n   filename=getattr(module,'__file__',None)or module.__name__\n   if filename[-4:]==\".pyc\":\n    filename=filename[:-1]\n  return self._parser.get_doctest(docstring,globs,name,\n  filename,lineno)\n  \n def _find_lineno(self,obj,source_lines):\n  ''\n\n\n\n  \n  lineno=None\n  docstring=getattr(obj,'__doc__',None)\n  \n  \n  if inspect.ismodule(obj)and docstring is not None:\n   lineno=0\n   \n   \n   \n   \n  if inspect.isclass(obj)and docstring is not None:\n   if source_lines is None:\n    return None\n   pat=re.compile(r'^\\s*class\\s*%s\\b'%\n   re.escape(getattr(obj,'__name__','-')))\n   for i,line in enumerate(source_lines):\n    if pat.match(line):\n     lineno=i\n     break\n     \n     \n  if inspect.ismethod(obj):obj=obj.__func__\n  if isinstance(obj,property):\n   obj=obj.fget\n  if inspect.isfunction(obj)and getattr(obj,'__doc__',None):\n  \n   obj=inspect.unwrap(obj)\n   try:\n    obj=obj.__code__\n   except AttributeError:\n   \n   \n   \n    return None\n  if inspect.istraceback(obj):obj=obj.tb_frame\n  if inspect.isframe(obj):obj=obj.f_code\n  if inspect.iscode(obj):\n   lineno=obj.co_firstlineno -1\n   \n   \n   \n   \n   \n   \n  if lineno is not None:\n   if source_lines is None:\n    return lineno+1\n   pat=re.compile(r'(^|.*:)\\s*\\w*(\"|\\')')\n   for lineno in range(lineno,len(source_lines)):\n    if pat.match(source_lines[lineno]):\n     return lineno\n     \n     \n  return None\n  \n  \n  \n  \n  \nclass DocTestRunner:\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n DIVIDER=\"*\"*70\n \n def __init__(self,checker=None,verbose=None,optionflags=0):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  self._checker=checker or OutputChecker()\n  if verbose is None:\n   verbose='-v'in sys.argv\n  self._verbose=verbose\n  self.optionflags=optionflags\n  self.original_optionflags=optionflags\n  \n  \n  self.tries=0\n  self.failures=0\n  self.skips=0\n  self._stats={}\n  \n  \n  self._fakeout=_SpoofOut()\n  \n  \n  \n  \n  \n def report_start(self,out,test,example):\n  ''\n\n\n  \n  if self._verbose:\n   if example.want:\n    out('Trying:\\n'+_indent(example.source)+\n    'Expecting:\\n'+_indent(example.want))\n   else:\n    out('Trying:\\n'+_indent(example.source)+\n    'Expecting nothing\\n')\n    \n def report_success(self,out,test,example,got):\n  ''\n\n\n  \n  if self._verbose:\n   out(\"ok\\n\")\n   \n def report_failure(self,out,test,example,got):\n  ''\n\n  \n  out(self._failure_header(test,example)+\n  self._checker.output_difference(example,got,self.optionflags))\n  \n def report_unexpected_exception(self,out,test,example,exc_info):\n  ''\n\n  \n  out(self._failure_header(test,example)+\n  'Exception raised:\\n'+_indent(_exception_traceback(exc_info)))\n  \n def _failure_header(self,test,example):\n  red,reset=(\n  (ANSIColors.RED,ANSIColors.RESET)if can_colorize()else(\"\",\"\")\n  )\n  out=[f\"{red}{self.DIVIDER}{reset}\"]\n  if test.filename:\n   if test.lineno is not None and example.lineno is not None:\n    lineno=test.lineno+example.lineno+1\n   else:\n    lineno='?'\n   out.append('File \"%s\", line %s, in %s'%\n   (test.filename,lineno,test.name))\n  else:\n   out.append('Line %s, in %s'%(example.lineno+1,test.name))\n  out.append('Failed example:')\n  source=example.source\n  out.append(_indent(source))\n  return '\\n'.join(out)\n  \n  \n  \n  \n  \n def __run(self,test,compileflags,out):\n  ''\n\n\n\n\n\n  \n  \n  failures=attempted=skips=0\n  \n  \n  \n  original_optionflags=self.optionflags\n  \n  SUCCESS,FAILURE,BOOM=range(3)\n  \n  check=self._checker.check_output\n  \n  \n  for examplenum,example in enumerate(test.examples):\n   attempted +=1\n   \n   \n   \n   quiet=(self.optionflags&REPORT_ONLY_FIRST_FAILURE and\n   failures >0)\n   \n   \n   self.optionflags=original_optionflags\n   if example.options:\n    for(optionflag,val)in example.options.items():\n     if val:\n      self.optionflags |=optionflag\n     else:\n      self.optionflags &=~optionflag\n      \n      \n   if self.optionflags&SKIP:\n    skips +=1\n    continue\n    \n    \n   if not quiet:\n    self.report_start(out,test,example)\n    \n    \n    \n    \n   filename='<doctest %s[%d]>'%(test.name,examplenum)\n   \n   \n   \n   \n   try:\n   \n    exec(compile(example.source,filename,\"single\",\n    compileflags,True),test.globs)\n    self.debugger.set_continue()\n    exception=None\n   except KeyboardInterrupt:\n    raise\n   except:\n    exception=sys.exc_info()\n    self.debugger.set_continue()\n    \n   got=self._fakeout.getvalue()\n   self._fakeout.truncate(0)\n   outcome=FAILURE\n   \n   \n   \n   if exception is None:\n    if check(example.want,got,self.optionflags):\n     outcome=SUCCESS\n     \n     \n   else:\n    formatted_ex=traceback.format_exception_only(*exception[:2])\n    if issubclass(exception[0],SyntaxError):\n    \n    \n    \n    \n     exception_line_prefixes=(\n     f\"{exception[0].__qualname__}:\",\n     f\"{exception[0].__module__}.{exception[0].__qualname__}:\",\n     )\n     exc_msg_index=next(\n     index\n     for index,line in enumerate(formatted_ex)\n     if line.startswith(exception_line_prefixes)\n     )\n     formatted_ex=formatted_ex[exc_msg_index:]\n     \n    exc_msg=\"\".join(formatted_ex)\n    if not quiet:\n     got +=_exception_traceback(exception)\n     \n     \n     \n    if example.exc_msg is None:\n     outcome=BOOM\n     \n     \n    elif check(example.exc_msg,exc_msg,self.optionflags):\n     outcome=SUCCESS\n     \n     \n    elif self.optionflags&IGNORE_EXCEPTION_DETAIL:\n     if check(_strip_exception_details(example.exc_msg),\n     _strip_exception_details(exc_msg),\n     self.optionflags):\n      outcome=SUCCESS\n      \n      \n   if outcome is SUCCESS:\n    if not quiet:\n     self.report_success(out,test,example,got)\n   elif outcome is FAILURE:\n    if not quiet:\n     self.report_failure(out,test,example,got)\n    failures +=1\n   elif outcome is BOOM:\n    if not quiet:\n     self.report_unexpected_exception(out,test,example,\n     exception)\n    failures +=1\n   else:\n    assert False,(\"unknown outcome\",outcome)\n    \n   if failures and self.optionflags&FAIL_FAST:\n    break\n    \n    \n  self.optionflags=original_optionflags\n  \n  \n  self.__record_outcome(test,failures,attempted,skips)\n  return TestResults(failures,attempted,skipped=skips)\n  \n def __record_outcome(self,test,failures,tries,skips):\n  ''\n\n\n  \n  failures2,tries2,skips2=self._stats.get(test.name,(0,0,0))\n  self._stats[test.name]=(failures+failures2,\n  tries+tries2,\n  skips+skips2)\n  self.failures +=failures\n  self.tries +=tries\n  self.skips +=skips\n  \n __LINECACHE_FILENAME_RE=re.compile(r'<doctest '\n r'(?P<name>.+)'\n r'\\[(?P<examplenum>\\d+)\\]>$')\n def __patched_linecache_getlines(self,filename,module_globals=None):\n  m=self.__LINECACHE_FILENAME_RE.match(filename)\n  if m and m.group('name')==self.test.name:\n   example=self.test.examples[int(m.group('examplenum'))]\n   return example.source.splitlines(keepends=True)\n  else:\n   return self.save_linecache_getlines(filename,module_globals)\n   \n def run(self,test,compileflags=None,out=None,clear_globs=True):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  self.test=test\n  \n  if compileflags is None:\n   compileflags=_extract_future_flags(test.globs)\n   \n  save_stdout=sys.stdout\n  if out is None:\n   encoding=save_stdout.encoding\n   if encoding is None or encoding.lower()=='utf-8':\n    out=save_stdout.write\n   else:\n   \n    def out(s):\n     s=str(s.encode(encoding,'backslashreplace'),encoding)\n     save_stdout.write(s)\n  sys.stdout=self._fakeout\n  \n  \n  \n  \n  \n  \n  save_trace=sys.gettrace()\n  save_set_trace=pdb.set_trace\n  self.debugger=_OutputRedirectingPdb(save_stdout)\n  self.debugger.reset()\n  pdb.set_trace=self.debugger.set_trace\n  \n  \n  \n  self.save_linecache_getlines=linecache.getlines\n  linecache.getlines=self.__patched_linecache_getlines\n  \n  \n  save_displayhook=sys.displayhook\n  sys.displayhook=sys.__displayhook__\n  saved_can_colorize=_colorize.can_colorize\n  _colorize.can_colorize=lambda:False\n  color_variables={\"PYTHON_COLORS\":None,\"FORCE_COLOR\":None}\n  for key in color_variables:\n   color_variables[key]=os.environ.pop(key,None)\n  try:\n   return self.__run(test,compileflags,out)\n  finally:\n   sys.stdout=save_stdout\n   pdb.set_trace=save_set_trace\n   sys.settrace(save_trace)\n   linecache.getlines=self.save_linecache_getlines\n   sys.displayhook=save_displayhook\n   _colorize.can_colorize=saved_can_colorize\n   for key,value in color_variables.items():\n    if value is not None:\n     os.environ[key]=value\n   if clear_globs:\n    test.globs.clear()\n    import builtins\n    builtins._=None\n    \n    \n    \n    \n def summarize(self,verbose=None):\n  ''\n\n\n\n\n\n\n  \n  if verbose is None:\n   verbose=self._verbose\n   \n  notests,passed,failed=[],[],[]\n  total_tries=total_failures=total_skips=0\n  \n  for name,(failures,tries,skips)in self._stats.items():\n   assert failures <=tries\n   total_tries +=tries\n   total_failures +=failures\n   total_skips +=skips\n   \n   if tries ==0:\n    notests.append(name)\n   elif failures ==0:\n    passed.append((name,tries))\n   else:\n    failed.append((name,(failures,tries,skips)))\n    \n  ansi=_colorize.get_colors()\n  bold_green=ansi.BOLD_GREEN\n  bold_red=ansi.BOLD_RED\n  green=ansi.GREEN\n  red=ansi.RED\n  reset=ansi.RESET\n  yellow=ansi.YELLOW\n  \n  if verbose:\n   if notests:\n    print(f\"{_n_items(notests)} had no tests:\")\n    notests.sort()\n    for name in notests:\n     print(f\"    {name}\")\n     \n   if passed:\n    print(f\"{green}{_n_items(passed)} passed all tests:{reset}\")\n    for name,count in sorted(passed):\n     s=\"\"if count ==1 else \"s\"\n     print(f\" {green}{count:3d} test{s} in {name}{reset}\")\n     \n  if failed:\n   print(f\"{red}{self.DIVIDER}{reset}\")\n   print(f\"{_n_items(failed)} had failures:\")\n   for name,(failures,tries,skips)in sorted(failed):\n    print(f\" {failures:3d} of {tries:3d} in {name}\")\n    \n  if verbose:\n   s=\"\"if total_tries ==1 else \"s\"\n   print(f\"{total_tries} test{s} in {_n_items(self._stats)}.\")\n   \n   and_f=(\n   f\" and {red}{total_failures} failed{reset}\"\n   if total_failures else \"\"\n   )\n   print(f\"{green}{total_tries -total_failures} passed{reset}{and_f}.\")\n   \n  if total_failures:\n   s=\"\"if total_failures ==1 else \"s\"\n   msg=f\"{bold_red}***Test Failed*** {total_failures} failure{s}{reset}\"\n   if total_skips:\n    s=\"\"if total_skips ==1 else \"s\"\n    msg=f\"{msg} and {yellow}{total_skips} skipped test{s}{reset}\"\n   print(f\"{msg}.\")\n  elif verbose:\n   print(f\"{bold_green}Test passed.{reset}\")\n   \n  return TestResults(total_failures,total_tries,skipped=total_skips)\n  \n  \n  \n  \n def merge(self,other):\n  d=self._stats\n  for name,(failures,tries,skips)in other._stats.items():\n   if name in d:\n    failures2,tries2,skips2=d[name]\n    failures=failures+failures2\n    tries=tries+tries2\n    skips=skips+skips2\n   d[name]=(failures,tries,skips)\n   \n   \ndef _n_items(items:list |dict)->str:\n ''\n\n \n n=len(items)\n s=\"\"if n ==1 else \"s\"\n return f\"{n} item{s}\"\n \n \nclass OutputChecker:\n ''\n\n\n\n\n\n \n def _toAscii(self,s):\n  ''\n\n  \n  return str(s.encode('ASCII','backslashreplace'),\"ASCII\")\n  \n def check_output(self,want,got,optionflags):\n  ''\n\n\n\n\n\n\n\n  \n  \n  \n  \n  \n  \n  \n  got=self._toAscii(got)\n  want=self._toAscii(want)\n  \n  \n  \n  if got ==want:\n   return True\n   \n   \n   \n  if not(optionflags&DONT_ACCEPT_TRUE_FOR_1):\n   if(got,want)==(\"True\\n\",\"1\\n\"):\n    return True\n   if(got,want)==(\"False\\n\",\"0\\n\"):\n    return True\n    \n    \n    \n  if not(optionflags&DONT_ACCEPT_BLANKLINE):\n  \n   want=re.sub(r'(?m)^%s\\s*?$'%re.escape(BLANKLINE_MARKER),\n   '',want)\n   \n   \n   got=re.sub(r'(?m)^[^\\S\\n]+$','',got)\n   if got ==want:\n    return True\n    \n    \n    \n    \n  if optionflags&NORMALIZE_WHITESPACE:\n   got=' '.join(got.split())\n   want=' '.join(want.split())\n   if got ==want:\n    return True\n    \n    \n    \n  if optionflags&ELLIPSIS:\n   if _ellipsis_match(want,got):\n    return True\n    \n    \n  return False\n  \n  \n def _do_a_fancy_diff(self,want,got,optionflags):\n \n  if not optionflags&(REPORT_UDIFF |\n  REPORT_CDIFF |\n  REPORT_NDIFF):\n   return False\n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n  if optionflags&REPORT_NDIFF:\n   return True\n   \n   \n  return want.count('\\n')>2 and got.count('\\n')>2\n  \n def output_difference(self,example,got,optionflags):\n  ''\n\n\n\n\n  \n  want=example.want\n  \n  \n  if not(optionflags&DONT_ACCEPT_BLANKLINE):\n   got=re.sub('(?m)^[ ]*(?=\\n)',BLANKLINE_MARKER,got)\n   \n   \n  if self._do_a_fancy_diff(want,got,optionflags):\n  \n   want_lines=want.splitlines(keepends=True)\n   got_lines=got.splitlines(keepends=True)\n   \n   if optionflags&REPORT_UDIFF:\n    diff=difflib.unified_diff(want_lines,got_lines,n=2)\n    diff=list(diff)[2:]\n    kind='unified diff with -expected +actual'\n   elif optionflags&REPORT_CDIFF:\n    diff=difflib.context_diff(want_lines,got_lines,n=2)\n    diff=list(diff)[2:]\n    kind='context diff with expected followed by actual'\n   elif optionflags&REPORT_NDIFF:\n    engine=difflib.Differ(charjunk=difflib.IS_CHARACTER_JUNK)\n    diff=list(engine.compare(want_lines,got_lines))\n    kind='ndiff with -expected +actual'\n   else:\n    assert 0,'Bad diff option'\n   return 'Differences (%s):\\n'%kind+_indent(''.join(diff))\n   \n   \n   \n  if want and got:\n   return 'Expected:\\n%sGot:\\n%s'%(_indent(want),_indent(got))\n  elif want:\n   return 'Expected:\\n%sGot nothing\\n'%_indent(want)\n  elif got:\n   return 'Expected nothing\\nGot:\\n%s'%_indent(got)\n  else:\n   return 'Expected nothing\\nGot nothing\\n'\n   \nclass DocTestFailure(Exception):\n ''\n\n\n\n\n\n\n\n\n \n def __init__(self,test,example,got):\n  self.test=test\n  self.example=example\n  self.got=got\n  \n def __str__(self):\n  return str(self.test)\n  \nclass UnexpectedException(Exception):\n ''\n\n\n\n\n\n\n\n\n \n def __init__(self,test,example,exc_info):\n  self.test=test\n  self.example=example\n  self.exc_info=exc_info\n  \n def __str__(self):\n  return str(self.test)\n  \nclass DebugRunner(DocTestRunner):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n def run(self,test,compileflags=None,out=None,clear_globs=True):\n  r=DocTestRunner.run(self,test,compileflags,out,False)\n  if clear_globs:\n   test.globs.clear()\n  return r\n  \n def report_unexpected_exception(self,out,test,example,exc_info):\n  raise UnexpectedException(test,example,exc_info)\n  \n def report_failure(self,out,test,example,got):\n  raise DocTestFailure(test,example,got)\n  \n  \n  \n  \n  \n  \n  \n  \nmaster=None\n\ndef testmod(m=None,name=None,globs=None,verbose=None,\nreport=True,optionflags=0,extraglobs=None,\nraise_on_error=False,exclude_empty=False):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n global master\n \n \n if m is None:\n \n \n \n  m=sys.modules.get('__main__')\n  \n  \n if not inspect.ismodule(m):\n  raise TypeError(\"testmod: module required; %r\"%(m,))\n  \n  \n if name is None:\n  name=m.__name__\n  \n  \n finder=DocTestFinder(exclude_empty=exclude_empty)\n \n if raise_on_error:\n  runner=DebugRunner(verbose=verbose,optionflags=optionflags)\n else:\n  runner=DocTestRunner(verbose=verbose,optionflags=optionflags)\n  \n for test in finder.find(m,name,globs=globs,extraglobs=extraglobs):\n  runner.run(test)\n  \n if report:\n  runner.summarize()\n  \n if master is None:\n  master=runner\n else:\n  master.merge(runner)\n  \n return TestResults(runner.failures,runner.tries,skipped=runner.skips)\n \n \ndef testfile(filename,module_relative=True,name=None,package=None,\nglobs=None,verbose=None,report=True,optionflags=0,\nextraglobs=None,raise_on_error=False,parser=DocTestParser(),\nencoding=None):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n global master\n \n if package and not module_relative:\n  raise ValueError(\"Package may only be specified for module-\"\n  \"relative paths.\")\n  \n  \n text,filename=_load_testfile(filename,package,module_relative,\n encoding or \"utf-8\")\n \n \n if name is None:\n  name=os.path.basename(filename)\n  \n  \n if globs is None:\n  globs={}\n else:\n  globs=globs.copy()\n if extraglobs is not None:\n  globs.update(extraglobs)\n if '__name__'not in globs:\n  globs['__name__']='__main__'\n  \n if raise_on_error:\n  runner=DebugRunner(verbose=verbose,optionflags=optionflags)\n else:\n  runner=DocTestRunner(verbose=verbose,optionflags=optionflags)\n  \n  \n test=parser.get_doctest(text,globs,name,filename,0)\n runner.run(test)\n \n if report:\n  runner.summarize()\n  \n if master is None:\n  master=runner\n else:\n  master.merge(runner)\n  \n return TestResults(runner.failures,runner.tries,skipped=runner.skips)\n \n \ndef run_docstring_examples(f,globs,verbose=False,name=\"NoName\",\ncompileflags=None,optionflags=0):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n finder=DocTestFinder(verbose=verbose,recurse=False)\n runner=DocTestRunner(verbose=verbose,optionflags=optionflags)\n for test in finder.find(f,name,globs=globs):\n  runner.run(test,compileflags=compileflags)\n  \n  \n  \n  \n  \n_unittest_reportflags=0\n\ndef set_unittest_reportflags(flags):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n global _unittest_reportflags\n \n if(flags&REPORTING_FLAGS)!=flags:\n  raise ValueError(\"Only reporting flags allowed\",flags)\n old=_unittest_reportflags\n _unittest_reportflags=flags\n return old\n \n \nclass DocTestCase(unittest.TestCase):\n\n def __init__(self,test,optionflags=0,setUp=None,tearDown=None,\n checker=None):\n \n  unittest.TestCase.__init__(self)\n  self._dt_optionflags=optionflags\n  self._dt_checker=checker\n  self._dt_test=test\n  self._dt_setUp=setUp\n  self._dt_tearDown=tearDown\n  \n def setUp(self):\n  test=self._dt_test\n  self._dt_globs=test.globs.copy()\n  \n  if self._dt_setUp is not None:\n   self._dt_setUp(test)\n   \n def tearDown(self):\n  test=self._dt_test\n  \n  if self._dt_tearDown is not None:\n   self._dt_tearDown(test)\n   \n   \n  test.globs.clear()\n  test.globs.update(self._dt_globs)\n  \n def runTest(self):\n  test=self._dt_test\n  old=sys.stdout\n  new=StringIO()\n  optionflags=self._dt_optionflags\n  \n  if not(optionflags&REPORTING_FLAGS):\n  \n  \n   optionflags |=_unittest_reportflags\n   \n  runner=DocTestRunner(optionflags=optionflags,\n  checker=self._dt_checker,verbose=False)\n  \n  try:\n   runner.DIVIDER=\"-\"*70\n   results=runner.run(test,out=new.write,clear_globs=False)\n   if results.skipped ==results.attempted:\n    raise unittest.SkipTest(\"all examples were skipped\")\n  finally:\n   sys.stdout=old\n   \n  if results.failed:\n   raise self.failureException(self.format_failure(new.getvalue()))\n   \n def format_failure(self,err):\n  test=self._dt_test\n  if test.lineno is None:\n   lineno='unknown line number'\n  else:\n   lineno='%s'%test.lineno\n  lname='.'.join(test.name.split('.')[-1:])\n  return('Failed doctest test for %s\\n'\n  '  File \"%s\", line %s, in %s\\n\\n%s'\n  %(test.name,test.filename,lineno,lname,err)\n  )\n  \n def debug(self):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  self.setUp()\n  runner=DebugRunner(optionflags=self._dt_optionflags,\n  checker=self._dt_checker,verbose=False)\n  runner.run(self._dt_test,clear_globs=False)\n  self.tearDown()\n  \n def id(self):\n  return self._dt_test.name\n  \n def __eq__(self,other):\n  if type(self)is not type(other):\n   return NotImplemented\n   \n  return self._dt_test ==other._dt_test and\\\n  self._dt_optionflags ==other._dt_optionflags and\\\n  self._dt_setUp ==other._dt_setUp and\\\n  self._dt_tearDown ==other._dt_tearDown and\\\n  self._dt_checker ==other._dt_checker\n  \n def __hash__(self):\n  return hash((self._dt_optionflags,self._dt_setUp,self._dt_tearDown,\n  self._dt_checker))\n  \n def __repr__(self):\n  name=self._dt_test.name.split('.')\n  return \"%s (%s)\"%(name[-1],'.'.join(name[:-1]))\n  \n __str__=object.__str__\n \n def shortDescription(self):\n  return \"Doctest: \"+self._dt_test.name\n  \nclass SkipDocTestCase(DocTestCase):\n def __init__(self,module):\n  self.module=module\n  DocTestCase.__init__(self,None)\n  \n def setUp(self):\n  self.skipTest(\"DocTestSuite will not work with -O2 and above\")\n  \n def test_skip(self):\n  pass\n  \n def shortDescription(self):\n  return \"Skipping tests from %s\"%self.module.__name__\n  \n __str__=shortDescription\n \n \nclass _DocTestSuite(unittest.TestSuite):\n\n def _removeTestAtIndex(self,index):\n  pass\n  \n  \ndef DocTestSuite(module=None,globs=None,extraglobs=None,test_finder=None,\n**options):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n if test_finder is None:\n  test_finder=DocTestFinder()\n  \n module=_normalize_module(module)\n tests=test_finder.find(module,globs=globs,extraglobs=extraglobs)\n \n if not tests and sys.flags.optimize >=2:\n \n  suite=_DocTestSuite()\n  suite.addTest(SkipDocTestCase(module))\n  return suite\n  \n tests.sort()\n suite=_DocTestSuite()\n \n for test in tests:\n  if len(test.examples)==0:\n   continue\n  if not test.filename:\n   filename=module.__file__\n   if filename[-4:]==\".pyc\":\n    filename=filename[:-1]\n   test.filename=filename\n  suite.addTest(DocTestCase(test,**options))\n  \n return suite\n \nclass DocFileCase(DocTestCase):\n\n def id(self):\n  return '_'.join(self._dt_test.name.split('.'))\n  \n def __repr__(self):\n  return self._dt_test.filename\n  \n def format_failure(self,err):\n  return('Failed doctest test for %s\\n  File \"%s\", line 0\\n\\n%s'\n  %(self._dt_test.name,self._dt_test.filename,err)\n  )\n  \ndef DocFileTest(path,module_relative=True,package=None,\nglobs=None,parser=DocTestParser(),\nencoding=None,**options):\n if globs is None:\n  globs={}\n else:\n  globs=globs.copy()\n  \n if package and not module_relative:\n  raise ValueError(\"Package may only be specified for module-\"\n  \"relative paths.\")\n  \n  \n doc,path=_load_testfile(path,package,module_relative,\n encoding or \"utf-8\")\n \n if \"__file__\"not in globs:\n  globs[\"__file__\"]=path\n  \n  \n name=os.path.basename(path)\n \n \n test=parser.get_doctest(doc,globs,name,path,0)\n return DocFileCase(test,**options)\n \ndef DocFileSuite(*paths,**kw):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n suite=_DocTestSuite()\n \n \n \n \n if kw.get('module_relative',True):\n  kw['package']=_normalize_module(kw.get('package'))\n  \n for path in paths:\n  suite.addTest(DocFileTest(path,**kw))\n  \n return suite\n \n \n \n \n \ndef script_from_examples(s):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n output=[]\n for piece in DocTestParser().parse(s):\n  if isinstance(piece,Example):\n  \n   output.append(piece.source[:-1])\n   \n   want=piece.want\n   if want:\n    output.append('# Expected:')\n    output +=['## '+l for l in want.split('\\n')[:-1]]\n  else:\n  \n   output +=[_comment_line(l)\n   for l in piece.split('\\n')[:-1]]\n   \n   \n while output and output[-1]=='#':\n  output.pop()\n while output and output[0]=='#':\n  output.pop(0)\n  \n  \n return '\\n'.join(output)+'\\n'\n \ndef testsource(module,name):\n ''\n\n\n\n\n \n module=_normalize_module(module)\n tests=DocTestFinder().find(module)\n test=[t for t in tests if t.name ==name]\n if not test:\n  raise ValueError(name,\"not found in tests\")\n test=test[0]\n testsrc=script_from_examples(test.docstring)\n return testsrc\n \ndef debug_src(src,pm=False,globs=None):\n ''\n testsrc=script_from_examples(src)\n debug_script(testsrc,pm,globs)\n \ndef debug_script(src,pm=False,globs=None):\n ''\n import pdb\n \n if globs:\n  globs=globs.copy()\n else:\n  globs={}\n  \n if pm:\n  try:\n   exec(src,globs,globs)\n  except:\n   print(sys.exc_info()[1])\n   p=pdb.Pdb(nosigint=True)\n   p.reset()\n   p.interaction(None,sys.exc_info()[2])\n else:\n  pdb.Pdb(nosigint=True).run(\"exec(%r)\"%src,globs,globs)\n  \ndef debug(module,name,pm=False):\n ''\n\n\n\n\n \n module=_normalize_module(module)\n testsrc=testsource(module,name)\n debug_script(testsrc,pm,module.__dict__)\n \n \n \n \nclass _TestClass:\n ''\n\n\n\n\n\n\n\n\n\n\n \n \n def __init__(self,val):\n  ''\n\n\n\n\n  \n  \n  self.val=val\n  \n def square(self):\n  ''\n\n\n\n  \n  \n  self.val=self.val **2\n  return self\n  \n def get(self):\n  ''\n\n\n\n\n  \n  \n  return self.val\n  \n__test__={\"_TestClass\":_TestClass,\n\"string\":r\"\"\"\n                      Example of a string object, searched as-is.\n                      >>> x = 1; y = 2\n                      >>> x + y, x * y\n                      (3, 2)\n                      \"\"\",\n\n\"bool-int equivalence\":r\"\"\"\n                                    In 2.2, boolean expressions displayed\n                                    0 or 1.  By default, we still accept\n                                    them.  This can be disabled by passing\n                                    DONT_ACCEPT_TRUE_FOR_1 to the new\n                                    optionflags argument.\n                                    >>> 4 == 4\n                                    1\n                                    >>> 4 == 4\n                                    True\n                                    >>> 4 > 4\n                                    0\n                                    >>> 4 > 4\n                                    False\n                                    \"\"\",\n\n\"blank lines\":r\"\"\"\n                Blank lines can be marked with <BLANKLINE>:\n                    >>> print('foo\\n\\nbar\\n')\n                    foo\n                    <BLANKLINE>\n                    bar\n                    <BLANKLINE>\n            \"\"\",\n\n\"ellipsis\":r\"\"\"\n                If the ellipsis flag is used, then '...' can be used to\n                elide substrings in the desired output:\n                    >>> print(list(range(1000))) #doctest: +ELLIPSIS\n                    [0, 1, 2, ..., 999]\n            \"\"\",\n\n\"whitespace normalization\":r\"\"\"\n                If the whitespace normalization flag is used, then\n                differences in whitespace are ignored.\n                    >>> print(list(range(30))) #doctest: +NORMALIZE_WHITESPACE\n                    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,\n                     15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26,\n                     27, 28, 29]\n            \"\"\",\n}\n\n\ndef _test():\n import argparse\n \n parser=argparse.ArgumentParser(description=\"doctest runner\")\n parser.add_argument('-v','--verbose',action='store_true',default=False,\n help='print very verbose output for all tests')\n parser.add_argument('-o','--option',action='append',\n choices=OPTIONFLAGS_BY_NAME.keys(),default=[],\n help=('specify a doctest option flag to apply'\n ' to the test run; may be specified more'\n ' than once to apply multiple options'))\n parser.add_argument('-f','--fail-fast',action='store_true',\n help=('stop running tests after first failure (this'\n ' is a shorthand for -o FAIL_FAST, and is'\n ' in addition to any other -o options)'))\n parser.add_argument('file',nargs='+',\n help='file containing the tests to run')\n args=parser.parse_args()\n testfiles=args.file\n \n \n verbose=args.verbose\n options=0\n for option in args.option:\n  options |=OPTIONFLAGS_BY_NAME[option]\n if args.fail_fast:\n  options |=FAIL_FAST\n for filename in testfiles:\n  if filename.endswith(\".py\"):\n  \n  \n  \n   dirname,filename=os.path.split(filename)\n   sys.path.insert(0,dirname)\n   m=__import__(filename[:-3])\n   del sys.path[0]\n   failures,_=testmod(m,verbose=verbose,optionflags=options)\n  else:\n   failures,_=testfile(filename,module_relative=False,\n   verbose=verbose,optionflags=options)\n  if failures:\n   return 1\n return 0\n \n \nif __name__ ==\"__main__\":\n sys.exit(_test())\n", ["__future__", "_colorize", "argparse", "builtins", "collections", "difflib", "inspect", "io", "linecache", "os", "pdb", "re", "sys", "traceback", "unittest"]], "functools": [".py", "''\n\n\n\n\n\n\n\n\n\n\n__all__=['update_wrapper','wraps','WRAPPER_ASSIGNMENTS','WRAPPER_UPDATES',\n'total_ordering','cache','cmp_to_key','lru_cache','reduce',\n'partial','partialmethod','singledispatch','singledispatchmethod',\n'cached_property']\n\nfrom abc import get_cache_token\nfrom collections import namedtuple\n\nfrom reprlib import recursive_repr\nfrom _thread import RLock\n\n\nGenericAlias=type(list[int])\n\n\n\n\n\n\n\n\nWRAPPER_ASSIGNMENTS=('__module__','__name__','__qualname__','__doc__',\n'__annotations__','__type_params__')\nWRAPPER_UPDATES=('__dict__',)\ndef update_wrapper(wrapper,\nwrapped,\nassigned=WRAPPER_ASSIGNMENTS,\nupdated=WRAPPER_UPDATES):\n ''\n\n\n\n\n\n\n\n\n\n \n for attr in assigned:\n  try:\n   value=getattr(wrapped,attr)\n  except AttributeError:\n   pass\n  else:\n   setattr(wrapper,attr,value)\n for attr in updated:\n  getattr(wrapper,attr).update(getattr(wrapped,attr,{}))\n  \n  \n wrapper.__wrapped__=wrapped\n \n return wrapper\n \ndef wraps(wrapped,\nassigned=WRAPPER_ASSIGNMENTS,\nupdated=WRAPPER_UPDATES):\n ''\n\n\n\n\n\n\n \n return partial(update_wrapper,wrapped=wrapped,\n assigned=assigned,updated=updated)\n \n \n \n \n \n \n \n \n \n \n \ndef _gt_from_lt(self,other):\n ''\n op_result=type(self).__lt__(self,other)\n if op_result is NotImplemented:\n  return op_result\n return not op_result and self !=other\n \ndef _le_from_lt(self,other):\n ''\n op_result=type(self).__lt__(self,other)\n if op_result is NotImplemented:\n  return op_result\n return op_result or self ==other\n \ndef _ge_from_lt(self,other):\n ''\n op_result=type(self).__lt__(self,other)\n if op_result is NotImplemented:\n  return op_result\n return not op_result\n \ndef _ge_from_le(self,other):\n ''\n op_result=type(self).__le__(self,other)\n if op_result is NotImplemented:\n  return op_result\n return not op_result or self ==other\n \ndef _lt_from_le(self,other):\n ''\n op_result=type(self).__le__(self,other)\n if op_result is NotImplemented:\n  return op_result\n return op_result and self !=other\n \ndef _gt_from_le(self,other):\n ''\n op_result=type(self).__le__(self,other)\n if op_result is NotImplemented:\n  return op_result\n return not op_result\n \ndef _lt_from_gt(self,other):\n ''\n op_result=type(self).__gt__(self,other)\n if op_result is NotImplemented:\n  return op_result\n return not op_result and self !=other\n \ndef _ge_from_gt(self,other):\n ''\n op_result=type(self).__gt__(self,other)\n if op_result is NotImplemented:\n  return op_result\n return op_result or self ==other\n \ndef _le_from_gt(self,other):\n ''\n op_result=type(self).__gt__(self,other)\n if op_result is NotImplemented:\n  return op_result\n return not op_result\n \ndef _le_from_ge(self,other):\n ''\n op_result=type(self).__ge__(self,other)\n if op_result is NotImplemented:\n  return op_result\n return not op_result or self ==other\n \ndef _gt_from_ge(self,other):\n ''\n op_result=type(self).__ge__(self,other)\n if op_result is NotImplemented:\n  return op_result\n return op_result and self !=other\n \ndef _lt_from_ge(self,other):\n ''\n op_result=type(self).__ge__(self,other)\n if op_result is NotImplemented:\n  return op_result\n return not op_result\n \n_convert={\n'__lt__':[('__gt__',_gt_from_lt),\n('__le__',_le_from_lt),\n('__ge__',_ge_from_lt)],\n'__le__':[('__ge__',_ge_from_le),\n('__lt__',_lt_from_le),\n('__gt__',_gt_from_le)],\n'__gt__':[('__lt__',_lt_from_gt),\n('__ge__',_ge_from_gt),\n('__le__',_le_from_gt)],\n'__ge__':[('__le__',_le_from_ge),\n('__gt__',_gt_from_ge),\n('__lt__',_lt_from_ge)]\n}\n\ndef total_ordering(cls):\n ''\n \n roots={op for op in _convert if getattr(cls,op,None)is not getattr(object,op,None)}\n if not roots:\n  raise ValueError('must define at least one ordering operation: < > <= >=')\n root=max(roots)\n for opname,opfunc in _convert[root]:\n  if opname not in roots:\n   opfunc.__name__=opname\n   setattr(cls,opname,opfunc)\n return cls\n \n \n \n \n \n \ndef cmp_to_key(mycmp):\n ''\n class K(object):\n  __slots__=['obj']\n  def __init__(self,obj):\n   self.obj=obj\n  def __lt__(self,other):\n   return mycmp(self.obj,other.obj)<0\n  def __gt__(self,other):\n   return mycmp(self.obj,other.obj)>0\n  def __eq__(self,other):\n   return mycmp(self.obj,other.obj)==0\n  def __le__(self,other):\n   return mycmp(self.obj,other.obj)<=0\n  def __ge__(self,other):\n   return mycmp(self.obj,other.obj)>=0\n  __hash__=None\n return K\n \ntry:\n from _functools import cmp_to_key\nexcept ImportError:\n pass\n \n \n \n \n \n \n_initial_missing=object()\n\ndef reduce(function,sequence,initial=_initial_missing):\n ''\n\n\n\n\n\n\n\n\n \n \n it=iter(sequence)\n \n if initial is _initial_missing:\n  try:\n   value=next(it)\n  except StopIteration:\n   raise TypeError(\n   \"reduce() of empty iterable with no initial value\")from None\n else:\n  value=initial\n  \n for element in it:\n  value=function(value,element)\n  \n return value\n \ntry:\n from _functools import reduce\nexcept ImportError:\n pass\n \n \n \n \n \n \n \nclass partial:\n ''\n\n \n \n __slots__=\"func\",\"args\",\"keywords\",\"__dict__\",\"__weakref__\"\n \n def __new__(cls,func,/,*args,**keywords):\n  if not callable(func):\n   raise TypeError(\"the first argument must be callable\")\n   \n  if isinstance(func,partial):\n   args=func.args+args\n   keywords={**func.keywords,**keywords}\n   func=func.func\n   \n  self=super(partial,cls).__new__(cls)\n  \n  self.func=func\n  self.args=args\n  self.keywords=keywords\n  return self\n  \n def __call__(self,/,*args,**keywords):\n  keywords={**self.keywords,**keywords}\n  return self.func(*self.args,*args,**keywords)\n  \n @recursive_repr()\n def __repr__(self):\n  cls=type(self)\n  qualname=cls.__qualname__\n  module=cls.__module__\n  args=[repr(self.func)]\n  args.extend(repr(x)for x in self.args)\n  args.extend(f\"{k}={v !r}\"for(k,v)in self.keywords.items())\n  return f\"{module}.{qualname}({', '.join(args)})\"\n  \n def __get__(self,obj,objtype=None):\n  if obj is None:\n   return self\n  import warnings\n  warnings.warn('functools.partial will be a method descriptor in '\n  'future Python versions; wrap it in staticmethod() '\n  'if you want to preserve the old behavior',\n  FutureWarning,2)\n  return self\n  \n def __reduce__(self):\n  return type(self),(self.func,),(self.func,self.args,\n  self.keywords or None,self.__dict__ or None)\n  \n def __setstate__(self,state):\n  if not isinstance(state,tuple):\n   raise TypeError(\"argument to __setstate__ must be a tuple\")\n  if len(state)!=4:\n   raise TypeError(f\"expected 4 items in state, got {len(state)}\")\n  func,args,kwds,namespace=state\n  if(not callable(func)or not isinstance(args,tuple)or\n  (kwds is not None and not isinstance(kwds,dict))or\n  (namespace is not None and not isinstance(namespace,dict))):\n   raise TypeError(\"invalid partial state\")\n   \n  args=tuple(args)\n  if kwds is None:\n   kwds={}\n  elif type(kwds)is not dict:\n   kwds=dict(kwds)\n  if namespace is None:\n   namespace={}\n   \n  self.__dict__=namespace\n  self.func=func\n  self.args=args\n  self.keywords=kwds\n  \ntry:\n from _functools import partial\nexcept ImportError:\n pass\n \n \nclass partialmethod(object):\n ''\n\n\n\n\n \n \n def __init__(self,func,/,*args,**keywords):\n  if not callable(func)and not hasattr(func,\"__get__\"):\n   raise TypeError(\"{!r} is not callable or a descriptor\"\n   .format(func))\n   \n   \n   \n  if isinstance(func,partialmethod):\n  \n  \n  \n   self.func=func.func\n   self.args=func.args+args\n   self.keywords={**func.keywords,**keywords}\n  else:\n   self.func=func\n   self.args=args\n   self.keywords=keywords\n   \n def __repr__(self):\n  cls=type(self)\n  module=cls.__module__\n  qualname=cls.__qualname__\n  args=[repr(self.func)]\n  args.extend(map(repr,self.args))\n  args.extend(f\"{k}={v !r}\"for k,v in self.keywords.items())\n  return f\"{module}.{qualname}({', '.join(args)})\"\n  \n def _make_unbound_method(self):\n  def _method(cls_or_self,/,*args,**keywords):\n   keywords={**self.keywords,**keywords}\n   return self.func(cls_or_self,*self.args,*args,**keywords)\n  _method.__isabstractmethod__=self.__isabstractmethod__\n  _method.__partialmethod__=self\n  return _method\n  \n def __get__(self,obj,cls=None):\n  get=getattr(self.func,\"__get__\",None)\n  result=None\n  if get is not None and not isinstance(self.func,partial):\n   new_func=get(obj,cls)\n   if new_func is not self.func:\n   \n   \n    result=partial(new_func,*self.args,**self.keywords)\n    try:\n     result.__self__=new_func.__self__\n    except AttributeError:\n     pass\n  if result is None:\n  \n  \n   result=self._make_unbound_method().__get__(obj,cls)\n  return result\n  \n @property\n def __isabstractmethod__(self):\n  return getattr(self.func,\"__isabstractmethod__\",False)\n  \n __class_getitem__=classmethod(GenericAlias)\n \n \n \n \ndef _unwrap_partial(func):\n while isinstance(func,partial):\n  func=func.func\n return func\n \ndef _unwrap_partialmethod(func):\n prev=None\n while func is not prev:\n  prev=func\n  while isinstance(getattr(func,\"__partialmethod__\",None),partialmethod):\n   func=func.__partialmethod__\n  while isinstance(func,partialmethod):\n   func=getattr(func,'func')\n  func=_unwrap_partial(func)\n return func\n \n \n \n \n \n_CacheInfo=namedtuple(\"CacheInfo\",[\"hits\",\"misses\",\"maxsize\",\"currsize\"])\n\nclass _HashedSeq(list):\n ''\n\n\n\n \n \n __slots__='hashvalue'\n \n def __init__(self,tup,hash=hash):\n  self[:]=tup\n  self.hashvalue=hash(tup)\n  \n def __hash__(self):\n  return self.hashvalue\n  \ndef _make_key(args,kwds,typed,\nkwd_mark=(object(),),\nfasttypes={int,str},\ntuple=tuple,type=type,len=len):\n ''\n\n\n\n\n\n\n\n\n \n \n \n \n \n key=args\n if kwds:\n  key +=kwd_mark\n  for item in kwds.items():\n   key +=item\n if typed:\n  key +=tuple(type(v)for v in args)\n  if kwds:\n   key +=tuple(type(v)for v in kwds.values())\n elif len(key)==1 and type(key[0])in fasttypes:\n  return key[0]\n return _HashedSeq(key)\n \ndef lru_cache(maxsize=128,typed=False):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n if isinstance(maxsize,int):\n \n  if maxsize <0:\n   maxsize=0\n elif callable(maxsize)and isinstance(typed,bool):\n \n  user_function,maxsize=maxsize,128\n  wrapper=_lru_cache_wrapper(user_function,maxsize,typed,_CacheInfo)\n  wrapper.cache_parameters=lambda:{'maxsize':maxsize,'typed':typed}\n  return update_wrapper(wrapper,user_function)\n elif maxsize is not None:\n  raise TypeError(\n  'Expected first argument to be an integer, a callable, or None')\n  \n def decorating_function(user_function):\n  wrapper=_lru_cache_wrapper(user_function,maxsize,typed,_CacheInfo)\n  wrapper.cache_parameters=lambda:{'maxsize':maxsize,'typed':typed}\n  return update_wrapper(wrapper,user_function)\n  \n return decorating_function\n \ndef _lru_cache_wrapper(user_function,maxsize,typed,_CacheInfo):\n\n sentinel=object()\n make_key=_make_key\n PREV,NEXT,KEY,RESULT=0,1,2,3\n \n cache={}\n hits=misses=0\n full=False\n cache_get=cache.get\n cache_len=cache.__len__\n lock=RLock()\n root=[]\n root[:]=[root,root,None,None]\n \n if maxsize ==0:\n \n  def wrapper(*args,**kwds):\n  \n   nonlocal misses\n   misses +=1\n   result=user_function(*args,**kwds)\n   return result\n   \n elif maxsize is None:\n \n  def wrapper(*args,**kwds):\n  \n   nonlocal hits,misses\n   key=make_key(args,kwds,typed)\n   result=cache_get(key,sentinel)\n   if result is not sentinel:\n    hits +=1\n    return result\n   misses +=1\n   result=user_function(*args,**kwds)\n   cache[key]=result\n   return result\n   \n else:\n \n  def wrapper(*args,**kwds):\n  \n   nonlocal root,hits,misses,full\n   key=make_key(args,kwds,typed)\n   with lock:\n    link=cache_get(key)\n    if link is not None:\n    \n     link_prev,link_next,_key,result=link\n     link_prev[NEXT]=link_next\n     link_next[PREV]=link_prev\n     last=root[PREV]\n     last[NEXT]=root[PREV]=link\n     link[PREV]=last\n     link[NEXT]=root\n     hits +=1\n     return result\n    misses +=1\n   result=user_function(*args,**kwds)\n   with lock:\n    if key in cache:\n    \n    \n    \n    \n     pass\n    elif full:\n    \n     oldroot=root\n     oldroot[KEY]=key\n     oldroot[RESULT]=result\n     \n     \n     \n     \n     \n     \n     root=oldroot[NEXT]\n     oldkey=root[KEY]\n     oldresult=root[RESULT]\n     root[KEY]=root[RESULT]=None\n     \n     del cache[oldkey]\n     \n     \n     \n     cache[key]=oldroot\n    else:\n    \n     last=root[PREV]\n     link=[last,root,key,result]\n     last[NEXT]=root[PREV]=cache[key]=link\n     \n     \n     full=(cache_len()>=maxsize)\n   return result\n   \n def cache_info():\n  ''\n  with lock:\n   return _CacheInfo(hits,misses,maxsize,cache_len())\n   \n def cache_clear():\n  ''\n  nonlocal hits,misses,full\n  with lock:\n   cache.clear()\n   root[:]=[root,root,None,None]\n   hits=misses=0\n   full=False\n   \n wrapper.cache_info=cache_info\n wrapper.cache_clear=cache_clear\n return wrapper\n \ntry:\n from _functools import _lru_cache_wrapper\nexcept ImportError:\n pass\n \n \n \n \n \n \ndef cache(user_function,/):\n ''\n return lru_cache(maxsize=None)(user_function)\n \n \n \n \n \n \ndef _c3_merge(sequences):\n ''\n\n\n\n \n result=[]\n while True:\n  sequences=[s for s in sequences if s]\n  if not sequences:\n   return result\n  for s1 in sequences:\n   candidate=s1[0]\n   for s2 in sequences:\n    if candidate in s2[1:]:\n     candidate=None\n     break\n   else:\n    break\n  if candidate is None:\n   raise RuntimeError(\"Inconsistent hierarchy\")\n  result.append(candidate)\n  \n  for seq in sequences:\n   if seq[0]==candidate:\n    del seq[0]\n    \ndef _c3_mro(cls,abcs=None):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n for i,base in enumerate(reversed(cls.__bases__)):\n  if hasattr(base,'__abstractmethods__'):\n   boundary=len(cls.__bases__)-i\n   break\n else:\n  boundary=0\n abcs=list(abcs)if abcs else[]\n explicit_bases=list(cls.__bases__[:boundary])\n abstract_bases=[]\n other_bases=list(cls.__bases__[boundary:])\n for base in abcs:\n  if issubclass(cls,base)and not any(\n  issubclass(b,base)for b in cls.__bases__\n  ):\n  \n  \n   abstract_bases.append(base)\n for base in abstract_bases:\n  abcs.remove(base)\n explicit_c3_mros=[_c3_mro(base,abcs=abcs)for base in explicit_bases]\n abstract_c3_mros=[_c3_mro(base,abcs=abcs)for base in abstract_bases]\n other_c3_mros=[_c3_mro(base,abcs=abcs)for base in other_bases]\n return _c3_merge(\n [[cls]]+\n explicit_c3_mros+abstract_c3_mros+other_c3_mros+\n [explicit_bases]+[abstract_bases]+[other_bases]\n )\n \ndef _compose_mro(cls,types):\n ''\n\n\n\n\n \n bases=set(cls.__mro__)\n \n def is_related(typ):\n  return(typ not in bases and hasattr(typ,'__mro__')\n  and not isinstance(typ,GenericAlias)\n  and issubclass(cls,typ))\n types=[n for n in types if is_related(n)]\n \n \n def is_strict_base(typ):\n  for other in types:\n   if typ !=other and typ in other.__mro__:\n    return True\n  return False\n types=[n for n in types if not is_strict_base(n)]\n \n \n type_set=set(types)\n mro=[]\n for typ in types:\n  found=[]\n  for sub in typ.__subclasses__():\n   if sub not in bases and issubclass(cls,sub):\n    found.append([s for s in sub.__mro__ if s in type_set])\n  if not found:\n   mro.append(typ)\n   continue\n   \n  found.sort(key=len,reverse=True)\n  for sub in found:\n   for subcls in sub:\n    if subcls not in mro:\n     mro.append(subcls)\n return _c3_mro(cls,abcs=mro)\n \ndef _find_impl(cls,registry):\n ''\n\n\n\n\n\n\n\n \n mro=_compose_mro(cls,registry.keys())\n match=None\n for t in mro:\n  if match is not None:\n  \n  \n   if(t in registry and t not in cls.__mro__\n   and match not in cls.__mro__\n   and not issubclass(match,t)):\n    raise RuntimeError(\"Ambiguous dispatch: {} or {}\".format(\n    match,t))\n   break\n  if t in registry:\n   match=t\n return registry.get(match)\n \ndef singledispatch(func):\n ''\n\n\n\n\n\n\n \n \n \n \n import types,weakref\n \n registry={}\n dispatch_cache=weakref.WeakKeyDictionary()\n cache_token=None\n \n def dispatch(cls):\n  ''\n\n\n\n\n  \n  nonlocal cache_token\n  if cache_token is not None:\n   current_token=get_cache_token()\n   if cache_token !=current_token:\n    dispatch_cache.clear()\n    cache_token=current_token\n  try:\n   impl=dispatch_cache[cls]\n  except KeyError:\n   try:\n    impl=registry[cls]\n   except KeyError:\n    impl=_find_impl(cls,registry)\n   dispatch_cache[cls]=impl\n  return impl\n  \n def _is_union_type(cls):\n  from typing import get_origin,Union\n  return get_origin(cls)in{Union,types.UnionType}\n  \n def _is_valid_dispatch_type(cls):\n  if isinstance(cls,type):\n   return True\n  from typing import get_args\n  return(_is_union_type(cls)and\n  all(isinstance(arg,type)for arg in get_args(cls)))\n  \n def register(cls,func=None):\n  ''\n\n\n\n  \n  nonlocal cache_token\n  if _is_valid_dispatch_type(cls):\n   if func is None:\n    return lambda f:register(cls,f)\n  else:\n   if func is not None:\n    raise TypeError(\n    f\"Invalid first argument to `register()`. \"\n    f\"{cls !r} is not a class or union type.\"\n    )\n   ann=getattr(cls,'__annotations__',{})\n   if not ann:\n    raise TypeError(\n    f\"Invalid first argument to `register()`: {cls !r}. \"\n    f\"Use either `@register(some_class)` or plain `@register` \"\n    f\"on an annotated function.\"\n    )\n   func=cls\n   \n   \n   from typing import get_type_hints\n   argname,cls=next(iter(get_type_hints(func).items()))\n   if not _is_valid_dispatch_type(cls):\n    if _is_union_type(cls):\n     raise TypeError(\n     f\"Invalid annotation for {argname !r}. \"\n     f\"{cls !r} not all arguments are classes.\"\n     )\n    else:\n     raise TypeError(\n     f\"Invalid annotation for {argname !r}. \"\n     f\"{cls !r} is not a class.\"\n     )\n     \n  if _is_union_type(cls):\n   from typing import get_args\n   \n   for arg in get_args(cls):\n    registry[arg]=func\n  else:\n   registry[cls]=func\n  if cache_token is None and hasattr(cls,'__abstractmethods__'):\n   cache_token=get_cache_token()\n  dispatch_cache.clear()\n  return func\n  \n def wrapper(*args,**kw):\n  if not args:\n   raise TypeError(f'{funcname} requires at least '\n   '1 positional argument')\n  return dispatch(args[0].__class__)(*args,**kw)\n  \n funcname=getattr(func,'__name__','singledispatch function')\n registry[object]=func\n wrapper.register=register\n wrapper.dispatch=dispatch\n wrapper.registry=types.MappingProxyType(registry)\n wrapper._clear_cache=dispatch_cache.clear\n update_wrapper(wrapper,func)\n return wrapper\n \n \n \nclass singledispatchmethod:\n ''\n\n\n\n \n \n def __init__(self,func):\n  if not callable(func)and not hasattr(func,\"__get__\"):\n   raise TypeError(f\"{func !r} is not callable or a descriptor\")\n   \n  self.dispatcher=singledispatch(func)\n  self.func=func\n  \n  import weakref\n  self._method_cache=weakref.WeakKeyDictionary()\n  \n def register(self,cls,method=None):\n  ''\n\n\n  \n  return self.dispatcher.register(cls,func=method)\n  \n def __get__(self,obj,cls=None):\n  if self._method_cache is not None:\n   try:\n    _method=self._method_cache[obj]\n   except TypeError:\n    self._method_cache=None\n   except KeyError:\n    pass\n   else:\n    return _method\n    \n  dispatch=self.dispatcher.dispatch\n  funcname=getattr(self.func,'__name__','singledispatchmethod method')\n  def _method(*args,**kwargs):\n   if not args:\n    raise TypeError(f'{funcname} requires at least '\n    '1 positional argument')\n   return dispatch(args[0].__class__).__get__(obj,cls)(*args,**kwargs)\n   \n  _method.__isabstractmethod__=self.__isabstractmethod__\n  _method.register=self.register\n  update_wrapper(_method,self.func)\n  \n  if self._method_cache is not None:\n   self._method_cache[obj]=_method\n   \n  return _method\n  \n @property\n def __isabstractmethod__(self):\n  return getattr(self.func,'__isabstractmethod__',False)\n  \n  \n  \n  \n  \n  \n_NOT_FOUND=object()\n\nclass cached_property:\n def __init__(self,func):\n  self.func=func\n  self.attrname=None\n  self.__doc__=func.__doc__\n  self.__module__=func.__module__\n  \n def __set_name__(self,owner,name):\n  if self.attrname is None:\n   self.attrname=name\n  elif name !=self.attrname:\n   raise TypeError(\n   \"Cannot assign the same cached_property to two different names \"\n   f\"({self.attrname !r} and {name !r}).\"\n   )\n   \n def __get__(self,instance,owner=None):\n  if instance is None:\n   return self\n  if self.attrname is None:\n   raise TypeError(\n   \"Cannot use cached_property instance without calling __set_name__ on it.\")\n  try:\n   cache=instance.__dict__\n  except AttributeError:\n   msg=(\n   f\"No '__dict__' attribute on {type(instance).__name__ !r} \"\n   f\"instance to cache {self.attrname !r} property.\"\n   )\n   raise TypeError(msg)from None\n  val=cache.get(self.attrname,_NOT_FOUND)\n  if val is _NOT_FOUND:\n   val=self.func(instance)\n   try:\n    cache[self.attrname]=val\n   except TypeError:\n    msg=(\n    f\"The '__dict__' attribute on {type(instance).__name__ !r} instance \"\n    f\"does not support item assignment for caching {self.attrname !r} property.\"\n    )\n    raise TypeError(msg)from None\n  return val\n  \n __class_getitem__=classmethod(GenericAlias)\n", ["_functools", "_thread", "abc", "collections", "reprlib", "types", "typing", "warnings", "weakref"]], "gc": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDEBUG_COLLECTABLE=2\n\nDEBUG_LEAK=38\n\nDEBUG_SAVEALL=32\n\nDEBUG_STATS=1\n\nDEBUG_UNCOLLECTABLE=4\n\nclass __loader__:\n pass\n \ncallbacks=[]\n\ndef collect(*args,**kw):\n ''\n\n\n\n\n\n \n pass\n \ndef disable(*args,**kw):\n ''\n\n \n pass\n \ndef enable(*args,**kw):\n ''\n\n \n pass\n \ngarbage=[]\n\ndef get_count(*args,**kw):\n ''\n\n \n pass\n \ndef get_debug(*args,**kw):\n ''\n\n \n pass\n \ndef get_objects(*args,**kw):\n ''\n\n\n \n pass\n \ndef get_referents(*args,**kw):\n ''\n pass\n \ndef get_referrers(*args,**kw):\n ''\n pass\n \ndef get_threshold(*args,**kw):\n ''\n\n \n pass\n \ndef is_tracked(*args,**kw):\n ''\n\n\n \n pass\n \ndef isenabled(*args,**kw):\n ''\n\n \n pass\n \ndef set_debug(*args,**kw):\n ''\n\n\n\n\n\n\n\n\n\n\n \n pass\n \ndef set_threshold(*args,**kw):\n ''\n\n\n \n pass\n", []], "interpreter": [".py", "import sys\nimport builtins\nimport re\n\nimport traceback\n\nfrom browser import console,document,window,html,DOMNode\nfrom browser.widgets.dialog import Dialog\n\n_credits=\"\"\"    Thanks to CWI, CNRI, BeOpen.com, Zope Corporation and a cast of thousands\n    for supporting Python development.  See www.python.org for more information.\"\"\"\n\n_copyright=\"\"\"Copyright (c) 2012, Pierre Quentel pierre.quentel@gmail.com\nAll Rights Reserved.\n\nCopyright (c) 2001-2022 Python Software Foundation.\nAll Rights Reserved.\n\nCopyright (c) 2000 BeOpen.com.\nAll Rights Reserved.\n\nCopyright (c) 1995-2001 Corporation for National Research Initiatives.\nAll Rights Reserved.\n\nCopyright (c) 1991-1995 Stichting Mathematisch Centrum, Amsterdam.\nAll Rights Reserved.\"\"\"\n\n_help=\"Type help() for interactive help, or help(object) for help about object.\"\n\n_license=\"\"\"Copyright 2012-2024 Pierre Quentel pierre.quentel@gmail.com\n\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n\n3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \u201cAS IS\u201d AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\"\"\"\n\nclass Info:\n\n def __init__(self,msg):\n  self.msg=msg\n  \n def __repr__(self):\n  return self.msg\n  \nclass License:\n\n def __repr__(self):\n  return 'Type license() to see the full license text'\n  \n def __call__(self):\n  print(_license)\n  \n  \neditor_ns={\n'credits':Info(_credits),\n'copyright':Info(_copyright),\n'license':License(),\n'__annotations__':{},\n'__builtins__':builtins,\n'__doc__':None,\n'__file__':'<stdin>',\n'__name__':'__main__'\n}\n\n\nstyle_sheet=\"\"\"\n.brython-interpreter {\n    background-color: #000;\n    color: #fff;\n    font-family: consolas, courier;\n    caret-color: #fff;\n    overflow-y: auto;\n    overflow-x: hidden;\n}\n\n@keyframes blinker {\n  50% {\n    opacity: 0;\n  }\n}\n\npre{\n    display:inline;\n}\n\"\"\"\n\nactive=[]\n\nclass Output:\n\n def __init__(self,interpreter):\n  self.interpreter=interpreter\n  \n def write(self,*args,**kw):\n  self.interpreter.write(*args,**kw)\n  \n def __len__(self):\n  return len(self.interpreter.buffer)\n  \n  \n  \n  \ncolor_character_pattern=re.compile(r'^\\033\\[([0-9;]*)m')\n\ndef swap_color_bgcolor(element):\n ''\n element.style.color,element.style.backgroundColor=\\\n element.style.backgroundColor,element.style.color\n \ncc_styles={\n0:[\"fontStyle\",\"normal\"],\n1:[\"fontWeight\",\"bold\"],\n2:[\"fontWeight\",\"lighter\"],\n3:[\"fontStyle\",\"italic\"],\n4:[\"textDecoration\",\"underline\"],\n5:[\"animation\",\"blinker 1s step-start infinite\"],\n6:[\"animation\",\"blinker 0.5s step-start infinite\"],\n7:swap_color_bgcolor\n}\n\ncc_colors={\n30:\"Black\",\n31:\"Red\",\n32:\"Green\",\n33:\"Yellow\",\n34:\"Blue\",\n35:\"Magenta\",\n36:\"Cyan\",\n37:\"White\"\n}\n\ncc_bgcolors={k+10:v for(k,v)in cc_colors.items()}\n\n\nclass Trace:\n\n def __init__(self,exc):\n  self.buf=\"\"\n  self.is_syntax_error=exc.__name__ in['SyntaxError',\n  'IndentationError']\n  \n def write(self,data):\n  self.buf +=str(data)\n  \n def format(self):\n  ''\n  return self.buf.rstrip()\n  \n  \nclass Interpreter:\n ''\n \n def __init__(self,elt_id=None,title=\"Interactive Interpreter\",\n globals=None,locals=None,history=None,\n rows=30,cols=120,default_css=True,\n clear_zone=True,banner=True):\n  ''\n\n\n\n\n\n  \n  if default_css:\n  \n   for stylesheet in document.styleSheets:\n    if stylesheet.ownerNode.id ==\"brython-interpreter\":\n     break\n   else:\n    document <=html.STYLE(style_sheet,id=\"brython-interpreter\")\n    \n  self.cc_style=None\n  self.cc_color=None\n  self.cc_bgcolor=None\n  self.default_cc_color='#fff'\n  self.default_cc_bgcolor='#000'\n  \n  if elt_id is None:\n   self.dialog=Dialog(title=title,top=10,left=10,\n   default_css=default_css)\n   self.dialog.bind('blur',self.blur)\n   self.dialog.bind('click',self.focus)\n   self.dialog.close_button.bind('click',self.close)\n   self.zone=html.DIV(Class=\"brython-interpreter\",\n   contenteditable=True)\n   self.zone.style.width=f'{cols}ch'\n   self.zone.style.height=f'{rows}ch'\n   self.dialog.panel <=self.zone\n  else:\n   if isinstance(elt_id,str):\n    try:\n     elt=document[elt_id]\n     if elt.tagName !=\"DIV\":\n      raise ValueError(\n      f\"element {elt_id} is a {elt.tagName}, \"+\n      \"not a DIV\")\n     self.zone=elt\n    except KeyError:\n     raise KeyError(f\"no element with id '{elt_id}'\")\n   elif isinstance(elt_id,DOMNode):\n    if elt_id.tagName ==\"DIV\":\n     self.zone=elt_id\n    else:\n     raise ValueError(\"element is not a DIV\")\n   else:\n    raise ValueError(\"element should be a string or \"+\n    f\"a DIV, got '{elt_id.__class__.__name__}'\")\n   if self.zone.contentEditable !='true':\n    raise ValueError(\"DIV element must be contenteditable\")\n  v=sys.implementation.version\n  if clear_zone:\n   self.clear()\n  if banner:\n   self.insert(\n   f\"Brython {v[0]}.{v[1]}.{v[2]} on \"\n   f\"{window.navigator.appName} {window.navigator.appVersion}\"\n   \"\\n\"\n   )\n   self.insert('Type \"help\", \"copyright\", \"credits\" '\n   'or \"license\" for more information.'+'\\n')\n  self.insert_prompt()\n  \n  self.input_num=0\n  self._status=\"main\"\n  self.history=history or[]\n  self.current=len(self.history)\n  \n  self.globals={}if globals is None else globals\n  self.globals.update(editor_ns)\n  self.locals=self.globals if locals is None else locals\n  \n  self.zone.bind('keypress',self.keypress)\n  self.zone.bind('keydown',self.keydown)\n  self.zone.bind('mouseup',self.mouseup)\n  \n  self.zone.bind('focus',self.focus)\n  self.zone.bind('blur',self.blur)\n  self.focus()\n  \n  self.cursor_to_end()\n  \n  active.append(self)\n  \n def clear(self):\n  self.zone.text=''\n  \n def insert(self,text):\n \n  pre=html.PRE(style=\"display:inline;white-space:pre-wrap;\")\n  pre.text=text\n  if self.cc_color is not None:\n   pre.style.color=self.cc_color\n  if self.cc_bgcolor is not None:\n   pre.style.backgroundColor=self.cc_bgcolor\n  if self.cc_style is not None:\n   style=cc_styles[self.cc_style]\n   if isinstance(style,list):\n    attr,value=style\n    setattr(pre.style,attr,value)\n   else:\n    style(pre)\n  self.zone <=pre\n  \n def insert_prompt(self):\n  self.insert('>>> ')\n  \n def insert_continuation(self):\n  self.insert('\\n... ')\n  \n def insert_cr(self):\n  self.insert('\\n')\n  \n def get_content(self):\n  return self.zone.text\n  \n def blur(self,ev):\n  if hasattr(self,'dialog'):\n   self.dialog.style.zIndex=0\n   \n def close(self,ev):\n  active.remove(self)\n  \n def cursor_to_end(self,*args):\n \n  sel=window.getSelection()\n  \n  last_child=self.zone.lastChild.firstChild\n  if last_child is None:\n   last_child=self.zone.lastChild\n  pos=len(last_child.text)\n  \n  sel.setBaseAndExtent(last_child,pos,last_child,pos)\n  \n  self.zone.lastChild.scrollIntoView({\"block\":\"end\",\"behaviour\":\"smooth\"})\n  \n def focus(self,*args):\n  ''\n  if hasattr(self,'dialog'):\n  \n   for w in active:\n    if w is not self:\n     w.dialog.style.zIndex=0\n   self.dialog.style.zIndex=1\n  sys.stdout=sys.stderr=Output(self)\n  self.zone.focus()\n  \n def keypress(self,event):\n  if event.key ==\"Tab\":\n   event.preventDefault()\n   self.insert(\"    \")\n  elif event.key ==\"Enter\":\n   event.preventDefault()\n   selection=window.getSelection().toString()\n   if selection:\n   \n    self.cursor_to_end()\n    return\n   self.handle_line(event)\n   \n def feed(self,src):\n  ''\n\n\n  \n  current_indent=0\n  lines=src.strip().split('\\n')\n  for line in lines:\n   self.insert(line)\n   self.handle_line()\n   \n def add_to_history(self,line):\n  self.history.append(line)\n  \n def set_filename(self,src):\n  filename=f'<python-input-{self.input_num}>'\n  __BRYTHON__.file_cache[filename]=src\n  traceback.linecache.cache[filename]=(\n  len(src),\n  None,\n  [line+'\\n'for line in src.splitlines()],\n  filename)\n  self.input_num +=1\n  return filename\n  \n def handle_line(self,event=None):\n  src=self.get_content().strip()\n  if self._status ==\"main\":\n   currentLine=src[src.rfind('\\n>>>')+5:]\n  elif self._status in[\"3string\",\"parenth_expr\"]:\n   currentLine=src[src.rfind('\\n>>>')+5:]\n   currentLine=currentLine.replace('\\n... ','\\n')\n  else:\n   currentLine=src[src.rfind('\\n...')+5:]\n  if self._status =='main'and not currentLine.strip():\n   self.insert_cr()\n   self.insert_prompt()\n   self.cursor_to_end()\n   if event is not None:\n    event.preventDefault()\n   return\n  self.add_to_history(currentLine)\n  self.current=len(self.history)\n  if self._status in[\"main\",\"3string\",\"parenth_expr\"]:\n  \n   if currentLine ==\"help\":\n    self.insert_cr()\n    self.write(_help)\n    self.insert_cr()\n    self.insert_prompt()\n    self.cursor_to_end()\n    if event is not None:\n     event.preventDefault()\n    return\n   filename=self.set_filename(currentLine)\n   try:\n    code=compile(currentLine,filename,'eval')\n   except IndentationError:\n    self.insert_continuation()\n    self._status=\"block\"\n   except SyntaxError as msg:\n    if str(msg).startswith('unterminated triple-quoted string literal'):\n     self.insert_continuation()\n     self._status=\"3string\"\n    elif str(msg)=='decorator expects function':\n     self.insert_continuation()\n     self._status=\"block\"\n    elif str(msg).endswith('was never closed'):\n     self.insert_continuation()\n     self._status=\"parenth_expr\"\n    else:\n     try:\n      code=compile(currentLine,filename,'exec')\n      exec(code,self.globals,self.locals)\n     except SyntaxError as exc:\n      if exc.args and\\\n      exc.args[0].startswith('expected an indented block'):\n       self.insert_continuation()\n       self._status=\"block\"\n      else:\n       self.insert_cr()\n       return self.print_tb(exc)\n     except Exception as exc:\n      self.insert_cr()\n      self._status=\"main\"\n      return self.print_tb(exc)\n     else:\n      self.insert_cr()\n      self.insert_prompt()\n      self._status=\"main\"\n   except Exception as exc:\n   \n   \n   \n    self._status=\"main\"\n    return self.print_tb(exc)\n   else:\n    self.insert_cr()\n    try:\n     self.globals['_']=eval(code,\n     self.globals,\n     self.locals)\n     if self.globals['_']is not None:\n      self.write(repr(self.globals['_'])+'\\n')\n     self.insert_prompt()\n     self._status=\"main\"\n    except Exception as exc:\n     self._status=\"main\"\n     return self.print_tb(exc)\n     \n  elif currentLine ==\"\":\n   block=src[src.rfind('\\n>>>')+5:].splitlines()\n   block=[block[0]]+[b[4:]for b in block[1:]]\n   block_src='\\n'.join(block)\n   self.insert_cr()\n   filename=self.set_filename(block_src)\n   mode=eval if self._status ==\"parenth_expr\"else exec\n   \n   self._status=\"main\"\n   try:\n    code=compile(block_src,filename,'eval')\n   except SyntaxError as exc:\n    try:\n     code=compile(block_src,filename,'file')\n    except Exception as exc:\n     return self.print_tb(exc)\n   except Exception as exc:\n    return self.print_tb(exc)\n   if mode is eval:\n    try:\n     self.globals['_']=eval(code,\n     self.globals,\n     self.locals)\n     if self.globals['_']is not None:\n      self.write(repr(self.globals['_'])+'\\n')\n     self._status=\"main\"\n    except Exception as exc:\n     self._status=\"main\"\n     return self.print_tb(exc)\n   else:\n    try:\n     mode(code,self.globals,self.locals)\n    except Exception as exc:\n     return self.print_tb(exc)\n   self.insert_prompt()\n   \n  else:\n   self.insert_continuation()\n   \n  self.cursor_to_end()\n  if event is not None:\n   event.preventDefault()\n   \n def keydown(self,event):\n  sel=window.getSelection()\n  if event.key in(\"ArrowLeft\",\"Backspace\"):\n  \n   if sel.anchorNode is not self.zone:\n    caret_column=sel.anchorOffset\n    if caret_column >=5:\n     return\n   event.preventDefault()\n   event.stopPropagation()\n  elif event.key ==\"Home\":\n   anchor=sel.anchorNode\n   sel.setBaseAndExtent(anchor,4,anchor,4)\n   event.preventDefault()\n   event.stopPropagation()\n  elif event.key ==\"ArrowUp\":\n   line=sel.anchorNode.data\n   if not line.startswith('\\n...'):\n    if self.current >0:\n     last_child=self.zone.lastChild\n     last_child.text=last_child.text[:4]+self.history[self.current -1]\n     self.current -=1\n     self.cursor_to_end()\n    event.preventDefault()\n  elif event.key ==\"ArrowDown\":\n   node=sel.anchorNode.parentNode\n   if not node.nextSibling:\n    if self.current <len(self.history)-1:\n     self.current +=1\n     last_child=self.zone.lastChild\n     last_child.text=last_child.text[:4]+self.history[self.current]\n     self.cursor_to_end()\n    event.preventDefault()\n  elif event.key in[\"PageUp\",\"PageDown\"]:\n   event.preventDefault()\n   \n def mouseup(self,ev):\n  ''\n  sel=window.getSelection()\n  if sel.type =='Caret':\n   self.cursor_to_end()\n   \n def write(self,data):\n  ''\n  if not data:\n   return\n  data=str(data.replace(chr(0),' '))\n  mo=color_character_pattern.search(data)\n  if mo:\n   data=data[mo.end():]\n   last_child=self.zone.lastChild\n   if not mo.groups()[0]:\n    tags=[]\n   else:\n    tags=mo.groups()[0].split(';')\n   self.cc_style=0\n   self.cc_color=self.default_cc_color\n   self.cc_bgcolor=self.default_cc_bgcolor\n   for tag in tags:\n    tag=int(tag)\n    if tag in cc_styles:\n     self.cc_style=tag\n    elif tag in cc_colors:\n     self.cc_color=cc_colors[tag]\n    elif tag in cc_bgcolors:\n     self.cc_bgcolor=cc_bgcolors[tag]\n  self.insert(data)\n  self.cursor_to_end()\n  \n def print_tb(self,exc):\n  trace=Trace(exc)\n  tb=exc.__traceback__\n  \n  while tb:\n   if not tb.tb_frame.f_code.co_filename.startswith('<python-input'):\n    tb=tb.tb_next\n   else:\n    break\n  exc.__traceback__=tb\n  traceback.print_exc(file=trace)\n  self.write(trace.format().lstrip())\n  self.insert_cr()\n  self.insert_prompt()\n  self.cursor_to_end()\n  \n  \nclass Inspector(Interpreter):\n\n def __init__(self,title=\"Frames inspector\",\n rows=30,cols=84,default_css=True):\n  frame=sys._getframe().f_back\n  super().__init__(None,title,\n  globals=frame.f_globals.copy(),\n  locals=frame.f_locals.copy(),\n  rows=rows,cols=cols,default_css=default_css)\n  \n  frames_sel=html.SELECT()\n  self.frames=[]\n  while frame:\n   self.frames.append([frame.f_globals.copy(),\n   frame.f_locals.copy()])\n   name=frame.f_code.co_name\n   name=name.replace(\"<\",\"&lt;\").replace(\">\",\"&gt;\")\n   frames_sel <=html.OPTION(name)\n   frame=frame.f_back\n  frames_sel.bind(\"change\",self.change_frame)\n  frame_div=html.DIV(\"Frame \"+frames_sel)\n  panel_style=window.getComputedStyle(self.dialog.panel)\n  frame_div.style.paddingLeft=panel_style.paddingLeft\n  frame_div.style.paddingTop=panel_style.paddingTop\n  self.dialog.insertBefore(frame_div,self.dialog.panel)\n  \n def change_frame(self,ev):\n  self.globals,self.locals=self.frames[ev.target.selectedIndex]\n  \n", ["browser", "browser.widgets.dialog", "builtins", "re", "sys", "traceback"]], "io": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n__author__=(\"Guido van Rossum <guido@python.org>, \"\n\"Mike Verdone <mike.verdone@gmail.com>, \"\n\"Mark Russell <mark.russell@zen.co.uk>, \"\n\"Antoine Pitrou <solipsis@pitrou.net>, \"\n\"Amaury Forgeot d'Arc <amauryfa@gmail.com>, \"\n\"Benjamin Peterson <benjamin@python.org>\")\n\n__all__=[\"BlockingIOError\",\"open\",\"open_code\",\"IOBase\",\"RawIOBase\",\n\"FileIO\",\"BytesIO\",\"StringIO\",\"BufferedIOBase\",\n\"BufferedReader\",\"BufferedWriter\",\"BufferedRWPair\",\n\"BufferedRandom\",\"TextIOBase\",\"TextIOWrapper\",\n\"UnsupportedOperation\",\"SEEK_SET\",\"SEEK_CUR\",\"SEEK_END\",\n\"DEFAULT_BUFFER_SIZE\",\"text_encoding\",\"IncrementalNewlineDecoder\"]\n\n\nimport _io\nimport abc\n\nfrom _io import(DEFAULT_BUFFER_SIZE,BlockingIOError,UnsupportedOperation,\nopen,open_code,FileIO,BytesIO,StringIO,BufferedReader,\nBufferedWriter,BufferedRWPair,BufferedRandom,\nIncrementalNewlineDecoder,text_encoding,TextIOWrapper)\n\n\n\nUnsupportedOperation.__module__=\"io\"\n\n\nSEEK_SET=0\nSEEK_CUR=1\nSEEK_END=2\n\n\n\n\nclass IOBase(_io._IOBase,metaclass=abc.ABCMeta):\n __doc__=_io._IOBase.__doc__\n \nclass RawIOBase(_io._RawIOBase,IOBase):\n __doc__=_io._RawIOBase.__doc__\n \nclass BufferedIOBase(_io._BufferedIOBase,IOBase):\n __doc__=_io._BufferedIOBase.__doc__\n \nclass TextIOBase(_io._TextIOBase,IOBase):\n __doc__=_io._TextIOBase.__doc__\n \nRawIOBase.register(FileIO)\n\nfor klass in(BytesIO,BufferedReader,BufferedWriter,BufferedRandom,\nBufferedRWPair):\n BufferedIOBase.register(klass)\n \nfor klass in(StringIO,TextIOWrapper):\n TextIOBase.register(klass)\ndel klass\n\ntry:\n from _io import _WindowsConsoleIO\nexcept ImportError:\n pass\nelse:\n RawIOBase.register(_WindowsConsoleIO)\n", ["_io", "abc"]], "itertools": [".py", "import operator\n\nclass accumulate:\n def __init__(self,iterable,func=operator.add):\n  self.it=iter(iterable)\n  self._total=None\n  self.func=func\n  \n def __iter__(self):\n  return self\n  \n def __next__(self):\n  if not self._total:\n   self._total=next(self.it)\n   return self._total\n  else:\n   element=next(self.it)\n   try:\n    self._total=self.func(self._total,element)\n   except:\n    raise TypeError(\"unsupported operand type\")\n   return self._total\n   \n   \n   \nclass chain:\n def __init__(self,*iterables):\n  self._iterables_iter=iter(map(iter,iterables))\n  \n  self._cur_iterable_iter=iter([])\n  \n def __iter__(self):\n  return self\n  \n def __next__(self):\n  while True:\n   try:\n    return next(self._cur_iterable_iter)\n   except StopIteration:\n    self._cur_iterable_iter=next(self._iterables_iter)\n    \n @classmethod\n def from_iterable(cls,iterable):\n  for it in iterable:\n   for element in it:\n    yield element\n    \nclass combinations:\n def __init__(self,iterable,r):\n  self.pool=tuple(iterable)\n  self.n=len(self.pool)\n  self.r=r\n  self.indices=list(range(self.r))\n  self.zero=False\n  \n def __iter__(self):\n  return self\n  \n def __next__(self):\n  if self.r >self.n:\n   raise StopIteration\n  if not self.zero:\n   self.zero=True\n   return tuple(self.pool[i]for i in self.indices)\n  else:\n   try:\n    for i in reversed(range(self.r)):\n     if self.indices[i]!=i+self.n -self.r:\n      break\n    self.indices[i]+=1\n    for j in range(i+1,self.r):\n     self.indices[j]=self.indices[j -1]+1\n    return tuple(self.pool[i]for i in self.indices)\n   except:\n    raise StopIteration\n    \nclass combinations_with_replacement:\n def __init__(self,iterable,r):\n  self.pool=tuple(iterable)\n  self.n=len(self.pool)\n  self.r=r\n  self.indices=[0]*self.r\n  self.zero=False\n  \n def __iter__(self):\n  return self\n  \n def __next__(self):\n  if not self.n and self.r:\n   raise StopIteration\n  if not self.zero:\n   self.zero=True\n   return tuple(self.pool[i]for i in self.indices)\n  else:\n   try:\n    for i in reversed(range(self.r)):\n     if self.indices[i]!=self.n -1:\n      break\n    self.indices[i:]=[self.indices[i]+1]*(self.r -i)\n    return tuple(self.pool[i]for i in self.indices)\n   except:\n    raise StopIteration\n    \n    \n    \nclass compress:\n def __init__(self,data,selectors):\n  self.data=iter(data)\n  self.selectors=iter(selectors)\n  \n def __iter__(self):\n  return self\n  \n def __next__(self):\n  while True:\n   next_item=next(self.data)\n   next_selector=next(self.selectors)\n   if bool(next_selector):\n    return next_item\n    \n    \n    \n    \nclass count:\n ''\n\n\n\n \n def __init__(self,start=0,step=1):\n  if not isinstance(start,(int,float)):\n   raise TypeError('a number is required')\n  self.times=start -step\n  self.step=step\n  \n def __iter__(self):\n  return self\n  \n def __next__(self):\n  self.times +=self.step\n  return self.times\n  \n def __repr__(self):\n  return 'count(%d)'%(self.times+self.step)\n  \n  \n  \nclass cycle:\n def __init__(self,iterable):\n  self._cur_iter=iter(iterable)\n  self._saved=[]\n  self._must_save=True\n  \n def __iter__(self):\n  return self\n  \n def __next__(self):\n  try:\n   next_elt=next(self._cur_iter)\n   if self._must_save:\n    self._saved.append(next_elt)\n  except StopIteration:\n   self._cur_iter=iter(self._saved)\n   next_elt=next(self._cur_iter)\n   self._must_save=False\n  return next_elt\n  \n  \n  \nclass dropwhile:\n def __init__(self,predicate,iterable):\n  self._predicate=predicate\n  self._iter=iter(iterable)\n  self._dropped=False\n  \n def __iter__(self):\n  return self\n  \n def __next__(self):\n  value=next(self._iter)\n  if self._dropped:\n   return value\n  while self._predicate(value):\n   value=next(self._iter)\n  self._dropped=True\n  return value\n  \n  \n  \nclass filterfalse:\n def __init__(self,predicate,iterable):\n \n  self._iter=iter(iterable)\n  if predicate is None:\n   self._predicate=bool\n  else:\n   self._predicate=predicate\n   \n def __iter__(self):\n  return self\n def __next__(self):\n  next_elt=next(self._iter)\n  while True:\n   if not self._predicate(next_elt):\n    return next_elt\n   next_elt=next(self._iter)\n   \nclass groupby:\n\n\n def __init__(self,iterable,key=None):\n  if key is None:\n   key=lambda x:x\n  self.keyfunc=key\n  self.it=iter(iterable)\n  self.tgtkey=self.currkey=self.currvalue=object()\n def __iter__(self):\n  return self\n def __next__(self):\n  while self.currkey ==self.tgtkey:\n   self.currvalue=next(self.it)\n   self.currkey=self.keyfunc(self.currvalue)\n  self.tgtkey=self.currkey\n  return(self.currkey,self._grouper(self.tgtkey))\n def _grouper(self,tgtkey):\n  while self.currkey ==tgtkey:\n   yield self.currvalue\n   self.currvalue=next(self.it)\n   self.currkey=self.keyfunc(self.currvalue)\n   \n   \n   \nclass islice:\n def __init__(self,iterable,*args):\n  s=slice(*args)\n  self.start,self.stop,self.step=s.start or 0,s.stop,s.step\n  if not isinstance(self.start,int):\n   raise ValueError(\"Start argument must be an integer\")\n  if self.stop !=None and not isinstance(self.stop,int):\n   raise ValueError(\"Stop argument must be an integer or None\")\n  if self.step is None:\n   self.step=1\n  if self.start <0 or(self.stop !=None and self.stop <0\n  )or self.step <=0:\n   raise ValueError(\"indices for islice() must be positive\")\n  self.it=iter(iterable)\n  self.donext=None\n  self.cnt=0\n  \n def __iter__(self):\n  return self\n  \n def __next__(self):\n  nextindex=self.start\n  if self.stop !=None and nextindex >=self.stop:\n   raise StopIteration\n  while self.cnt <=nextindex:\n   nextitem=next(self.it)\n   self.cnt +=1\n  self.start +=self.step\n  return nextitem\n  \nclass permutations:\n def __init__(self,iterable,r=None):\n  self.pool=tuple(iterable)\n  self.n=len(self.pool)\n  self.r=self.n if r is None else r\n  self.indices=list(range(self.n))\n  self.cycles=list(range(self.n,self.n -self.r,-1))\n  self.zero=False\n  self.stop=False\n  \n def __iter__(self):\n  return self\n  \n def __next__(self):\n  indices=self.indices\n  if self.r >self.n:\n   raise StopIteration\n  if not self.zero:\n   self.zero=True\n   return tuple(self.pool[i]for i in indices[:self.r])\n   \n  i=self.r -1\n  while i >=0:\n   j=self.cycles[i]-1\n   if j >0:\n    self.cycles[i]=j\n    indices[i],indices[-j]=indices[-j],indices[i]\n    return tuple(self.pool[i]for i in indices[:self.r])\n   self.cycles[i]=len(indices)-i\n   n1=len(indices)-1\n   assert n1 >=0\n   num=indices[i]\n   for k in range(i,n1):\n    indices[k]=indices[k+1]\n   indices[n1]=num\n   i -=1\n  raise StopIteration\n  \n  \ndef product(*args,repeat=1):\n\n\n pools=[tuple(pool)for pool in args]*repeat\n result=[[]]\n for pool in pools:\n  result=[x+[y]for x in result for y in pool]\n for prod in result:\n  yield tuple(prod)\n  \n  \n  \n  \n  \n  \n  \n  \nclass _product:\n def __init__(self,*args,**kw):\n  if len(kw)>1:\n   raise TypeError(\"product() takes at most 1 argument (%d given)\"%\n   len(kw))\n  self.repeat=kw.get('repeat',1)\n  if not isinstance(self.repeat,int):\n   raise TypeError(\"integer argument expected, got %s\"%\n   type(self.repeat))\n  self.gears=[x for x in args]*self.repeat\n  self.num_gears=len(self.gears)\n  \n  self.indicies=[(0,len(self.gears[x]))\n  for x in range(0,self.num_gears)]\n  self.cont=True\n  self.zero=False\n  \n def roll_gears(self):\n \n \n \n  should_carry=True\n  for n in range(0,self.num_gears):\n   nth_gear=self.num_gears -n -1\n   if should_carry:\n    count,lim=self.indicies[nth_gear]\n    count +=1\n    if count ==lim and nth_gear ==0:\n     self.cont=False\n    if count ==lim:\n     should_carry=True\n     count=0\n    else:\n     should_carry=False\n    self.indicies[nth_gear]=(count,lim)\n   else:\n    break\n    \n def __iter__(self):\n  return self\n  \n def __next__(self):\n  if self.zero:\n   raise StopIteration\n  if self.repeat >0:\n   if not self.cont:\n    raise StopIteration\n   l=[]\n   for x in range(0,self.num_gears):\n    index,limit=self.indicies[x]\n    print('itertools 353',self.gears,x,index)\n    l.append(self.gears[x][index])\n   self.roll_gears()\n   return tuple(l)\n  elif self.repeat ==0:\n   self.zero=True\n   return()\n  else:\n   raise ValueError(\"repeat argument cannot be negative\")\n   \n   \n   \nclass repeat:\n def __init__(self,obj,times=None):\n  self._obj=obj\n  if times is not None:\n   range(times)\n   if times <0:\n    times=0\n  self._times=times\n  \n def __iter__(self):\n  return self\n  \n def __next__(self):\n \n  if self._times is not None:\n   if self._times <=0:\n    raise StopIteration()\n   self._times -=1\n  return self._obj\n  \n def __repr__(self):\n  if self._times is not None:\n   return 'repeat(%r, %r)'%(self._obj,self._times)\n  else:\n   return 'repeat(%r)'%(self._obj,)\n   \n def __len__(self):\n  if self._times ==-1 or self._times is None:\n   raise TypeError(\"len() of uniszed object\")\n  return self._times\n  \n  \n  \nclass starmap(object):\n def __init__(self,function,iterable):\n  self._func=function\n  self._iter=iter(iterable)\n  \n def __iter__(self):\n  return self\n  \n def __next__(self):\n  t=next(self._iter)\n  return self._func(*t)\n  \n  \n  \nclass takewhile(object):\n def __init__(self,predicate,iterable):\n  self._predicate=predicate\n  self._iter=iter(iterable)\n  \n def __iter__(self):\n  return self\n  \n def __next__(self):\n  value=next(self._iter)\n  if not self._predicate(value):\n   raise StopIteration()\n  return value\n  \n  \n  \nclass TeeData(object):\n def __init__(self,iterator):\n  self.data=[]\n  self._iter=iterator\n  \n def __getitem__(self,i):\n \n  while i >=len(self.data):\n   self.data.append(next(self._iter))\n  return self.data[i]\n  \n  \nclass TeeObject(object):\n def __init__(self,iterable=None,tee_data=None):\n  if tee_data:\n   self.tee_data=tee_data\n   self.pos=0\n   \n  elif isinstance(iterable,TeeObject):\n   self.tee_data=iterable.tee_data\n   self.pos=iterable.pos\n  else:\n   self.tee_data=TeeData(iter(iterable))\n   self.pos=0\n   \n def __next__(self):\n  data=self.tee_data[self.pos]\n  self.pos +=1\n  return data\n  \n def __iter__(self):\n  return self\n  \n  \ndef tee(iterable,n=2):\n if isinstance(iterable,TeeObject):\n  return tuple([iterable]+\n  [TeeObject(tee_data=iterable.tee_data)for i in range(n -1)])\n tee_data=TeeData(iter(iterable))\n return tuple([TeeObject(tee_data=tee_data)for i in range(n)])\n \nclass zip_longest:\n def __init__(self,*args,fillvalue=None):\n  self.args=[iter(arg)for arg in args]\n  self.fillvalue=fillvalue\n  self.units=len(args)\n  \n def __iter__(self):\n  return self\n  \n def __next__(self):\n  temp=[]\n  nb=0\n  for i in range(self.units):\n   try:\n    temp.append(next(self.args[i]))\n    nb +=1\n   except StopIteration:\n    temp.append(self.fillvalue)\n  if nb ==0:\n   raise StopIteration\n  return tuple(temp)\n", ["operator"]], "numbers": [".py", "\n\n\n\"\"\"Abstract Base Classes (ABCs) for numbers, according to PEP 3141.\n\nTODO: Fill out more detailed documentation on the operators.\"\"\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfrom abc import ABCMeta,abstractmethod\n\n__all__=[\"Number\",\"Complex\",\"Real\",\"Rational\",\"Integral\"]\n\nclass Number(metaclass=ABCMeta):\n ''\n\n\n\n \n __slots__=()\n \n \n __hash__=None\n \n \n \n \n \n \n \n \n \n \nclass Complex(Number):\n ''\n\n\n\n\n\n\n\n \n \n __slots__=()\n \n @abstractmethod\n def __complex__(self):\n  ''\n  \n def __bool__(self):\n  ''\n  return self !=0\n  \n @property\n @abstractmethod\n def real(self):\n  ''\n\n\n  \n  raise NotImplementedError\n  \n @property\n @abstractmethod\n def imag(self):\n  ''\n\n\n  \n  raise NotImplementedError\n  \n @abstractmethod\n def __add__(self,other):\n  ''\n  raise NotImplementedError\n  \n @abstractmethod\n def __radd__(self,other):\n  ''\n  raise NotImplementedError\n  \n @abstractmethod\n def __neg__(self):\n  ''\n  raise NotImplementedError\n  \n @abstractmethod\n def __pos__(self):\n  ''\n  raise NotImplementedError\n  \n def __sub__(self,other):\n  ''\n  return self+-other\n  \n def __rsub__(self,other):\n  ''\n  return -self+other\n  \n @abstractmethod\n def __mul__(self,other):\n  ''\n  raise NotImplementedError\n  \n @abstractmethod\n def __rmul__(self,other):\n  ''\n  raise NotImplementedError\n  \n @abstractmethod\n def __truediv__(self,other):\n  ''\n  raise NotImplementedError\n  \n @abstractmethod\n def __rtruediv__(self,other):\n  ''\n  raise NotImplementedError\n  \n @abstractmethod\n def __pow__(self,exponent):\n  ''\n  raise NotImplementedError\n  \n @abstractmethod\n def __rpow__(self,base):\n  ''\n  raise NotImplementedError\n  \n @abstractmethod\n def __abs__(self):\n  ''\n  raise NotImplementedError\n  \n @abstractmethod\n def conjugate(self):\n  ''\n  raise NotImplementedError\n  \n @abstractmethod\n def __eq__(self,other):\n  ''\n  raise NotImplementedError\n  \nComplex.register(complex)\n\n\nclass Real(Complex):\n ''\n\n\n\n\n\n \n \n __slots__=()\n \n @abstractmethod\n def __float__(self):\n  ''\n\n  \n  raise NotImplementedError\n  \n @abstractmethod\n def __trunc__(self):\n  ''\n\n\n\n\n\n\n\n  \n  raise NotImplementedError\n  \n @abstractmethod\n def __floor__(self):\n  ''\n  raise NotImplementedError\n  \n @abstractmethod\n def __ceil__(self):\n  ''\n  raise NotImplementedError\n  \n @abstractmethod\n def __round__(self,ndigits=None):\n  ''\n\n\n\n  \n  raise NotImplementedError\n  \n def __divmod__(self,other):\n  ''\n\n\n\n  \n  return(self //other,self %other)\n  \n def __rdivmod__(self,other):\n  ''\n\n\n\n  \n  return(other //self,other %self)\n  \n @abstractmethod\n def __floordiv__(self,other):\n  ''\n  raise NotImplementedError\n  \n @abstractmethod\n def __rfloordiv__(self,other):\n  ''\n  raise NotImplementedError\n  \n @abstractmethod\n def __mod__(self,other):\n  ''\n  raise NotImplementedError\n  \n @abstractmethod\n def __rmod__(self,other):\n  ''\n  raise NotImplementedError\n  \n @abstractmethod\n def __lt__(self,other):\n  ''\n\n  \n  raise NotImplementedError\n  \n @abstractmethod\n def __le__(self,other):\n  ''\n  raise NotImplementedError\n  \n  \n def __complex__(self):\n  ''\n  return complex(float(self))\n  \n @property\n def real(self):\n  ''\n  return+self\n  \n @property\n def imag(self):\n  ''\n  return 0\n  \n def conjugate(self):\n  ''\n  return+self\n  \nReal.register(float)\n\n\nclass Rational(Real):\n ''\n \n __slots__=()\n \n @property\n @abstractmethod\n def numerator(self):\n  raise NotImplementedError\n  \n @property\n @abstractmethod\n def denominator(self):\n  raise NotImplementedError\n  \n  \n def __float__(self):\n  ''\n\n\n\n\n\n  \n  return int(self.numerator)/int(self.denominator)\n  \n  \nclass Integral(Rational):\n ''\n\n\n\n \n \n __slots__=()\n \n @abstractmethod\n def __int__(self):\n  ''\n  raise NotImplementedError\n  \n def __index__(self):\n  ''\n  return int(self)\n  \n @abstractmethod\n def __pow__(self,exponent,modulus=None):\n  ''\n\n\n\n\n\n  \n  raise NotImplementedError\n  \n @abstractmethod\n def __lshift__(self,other):\n  ''\n  raise NotImplementedError\n  \n @abstractmethod\n def __rlshift__(self,other):\n  ''\n  raise NotImplementedError\n  \n @abstractmethod\n def __rshift__(self,other):\n  ''\n  raise NotImplementedError\n  \n @abstractmethod\n def __rrshift__(self,other):\n  ''\n  raise NotImplementedError\n  \n @abstractmethod\n def __and__(self,other):\n  ''\n  raise NotImplementedError\n  \n @abstractmethod\n def __rand__(self,other):\n  ''\n  raise NotImplementedError\n  \n @abstractmethod\n def __xor__(self,other):\n  ''\n  raise NotImplementedError\n  \n @abstractmethod\n def __rxor__(self,other):\n  ''\n  raise NotImplementedError\n  \n @abstractmethod\n def __or__(self,other):\n  ''\n  raise NotImplementedError\n  \n @abstractmethod\n def __ror__(self,other):\n  ''\n  raise NotImplementedError\n  \n @abstractmethod\n def __invert__(self):\n  ''\n  raise NotImplementedError\n  \n  \n def __float__(self):\n  ''\n  return float(int(self))\n  \n @property\n def numerator(self):\n  ''\n  return+self\n  \n @property\n def denominator(self):\n  ''\n  return 1\n  \nIntegral.register(int)\n", ["abc"]], "pickle": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfrom types import FunctionType\nfrom copyreg import dispatch_table\nfrom copyreg import _extension_registry,_inverted_registry,_extension_cache\nfrom itertools import islice\nfrom functools import partial\nimport sys\nfrom sys import maxsize\nfrom struct import pack,unpack\nimport re\nimport io\nimport codecs\nimport _compat_pickle\n\n__all__=[\"PickleError\",\"PicklingError\",\"UnpicklingError\",\"Pickler\",\n\"Unpickler\",\"dump\",\"dumps\",\"load\",\"loads\"]\n\ntry:\n from _pickle import PickleBuffer\n __all__.append(\"PickleBuffer\")\n _HAVE_PICKLE_BUFFER=True\nexcept ImportError:\n _HAVE_PICKLE_BUFFER=False\n \n \n \nbytes_types=(bytes,bytearray)\n\n\nformat_version=\"4.0\"\ncompatible_formats=[\"1.0\",\n\"1.1\",\n\"1.2\",\n\"1.3\",\n\"2.0\",\n\"3.0\",\n\"4.0\",\n\"5.0\",\n]\n\n\nHIGHEST_PROTOCOL=5\n\n\n\n\nDEFAULT_PROTOCOL=4\n\nclass PickleError(Exception):\n ''\n pass\n \nclass PicklingError(PickleError):\n ''\n\n\n \n pass\n \nclass UnpicklingError(PickleError):\n ''\n\n\n\n\n\n\n \n pass\n \n \n \nclass _Stop(Exception):\n def __init__(self,value):\n  self.value=value\n  \n  \n  \n  \n  \nMARK=b'('\nSTOP=b'.'\nPOP=b'0'\nPOP_MARK=b'1'\nDUP=b'2'\nFLOAT=b'F'\nINT=b'I'\nBININT=b'J'\nBININT1=b'K'\nLONG=b'L'\nBININT2=b'M'\nNONE=b'N'\nPERSID=b'P'\nBINPERSID=b'Q'\nREDUCE=b'R'\nSTRING=b'S'\nBINSTRING=b'T'\nSHORT_BINSTRING=b'U'\nUNICODE=b'V'\nBINUNICODE=b'X'\nAPPEND=b'a'\nBUILD=b'b'\nGLOBAL=b'c'\nDICT=b'd'\nEMPTY_DICT=b'}'\nAPPENDS=b'e'\nGET=b'g'\nBINGET=b'h'\nINST=b'i'\nLONG_BINGET=b'j'\nLIST=b'l'\nEMPTY_LIST=b']'\nOBJ=b'o'\nPUT=b'p'\nBINPUT=b'q'\nLONG_BINPUT=b'r'\nSETITEM=b's'\nTUPLE=b't'\nEMPTY_TUPLE=b')'\nSETITEMS=b'u'\nBINFLOAT=b'G'\n\nTRUE=b'I01\\n'\nFALSE=b'I00\\n'\n\n\n\nPROTO=b'\\x80'\nNEWOBJ=b'\\x81'\nEXT1=b'\\x82'\nEXT2=b'\\x83'\nEXT4=b'\\x84'\nTUPLE1=b'\\x85'\nTUPLE2=b'\\x86'\nTUPLE3=b'\\x87'\nNEWTRUE=b'\\x88'\nNEWFALSE=b'\\x89'\nLONG1=b'\\x8a'\nLONG4=b'\\x8b'\n\n_tuplesize2code=[EMPTY_TUPLE,TUPLE1,TUPLE2,TUPLE3]\n\n\n\nBINBYTES=b'B'\nSHORT_BINBYTES=b'C'\n\n\n\nSHORT_BINUNICODE=b'\\x8c'\nBINUNICODE8=b'\\x8d'\nBINBYTES8=b'\\x8e'\nEMPTY_SET=b'\\x8f'\nADDITEMS=b'\\x90'\nFROZENSET=b'\\x91'\nNEWOBJ_EX=b'\\x92'\nSTACK_GLOBAL=b'\\x93'\nMEMOIZE=b'\\x94'\nFRAME=b'\\x95'\n\n\n\nBYTEARRAY8=b'\\x96'\nNEXT_BUFFER=b'\\x97'\nREADONLY_BUFFER=b'\\x98'\n\n__all__.extend([x for x in dir()if re.match(\"[A-Z][A-Z0-9_]+$\",x)])\n\n\nclass _Framer:\n\n _FRAME_SIZE_MIN=4\n _FRAME_SIZE_TARGET=64 *1024\n \n def __init__(self,file_write):\n  self.file_write=file_write\n  self.current_frame=None\n  \n def start_framing(self):\n  self.current_frame=io.BytesIO()\n  \n def end_framing(self):\n  if self.current_frame and self.current_frame.tell()>0:\n   self.commit_frame(force=True)\n   self.current_frame=None\n   \n def commit_frame(self,force=False):\n  if self.current_frame:\n   f=self.current_frame\n   if f.tell()>=self._FRAME_SIZE_TARGET or force:\n    data=f.getbuffer()\n    write=self.file_write\n    if len(data)>=self._FRAME_SIZE_MIN:\n    \n    \n    \n    \n     write(FRAME+pack(\"<Q\",len(data)))\n     \n     \n     \n     \n    write(data)\n    \n    \n    \n    \n    \n    self.current_frame=io.BytesIO()\n    \n def write(self,data):\n  if self.current_frame:\n   return self.current_frame.write(data)\n  else:\n   return self.file_write(data)\n   \n def write_large_bytes(self,header,payload):\n  write=self.file_write\n  if self.current_frame:\n  \n   self.commit_frame(force=True)\n   \n   \n   \n   \n   \n   \n   \n  write(header)\n  write(payload)\n  \n  \nclass _Unframer:\n\n def __init__(self,file_read,file_readline,file_tell=None):\n  self.file_read=file_read\n  self.file_readline=file_readline\n  self.current_frame=None\n  \n def readinto(self,buf):\n  if self.current_frame:\n   n=self.current_frame.readinto(buf)\n   if n ==0 and len(buf)!=0:\n    self.current_frame=None\n    n=len(buf)\n    buf[:]=self.file_read(n)\n    return n\n   if n <len(buf):\n    raise UnpicklingError(\n    \"pickle exhausted before end of frame\")\n   return n\n  else:\n   n=len(buf)\n   buf[:]=self.file_read(n)\n   return n\n   \n def read(self,n):\n  if self.current_frame:\n   data=self.current_frame.read(n)\n   if not data and n !=0:\n    self.current_frame=None\n    return self.file_read(n)\n   if len(data)<n:\n    raise UnpicklingError(\n    \"pickle exhausted before end of frame\")\n   return data\n  else:\n   return self.file_read(n)\n   \n def readline(self):\n  if self.current_frame:\n   data=self.current_frame.readline()\n   if not data:\n    self.current_frame=None\n    return self.file_readline()\n   if data[-1]!=b'\\n'[0]:\n    raise UnpicklingError(\n    \"pickle exhausted before end of frame\")\n   return data\n  else:\n   return self.file_readline()\n   \n def load_frame(self,frame_size):\n  if self.current_frame and self.current_frame.read()!=b'':\n   raise UnpicklingError(\n   \"beginning of a new frame before end of current frame\")\n  self.current_frame=io.BytesIO(self.file_read(frame_size))\n  \n  \n  \n  \ndef _getattribute(obj,name):\n for subpath in name.split('.'):\n  if subpath =='<locals>':\n   raise AttributeError(\"Can't get local attribute {!r} on {!r}\"\n   .format(name,obj))\n  try:\n   parent=obj\n   obj=getattr(obj,subpath)\n  except AttributeError:\n   raise AttributeError(\"Can't get attribute {!r} on {!r}\"\n   .format(name,obj))from None\n return obj,parent\n \ndef whichmodule(obj,name):\n ''\n module_name=getattr(obj,'__module__',None)\n if module_name is not None:\n  return module_name\n  \n  \n for module_name,module in sys.modules.copy().items():\n  if(module_name =='__main__'\n  or module_name =='__mp_main__'\n  or module is None):\n   continue\n  try:\n   if _getattribute(module,name)[0]is obj:\n    return module_name\n  except AttributeError:\n   pass\n return '__main__'\n \ndef encode_long(x):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n if x ==0:\n  return b''\n nbytes=(x.bit_length()>>3)+1\n result=x.to_bytes(nbytes,byteorder='little',signed=True)\n if x <0 and nbytes >1:\n  if result[-1]==0xff and(result[-2]&0x80)!=0:\n   result=result[:-1]\n return result\n \ndef decode_long(data):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n return int.from_bytes(data,byteorder='little',signed=True)\n \n \n_NoValue=object()\n\n\n\nclass _Pickler:\n\n def __init__(self,file,protocol=None,*,fix_imports=True,\n buffer_callback=None):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  if protocol is None:\n   protocol=DEFAULT_PROTOCOL\n  if protocol <0:\n   protocol=HIGHEST_PROTOCOL\n  elif not 0 <=protocol <=HIGHEST_PROTOCOL:\n   raise ValueError(\"pickle protocol must be <= %d\"%HIGHEST_PROTOCOL)\n  if buffer_callback is not None and protocol <5:\n   raise ValueError(\"buffer_callback needs protocol >= 5\")\n  self._buffer_callback=buffer_callback\n  try:\n   self._file_write=file.write\n  except AttributeError:\n   raise TypeError(\"file must have a 'write' attribute\")\n  self.framer=_Framer(self._file_write)\n  self.write=self.framer.write\n  self._write_large_bytes=self.framer.write_large_bytes\n  self.memo={}\n  self.proto=int(protocol)\n  self.bin=protocol >=1\n  self.fast=0\n  self.fix_imports=fix_imports and protocol <3\n  \n def clear_memo(self):\n  ''\n\n\n\n\n\n  \n  self.memo.clear()\n  \n def dump(self,obj):\n  ''\n  \n  \n  if not hasattr(self,\"_file_write\"):\n   raise PicklingError(\"Pickler.__init__() was not called by \"\n   \"%s.__init__()\"%(self.__class__.__name__,))\n  if self.proto >=2:\n   self.write(PROTO+pack(\"<B\",self.proto))\n  if self.proto >=4:\n   self.framer.start_framing()\n  self.save(obj)\n  self.write(STOP)\n  self.framer.end_framing()\n  \n def memoize(self,obj):\n  ''\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if self.fast:\n   return\n  assert id(obj)not in self.memo\n  idx=len(self.memo)\n  self.write(self.put(idx))\n  self.memo[id(obj)]=idx,obj\n  \n  \n def put(self,idx):\n  if self.proto >=4:\n   return MEMOIZE\n  elif self.bin:\n   if idx <256:\n    return BINPUT+pack(\"<B\",idx)\n   else:\n    return LONG_BINPUT+pack(\"<I\",idx)\n  else:\n   return PUT+repr(idx).encode(\"ascii\")+b'\\n'\n   \n   \n def get(self,i):\n  if self.bin:\n   if i <256:\n    return BINGET+pack(\"<B\",i)\n   else:\n    return LONG_BINGET+pack(\"<I\",i)\n    \n  return GET+repr(i).encode(\"ascii\")+b'\\n'\n  \n def save(self,obj,save_persistent_id=True):\n  self.framer.commit_frame()\n  \n  \n  pid=self.persistent_id(obj)\n  if pid is not None and save_persistent_id:\n   self.save_pers(pid)\n   return\n   \n   \n  x=self.memo.get(id(obj))\n  if x is not None:\n   self.write(self.get(x[0]))\n   return\n   \n  rv=NotImplemented\n  reduce=getattr(self,\"reducer_override\",_NoValue)\n  if reduce is not _NoValue:\n   rv=reduce(obj)\n   \n  if rv is NotImplemented:\n  \n   t=type(obj)\n   f=self.dispatch.get(t)\n   if f is not None:\n    f(self,obj)\n    return\n    \n    \n    \n   reduce=getattr(self,'dispatch_table',dispatch_table).get(t,_NoValue)\n   if reduce is not _NoValue:\n    rv=reduce(obj)\n   else:\n   \n   \n    if issubclass(t,type):\n     self.save_global(obj)\n     return\n     \n     \n    reduce=getattr(obj,\"__reduce_ex__\",_NoValue)\n    if reduce is not _NoValue:\n     rv=reduce(self.proto)\n    else:\n     reduce=getattr(obj,\"__reduce__\",_NoValue)\n     if reduce is not _NoValue:\n      rv=reduce()\n     else:\n      raise PicklingError(\"Can't pickle %r object: %r\"%\n      (t.__name__,obj))\n      \n      \n  if isinstance(rv,str):\n   self.save_global(obj,rv)\n   return\n   \n   \n  if not isinstance(rv,tuple):\n   raise PicklingError(\"%s must return string or tuple\"%reduce)\n   \n   \n  l=len(rv)\n  if not(2 <=l <=6):\n   raise PicklingError(\"Tuple returned by %s must have \"\n   \"two to six elements\"%reduce)\n   \n   \n  self.save_reduce(obj=obj,*rv)\n  \n def persistent_id(self,obj):\n \n  return None\n  \n def save_pers(self,pid):\n \n  if self.bin:\n   self.save(pid,save_persistent_id=False)\n   self.write(BINPERSID)\n  else:\n   try:\n    self.write(PERSID+str(pid).encode(\"ascii\")+b'\\n')\n   except UnicodeEncodeError:\n    raise PicklingError(\n    \"persistent IDs in protocol 0 must be ASCII strings\")\n    \n def save_reduce(self,func,args,state=None,listitems=None,\n dictitems=None,state_setter=None,*,obj=None):\n \n \n  if not isinstance(args,tuple):\n   raise PicklingError(\"args from save_reduce() must be a tuple\")\n  if not callable(func):\n   raise PicklingError(\"func from save_reduce() must be callable\")\n   \n  save=self.save\n  write=self.write\n  \n  func_name=getattr(func,\"__name__\",\"\")\n  if self.proto >=2 and func_name ==\"__newobj_ex__\":\n   cls,args,kwargs=args\n   if not hasattr(cls,\"__new__\"):\n    raise PicklingError(\"args[0] from {} args has no __new__\"\n    .format(func_name))\n   if obj is not None and cls is not obj.__class__:\n    raise PicklingError(\"args[0] from {} args has the wrong class\"\n    .format(func_name))\n   if self.proto >=4:\n    save(cls)\n    save(args)\n    save(kwargs)\n    write(NEWOBJ_EX)\n   else:\n    func=partial(cls.__new__,cls,*args,**kwargs)\n    save(func)\n    save(())\n    write(REDUCE)\n  elif self.proto >=2 and func_name ==\"__newobj__\":\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n   cls=args[0]\n   if not hasattr(cls,\"__new__\"):\n    raise PicklingError(\n    \"args[0] from __newobj__ args has no __new__\")\n   if obj is not None and cls is not obj.__class__:\n    raise PicklingError(\n    \"args[0] from __newobj__ args has the wrong class\")\n   args=args[1:]\n   save(cls)\n   save(args)\n   write(NEWOBJ)\n  else:\n   save(func)\n   save(args)\n   write(REDUCE)\n   \n  if obj is not None:\n  \n  \n  \n   if id(obj)in self.memo:\n    write(POP+self.get(self.memo[id(obj)][0]))\n   else:\n    self.memoize(obj)\n    \n    \n    \n    \n    \n    \n  if listitems is not None:\n   self._batch_appends(listitems)\n   \n  if dictitems is not None:\n   self._batch_setitems(dictitems)\n   \n  if state is not None:\n   if state_setter is None:\n    save(state)\n    write(BUILD)\n   else:\n   \n   \n   \n   \n    save(state_setter)\n    save(obj)\n    save(state)\n    write(TUPLE2)\n    \n    write(REDUCE)\n    \n    \n    \n    \n    write(POP)\n    \n    \n    \n dispatch={}\n \n def save_none(self,obj):\n  self.write(NONE)\n dispatch[type(None)]=save_none\n \n def save_bool(self,obj):\n  if self.proto >=2:\n   self.write(NEWTRUE if obj else NEWFALSE)\n  else:\n   self.write(TRUE if obj else FALSE)\n dispatch[bool]=save_bool\n \n def save_long(self,obj):\n  if self.bin:\n  \n  \n  \n  \n   if obj >=0:\n    if obj <=0xff:\n     self.write(BININT1+pack(\"<B\",obj))\n     return\n    if obj <=0xffff:\n     self.write(BININT2+pack(\"<H\",obj))\n     return\n     \n   if -0x80000000 <=obj <=0x7fffffff:\n    self.write(BININT+pack(\"<i\",obj))\n    return\n  if self.proto >=2:\n   encoded=encode_long(obj)\n   n=len(encoded)\n   if n <256:\n    self.write(LONG1+pack(\"<B\",n)+encoded)\n   else:\n    self.write(LONG4+pack(\"<i\",n)+encoded)\n   return\n  if -0x80000000 <=obj <=0x7fffffff:\n   self.write(INT+repr(obj).encode(\"ascii\")+b'\\n')\n  else:\n   self.write(LONG+repr(obj).encode(\"ascii\")+b'L\\n')\n dispatch[int]=save_long\n \n def save_float(self,obj):\n  if self.bin:\n   self.write(BINFLOAT+pack('>d',obj))\n  else:\n   self.write(FLOAT+repr(obj).encode(\"ascii\")+b'\\n')\n dispatch[float]=save_float\n \n def _save_bytes_no_memo(self,obj):\n \n \n  assert self.proto >=3\n  n=len(obj)\n  if n <=0xff:\n   self.write(SHORT_BINBYTES+pack(\"<B\",n)+obj)\n  elif n >0xffffffff and self.proto >=4:\n   self._write_large_bytes(BINBYTES8+pack(\"<Q\",n),obj)\n  elif n >=self.framer._FRAME_SIZE_TARGET:\n   self._write_large_bytes(BINBYTES+pack(\"<I\",n),obj)\n  else:\n   self.write(BINBYTES+pack(\"<I\",n)+obj)\n   \n def save_bytes(self,obj):\n  if self.proto <3:\n   if not obj:\n    self.save_reduce(bytes,(),obj=obj)\n   else:\n    self.save_reduce(codecs.encode,\n    (str(obj,'latin1'),'latin1'),obj=obj)\n   return\n  self._save_bytes_no_memo(obj)\n  self.memoize(obj)\n dispatch[bytes]=save_bytes\n \n def _save_bytearray_no_memo(self,obj):\n \n \n  assert self.proto >=5\n  n=len(obj)\n  if n >=self.framer._FRAME_SIZE_TARGET:\n   self._write_large_bytes(BYTEARRAY8+pack(\"<Q\",n),obj)\n  else:\n   self.write(BYTEARRAY8+pack(\"<Q\",n)+obj)\n   \n def save_bytearray(self,obj):\n  if self.proto <5:\n   if not obj:\n    self.save_reduce(bytearray,(),obj=obj)\n   else:\n    self.save_reduce(bytearray,(bytes(obj),),obj=obj)\n   return\n  self._save_bytearray_no_memo(obj)\n  self.memoize(obj)\n dispatch[bytearray]=save_bytearray\n \n if _HAVE_PICKLE_BUFFER:\n  def save_picklebuffer(self,obj):\n   if self.proto <5:\n    raise PicklingError(\"PickleBuffer can only pickled with \"\n    \"protocol >= 5\")\n   with obj.raw()as m:\n    if not m.contiguous:\n     raise PicklingError(\"PickleBuffer can not be pickled when \"\n     \"pointing to a non-contiguous buffer\")\n    in_band=True\n    if self._buffer_callback is not None:\n     in_band=bool(self._buffer_callback(obj))\n    if in_band:\n    \n    \n     buf=m.tobytes()\n     in_memo=id(buf)in self.memo\n     if m.readonly:\n      if in_memo:\n       self._save_bytes_no_memo(buf)\n      else:\n       self.save_bytes(buf)\n     else:\n      if in_memo:\n       self._save_bytearray_no_memo(buf)\n      else:\n       self.save_bytearray(buf)\n    else:\n    \n     self.write(NEXT_BUFFER)\n     if m.readonly:\n      self.write(READONLY_BUFFER)\n      \n  dispatch[PickleBuffer]=save_picklebuffer\n  \n def save_str(self,obj):\n  if self.bin:\n   encoded=obj.encode('utf-8','surrogatepass')\n   n=len(encoded)\n   if n <=0xff and self.proto >=4:\n    self.write(SHORT_BINUNICODE+pack(\"<B\",n)+encoded)\n   elif n >0xffffffff and self.proto >=4:\n    self._write_large_bytes(BINUNICODE8+pack(\"<Q\",n),encoded)\n   elif n >=self.framer._FRAME_SIZE_TARGET:\n    self._write_large_bytes(BINUNICODE+pack(\"<I\",n),encoded)\n   else:\n    self.write(BINUNICODE+pack(\"<I\",n)+encoded)\n  else:\n  \n   tmp=obj.replace(\"\\\\\",\"\\\\u005c\")\n   tmp=tmp.replace(\"\\0\",\"\\\\u0000\")\n   tmp=tmp.replace(\"\\n\",\"\\\\u000a\")\n   tmp=tmp.replace(\"\\r\",\"\\\\u000d\")\n   tmp=tmp.replace(\"\\x1a\",\"\\\\u001a\")\n   self.write(UNICODE+tmp.encode('raw-unicode-escape')+b'\\n')\n  self.memoize(obj)\n dispatch[str]=save_str\n \n def save_tuple(self,obj):\n  if not obj:\n   if self.bin:\n    self.write(EMPTY_TUPLE)\n   else:\n    self.write(MARK+TUPLE)\n   return\n   \n  n=len(obj)\n  save=self.save\n  memo=self.memo\n  if n <=3 and self.proto >=2:\n   for element in obj:\n    save(element)\n    \n   if id(obj)in memo:\n    get=self.get(memo[id(obj)][0])\n    self.write(POP *n+get)\n   else:\n    self.write(_tuplesize2code[n])\n    self.memoize(obj)\n   return\n   \n   \n   \n  write=self.write\n  write(MARK)\n  for element in obj:\n   save(element)\n   \n  if id(obj)in memo:\n  \n  \n  \n  \n  \n  \n  \n   get=self.get(memo[id(obj)][0])\n   if self.bin:\n    write(POP_MARK+get)\n   else:\n    write(POP *(n+1)+get)\n   return\n   \n   \n  write(TUPLE)\n  self.memoize(obj)\n  \n dispatch[tuple]=save_tuple\n \n def save_list(self,obj):\n  if self.bin:\n   self.write(EMPTY_LIST)\n  else:\n   self.write(MARK+LIST)\n   \n  self.memoize(obj)\n  self._batch_appends(obj)\n  \n dispatch[list]=save_list\n \n _BATCHSIZE=1000\n \n def _batch_appends(self,items):\n \n  save=self.save\n  write=self.write\n  \n  if not self.bin:\n   for x in items:\n    save(x)\n    write(APPEND)\n   return\n   \n  it=iter(items)\n  while True:\n   tmp=list(islice(it,self._BATCHSIZE))\n   n=len(tmp)\n   if n >1:\n    write(MARK)\n    for x in tmp:\n     save(x)\n    write(APPENDS)\n   elif n:\n    save(tmp[0])\n    write(APPEND)\n    \n   if n <self._BATCHSIZE:\n    return\n    \n def save_dict(self,obj):\n  if self.bin:\n   self.write(EMPTY_DICT)\n  else:\n   self.write(MARK+DICT)\n   \n  self.memoize(obj)\n  self._batch_setitems(obj.items())\n  \n dispatch[dict]=save_dict\n \n def _batch_setitems(self,items):\n \n  save=self.save\n  write=self.write\n  \n  if not self.bin:\n   for k,v in items:\n    save(k)\n    save(v)\n    write(SETITEM)\n   return\n   \n  it=iter(items)\n  while True:\n   tmp=list(islice(it,self._BATCHSIZE))\n   n=len(tmp)\n   if n >1:\n    write(MARK)\n    for k,v in tmp:\n     save(k)\n     save(v)\n    write(SETITEMS)\n   elif n:\n    k,v=tmp[0]\n    save(k)\n    save(v)\n    write(SETITEM)\n    \n   if n <self._BATCHSIZE:\n    return\n    \n def save_set(self,obj):\n  save=self.save\n  write=self.write\n  \n  if self.proto <4:\n   self.save_reduce(set,(list(obj),),obj=obj)\n   return\n   \n  write(EMPTY_SET)\n  self.memoize(obj)\n  \n  it=iter(obj)\n  while True:\n   batch=list(islice(it,self._BATCHSIZE))\n   n=len(batch)\n   if n >0:\n    write(MARK)\n    for item in batch:\n     save(item)\n    write(ADDITEMS)\n   if n <self._BATCHSIZE:\n    return\n dispatch[set]=save_set\n \n def save_frozenset(self,obj):\n  save=self.save\n  write=self.write\n  \n  if self.proto <4:\n   self.save_reduce(frozenset,(list(obj),),obj=obj)\n   return\n   \n  write(MARK)\n  for item in obj:\n   save(item)\n   \n  if id(obj)in self.memo:\n  \n  \n  \n   write(POP_MARK+self.get(self.memo[id(obj)][0]))\n   return\n   \n  write(FROZENSET)\n  self.memoize(obj)\n dispatch[frozenset]=save_frozenset\n \n def save_global(self,obj,name=None):\n  write=self.write\n  memo=self.memo\n  \n  if name is None:\n   name=getattr(obj,'__qualname__',None)\n  if name is None:\n   name=obj.__name__\n   \n  module_name=whichmodule(obj,name)\n  try:\n   __import__(module_name,level=0)\n   module=sys.modules[module_name]\n   obj2,parent=_getattribute(module,name)\n  except(ImportError,KeyError,AttributeError):\n   raise PicklingError(\n   \"Can't pickle %r: it's not found as %s.%s\"%\n   (obj,module_name,name))from None\n  else:\n   if obj2 is not obj:\n    raise PicklingError(\n    \"Can't pickle %r: it's not the same object as %s.%s\"%\n    (obj,module_name,name))\n    \n  if self.proto >=2:\n   code=_extension_registry.get((module_name,name))\n   if code:\n    assert code >0\n    if code <=0xff:\n     write(EXT1+pack(\"<B\",code))\n    elif code <=0xffff:\n     write(EXT2+pack(\"<H\",code))\n    else:\n     write(EXT4+pack(\"<i\",code))\n    return\n  lastname=name.rpartition('.')[2]\n  if parent is module:\n   name=lastname\n   \n  if self.proto >=4:\n   self.save(module_name)\n   self.save(name)\n   write(STACK_GLOBAL)\n  elif parent is not module:\n   self.save_reduce(getattr,(parent,lastname))\n  elif self.proto >=3:\n   write(GLOBAL+bytes(module_name,\"utf-8\")+b'\\n'+\n   bytes(name,\"utf-8\")+b'\\n')\n  else:\n   if self.fix_imports:\n    r_name_mapping=_compat_pickle.REVERSE_NAME_MAPPING\n    r_import_mapping=_compat_pickle.REVERSE_IMPORT_MAPPING\n    if(module_name,name)in r_name_mapping:\n     module_name,name=r_name_mapping[(module_name,name)]\n    elif module_name in r_import_mapping:\n     module_name=r_import_mapping[module_name]\n   try:\n    write(GLOBAL+bytes(module_name,\"ascii\")+b'\\n'+\n    bytes(name,\"ascii\")+b'\\n')\n   except UnicodeEncodeError:\n    raise PicklingError(\n    \"can't pickle global identifier '%s.%s' using \"\n    \"pickle protocol %i\"%(module,name,self.proto))from None\n    \n  self.memoize(obj)\n  \n def save_type(self,obj):\n  if obj is type(None):\n   return self.save_reduce(type,(None,),obj=obj)\n  elif obj is type(NotImplemented):\n   return self.save_reduce(type,(NotImplemented,),obj=obj)\n  elif obj is type(...):\n   return self.save_reduce(type,(...,),obj=obj)\n  return self.save_global(obj)\n  \n dispatch[FunctionType]=save_global\n dispatch[type]=save_type\n \n \n \n \nclass _Unpickler:\n\n def __init__(self,file,*,fix_imports=True,\n encoding=\"ASCII\",errors=\"strict\",buffers=None):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  self._buffers=iter(buffers)if buffers is not None else None\n  self._file_readline=file.readline\n  self._file_read=file.read\n  self.memo={}\n  self.encoding=encoding\n  self.errors=errors\n  self.proto=0\n  self.fix_imports=fix_imports\n  \n def load(self):\n  ''\n\n\n  \n  \n  \n  if not hasattr(self,\"_file_read\"):\n   raise UnpicklingError(\"Unpickler.__init__() was not called by \"\n   \"%s.__init__()\"%(self.__class__.__name__,))\n  self._unframer=_Unframer(self._file_read,self._file_readline)\n  self.read=self._unframer.read\n  self.readinto=self._unframer.readinto\n  self.readline=self._unframer.readline\n  self.metastack=[]\n  self.stack=[]\n  self.append=self.stack.append\n  self.proto=0\n  read=self.read\n  dispatch=self.dispatch\n  try:\n   while True:\n    key=read(1)\n    if not key:\n     raise EOFError\n    assert isinstance(key,bytes_types)\n    dispatch[key[0]](self)\n  except _Stop as stopinst:\n   return stopinst.value\n   \n   \n def pop_mark(self):\n  items=self.stack\n  self.stack=self.metastack.pop()\n  self.append=self.stack.append\n  return items\n  \n def persistent_load(self,pid):\n  raise UnpicklingError(\"unsupported persistent id encountered\")\n  \n dispatch={}\n \n def load_proto(self):\n  proto=self.read(1)[0]\n  if not 0 <=proto <=HIGHEST_PROTOCOL:\n   raise ValueError(\"unsupported pickle protocol: %d\"%proto)\n  self.proto=proto\n dispatch[PROTO[0]]=load_proto\n \n def load_frame(self):\n  frame_size,=unpack('<Q',self.read(8))\n  if frame_size >sys.maxsize:\n   raise ValueError(\"frame size > sys.maxsize: %d\"%frame_size)\n  self._unframer.load_frame(frame_size)\n dispatch[FRAME[0]]=load_frame\n \n def load_persid(self):\n  try:\n   pid=self.readline()[:-1].decode(\"ascii\")\n  except UnicodeDecodeError:\n   raise UnpicklingError(\n   \"persistent IDs in protocol 0 must be ASCII strings\")\n  self.append(self.persistent_load(pid))\n dispatch[PERSID[0]]=load_persid\n \n def load_binpersid(self):\n  pid=self.stack.pop()\n  self.append(self.persistent_load(pid))\n dispatch[BINPERSID[0]]=load_binpersid\n \n def load_none(self):\n  self.append(None)\n dispatch[NONE[0]]=load_none\n \n def load_false(self):\n  self.append(False)\n dispatch[NEWFALSE[0]]=load_false\n \n def load_true(self):\n  self.append(True)\n dispatch[NEWTRUE[0]]=load_true\n \n def load_int(self):\n  data=self.readline()\n  if data ==FALSE[1:]:\n   val=False\n  elif data ==TRUE[1:]:\n   val=True\n  else:\n   val=int(data,0)\n  self.append(val)\n dispatch[INT[0]]=load_int\n \n def load_binint(self):\n  self.append(unpack('<i',self.read(4))[0])\n dispatch[BININT[0]]=load_binint\n \n def load_binint1(self):\n  self.append(self.read(1)[0])\n dispatch[BININT1[0]]=load_binint1\n \n def load_binint2(self):\n  self.append(unpack('<H',self.read(2))[0])\n dispatch[BININT2[0]]=load_binint2\n \n def load_long(self):\n  val=self.readline()[:-1]\n  if val and val[-1]==b'L'[0]:\n   val=val[:-1]\n  self.append(int(val,0))\n dispatch[LONG[0]]=load_long\n \n def load_long1(self):\n  n=self.read(1)[0]\n  data=self.read(n)\n  self.append(decode_long(data))\n dispatch[LONG1[0]]=load_long1\n \n def load_long4(self):\n  n,=unpack('<i',self.read(4))\n  if n <0:\n  \n   raise UnpicklingError(\"LONG pickle has negative byte count\")\n  data=self.read(n)\n  self.append(decode_long(data))\n dispatch[LONG4[0]]=load_long4\n \n def load_float(self):\n  self.append(float(self.readline()[:-1]))\n dispatch[FLOAT[0]]=load_float\n \n def load_binfloat(self):\n  self.append(unpack('>d',self.read(8))[0])\n dispatch[BINFLOAT[0]]=load_binfloat\n \n def _decode_string(self,value):\n \n \n \n  if self.encoding ==\"bytes\":\n   return value\n  else:\n   return value.decode(self.encoding,self.errors)\n   \n def load_string(self):\n  data=self.readline()[:-1]\n  \n  if len(data)>=2 and data[0]==data[-1]and data[0]in b'\"\\'':\n   data=data[1:-1]\n  else:\n   raise UnpicklingError(\"the STRING opcode argument must be quoted\")\n  self.append(self._decode_string(codecs.escape_decode(data)[0]))\n dispatch[STRING[0]]=load_string\n \n def load_binstring(self):\n \n  len,=unpack('<i',self.read(4))\n  if len <0:\n   raise UnpicklingError(\"BINSTRING pickle has negative byte count\")\n  data=self.read(len)\n  self.append(self._decode_string(data))\n dispatch[BINSTRING[0]]=load_binstring\n \n def load_binbytes(self):\n  len,=unpack('<I',self.read(4))\n  if len >maxsize:\n   raise UnpicklingError(\"BINBYTES exceeds system's maximum size \"\n   \"of %d bytes\"%maxsize)\n  self.append(self.read(len))\n dispatch[BINBYTES[0]]=load_binbytes\n \n def load_unicode(self):\n  self.append(str(self.readline()[:-1],'raw-unicode-escape'))\n dispatch[UNICODE[0]]=load_unicode\n \n def load_binunicode(self):\n  len,=unpack('<I',self.read(4))\n  if len >maxsize:\n   raise UnpicklingError(\"BINUNICODE exceeds system's maximum size \"\n   \"of %d bytes\"%maxsize)\n  self.append(str(self.read(len),'utf-8','surrogatepass'))\n dispatch[BINUNICODE[0]]=load_binunicode\n \n def load_binunicode8(self):\n  len,=unpack('<Q',self.read(8))\n  if len >maxsize:\n   raise UnpicklingError(\"BINUNICODE8 exceeds system's maximum size \"\n   \"of %d bytes\"%maxsize)\n  self.append(str(self.read(len),'utf-8','surrogatepass'))\n dispatch[BINUNICODE8[0]]=load_binunicode8\n \n def load_binbytes8(self):\n  len,=unpack('<Q',self.read(8))\n  if len >maxsize:\n   raise UnpicklingError(\"BINBYTES8 exceeds system's maximum size \"\n   \"of %d bytes\"%maxsize)\n  self.append(self.read(len))\n dispatch[BINBYTES8[0]]=load_binbytes8\n \n def load_bytearray8(self):\n  len,=unpack('<Q',self.read(8))\n  if len >maxsize:\n   raise UnpicklingError(\"BYTEARRAY8 exceeds system's maximum size \"\n   \"of %d bytes\"%maxsize)\n  b=bytearray(len)\n  self.readinto(b)\n  self.append(b)\n dispatch[BYTEARRAY8[0]]=load_bytearray8\n \n def load_next_buffer(self):\n  if self._buffers is None:\n   raise UnpicklingError(\"pickle stream refers to out-of-band data \"\n   \"but no *buffers* argument was given\")\n  try:\n   buf=next(self._buffers)\n  except StopIteration:\n   raise UnpicklingError(\"not enough out-of-band buffers\")\n  self.append(buf)\n dispatch[NEXT_BUFFER[0]]=load_next_buffer\n \n def load_readonly_buffer(self):\n  buf=self.stack[-1]\n  with memoryview(buf)as m:\n   if not m.readonly:\n    self.stack[-1]=m.toreadonly()\n dispatch[READONLY_BUFFER[0]]=load_readonly_buffer\n \n def load_short_binstring(self):\n  len=self.read(1)[0]\n  data=self.read(len)\n  self.append(self._decode_string(data))\n dispatch[SHORT_BINSTRING[0]]=load_short_binstring\n \n def load_short_binbytes(self):\n  len=self.read(1)[0]\n  self.append(self.read(len))\n dispatch[SHORT_BINBYTES[0]]=load_short_binbytes\n \n def load_short_binunicode(self):\n  len=self.read(1)[0]\n  self.append(str(self.read(len),'utf-8','surrogatepass'))\n dispatch[SHORT_BINUNICODE[0]]=load_short_binunicode\n \n def load_tuple(self):\n  items=self.pop_mark()\n  self.append(tuple(items))\n dispatch[TUPLE[0]]=load_tuple\n \n def load_empty_tuple(self):\n  self.append(())\n dispatch[EMPTY_TUPLE[0]]=load_empty_tuple\n \n def load_tuple1(self):\n  self.stack[-1]=(self.stack[-1],)\n dispatch[TUPLE1[0]]=load_tuple1\n \n def load_tuple2(self):\n  self.stack[-2:]=[(self.stack[-2],self.stack[-1])]\n dispatch[TUPLE2[0]]=load_tuple2\n \n def load_tuple3(self):\n  self.stack[-3:]=[(self.stack[-3],self.stack[-2],self.stack[-1])]\n dispatch[TUPLE3[0]]=load_tuple3\n \n def load_empty_list(self):\n  self.append([])\n dispatch[EMPTY_LIST[0]]=load_empty_list\n \n def load_empty_dictionary(self):\n  self.append({})\n dispatch[EMPTY_DICT[0]]=load_empty_dictionary\n \n def load_empty_set(self):\n  self.append(set())\n dispatch[EMPTY_SET[0]]=load_empty_set\n \n def load_frozenset(self):\n  items=self.pop_mark()\n  self.append(frozenset(items))\n dispatch[FROZENSET[0]]=load_frozenset\n \n def load_list(self):\n  items=self.pop_mark()\n  self.append(items)\n dispatch[LIST[0]]=load_list\n \n def load_dict(self):\n  items=self.pop_mark()\n  d={items[i]:items[i+1]\n  for i in range(0,len(items),2)}\n  self.append(d)\n dispatch[DICT[0]]=load_dict\n \n \n \n \n \n \n def _instantiate(self,klass,args):\n  if(args or not isinstance(klass,type)or\n  hasattr(klass,\"__getinitargs__\")):\n   try:\n    value=klass(*args)\n   except TypeError as err:\n    raise TypeError(\"in constructor for %s: %s\"%\n    (klass.__name__,str(err)),err.__traceback__)\n  else:\n   value=klass.__new__(klass)\n  self.append(value)\n  \n def load_inst(self):\n  module=self.readline()[:-1].decode(\"ascii\")\n  name=self.readline()[:-1].decode(\"ascii\")\n  klass=self.find_class(module,name)\n  self._instantiate(klass,self.pop_mark())\n dispatch[INST[0]]=load_inst\n \n def load_obj(self):\n \n  args=self.pop_mark()\n  cls=args.pop(0)\n  self._instantiate(cls,args)\n dispatch[OBJ[0]]=load_obj\n \n def load_newobj(self):\n  args=self.stack.pop()\n  cls=self.stack.pop()\n  obj=cls.__new__(cls,*args)\n  self.append(obj)\n dispatch[NEWOBJ[0]]=load_newobj\n \n def load_newobj_ex(self):\n  kwargs=self.stack.pop()\n  args=self.stack.pop()\n  cls=self.stack.pop()\n  obj=cls.__new__(cls,*args,**kwargs)\n  self.append(obj)\n dispatch[NEWOBJ_EX[0]]=load_newobj_ex\n \n def load_global(self):\n  module=self.readline()[:-1].decode(\"utf-8\")\n  name=self.readline()[:-1].decode(\"utf-8\")\n  klass=self.find_class(module,name)\n  self.append(klass)\n dispatch[GLOBAL[0]]=load_global\n \n def load_stack_global(self):\n  name=self.stack.pop()\n  module=self.stack.pop()\n  if type(name)is not str or type(module)is not str:\n   raise UnpicklingError(\"STACK_GLOBAL requires str\")\n  self.append(self.find_class(module,name))\n dispatch[STACK_GLOBAL[0]]=load_stack_global\n \n def load_ext1(self):\n  code=self.read(1)[0]\n  self.get_extension(code)\n dispatch[EXT1[0]]=load_ext1\n \n def load_ext2(self):\n  code,=unpack('<H',self.read(2))\n  self.get_extension(code)\n dispatch[EXT2[0]]=load_ext2\n \n def load_ext4(self):\n  code,=unpack('<i',self.read(4))\n  self.get_extension(code)\n dispatch[EXT4[0]]=load_ext4\n \n def get_extension(self,code):\n  nil=[]\n  obj=_extension_cache.get(code,nil)\n  if obj is not nil:\n   self.append(obj)\n   return\n  key=_inverted_registry.get(code)\n  if not key:\n   if code <=0:\n   \n    raise UnpicklingError(\"EXT specifies code <= 0\")\n   raise ValueError(\"unregistered extension code %d\"%code)\n  obj=self.find_class(*key)\n  _extension_cache[code]=obj\n  self.append(obj)\n  \n def find_class(self,module,name):\n \n  sys.audit('pickle.find_class',module,name)\n  if self.proto <3 and self.fix_imports:\n   if(module,name)in _compat_pickle.NAME_MAPPING:\n    module,name=_compat_pickle.NAME_MAPPING[(module,name)]\n   elif module in _compat_pickle.IMPORT_MAPPING:\n    module=_compat_pickle.IMPORT_MAPPING[module]\n  __import__(module,level=0)\n  if self.proto >=4:\n   return _getattribute(sys.modules[module],name)[0]\n  else:\n   return getattr(sys.modules[module],name)\n   \n def load_reduce(self):\n  stack=self.stack\n  args=stack.pop()\n  func=stack[-1]\n  stack[-1]=func(*args)\n dispatch[REDUCE[0]]=load_reduce\n \n def load_pop(self):\n  if self.stack:\n   del self.stack[-1]\n  else:\n   self.pop_mark()\n dispatch[POP[0]]=load_pop\n \n def load_pop_mark(self):\n  self.pop_mark()\n dispatch[POP_MARK[0]]=load_pop_mark\n \n def load_dup(self):\n  self.append(self.stack[-1])\n dispatch[DUP[0]]=load_dup\n \n def load_get(self):\n  i=int(self.readline()[:-1])\n  try:\n   self.append(self.memo[i])\n  except KeyError:\n   msg=f'Memo value not found at index {i}'\n   raise UnpicklingError(msg)from None\n dispatch[GET[0]]=load_get\n \n def load_binget(self):\n  i=self.read(1)[0]\n  try:\n   self.append(self.memo[i])\n  except KeyError as exc:\n   msg=f'Memo value not found at index {i}'\n   raise UnpicklingError(msg)from None\n dispatch[BINGET[0]]=load_binget\n \n def load_long_binget(self):\n  i,=unpack('<I',self.read(4))\n  try:\n   self.append(self.memo[i])\n  except KeyError as exc:\n   msg=f'Memo value not found at index {i}'\n   raise UnpicklingError(msg)from None\n dispatch[LONG_BINGET[0]]=load_long_binget\n \n def load_put(self):\n  i=int(self.readline()[:-1])\n  if i <0:\n   raise ValueError(\"negative PUT argument\")\n  self.memo[i]=self.stack[-1]\n dispatch[PUT[0]]=load_put\n \n def load_binput(self):\n  i=self.read(1)[0]\n  if i <0:\n   raise ValueError(\"negative BINPUT argument\")\n  self.memo[i]=self.stack[-1]\n dispatch[BINPUT[0]]=load_binput\n \n def load_long_binput(self):\n  i,=unpack('<I',self.read(4))\n  if i >maxsize:\n   raise ValueError(\"negative LONG_BINPUT argument\")\n  self.memo[i]=self.stack[-1]\n dispatch[LONG_BINPUT[0]]=load_long_binput\n \n def load_memoize(self):\n  memo=self.memo\n  memo[len(memo)]=self.stack[-1]\n dispatch[MEMOIZE[0]]=load_memoize\n \n def load_append(self):\n  stack=self.stack\n  value=stack.pop()\n  list=stack[-1]\n  list.append(value)\n dispatch[APPEND[0]]=load_append\n \n def load_appends(self):\n  items=self.pop_mark()\n  list_obj=self.stack[-1]\n  try:\n   extend=list_obj.extend\n  except AttributeError:\n   pass\n  else:\n   extend(items)\n   return\n   \n   \n   \n  append=list_obj.append\n  for item in items:\n   append(item)\n dispatch[APPENDS[0]]=load_appends\n \n def load_setitem(self):\n  stack=self.stack\n  value=stack.pop()\n  key=stack.pop()\n  dict=stack[-1]\n  dict[key]=value\n dispatch[SETITEM[0]]=load_setitem\n \n def load_setitems(self):\n  items=self.pop_mark()\n  dict=self.stack[-1]\n  for i in range(0,len(items),2):\n   dict[items[i]]=items[i+1]\n dispatch[SETITEMS[0]]=load_setitems\n \n def load_additems(self):\n  items=self.pop_mark()\n  set_obj=self.stack[-1]\n  if isinstance(set_obj,set):\n   set_obj.update(items)\n  else:\n   add=set_obj.add\n   for item in items:\n    add(item)\n dispatch[ADDITEMS[0]]=load_additems\n \n def load_build(self):\n  stack=self.stack\n  state=stack.pop()\n  inst=stack[-1]\n  setstate=getattr(inst,\"__setstate__\",_NoValue)\n  if setstate is not _NoValue:\n   setstate(state)\n   return\n  slotstate=None\n  if isinstance(state,tuple)and len(state)==2:\n   state,slotstate=state\n  if state:\n   inst_dict=inst.__dict__\n   intern=sys.intern\n   for k,v in state.items():\n    if type(k)is str:\n     inst_dict[intern(k)]=v\n    else:\n     inst_dict[k]=v\n  if slotstate:\n   for k,v in slotstate.items():\n    setattr(inst,k,v)\n dispatch[BUILD[0]]=load_build\n \n def load_mark(self):\n  self.metastack.append(self.stack)\n  self.stack=[]\n  self.append=self.stack.append\n dispatch[MARK[0]]=load_mark\n \n def load_stop(self):\n  value=self.stack.pop()\n  raise _Stop(value)\n dispatch[STOP[0]]=load_stop\n \n \n \n \ndef _dump(obj,file,protocol=None,*,fix_imports=True,buffer_callback=None):\n _Pickler(file,protocol,fix_imports=fix_imports,\n buffer_callback=buffer_callback).dump(obj)\n \ndef _dumps(obj,protocol=None,*,fix_imports=True,buffer_callback=None):\n f=io.BytesIO()\n _Pickler(f,protocol,fix_imports=fix_imports,\n buffer_callback=buffer_callback).dump(obj)\n res=f.getvalue()\n assert isinstance(res,bytes_types)\n return res\n \ndef _load(file,*,fix_imports=True,encoding=\"ASCII\",errors=\"strict\",\nbuffers=None):\n return _Unpickler(file,fix_imports=fix_imports,buffers=buffers,\n encoding=encoding,errors=errors).load()\n \ndef _loads(s,/,*,fix_imports=True,encoding=\"ASCII\",errors=\"strict\",\nbuffers=None):\n if isinstance(s,str):\n  raise TypeError(\"Can't load pickle from unicode string\")\n file=io.BytesIO(s)\n return _Unpickler(file,fix_imports=fix_imports,buffers=buffers,\n encoding=encoding,errors=errors).load()\n \n \ntry:\n from _pickle import(\n PickleError,\n PicklingError,\n UnpicklingError,\n Pickler,\n Unpickler,\n dump,\n dumps,\n load,\n loads\n )\nexcept ImportError:\n Pickler,Unpickler=_Pickler,_Unpickler\n dump,dumps,load,loads=_dump,_dumps,_load,_loads\n \n \ndef _test():\n import doctest\n return doctest.testmod()\n \nif __name__ ==\"__main__\":\n import argparse\n parser=argparse.ArgumentParser(\n description='display contents of the pickle files')\n parser.add_argument(\n 'pickle_file',\n nargs='*',help='the pickle file')\n parser.add_argument(\n '-t','--test',action='store_true',\n help='run self-test suite')\n parser.add_argument(\n '-v',action='store_true',\n help='run verbosely; only affects self-test run')\n args=parser.parse_args()\n if args.test:\n  _test()\n else:\n  if not args.pickle_file:\n   parser.print_help()\n  else:\n   import pprint\n   for fn in args.pickle_file:\n    if fn =='-':\n     obj=load(sys.stdin.buffer)\n    else:\n     with open(fn,'rb')as f:\n      obj=load(f)\n    pprint.pprint(obj)\n", ["_compat_pickle", "_pickle", "argparse", "codecs", "copyreg", "doctest", "functools", "io", "itertools", "pprint", "re", "struct", "sys", "types"]], "random": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfrom warnings import warn as _warn\nfrom math import log as _log,exp as _exp,pi as _pi,e as _e,ceil as _ceil\nfrom math import sqrt as _sqrt,acos as _acos,cos as _cos,sin as _sin\nfrom math import tau as TWOPI,floor as _floor,isfinite as _isfinite\nfrom math import lgamma as _lgamma,fabs as _fabs,log2 as _log2\nfrom os import urandom as _urandom\nfrom _collections_abc import Sequence as _Sequence\nfrom operator import index as _index\nfrom itertools import accumulate as _accumulate,repeat as _repeat\nfrom bisect import bisect as _bisect\nimport os as _os\nimport _random\n\ntry:\n\n from _sha512 import sha512 as _sha512\nexcept ImportError:\n\n from hashlib import sha512 as _sha512\n \n__all__=[\n\"Random\",\n\"SystemRandom\",\n\"betavariate\",\n\"binomialvariate\",\n\"choice\",\n\"choices\",\n\"expovariate\",\n\"gammavariate\",\n\"gauss\",\n\"getrandbits\",\n\"getstate\",\n\"lognormvariate\",\n\"normalvariate\",\n\"paretovariate\",\n\"randbytes\",\n\"randint\",\n\"random\",\n\"randrange\",\n\"sample\",\n\"seed\",\n\"setstate\",\n\"shuffle\",\n\"triangular\",\n\"uniform\",\n\"vonmisesvariate\",\n\"weibullvariate\",\n]\n\nNV_MAGICCONST=4 *_exp(-0.5)/_sqrt(2.0)\nLOG4=_log(4.0)\nSG_MAGICCONST=1.0+_log(4.5)\nBPF=53\nRECIP_BPF=2 **-BPF\n_ONE=1\n\n\nclass Random(_random.Random):\n ''\n\n\n\n\n\n\n\n\n\n\n \n \n VERSION=3\n \n def __init__(self,x=None):\n  ''\n\n\n  \n  \n  self.seed(x)\n  self.gauss_next=None\n  \n def seed(self,a=None,version=2):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  if version ==1 and isinstance(a,(str,bytes)):\n   a=a.decode('latin-1')if isinstance(a,bytes)else a\n   x=ord(a[0])<<7 if a else 0\n   for c in map(ord,a):\n    x=((1000003 *x)^c)&0xFFFFFFFFFFFFFFFF\n   x ^=len(a)\n   a=-2 if x ==-1 else x\n   \n  elif version ==2 and isinstance(a,(str,bytes,bytearray)):\n   if isinstance(a,str):\n    a=a.encode()\n   a=int.from_bytes(a+_sha512(a).digest())\n   \n  elif not isinstance(a,(type(None),int,float,str,bytes,bytearray)):\n   raise TypeError('The only supported seed types are: None,\\n'\n   'int, float, str, bytes, and bytearray.')\n   \n  super().seed(a)\n  self.gauss_next=None\n  \n def getstate(self):\n  ''\n  return self.VERSION,super().getstate(),self.gauss_next\n  \n def setstate(self,state):\n  ''\n  version=state[0]\n  if version ==3:\n   version,internalstate,self.gauss_next=state\n   super().setstate(internalstate)\n  elif version ==2:\n   version,internalstate,self.gauss_next=state\n   \n   \n   \n   \n   try:\n    internalstate=tuple(x %(2 **32)for x in internalstate)\n   except ValueError as e:\n    raise TypeError from e\n   super().setstate(internalstate)\n  else:\n   raise ValueError(\"state with version %s passed to \"\n   \"Random.setstate() of version %s\"%\n   (version,self.VERSION))\n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n def __getstate__(self):\n  return self.getstate()\n  \n def __setstate__(self,state):\n  self.setstate(state)\n  \n def __reduce__(self):\n  return self.__class__,(),self.getstate()\n  \n  \n  \n  \n def __init_subclass__(cls,/,**kwargs):\n  ''\n\n\n\n\n\n  \n  \n  for c in cls.__mro__:\n   if '_randbelow'in c.__dict__:\n   \n    break\n   if 'getrandbits'in c.__dict__:\n    cls._randbelow=cls._randbelow_with_getrandbits\n    break\n   if 'random'in c.__dict__:\n    cls._randbelow=cls._randbelow_without_getrandbits\n    break\n    \n def _randbelow_with_getrandbits(self,n):\n  ''\n  \n  getrandbits=self.getrandbits\n  k=n.bit_length()\n  r=getrandbits(k)\n  while r >=n:\n   r=getrandbits(k)\n  return r\n  \n def _randbelow_without_getrandbits(self,n,maxsize=1 <<BPF):\n  ''\n\n\n  \n  \n  random=self.random\n  if n >=maxsize:\n   _warn(\"Underlying random() generator does not supply \\n\"\n   \"enough bits to choose from a population range this large.\\n\"\n   \"To remove the range limitation, add a getrandbits() method.\")\n   return _floor(random()*n)\n  rem=maxsize %n\n  limit=(maxsize -rem)/maxsize\n  r=random()\n  while r >=limit:\n   r=random()\n  return _floor(r *maxsize)%n\n  \n _randbelow=_randbelow_with_getrandbits\n \n \n \n \n \n \n \n \n \n \n \n \n def randbytes(self,n):\n  ''\n  return self.getrandbits(n *8).to_bytes(n,'little')\n  \n  \n  \n  \n def randrange(self,start,stop=None,step=_ONE):\n  ''\n\n\n\n\n  \n  \n  \n  \n  istart=_index(start)\n  if stop is None:\n  \n  \n   if step is not _ONE:\n    raise TypeError(\"Missing a non-None stop argument\")\n   if istart >0:\n    return self._randbelow(istart)\n   raise ValueError(\"empty range for randrange()\")\n   \n   \n  istop=_index(stop)\n  width=istop -istart\n  istep=_index(step)\n  \n  if istep ==1:\n   if width >0:\n    return istart+self._randbelow(width)\n   raise ValueError(f\"empty range in randrange({start}, {stop})\")\n   \n   \n  if istep >0:\n   n=(width+istep -1)//istep\n  elif istep <0:\n   n=(width+istep+1)//istep\n  else:\n   raise ValueError(\"zero step for randrange()\")\n  if n <=0:\n   raise ValueError(f\"empty range in randrange({start}, {stop}, {step})\")\n  return istart+istep *self._randbelow(n)\n  \n def randint(self,a,b):\n  ''\n  \n  \n  return self.randrange(a,b+1)\n  \n  \n  \n  \n def choice(self,seq):\n  ''\n  \n  \n  \n  if not len(seq):\n   raise IndexError('Cannot choose from an empty sequence')\n  return seq[self._randbelow(len(seq))]\n  \n def shuffle(self,x):\n  ''\n  \n  randbelow=self._randbelow\n  for i in reversed(range(1,len(x))):\n  \n   j=randbelow(i+1)\n   x[i],x[j]=x[j],x[i]\n   \n def sample(self,population,k,*,counts=None):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if not isinstance(population,_Sequence):\n   raise TypeError(\"Population must be a sequence.  \"\n   \"For dicts or sets, use sorted(d).\")\n  n=len(population)\n  if counts is not None:\n   cum_counts=list(_accumulate(counts))\n   if len(cum_counts)!=n:\n    raise ValueError('The number of counts does not match the population')\n   total=cum_counts.pop()\n   if not isinstance(total,int):\n    raise TypeError('Counts must be integers')\n   if total <=0:\n    raise ValueError('Total of counts must be greater than zero')\n   selections=self.sample(range(total),k=k)\n   bisect=_bisect\n   return[population[bisect(cum_counts,s)]for s in selections]\n  randbelow=self._randbelow\n  if not 0 <=k <=n:\n   raise ValueError(\"Sample larger than population or is negative\")\n  result=[None]*k\n  setsize=21\n  if k >5:\n   setsize +=4 **_ceil(_log(k *3,4))\n  if n <=setsize:\n  \n  \n   pool=list(population)\n   for i in range(k):\n    j=randbelow(n -i)\n    result[i]=pool[j]\n    pool[j]=pool[n -i -1]\n  else:\n   selected=set()\n   selected_add=selected.add\n   for i in range(k):\n    j=randbelow(n)\n    while j in selected:\n     j=randbelow(n)\n    selected_add(j)\n    result[i]=population[j]\n  return result\n  \n def choices(self,population,weights=None,*,cum_weights=None,k=1):\n  ''\n\n\n\n\n  \n  random=self.random\n  n=len(population)\n  if cum_weights is None:\n   if weights is None:\n    floor=_floor\n    n +=0.0\n    return[population[floor(random()*n)]for i in _repeat(None,k)]\n   try:\n    cum_weights=list(_accumulate(weights))\n   except TypeError:\n    if not isinstance(weights,int):\n     raise\n    k=weights\n    raise TypeError(\n    f'The number of choices must be a keyword argument: {k=}'\n    )from None\n  elif weights is not None:\n   raise TypeError('Cannot specify both weights and cumulative weights')\n  if len(cum_weights)!=n:\n   raise ValueError('The number of weights does not match the population')\n  total=cum_weights[-1]+0.0\n  if total <=0.0:\n   raise ValueError('Total of weights must be greater than zero')\n  if not _isfinite(total):\n   raise ValueError('Total of weights must be finite')\n  bisect=_bisect\n  hi=n -1\n  return[population[bisect(cum_weights,random()*total,0,hi)]\n  for i in _repeat(None,k)]\n  \n  \n  \n  \n def uniform(self,a,b):\n  ''\n  return a+(b -a)*self.random()\n  \n def triangular(self,low=0.0,high=1.0,mode=None):\n  ''\n\n\n\n\n\n\n  \n  u=self.random()\n  try:\n   c=0.5 if mode is None else(mode -low)/(high -low)\n  except ZeroDivisionError:\n   return low\n  if u >c:\n   u=1.0 -u\n   c=1.0 -c\n   low,high=high,low\n  return low+(high -low)*_sqrt(u *c)\n  \n def normalvariate(self,mu=0.0,sigma=1.0):\n  ''\n\n\n\n  \n  \n  \n  \n  \n  \n  random=self.random\n  while True:\n   u1=random()\n   u2=1.0 -random()\n   z=NV_MAGICCONST *(u1 -0.5)/u2\n   zz=z *z /4.0\n   if zz <=-_log(u2):\n    break\n  return mu+z *sigma\n  \n def gauss(self,mu=0.0,sigma=1.0):\n  ''\n\n\n\n\n\n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  random=self.random\n  z=self.gauss_next\n  self.gauss_next=None\n  if z is None:\n   x2pi=random()*TWOPI\n   g2rad=_sqrt(-2.0 *_log(1.0 -random()))\n   z=_cos(x2pi)*g2rad\n   self.gauss_next=_sin(x2pi)*g2rad\n   \n  return mu+z *sigma\n  \n def lognormvariate(self,mu,sigma):\n  ''\n\n\n\n\n\n  \n  return _exp(self.normalvariate(mu,sigma))\n  \n def expovariate(self,lambd=1.0):\n  ''\n\n\n\n\n\n\n\n  \n  \n  \n  \n  \n  \n  return -_log(1.0 -self.random())/lambd\n  \n def vonmisesvariate(self,mu,kappa):\n  ''\n\n\n\n\n\n\n  \n  \n  \n  \n  \n  \n  \n  \n  random=self.random\n  if kappa <=1e-6:\n   return TWOPI *random()\n   \n  s=0.5 /kappa\n  r=s+_sqrt(1.0+s *s)\n  \n  while True:\n   u1=random()\n   z=_cos(_pi *u1)\n   \n   d=z /(r+z)\n   u2=random()\n   if u2 <1.0 -d *d or u2 <=(1.0 -d)*_exp(d):\n    break\n    \n  q=1.0 /r\n  f=(q+z)/(1.0+q *z)\n  u3=random()\n  if u3 >0.5:\n   theta=(mu+_acos(f))%TWOPI\n  else:\n   theta=(mu -_acos(f))%TWOPI\n   \n  return theta\n  \n def gammavariate(self,alpha,beta):\n  ''\n\n\n\n\n\n\n\n\n\n  \n  \n  \n  \n  \n  if alpha <=0.0 or beta <=0.0:\n   raise ValueError('gammavariate: alpha and beta must be > 0.0')\n   \n  random=self.random\n  if alpha >1.0:\n  \n  \n  \n  \n  \n   ainv=_sqrt(2.0 *alpha -1.0)\n   bbb=alpha -LOG4\n   ccc=alpha+ainv\n   \n   while True:\n    u1=random()\n    if not 1e-7 <u1 <0.9999999:\n     continue\n    u2=1.0 -random()\n    v=_log(u1 /(1.0 -u1))/ainv\n    x=alpha *_exp(v)\n    z=u1 *u1 *u2\n    r=bbb+ccc *v -x\n    if r+SG_MAGICCONST -4.5 *z >=0.0 or r >=_log(z):\n     return x *beta\n     \n  elif alpha ==1.0:\n  \n   return -_log(1.0 -random())*beta\n   \n  else:\n  \n  \n   while True:\n    u=random()\n    b=(_e+alpha)/_e\n    p=b *u\n    if p <=1.0:\n     x=p **(1.0 /alpha)\n    else:\n     x=-_log((b -p)/alpha)\n    u1=random()\n    if p >1.0:\n     if u1 <=x **(alpha -1.0):\n      break\n    elif u1 <=_exp(-x):\n     break\n   return x *beta\n   \n def betavariate(self,alpha,beta):\n  ''\n\n\n\n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  y=self.gammavariate(alpha,1.0)\n  if y:\n   return y /(y+self.gammavariate(beta,1.0))\n  return 0.0\n  \n def paretovariate(self,alpha):\n  ''\n  \n  \n  u=1.0 -self.random()\n  return u **(-1.0 /alpha)\n  \n def weibullvariate(self,alpha,beta):\n  ''\n\n\n\n  \n  \n  \n  u=1.0 -self.random()\n  return alpha *(-_log(u))**(1.0 /beta)\n  \n  \n  \n  \n def binomialvariate(self,n=1,p=0.5):\n  ''\n\n\n\n\n\n\n\n\n  \n  \n  if n <0:\n   raise ValueError(\"n must be non-negative\")\n  if p <=0.0 or p >=1.0:\n   if p ==0.0:\n    return 0\n   if p ==1.0:\n    return n\n   raise ValueError(\"p must be in the range 0.0 <= p <= 1.0\")\n   \n  random=self.random\n  \n  \n  if n ==1:\n   return _index(random()<p)\n   \n   \n  if p >0.5:\n   return n -self.binomialvariate(n,1.0 -p)\n   \n  if n *p <10.0:\n  \n  \n   x=y=0\n   c=_log2(1.0 -p)\n   if not c:\n    return x\n   while True:\n    y +=_floor(_log2(random())/c)+1\n    if y >n:\n     return x\n    x +=1\n    \n    \n    \n  assert n *p >=10.0 and p <=0.5\n  setup_complete=False\n  \n  spq=_sqrt(n *p *(1.0 -p))\n  b=1.15+2.53 *spq\n  a=-0.0873+0.0248 *b+0.01 *p\n  c=n *p+0.5\n  vr=0.92 -4.2 /b\n  \n  while True:\n  \n   u=random()\n   u -=0.5\n   us=0.5 -_fabs(u)\n   k=_floor((2.0 *a /us+b)*u+c)\n   if k <0 or k >n:\n    continue\n    \n    \n    \n   v=random()\n   if us >=0.07 and v <=vr:\n    return k\n    \n    \n    \n    \n   if not setup_complete:\n    alpha=(2.83+5.1 /b)*spq\n    lpq=_log(p /(1.0 -p))\n    m=_floor((n+1)*p)\n    h=_lgamma(m+1)+_lgamma(n -m+1)\n    setup_complete=True\n   v *=alpha /(a /(us *us)+b)\n   if _log(v)<=h -_lgamma(k+1)-_lgamma(n -k+1)+(k -m)*lpq:\n    return k\n    \n    \n    \n    \n    \n    \nclass SystemRandom(Random):\n ''\n\n\n\n\n\n \n \n def random(self):\n  ''\n  return(int.from_bytes(_urandom(7))>>3)*RECIP_BPF\n  \n def getrandbits(self,k):\n  ''\n  if k <0:\n   raise ValueError('number of bits must be non-negative')\n  numbytes=(k+7)//8\n  x=int.from_bytes(_urandom(numbytes))\n  return x >>(numbytes *8 -k)\n  \n def randbytes(self,n):\n  ''\n  \n  \n  return _urandom(n)\n  \n def seed(self,*args,**kwds):\n  ''\n  return None\n  \n def _notimplemented(self,*args,**kwds):\n  ''\n  raise NotImplementedError('System entropy source does not have state.')\n getstate=setstate=_notimplemented\n \n \n \n \n \n \n \n \n \n_inst=Random()\nseed=_inst.seed\nrandom=_inst.random\nuniform=_inst.uniform\ntriangular=_inst.triangular\nrandint=_inst.randint\nchoice=_inst.choice\nrandrange=_inst.randrange\nsample=_inst.sample\nshuffle=_inst.shuffle\nchoices=_inst.choices\nnormalvariate=_inst.normalvariate\nlognormvariate=_inst.lognormvariate\nexpovariate=_inst.expovariate\nvonmisesvariate=_inst.vonmisesvariate\ngammavariate=_inst.gammavariate\ngauss=_inst.gauss\nbetavariate=_inst.betavariate\nbinomialvariate=_inst.binomialvariate\nparetovariate=_inst.paretovariate\nweibullvariate=_inst.weibullvariate\ngetstate=_inst.getstate\nsetstate=_inst.setstate\ngetrandbits=_inst.getrandbits\nrandbytes=_inst.randbytes\n\n\n\n\n\ndef _test_generator(n,func,args):\n from statistics import stdev,fmean as mean\n from time import perf_counter\n \n t0=perf_counter()\n data=[func(*args)for i in _repeat(None,n)]\n t1=perf_counter()\n \n xbar=mean(data)\n sigma=stdev(data,xbar)\n low=min(data)\n high=max(data)\n \n print(f'{t1 -t0:.3f} sec, {n} times {func.__name__}{args !r}')\n print('avg %g, stddev %g, min %g, max %g\\n'%(xbar,sigma,low,high))\n \n \ndef _test(N=10_000):\n _test_generator(N,random,())\n _test_generator(N,normalvariate,(0.0,1.0))\n _test_generator(N,lognormvariate,(0.0,1.0))\n _test_generator(N,vonmisesvariate,(0.0,1.0))\n _test_generator(N,binomialvariate,(15,0.60))\n _test_generator(N,binomialvariate,(100,0.75))\n _test_generator(N,gammavariate,(0.01,1.0))\n _test_generator(N,gammavariate,(0.1,1.0))\n _test_generator(N,gammavariate,(0.1,2.0))\n _test_generator(N,gammavariate,(0.5,1.0))\n _test_generator(N,gammavariate,(0.9,1.0))\n _test_generator(N,gammavariate,(1.0,1.0))\n _test_generator(N,gammavariate,(2.0,1.0))\n _test_generator(N,gammavariate,(20.0,1.0))\n _test_generator(N,gammavariate,(200.0,1.0))\n _test_generator(N,gauss,(0.0,1.0))\n _test_generator(N,betavariate,(3.0,3.0))\n _test_generator(N,triangular,(0.0,1.0,1.0 /3.0))\n \n \n \n \n \nif hasattr(_os,\"fork\"):\n _os.register_at_fork(after_in_child=_inst.seed)\n \n \nif __name__ =='__main__':\n _test()\n \n", ["_collections_abc", "_random", "_sha512", "bisect", "hashlib", "itertools", "math", "operator", "os", "statistics", "time", "warnings"]], "re": [".py", "import enum\n\n\nclass _compiler:\n SRE_FLAG_IGNORECASE=2\n SRE_FLAG_LOCALE=4\n SRE_FLAG_MULTILINE=8\n SRE_FLAG_DOTALL=16\n SRE_FLAG_UNICODE=32\n SRE_FLAG_VERBOSE=64\n SRE_FLAG_DEBUG=128\n SRE_FLAG_ASCII=256\n SRE_INFO_PREFIX=1\n SRE_INFO_LITERAL=2\n SRE_INFO_CHARSET=4\n \n@enum.global_enum\n@enum._simple_enum(enum.IntFlag,boundary=enum.KEEP)\nclass RegexFlag:\n NOFLAG=0\n ASCII=A=_compiler.SRE_FLAG_ASCII\n IGNORECASE=I=_compiler.SRE_FLAG_IGNORECASE\n LOCALE=L=_compiler.SRE_FLAG_LOCALE\n UNICODE=U=_compiler.SRE_FLAG_UNICODE\n MULTILINE=M=_compiler.SRE_FLAG_MULTILINE\n DOTALL=S=_compiler.SRE_FLAG_DOTALL\n VERBOSE=X=_compiler.SRE_FLAG_VERBOSE\n \n \n DEBUG=_compiler.SRE_FLAG_DEBUG\n __str__=object.__str__\n _numeric_repr_=hex\n \n \nfrom python_re import *\nfrom browser import console\n\n\nimport python_re\n_compile=python_re._compile\n_reconstructor=python_re._reconstructor\n\npython_re._reconstructor.__module__='re'\n", ["browser", "enum", "python_re"]], "secrets": [".py", "''\n\n\n\n\n\n\n\n__all__=['choice','randbelow','randbits','SystemRandom',\n'token_bytes','token_hex','token_urlsafe',\n'compare_digest',\n]\n\n\nimport base64\n\nfrom hmac import compare_digest\nfrom random import SystemRandom\n\n_sysrand=SystemRandom()\n\nrandbits=_sysrand.getrandbits\nchoice=_sysrand.choice\n\ndef randbelow(exclusive_upper_bound):\n ''\n if exclusive_upper_bound <=0:\n  raise ValueError(\"Upper bound must be positive.\")\n return _sysrand._randbelow(exclusive_upper_bound)\n \nDEFAULT_ENTROPY=32\n\ndef token_bytes(nbytes=None):\n ''\n\n\n\n\n\n\n\n \n if nbytes is None:\n  nbytes=DEFAULT_ENTROPY\n return _sysrand.randbytes(nbytes)\n \ndef token_hex(nbytes=None):\n ''\n\n\n\n\n\n\n\n\n \n return token_bytes(nbytes).hex()\n \ndef token_urlsafe(nbytes=None):\n ''\n\n\n\n\n\n\n\n \n tok=token_bytes(nbytes)\n return base64.urlsafe_b64encode(tok).rstrip(b'=').decode('ascii')\n", ["base64", "hmac", "random"]], "string": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n__all__=[\"ascii_letters\",\"ascii_lowercase\",\"ascii_uppercase\",\"capwords\",\n\"digits\",\"hexdigits\",\"octdigits\",\"printable\",\"punctuation\",\n\"whitespace\",\"Formatter\",\"Template\"]\n\nimport _string\n\n\nwhitespace=' \\t\\n\\r\\v\\f'\nascii_lowercase='abcdefghijklmnopqrstuvwxyz'\nascii_uppercase='ABCDEFGHIJKLMNOPQRSTUVWXYZ'\nascii_letters=ascii_lowercase+ascii_uppercase\ndigits='0123456789'\nhexdigits=digits+'abcdef'+'ABCDEF'\noctdigits='01234567'\npunctuation=r\"\"\"!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~\"\"\"\nprintable=digits+ascii_letters+punctuation+whitespace\n\n\n\n\ndef capwords(s,sep=None):\n ''\n\n\n\n\n\n\n\n\n \n return(sep or ' ').join(map(str.capitalize,s.split(sep)))\n \n \n \nimport re as _re\nfrom collections import ChainMap as _ChainMap\n\n_sentinel_dict={}\n\nclass Template:\n ''\n \n delimiter='$'\n \n \n \n \n idpattern=r'(?a:[_a-z][_a-z0-9]*)'\n braceidpattern=None\n flags=_re.IGNORECASE\n \n def __init_subclass__(cls):\n  super().__init_subclass__()\n  if 'pattern'in cls.__dict__:\n   pattern=cls.pattern\n  else:\n   delim=_re.escape(cls.delimiter)\n   id=cls.idpattern\n   bid=cls.braceidpattern or cls.idpattern\n   pattern=fr\"\"\"\n            {delim}(?:\n              (?P<escaped>{delim})  |   # Escape sequence of two delimiters\n              (?P<named>{id})       |   # delimiter and a Python identifier\n              {{(?P<braced>{bid})}} |   # delimiter and a braced identifier\n              (?P<invalid>)             # Other ill-formed delimiter exprs\n            )\n            \"\"\"\n  cls.pattern=_re.compile(pattern,cls.flags |_re.VERBOSE)\n  \n def __init__(self,template):\n  self.template=template\n  \n  \n  \n def _invalid(self,mo):\n  i=mo.start('invalid')\n  lines=self.template[:i].splitlines(keepends=True)\n  if not lines:\n   colno=1\n   lineno=1\n  else:\n   colno=i -len(''.join(lines[:-1]))\n   lineno=len(lines)\n  raise ValueError('Invalid placeholder in string: line %d, col %d'%\n  (lineno,colno))\n  \n def substitute(self,mapping=_sentinel_dict,/,**kws):\n  if mapping is _sentinel_dict:\n   mapping=kws\n  elif kws:\n   mapping=_ChainMap(kws,mapping)\n   \n  def convert(mo):\n  \n   named=mo.group('named')or mo.group('braced')\n   if named is not None:\n    return str(mapping[named])\n   if mo.group('escaped')is not None:\n    return self.delimiter\n   if mo.group('invalid')is not None:\n    self._invalid(mo)\n   raise ValueError('Unrecognized named group in pattern',\n   self.pattern)\n  return self.pattern.sub(convert,self.template)\n  \n def safe_substitute(self,mapping=_sentinel_dict,/,**kws):\n  if mapping is _sentinel_dict:\n   mapping=kws\n  elif kws:\n   mapping=_ChainMap(kws,mapping)\n   \n  def convert(mo):\n   named=mo.group('named')or mo.group('braced')\n   if named is not None:\n    try:\n     return str(mapping[named])\n    except KeyError:\n     return mo.group()\n   if mo.group('escaped')is not None:\n    return self.delimiter\n   if mo.group('invalid')is not None:\n    return mo.group()\n   raise ValueError('Unrecognized named group in pattern',\n   self.pattern)\n  return self.pattern.sub(convert,self.template)\n  \n def is_valid(self):\n  for mo in self.pattern.finditer(self.template):\n   if mo.group('invalid')is not None:\n    return False\n   if(mo.group('named')is None\n   and mo.group('braced')is None\n   and mo.group('escaped')is None):\n   \n   \n    raise ValueError('Unrecognized named group in pattern',\n    self.pattern)\n  return True\n  \n def get_identifiers(self):\n  ids=[]\n  for mo in self.pattern.finditer(self.template):\n   named=mo.group('named')or mo.group('braced')\n   if named is not None and named not in ids:\n   \n    ids.append(named)\n   elif(named is None\n   and mo.group('invalid')is None\n   and mo.group('escaped')is None):\n   \n   \n    raise ValueError('Unrecognized named group in pattern',\n    self.pattern)\n  return ids\n  \n  \n  \nTemplate.__init_subclass__()\n\n\n\n\n\n\n\n\n\n\n\n\nclass Formatter:\n def format(self,format_string,/,*args,**kwargs):\n  return self.vformat(format_string,args,kwargs)\n  \n def vformat(self,format_string,args,kwargs):\n  used_args=set()\n  result,_=self._vformat(format_string,args,kwargs,used_args,2)\n  self.check_unused_args(used_args,args,kwargs)\n  return result\n  \n def _vformat(self,format_string,args,kwargs,used_args,recursion_depth,\n auto_arg_index=0):\n  if recursion_depth <0:\n   raise ValueError('Max string recursion exceeded')\n  result=[]\n  for literal_text,field_name,format_spec,conversion in\\\n  self.parse(format_string):\n  \n  \n   if literal_text:\n    result.append(literal_text)\n    \n    \n   if field_name is not None:\n   \n   \n   \n   \n    if field_name =='':\n     if auto_arg_index is False:\n      raise ValueError('cannot switch from manual field '\n      'specification to automatic field '\n      'numbering')\n     field_name=str(auto_arg_index)\n     auto_arg_index +=1\n    elif field_name.isdigit():\n     if auto_arg_index:\n      raise ValueError('cannot switch from manual field '\n      'specification to automatic field '\n      'numbering')\n      \n      \n     auto_arg_index=False\n     \n     \n     \n    obj,arg_used=self.get_field(field_name,args,kwargs)\n    used_args.add(arg_used)\n    \n    \n    obj=self.convert_field(obj,conversion)\n    \n    \n    format_spec,auto_arg_index=self._vformat(\n    format_spec,args,kwargs,\n    used_args,recursion_depth -1,\n    auto_arg_index=auto_arg_index)\n    \n    \n    result.append(self.format_field(obj,format_spec))\n    \n  return ''.join(result),auto_arg_index\n  \n  \n def get_value(self,key,args,kwargs):\n  if isinstance(key,int):\n   return args[key]\n  else:\n   return kwargs[key]\n   \n   \n def check_unused_args(self,used_args,args,kwargs):\n  pass\n  \n  \n def format_field(self,value,format_spec):\n  return format(value,format_spec)\n  \n  \n def convert_field(self,value,conversion):\n \n  if conversion is None:\n   return value\n  elif conversion =='s':\n   return str(value)\n  elif conversion =='r':\n   return repr(value)\n  elif conversion =='a':\n   return ascii(value)\n  raise ValueError(\"Unknown conversion specifier {0!s}\".format(conversion))\n  \n  \n  \n  \n  \n  \n  \n  \n  \n def parse(self,format_string):\n  return _string.formatter_parser(format_string)\n  \n  \n  \n  \n  \n  \n  \n def get_field(self,field_name,args,kwargs):\n  first,rest=_string.formatter_field_name_split(field_name)\n  \n  obj=self.get_value(first,args,kwargs)\n  \n  \n  \n  for is_attr,i in rest:\n   if is_attr:\n    obj=getattr(obj,i)\n   else:\n    obj=obj[i]\n    \n  return obj,first\n", ["_string", "collections", "re"]], "struct": [".py", "__all__=[\n\n'calcsize','pack','pack_into','unpack','unpack_from',\n'iter_unpack',\n\n\n'Struct',\n\n\n'error'\n]\n\nfrom _struct import *\nfrom _struct import _clearcache\nfrom _struct import __doc__\n", ["_struct"]], "sys": [".py", "\nfrom _sys import *\nimport _sys\n\n_getframe=_sys._getframe\n\nclass _dataclass(tuple):\n\n def __init__(self,**kwargs):\n  self.keys=list(kwargs)\n  self.__dict__.update(kwargs)\n  \n def __getitem__(self,key):\n  if isinstance(key,int)and 0 <=key <=len(self.keys):\n   return self.__dict__[self.keys[key]]\n  elif isinstance(key,slice):\n   return[self.__dict__[k]for k in self.keys[key]]\n  raise KeyError(key)\n  \n def __iter__(self):\n  return(self.__dict__[key]for key in self.keys)\n  \n def __len__(self):\n  return len(self.keys)\n  \n def __repr__(self):\n  s=', '.join(f'{k}={self.__dict__[k]!r}'for k in self.keys)\n  return f'sys.{self.__class__.__name__}({s})'\n  \n  \ndef make_dataclass(name,bases=None):\n bases=[_dataclass]if bases is None else[*bases,_dataclass]\n cls=type(name,bases,{})\n return cls\n \n \n__breakpointhook__=breakpointhook\n\nabiflags=0\n\ndef audit(event,*args):\n ''\n pass\n \nbrython_debug_mode=__BRYTHON__.get_option('debug')\n\nbase_exec_prefix=__BRYTHON__.brython_path\n\nbase_prefix=__BRYTHON__.brython_path\n\nbuiltin_module_names=__BRYTHON__.builtin_module_names\n\nbyteorder='little'\n\ncopyright=\"\"\"Copyright (c) 2001-2023 Python Software Foundation.\nAll Rights Reserved.\n\nCopyright (c) 2000 BeOpen.com.\nAll Rights Reserved.\n\nCopyright (c) 1995-2001 Corporation for National Research Initiatives.\nAll Rights Reserved.\n\nCopyright (c) 1991-1995 Stichting Mathematisch Centrum, Amsterdam.\nAll Rights Reserved.\"\"\"\n\ndont_write_bytecode=True\n\nexec_prefix=__BRYTHON__.brython_path\n\nargv=orig_argv=[__BRYTHON__.script_path]+list(__BRYTHON__.get_option('args'))\n\ndef displayhook(value):\n if value is not None:\n  stdout.write(repr(value))\n  \n__displayhook__=displayhook\n\ndef exit(i=None):\n raise SystemExit('')\n \nflags=make_dataclass('flags')(\ndebug=0,\ninspect=0,\ninteractive=0,\noptimize=0,\ndont_write_bytecode=0,\nno_user_site=0,\nno_site=0,\nignore_environment=0,\nverbose=0,\nbytes_warning=0,\nquiet=0,\nhash_randomization=1,\nisolated=0,\ndev_mode=False,\nutf8_mode=0,\nwarn_default_encoding=0\n)\n\ndef getfilesystemencoding(*args,**kw):\n ''\n\n \n return 'utf-8'\n \ndef getfilesystemencodeerrors():\n return \"utf-8\"\n \ndef intern(string):\n return string\n \nint_info=make_dataclass('int_info')(\nbits_per_digit=30,\nsizeof_digit=4,\ndefault_max_str_digits=__BRYTHON__.int_max_str_digits,\nstr_digits_check_threshold=__BRYTHON__.str_digits_check_threshold)\n\ndef get_int_max_str_digits():\n return __BRYTHON__.int_max_str_digits\n \ndef set_int_max_str_digits(value):\n try:\n  value=int(value)\n except:\n  raise ValueError(f\"'{value.__class__.__name__}' object \"\n  \"cannot be interpreted as an integer\")\n if value !=0 and value <int_info.str_digits_check_threshold:\n  raise ValueError('maxdigits must be 0 or larger than 640')\n __BRYTHON__.int_max_str_digits=value\n \n \nmaxsize=__BRYTHON__.max_array_size\n\nmaxunicode=1114111\n\nplatform=\"brython\"\n\nplatlibdir=__BRYTHON__.brython_path+'Lib'\n\nprefix=__BRYTHON__.brython_path\n\npycache_prefix=None\n\nstdlib_module_names=frozenset(__BRYTHON__.stdlib_module_names)\n\ndef unraisablehook(unraisable,/):\n pass\n \n__unraisablehook__=unraisablehook\n\nversion='.'.join(str(x)for x in __BRYTHON__.version_info[:3])\nversion +=\" (default, %s) \\n[Javascript 1.5] on Brython\"\\\n%__BRYTHON__.compiled_date\n\nclass _comparable:\n\n def __eq__(self,other):\n  if isinstance(other,tuple):\n   return(self.major,self.minor,self.micro)==other\n   \n  return NotImplemented\n  \n def __ge__(self,other):\n  if isinstance(other,tuple):\n   return(self.major,self.minor,self.micro)>=other\n   \n  return NotImplemented\n  \n def __gt__(self,other):\n  if isinstance(other,tuple):\n   return(self.major,self.minor,self.micro)>other\n   \n  return NotImplemented\n  \n def __le__(self,other):\n  if isinstance(other,tuple):\n   return(self.major,self.minor,self.micro)<=other\n   \n  return NotImplemented\n  \n def __lt__(self,other):\n  if isinstance(other,tuple):\n   return(self.major,self.minor,self.micro)<other\n   \n  return NotImplemented\n  \n def __ne__(self,other):\n  if isinstance(other,tuple):\n   return(self.major,self.minor,self.micro)!=other\n   \n  return NotImplemented\n  \n  \nversion_info=make_dataclass('version_info',[_comparable])(\nmajor=__BRYTHON__.version_info[0],\nminor=__BRYTHON__.version_info[1],\nmicro=__BRYTHON__.version_info[2],\nreleaselevel=__BRYTHON__.version_info[3],\nserial=__BRYTHON__.version_info[4])\n\n\nclass SimpleNamespace:\n\n def __init__(self,/,**kwargs):\n  self.keys=list(kwargs)\n  self.__dict__.update(kwargs)\n  \n def __getitem__(self,key):\n  if isinstance(key,int)and 0 <=key <=len(self.keys):\n   return getattr(self,self.keys[key])\n  raise KeyError(key)\n  \n def __iter__(self):\n  return iter(self.__dict__.values())\n  \n def __repr__(self):\n  items=(f\"{k}={v !r}\"for k,v in self.__dict__.items()\n  if k in self.keys)\n  return f\"namespace({', '.join(items)})\"\n  \n def __eq__(self,other):\n  if isinstance(self,SimpleNamespace)and isinstance(other,SimpleNamespace):\n   return self.__dict__ ==other.__dict__\n  return NotImplemented\n  \n  \nSimpleNamespace.__module__=\"types\"\n\nhexversion=((__BRYTHON__.version_info[0]<<24)+\n(__BRYTHON__.version_info[1]<<16)+\n(__BRYTHON__.version_info[2]<<8))\n\n_implementation_info=make_dataclass('version_info',[_comparable])(\nmajor=__BRYTHON__.implementation[0],\nminor=__BRYTHON__.implementation[1],\nmicro=__BRYTHON__.implementation[2],\nreleaselevel=__BRYTHON__.implementation[3],\nserial=__BRYTHON__.implementation[4])\n\nimplementation=SimpleNamespace(\nname='Brython',\ncache_tag=None,\nversion=_implementation_info,\nhexversion=hexversion\n)\n\nhash_info=make_dataclass('hash_info')(\nwidth=32,\nmodulus=2147483647,\ninf=314159,\nnan=0,\nimag=1000003,\nalgorithm='siphash24',\nhash_bits=64,\nseed_bits=128,\ncutoff=0\n)\n\nfloat_info=make_dataclass('float_info')(\ndig=15,\nepsilon=2 **-52,\nmant_dig=53,\nmax=__BRYTHON__.MAX_VALUE,\nmax_exp=2 **10,\nmax_10_exp=308,\nmin=__BRYTHON__.MIN_VALUE,\nmin_exp=-1021,\nmin_10_exp=-307,\nradix=2,\nrounds=1\n)\n\nwarnoptions=[]\n\ndef getfilesystemencoding():\n return 'utf-8'\n \n \n__stdout__=stdout\n__stderr__=stderr\n__stdin__=stdin\n\n__excepthook__=excepthook\n", ["_sys"]], "time": [".py", "from browser import self as window\nimport _locale\nimport javascript\n\n\ndate=javascript.Date.new\nnow=javascript.Date.now\n\n\n\n\n\n\n\n_STRUCT_TM_ITEMS=9\n\n\n\n\n\ndef _get_day_of_year(arg):\n ''\n\n\n\n\n\n\n\n\n\n \n ml=[31,28,31,30,31,30,31,31,30,31,30,31]\n if arg[0]%4 ==0:\n  ml[1]+=1\n i=1\n yday=0\n while i <arg[1]:\n  yday +=ml[i -1]\n  i +=1\n yday +=arg[2]\n return yday\n \ndef _get_week_of_year(arg):\n ''\n\n\n\n\n\n\n\n\n\n\n \n d1=date(arg[0],arg[1]-1,arg[2])\n d0=date(arg[0],0,1)\n firstday=d0.getDay()\n if firstday ==0:\n  firstday=7\n firstweek=8 -firstday\n doy=arg[7]\n if firstday !=1:\n  doy=doy -firstweek\n if doy %7 ==0:\n  week_number=doy //7\n else:\n  week_number=doy //7+1\n return week_number\n \ndef _check_struct_time(t):\n mm=t[1]\n if mm ==0:\n  mm=1\n if -1 >mm >13:\n  raise ValueError(\"month out of range\")\n  \n dd=t[2]\n if dd ==0:dd=1\n if -1 >dd >32:\n  raise ValueError(\"day of month out of range\")\n  \n hh=t[3]\n if -1 >hh >24:\n  raise ValueError(\"hour out of range\")\n  \n minu=t[4]\n if -1 >minu >60:\n  raise ValueError(\"minute out of range\")\n  \n ss=t[5]\n if -1 >ss >62:\n  raise ValueError(\"seconds out of range\")\n  \n wd=t[6]%7\n if wd <-2:\n  raise ValueError(\"day of week out of range\")\n  \n dy=t[7]\n if dy ==0:dy=1\n if -1 >dy >367:\n  raise ValueError(\"day of year out of range\")\n  \n return t[0],mm,dd,hh,minu,ss,wd,dy,t[-1]\n \n \ndef _is_dst(secs=None):\n ''\n d=date()\n if secs is not None:\n  d=date(secs *1000)\n  \n  \n  \n jan=date(d.getFullYear(),0,1)\n jul=date(d.getFullYear(),6,1)\n dst=int(d.getTimezoneOffset()<max(abs(jan.getTimezoneOffset()),\n abs(jul.getTimezoneOffset())))\n return dst\n \ndef _get_tzname():\n ''\n d=date()\n d=d.toTimeString()\n try:\n  d=d.split('(')[1].split(')')[0]\n  return(d,'NotAvailable')\n except:\n  return('','')\n  \ndef _set_altzone():\n d=date()\n jan=date(d.getFullYear(),0,1)\n jul=date(d.getFullYear(),6,1)\n result=timezone -(jan.getTimezoneOffset()-jul.getTimezoneOffset())*60\n return result\n \ndef _check_input(t):\n if t and isinstance(t,struct_time)and len(t.args)==9:\n  t=t.args\n elif t and isinstance(t,tuple)and len(t)==9:\n  t=t\n elif t and isinstance(t,struct_time)and len(t.args)!=9:\n  raise TypeError(\"function takes exactly 9 arguments ({} given)\".format(len(t.args)))\n elif t and isinstance(t,tuple)and len(t)!=9:\n  raise TypeError(\"function takes exactly 9 arguments ({} given)\".format(len(t)))\n elif t and not isinstance(t,(tuple,struct_time)):\n  raise TypeError(\"Tuple or struct_time argument required\")\n else:\n  t=localtime().args\n return t\n \n \n \n \n \ndaylight=_is_dst()\ntimezone=date().getTimezoneOffset()*60\ntzname=_get_tzname()\naltzone=_set_altzone()if daylight else timezone\n\n\ndef asctime(t=None):\n weekdays={i:day for(i,day)in\n enumerate(\"Mon Tue Wed Thu Fri Sat Sun\".split())\n }\n \n months={i+1:month for(i,month)in\n enumerate(\"Jan Fev Mar Apr May Jun Jul Aug Sep Oct Nov Dec\".split())\n }\n \n t=_check_input(t)\n t=_check_struct_time(t)\n \n result=\"%s %s %2d %02d:%02d:%02d %d\"%(\n weekdays[t[6]],months[t[1]],t[2],t[3],t[4],t[5],t[0])\n return result\n \ndef ctime(timestamp=None):\n return asctime(localtime(timestamp))\n \ndef gmtime(secs=None):\n d=date()\n if secs is not None:\n  d=date(secs *1000)\n wday=d.getUTCDay()-1 if d.getUTCDay()-1 >=0 else 6\n tmp=struct_time([d.getUTCFullYear(),\n d.getUTCMonth()+1,d.getUTCDate(),\n d.getUTCHours(),d.getUTCMinutes(),d.getUTCSeconds(),\n wday,0,0])\n tmp.args[7]=_get_day_of_year(tmp.args)\n return tmp\n \ndef localtime(secs=None):\n d=date()\n if secs is not None:\n  d=date(secs *1000)\n dst=_is_dst(secs)\n wday=d.getDay()-1 if d.getDay()-1 >=0 else 6\n tmp=struct_time([d.getFullYear(),\n d.getMonth()+1,d.getDate(),\n d.getHours(),d.getMinutes(),d.getSeconds(),\n wday,0,dst])\n tmp.args[7]=_get_day_of_year(tmp.args)\n return tmp\n \ndef mktime(t):\n if isinstance(t,struct_time):\n  d1=date(t.tm_year,t.tm_mon -1,t.tm_mday,\n  t.tm_hour,t.tm_min,t.tm_sec,0).getTime()\n elif isinstance(t,tuple):\n  d1=date(t[0],t[1]-1,t[2],t[3],t[4],t[5],0).getTime()\n else:\n  raise ValueError(\"Tuple or struct_time argument required\")\n d2=date(0).getTime()\n return(d1 -d2)/1000.\n \ndef monotonic():\n return now()/1000.\n \ndef perf_counter():\n return window.performance.now()/1000.\n \ndef process_time():\n return now()/1000.\n \ndef time():\n return float(date().getTime()/1000)\n \ndef time_ns():\n try:\n  return window.Temporal.Now.instant().fromEpochNanoseconds()\n except:\n  return date().getTime()*1_000_000\n  \ndef sleep(secs):\n ''\n\n \n \n float(secs)\n raise NotImplementedError(\"Blocking functions like time.sleep() are not \"\n \"supported in the browser. Use functions in module browser.timer \"\n \"instead.\")\n \ndef strftime(_format,t=None):\n def ns(t,nb):\n \n  res=str(t)\n  while len(res)<nb:\n   res='0'+res\n  return res\n  \n t=_check_input(t)\n t=_check_struct_time(t)\n \n YY=ns(t[0],4)\n yy=ns(t[0],4)[2:]\n mm=ns(t[1],2)\n dd=ns(t[2],2)\n HH=t[3]\n HH24=ns(HH,2)\n HH12=ns(HH %12,2)\n if HH12 ==0:\n  HH12=12\n AMPM='AM'if 0 <=HH <12 else 'PM'\n MM=ns(t[4],2)\n SS=ns(t[5],2)\n DoY=ns(t[7],3)\n w=t[6]+1 if t[6]<6 else 0\n W=ns(_get_week_of_year(t),2)\n \n abb_weekdays=['Sun','Mon','Tue','Wed','Thu','Fri','Sat']\n full_weekdays=['Sunday','Monday','Tuesday','Wednesday',\n 'Thursday','Friday','Saturday']\n abb_months=['Jan','Feb','Mar','Apr','May','Jun',\n 'Jul','Aug','Sep','Oct','Nov','Dec']\n full_months=['January','February','March','April','May','June',\n 'July','August','September','October','November','December']\n \n res=_format\n if __BRYTHON__.locale ==\"C\":\n  res=res.replace(\"%c\",abb_weekdays[w]+' '+abb_months[int(mm)-1]+\n  ' '+dd+' '+HH24+':'+MM+':'+SS+' '+YY)\n  res=res.replace(\"%x\",mm+'/'+dd+'/'+yy)\n  res=res.replace(\"%X\",HH24+':'+MM+':'+SS)\n else:\n  formatter=_locale._date_format\n  c_format=formatter(\"x\")+\" \"+formatter(\"X\")\n  res=res.replace(\"%c\",c_format)\n  x_format=formatter(\"x\")\n  res=res.replace(\"%x\",x_format)\n  X_format=formatter(\"X\")\n  res=res.replace(\"%X\",X_format)\n  \n res=res.replace(\"%H\",HH24)\n res=res.replace(\"%I\",HH12)\n res=res.replace(\"%i\",HH12.lstrip(\"0\"))\n res=res.replace(\"%p\",AMPM)\n res=res.replace(\"%M\",MM)\n res=res.replace(\"%S\",SS)\n res=res.replace(\"%Y\",YY)\n res=res.replace(\"%y\",yy)\n res=res.replace(\"%m\",mm)\n res=res.replace(\"%d\",dd)\n res=res.replace(\"%a\",abb_weekdays[w])\n res=res.replace(\"%A\",full_weekdays[w])\n res=res.replace(\"%b\",abb_months[int(mm)-1])\n res=res.replace(\"%B\",full_months[int(mm)-1])\n res=res.replace(\"%j\",DoY)\n res=res.replace(\"%w\",str(w))\n res=res.replace(\"%W\",W)\n res=res.replace(\"%%\",'%')\n \n return res\n \nclass struct_time:\n\n def __init__(self,*args,**kw):\n \n  time_tuple=args[0]\n  if len(time_tuple)!=9:\n   raise TypeError(\"time.struct_time() takes a 9-sequence (%s-sequence given)\"%len(time_tuple))\n   \n  self.args=time_tuple\n  \n @property\n def tm_year(self):\n  return self.args[0]\n  \n @property\n def tm_mon(self):\n  return self.args[1]\n  \n @property\n def tm_mday(self):\n  return self.args[2]\n  \n @property\n def tm_hour(self):\n  return self.args[3]\n  \n @property\n def tm_min(self):\n  return self.args[4]\n  \n @property\n def tm_sec(self):\n  return self.args[5]\n  \n @property\n def tm_wday(self):\n  return self.args[6]\n  \n @property\n def tm_yday(self):\n  return self.args[7]\n  \n @property\n def tm_isdst(self):\n  return self.args[8]\n  \n @property\n def tm_gmtoff(self):\n  return -date().getTimezoneOffset()*60\n  \n @property\n def tm_zone(self):\n  return __BRYTHON__.tz_name\n  \n def __eq__(self,other):\n  return self.args ==other.args\n  \n def __getitem__(self,i):\n  return self.args[i]\n  \n def __iter__(self):\n  return iter(self.args)\n  \n def __reduce_ex__(self,protocol):\n  return(struct_time,(self.args,{}))\n  \n def __repr__(self):\n  return(\"time.structime(tm_year={}, tm_mon={}, tm_day={}, \"+\\\n  \"tm_hour={}, tm_min={}, tm_sec={}, tm_wday={}, \"+\\\n  \"tm_yday={}, tm_isdst={})\").format(*self.args)\n  \n def __str__(self):\n  return self.__repr__()\n  \ndef to_struct_time(*arg):\n arg=list(arg)\n \n \n del arg[-2:]\n \n from browser import window\n d=window.Date.new(arg[0],arg[1]-1,arg[2])\n weekday=(d.getDay()+6)%7\n arg.append(weekday)\n \n ml=[31,28,31,30,31,30,31,31,30,31,30,31]\n if arg[0]%4 ==0:\n  ml[1]+=1\n  \n i=1\n yday=0\n while i <arg[1]:\n  yday +=ml[i -1]\n  i +=1\n yday +=arg[2]\n arg.append(yday)\n arg.append(-1)\n return struct_time(tuple(arg))\n \ndef wait(secs):\n\n pass\n \ndef strptime(string,_format):\n import _strptime\n return _strptime._strptime_datetime(to_struct_time,string,_format)\n \n \n \n_clock_msg=\"\"\"Browser cannot access CPU. See '%s'\"\"\"\ndef _clock_xx(url):\n raise NotImplementedError(_clock_msg %url)\nclock=time\nclock_getres=lambda:_clock_xx(\"https://docs.python.org/3/library/time.html#time.clock_getres\")\nclock_gettime=lambda:_clock_xx(\"https://docs.python.org/3/library/time.html#time.clock_gettime\")\nclock_settime=lambda:_clock_xx(\"https://docs.python.org/3/library/time.html#time.clock_settime\")\nCLOCK_HIGHRES=_clock_msg %\"https://docs.python.org/3/library/time.html#time.CLOCK_HIGHRES\"\nCLOCK_MONOTONIC=_clock_msg %\"https://docs.python.org/3/library/time.html#time.CLOCK_MONOTONIC\"\nCLOCK_MONOTONIC_RAW=_clock_msg %\"https://docs.python.org/3/library/time.html#time.CLOCK_MONOTONIC_RAW\"\nCLOCK_PROCESS_CPUTIME_ID=_clock_msg %\"https://docs.python.org/3/library/time.html#time.CLOCK_PROCESS_CPUTIME_ID\"\nCLOCK_REALTIME=_clock_msg %\"https://docs.python.org/3/library/time.html#time.CLOCK_REALTIME\"\nCLOCK_THREAD_CPUTIME_ID=_clock_msg %\"https://docs.python.org/3/library/time.html#time.CLOCK_THREAD_CPUTIME_ID\"\n\nclass ClockInfo:\n\n def __init__(self,*kw):\n  for key,value in kw.items():\n   setattr(self,key,value)\n   \ndef get_clock_info(cl):\n\n if cl =='monotonic':\n  return ClockInfo(adjustable=False,\n  implementation='window.performance.now',\n  monotonic=True,\n  resolution=0.000001)\n elif cl =='perf_counter'or cl =='process_time':\n  return ClockInfo(adjustable=False,\n  implementation='date.getTime',\n  monotonic=False,\n  resolution=0.001)\n else:\n  _clock_xx(\"https://docs.python.org/3/library/time.html#time.get_clock_info\")\n  \ndef tzset():\n pass\n", ["_locale", "_strptime", "browser", "javascript"]], "timeit": [".py", "#! /usr/bin/env python3\n\n\"\"\"Tool for measuring execution time of small code snippets.\n\nThis module avoids a number of common traps for measuring execution\ntimes.  See also Tim Peters' introduction to the Algorithms chapter in\nthe Python Cookbook, published by O'Reilly.\n\nLibrary usage: see the Timer class.\n\nCommand line usage:\n    python timeit.py [-n N] [-r N] [-s S] [-p] [-h] [--] [statement]\n\nOptions:\n  -n/--number N: how many times to execute 'statement' (default: see below)\n  -r/--repeat N: how many times to repeat the timer (default 5)\n  -s/--setup S: statement to be executed once initially (default 'pass').\n                Execution time of this setup statement is NOT timed.\n  -p/--process: use time.process_time() (default is time.perf_counter())\n  -v/--verbose: print raw timing results; repeat for more digits precision\n  -u/--unit: set the output time unit (nsec, usec, msec, or sec)\n  -h/--help: print this usage message and exit\n  --: separate options from statement, use when statement starts with -\n  statement: statement to be timed (default 'pass')\n\nA multi-line statement may be given by specifying each line as a\nseparate argument; indented lines are possible by enclosing an\nargument in quotes and using leading spaces.  Multiple -s options are\ntreated similarly.\n\nIf -n is not given, a suitable number of loops is calculated by trying\nincreasing numbers from the sequence 1, 2, 5, 10, 20, 50, ... until the\ntotal time is at least 0.2 seconds.\n\nNote: there is a certain baseline overhead associated with executing a\npass statement.  It differs between versions.  The code here doesn't try\nto hide it, but you should be aware of it.  The baseline overhead can be\nmeasured by invoking the program without arguments.\n\nClasses:\n\n    Timer\n\nFunctions:\n\n    timeit(string, string) -> float\n    repeat(string, string) -> list\n    default_timer() -> float\n\n\"\"\"\n\nimport gc\nimport itertools\nimport sys\nimport time\n\n__all__=[\"Timer\",\"timeit\",\"repeat\",\"default_timer\"]\n\ndummy_src_name=\"<timeit-src>\"\ndefault_number=1000000\ndefault_repeat=5\ndefault_timer=time.perf_counter\n\n_globals=globals\n\n\n\n\ntemplate=\"\"\"\ndef inner(_it, _timer{init}):\n    {setup}\n    _t0 = _timer()\n    for _i in _it:\n        {stmt}\n        pass\n    _t1 = _timer()\n    return _t1 - _t0\n\"\"\"\n\n\ndef reindent(src,indent):\n ''\n return src.replace(\"\\n\",\"\\n\"+\" \"*indent)\n \n \nclass Timer:\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n def __init__(self,stmt=\"pass\",setup=\"pass\",timer=default_timer,\n globals=None):\n  ''\n  self.timer=timer\n  local_ns={}\n  global_ns=_globals()if globals is None else globals\n  init=''\n  if isinstance(setup,str):\n  \n   compile(setup,dummy_src_name,\"exec\")\n   stmtprefix=setup+'\\n'\n   setup=reindent(setup,4)\n  elif callable(setup):\n   local_ns['_setup']=setup\n   init +=', _setup=_setup'\n   stmtprefix=''\n   setup='_setup()'\n  else:\n   raise ValueError(\"setup is neither a string nor callable\")\n  if isinstance(stmt,str):\n  \n   compile(stmtprefix+stmt,dummy_src_name,\"exec\")\n   stmt=reindent(stmt,8)\n  elif callable(stmt):\n   local_ns['_stmt']=stmt\n   init +=', _stmt=_stmt'\n   stmt='_stmt()'\n  else:\n   raise ValueError(\"stmt is neither a string nor callable\")\n  src=template.format(stmt=stmt,setup=setup,init=init)\n  self.src=src\n  code=compile(src,dummy_src_name,\"exec\")\n  exec(code,global_ns,local_ns)\n  self.inner=local_ns[\"inner\"]\n  \n def print_exc(self,file=None):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  import linecache,traceback\n  if self.src is not None:\n   linecache.cache[dummy_src_name]=(len(self.src),\n   None,\n   self.src.split(\"\\n\"),\n   dummy_src_name)\n   \n   \n  traceback.print_exc(file=file)\n  \n def timeit(self,number=default_number):\n  ''\n\n\n\n\n\n\n\n  \n  it=itertools.repeat(None,number)\n  gcold=gc.isenabled()\n  gc.disable()\n  try:\n   timing=self.inner(it,self.timer)\n  finally:\n   if gcold:\n    gc.enable()\n  return timing\n  \n def repeat(self,repeat=default_repeat,number=default_number):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  r=[]\n  for i in range(repeat):\n   t=self.timeit(number)\n   r.append(t)\n  return r\n  \n def autorange(self,callback=None):\n  ''\n\n\n\n\n\n\n\n  \n  i=1\n  while True:\n   for j in 1,2,5:\n    number=i *j\n    time_taken=self.timeit(number)\n    if callback:\n     callback(number,time_taken)\n    if time_taken >=0.2:\n     return(number,time_taken)\n   i *=10\n   \n   \ndef timeit(stmt=\"pass\",setup=\"pass\",timer=default_timer,\nnumber=default_number,globals=None):\n ''\n return Timer(stmt,setup,timer,globals).timeit(number)\n \n \ndef repeat(stmt=\"pass\",setup=\"pass\",timer=default_timer,\nrepeat=default_repeat,number=default_number,globals=None):\n ''\n return Timer(stmt,setup,timer,globals).repeat(repeat,number)\n \n \ndef main(args=None,*,_wrap_timer=None):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n if args is None:\n  args=sys.argv[1:]\n import getopt\n try:\n  opts,args=getopt.getopt(args,\"n:u:s:r:pvh\",\n  [\"number=\",\"setup=\",\"repeat=\",\n  \"process\",\"verbose\",\"unit=\",\"help\"])\n except getopt.error as err:\n  print(err)\n  print(\"use -h/--help for command line help\")\n  return 2\n  \n timer=default_timer\n stmt=\"\\n\".join(args)or \"pass\"\n number=0\n setup=[]\n repeat=default_repeat\n verbose=0\n time_unit=None\n units={\"nsec\":1e-9,\"usec\":1e-6,\"msec\":1e-3,\"sec\":1.0}\n precision=3\n for o,a in opts:\n  if o in(\"-n\",\"--number\"):\n   number=int(a)\n  if o in(\"-s\",\"--setup\"):\n   setup.append(a)\n  if o in(\"-u\",\"--unit\"):\n   if a in units:\n    time_unit=a\n   else:\n    print(\"Unrecognized unit. Please select nsec, usec, msec, or sec.\",\n    file=sys.stderr)\n    return 2\n  if o in(\"-r\",\"--repeat\"):\n   repeat=int(a)\n   if repeat <=0:\n    repeat=1\n  if o in(\"-p\",\"--process\"):\n   timer=time.process_time\n  if o in(\"-v\",\"--verbose\"):\n   if verbose:\n    precision +=1\n   verbose +=1\n  if o in(\"-h\",\"--help\"):\n   print(__doc__,end=' ')\n   return 0\n setup=\"\\n\".join(setup)or \"pass\"\n \n \n \n \n import os\n sys.path.insert(0,os.curdir)\n if _wrap_timer is not None:\n  timer=_wrap_timer(timer)\n  \n t=Timer(stmt,setup,timer)\n if number ==0:\n \n  callback=None\n  if verbose:\n   def callback(number,time_taken):\n    msg=\"{num} loop{s} -> {secs:.{prec}g} secs\"\n    plural=(number !=1)\n    print(msg.format(num=number,s='s'if plural else '',\n    secs=time_taken,prec=precision))\n  try:\n   number,_=t.autorange(callback)\n  except:\n   t.print_exc()\n   return 1\n   \n  if verbose:\n   print()\n   \n try:\n  raw_timings=t.repeat(repeat,number)\n except:\n  t.print_exc()\n  return 1\n  \n def format_time(dt):\n  unit=time_unit\n  \n  if unit is not None:\n   scale=units[unit]\n  else:\n   scales=[(scale,unit)for unit,scale in units.items()]\n   scales.sort(reverse=True)\n   for scale,unit in scales:\n    if dt >=scale:\n     break\n     \n  return \"%.*g %s\"%(precision,dt /scale,unit)\n  \n if verbose:\n  print(\"raw times: %s\"%\", \".join(map(format_time,raw_timings)))\n  print()\n timings=[dt /number for dt in raw_timings]\n \n best=min(timings)\n print(\"%d loop%s, best of %d: %s per loop\"\n %(number,'s'if number !=1 else '',\n repeat,format_time(best)))\n \n best=min(timings)\n worst=max(timings)\n if worst >=best *4:\n  import warnings\n  warnings.warn_explicit(\"The test results are likely unreliable. \"\n  \"The worst time (%s) was more than four times \"\n  \"slower than the best time (%s).\"\n  %(format_time(worst),format_time(best)),\n  UserWarning,'',0)\n return None\n \n \nif __name__ ==\"__main__\":\n sys.exit(main())\n", ["gc", "getopt", "itertools", "linecache", "os", "sys", "time", "traceback", "warnings"]], "types": [".py", "''\n\n\n\nimport sys\n\n\n\n\n\n\ndef _f():pass\nFunctionType=type(_f)\nLambdaType=type(lambda:None)\nCodeType=type(_f.__code__)\nMappingProxyType=type(type.__dict__)\nSimpleNamespace=type(sys.implementation)\n\ndef _cell_factory():\n a=1\n def f():\n  nonlocal a\n return f.__closure__[0]\nCellType=type(_cell_factory())\n\ndef _g():\n yield 1\nGeneratorType=type(_g())\n\nasync def _c():pass\n_c=_c()\nCoroutineType=type(_c)\n_c.close()\n\nasync def _ag():\n yield\n_ag=_ag()\nAsyncGeneratorType=type(_ag)\n\nclass _C:\n def _m(self):pass\nMethodType=type(_C()._m)\n\nBuiltinFunctionType=type(len)\nBuiltinMethodType=type([].append)\n\nWrapperDescriptorType=type(object.__init__)\nMethodWrapperType=type(object().__str__)\nMethodDescriptorType=type(str.join)\nClassMethodDescriptorType=type(dict.__dict__['fromkeys'])\n\nModuleType=type(sys)\n\ntry:\n raise TypeError\nexcept TypeError as exc:\n TracebackType=type(exc.__traceback__)\n FrameType=type(exc.__traceback__.tb_frame)\n \nGetSetDescriptorType=type(FunctionType.__code__)\nMemberDescriptorType=type(FunctionType.__globals__)\n\ndel sys,_f,_g,_C,_c,_ag,_cell_factory\n\n\n\ndef new_class(name,bases=(),kwds=None,exec_body=None):\n ''\n resolved_bases=resolve_bases(bases)\n meta,ns,kwds=prepare_class(name,resolved_bases,kwds)\n if exec_body is not None:\n  exec_body(ns)\n if resolved_bases is not bases:\n  ns['__orig_bases__']=bases\n return meta(name,resolved_bases,ns,**kwds)\n \ndef resolve_bases(bases):\n ''\n new_bases=list(bases)\n updated=False\n shift=0\n for i,base in enumerate(bases):\n  if isinstance(base,type):\n   continue\n  if not hasattr(base,\"__mro_entries__\"):\n   continue\n  new_base=base.__mro_entries__(bases)\n  updated=True\n  if not isinstance(new_base,tuple):\n   raise TypeError(\"__mro_entries__ must return a tuple\")\n  else:\n   new_bases[i+shift:i+shift+1]=new_base\n   shift +=len(new_base)-1\n if not updated:\n  return bases\n return tuple(new_bases)\n \ndef prepare_class(name,bases=(),kwds=None):\n ''\n\n\n\n\n\n\n\n\n \n if kwds is None:\n  kwds={}\n else:\n  kwds=dict(kwds)\n if 'metaclass'in kwds:\n  meta=kwds.pop('metaclass')\n else:\n  if bases:\n   meta=type(bases[0])\n  else:\n   meta=type\n if isinstance(meta,type):\n \n \n  meta=_calculate_meta(meta,bases)\n if hasattr(meta,'__prepare__'):\n  ns=meta.__prepare__(name,bases,**kwds)\n else:\n  ns={}\n return meta,ns,kwds\n \ndef _calculate_meta(meta,bases):\n ''\n winner=meta\n for base in bases:\n  base_meta=type(base)\n  if issubclass(winner,base_meta):\n   continue\n  if issubclass(base_meta,winner):\n   winner=base_meta\n   continue\n   \n  raise TypeError(\"metaclass conflict: \"\n  \"the metaclass of a derived class \"\n  \"must be a (non-strict) subclass \"\n  \"of the metaclasses of all its bases\")\n return winner\n \n \ndef get_original_bases(cls,/):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n try:\n  return cls.__dict__.get(\"__orig_bases__\",cls.__bases__)\n except AttributeError:\n  raise TypeError(\n  f\"Expected an instance of type, not {type(cls).__name__ !r}\"\n  )from None\n  \n  \nclass DynamicClassAttribute:\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n def __init__(self,fget=None,fset=None,fdel=None,doc=None):\n  self.fget=fget\n  self.fset=fset\n  self.fdel=fdel\n  \n  self.__doc__=doc or fget.__doc__\n  self.overwrite_doc=doc is None\n  \n  self.__isabstractmethod__=bool(getattr(fget,'__isabstractmethod__',False))\n  \n def __get__(self,instance,ownerclass=None):\n  if instance is None:\n   if self.__isabstractmethod__:\n    return self\n   raise AttributeError()\n  elif self.fget is None:\n   raise AttributeError(\"unreadable attribute\")\n  return self.fget(instance)\n  \n def __set__(self,instance,value):\n  if self.fset is None:\n   raise AttributeError(\"can't set attribute\")\n  self.fset(instance,value)\n  \n def __delete__(self,instance):\n  if self.fdel is None:\n   raise AttributeError(\"can't delete attribute\")\n  self.fdel(instance)\n  \n def getter(self,fget):\n  fdoc=fget.__doc__ if self.overwrite_doc else None\n  result=type(self)(fget,self.fset,self.fdel,fdoc or self.__doc__)\n  result.overwrite_doc=self.overwrite_doc\n  return result\n  \n def setter(self,fset):\n  result=type(self)(self.fget,fset,self.fdel,self.__doc__)\n  result.overwrite_doc=self.overwrite_doc\n  return result\n  \n def deleter(self,fdel):\n  result=type(self)(self.fget,self.fset,fdel,self.__doc__)\n  result.overwrite_doc=self.overwrite_doc\n  return result\n  \n  \nclass _GeneratorWrapper:\n\n def __init__(self,gen):\n  self.__wrapped=gen\n  self.__isgen=gen.__class__ is GeneratorType\n  self.__name__=getattr(gen,'__name__',None)\n  self.__qualname__=getattr(gen,'__qualname__',None)\n def send(self,val):\n  return self.__wrapped.send(val)\n def throw(self,tp,*rest):\n  return self.__wrapped.throw(tp,*rest)\n def close(self):\n  return self.__wrapped.close()\n @property\n def gi_code(self):\n  return self.__wrapped.gi_code\n @property\n def gi_frame(self):\n  return self.__wrapped.gi_frame\n @property\n def gi_running(self):\n  return self.__wrapped.gi_running\n @property\n def gi_yieldfrom(self):\n  return self.__wrapped.gi_yieldfrom\n cr_code=gi_code\n cr_frame=gi_frame\n cr_running=gi_running\n cr_await=gi_yieldfrom\n def __next__(self):\n  return next(self.__wrapped)\n def __iter__(self):\n  if self.__isgen:\n   return self.__wrapped\n  return self\n __await__=__iter__\n \ndef coroutine(func):\n ''\n \n if not callable(func):\n  raise TypeError('types.coroutine() expects a callable')\n  \n if(func.__class__ is FunctionType and\n getattr(func,'__code__',None).__class__ is CodeType):\n \n  co_flags=func.__code__.co_flags\n  \n  \n  \n  if co_flags&0x180:\n   return func\n   \n   \n   \n  if co_flags&0x20:\n  \n   co=func.__code__\n   \n   func.__code__=co.replace(co_flags=co.co_flags |0x100)\n   return func\n   \n   \n   \n   \n   \n   \n import functools\n import _collections_abc\n @functools.wraps(func)\n def wrapped(*args,**kwargs):\n  coro=func(*args,**kwargs)\n  if(coro.__class__ is CoroutineType or\n  coro.__class__ is GeneratorType and coro.gi_code.co_flags&0x100):\n  \n   return coro\n  if(isinstance(coro,_collections_abc.Generator)and\n  not isinstance(coro,_collections_abc.Coroutine)):\n  \n  \n  \n   return _GeneratorWrapper(coro)\n   \n   \n  return coro\n  \n return wrapped\n \nGenericAlias=type(list[int])\nUnionType=type(int |str)\n\nEllipsisType=type(Ellipsis)\nNoneType=type(None)\nNotImplementedType=type(NotImplemented)\n\ndef __getattr__(name):\n if name =='CapsuleType':\n  import _socket\n  return type(_socket.CAPI)\n raise AttributeError(f\"module {__name__ !r} has no attribute {name !r}\")\n \n__all__=[n for n in globals()if n[:1]!='_']\n__all__ +=['CapsuleType']\n", ["_collections_abc", "_socket", "functools", "sys"]], "typing": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfrom abc import abstractmethod,ABCMeta\nimport collections\nfrom collections import defaultdict\nimport collections.abc\nimport copyreg\nimport functools\nimport operator\nimport sys\nimport types\nfrom types import WrapperDescriptorType,MethodWrapperType,MethodDescriptorType,GenericAlias\n\nfrom _typing import(\n_idfunc,\nTypeVar,\nParamSpec,\nTypeVarTuple,\nParamSpecArgs,\nParamSpecKwargs,\nTypeAliasType,\nGeneric,\nNoDefault,\n)\n\n\n__all__=[\n\n'Annotated',\n'Any',\n'Callable',\n'ClassVar',\n'Concatenate',\n'Final',\n'ForwardRef',\n'Generic',\n'Literal',\n'Optional',\n'ParamSpec',\n'Protocol',\n'Tuple',\n'Type',\n'TypeVar',\n'TypeVarTuple',\n'Union',\n\n\n'AbstractSet',\n'ByteString',\n'Container',\n'ContextManager',\n'Hashable',\n'ItemsView',\n'Iterable',\n'Iterator',\n'KeysView',\n'Mapping',\n'MappingView',\n'MutableMapping',\n'MutableSequence',\n'MutableSet',\n'Sequence',\n'Sized',\n'ValuesView',\n'Awaitable',\n'AsyncIterator',\n'AsyncIterable',\n'Coroutine',\n'Collection',\n'AsyncGenerator',\n'AsyncContextManager',\n\n\n'Reversible',\n'SupportsAbs',\n'SupportsBytes',\n'SupportsComplex',\n'SupportsFloat',\n'SupportsIndex',\n'SupportsInt',\n'SupportsRound',\n\n\n'ChainMap',\n'Counter',\n'Deque',\n'Dict',\n'DefaultDict',\n'List',\n'OrderedDict',\n'Set',\n'FrozenSet',\n'NamedTuple',\n'TypedDict',\n'Generator',\n\n\n'BinaryIO',\n'IO',\n'Match',\n'Pattern',\n'TextIO',\n\n\n'AnyStr',\n'assert_type',\n'assert_never',\n'cast',\n'clear_overloads',\n'dataclass_transform',\n'final',\n'get_args',\n'get_origin',\n'get_overloads',\n'get_protocol_members',\n'get_type_hints',\n'is_protocol',\n'is_typeddict',\n'LiteralString',\n'Never',\n'NewType',\n'no_type_check',\n'no_type_check_decorator',\n'NoDefault',\n'NoReturn',\n'NotRequired',\n'overload',\n'override',\n'ParamSpecArgs',\n'ParamSpecKwargs',\n'ReadOnly',\n'Required',\n'reveal_type',\n'runtime_checkable',\n'Self',\n'Text',\n'TYPE_CHECKING',\n'TypeAlias',\n'TypeGuard',\n'TypeIs',\n'TypeAliasType',\n'Unpack',\n]\n\n\ndef _type_convert(arg,module=None,*,allow_special_forms=False):\n ''\n if arg is None:\n  return type(None)\n if isinstance(arg,str):\n  return ForwardRef(arg,module=module,is_class=allow_special_forms)\n return arg\n \n \ndef _type_check(arg,msg,is_argument=True,module=None,*,allow_special_forms=False):\n ''\n\n\n\n\n\n\n\n\n\n \n invalid_generic_forms=(Generic,Protocol)\n if not allow_special_forms:\n  invalid_generic_forms +=(ClassVar,)\n  if is_argument:\n   invalid_generic_forms +=(Final,)\n   \n arg=_type_convert(arg,module=module,allow_special_forms=allow_special_forms)\n if(isinstance(arg,_GenericAlias)and\n arg.__origin__ in invalid_generic_forms):\n  raise TypeError(f\"{arg} is not valid as type argument\")\n if arg in(Any,LiteralString,NoReturn,Never,Self,TypeAlias):\n  return arg\n if allow_special_forms and arg in(ClassVar,Final):\n  return arg\n if isinstance(arg,_SpecialForm)or arg in(Generic,Protocol):\n  raise TypeError(f\"Plain {arg} is not valid as type argument\")\n if type(arg)is tuple:\n  raise TypeError(f\"{msg} Got {arg !r:.100}.\")\n return arg\n \n \ndef _is_param_expr(arg):\n return arg is ...or isinstance(arg,\n (tuple,list,ParamSpec,_ConcatenateGenericAlias))\n \n \ndef _should_unflatten_callable_args(typ,args):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n return(\n typ.__origin__ is collections.abc.Callable\n and not(len(args)==2 and _is_param_expr(args[0]))\n )\n \n \ndef _type_repr(obj):\n ''\n\n\n\n\n\n \n \n \n \n if isinstance(obj,type):\n  if obj.__module__ =='builtins':\n   return obj.__qualname__\n  return f'{obj.__module__}.{obj.__qualname__}'\n if obj is ...:\n  return '...'\n if isinstance(obj,types.FunctionType):\n  return obj.__name__\n if isinstance(obj,tuple):\n \n  return '['+', '.join(_type_repr(t)for t in obj)+']'\n return repr(obj)\n \n \ndef _collect_type_parameters(args,*,enforce_default_ordering:bool=True):\n ''\n\n\n\n\n\n\n\n\n \n \n default_encountered=False\n \n type_var_tuple_encountered=False\n parameters=[]\n for t in args:\n  if isinstance(t,type):\n  \n   pass\n  elif isinstance(t,tuple):\n  \n  \n   for x in t:\n    for collected in _collect_type_parameters([x]):\n     if collected not in parameters:\n      parameters.append(collected)\n  elif hasattr(t,'__typing_subst__'):\n   if t not in parameters:\n    if enforce_default_ordering:\n     if type_var_tuple_encountered and t.has_default():\n      raise TypeError('Type parameter with a default'\n      ' follows TypeVarTuple')\n      \n     if t.has_default():\n      default_encountered=True\n     elif default_encountered:\n      raise TypeError(f'Type parameter {t !r} without a default'\n      ' follows type parameter with a default')\n      \n    parameters.append(t)\n  else:\n   if _is_unpacked_typevartuple(t):\n    type_var_tuple_encountered=True\n   for x in getattr(t,'__parameters__',()):\n    if x not in parameters:\n     parameters.append(x)\n return tuple(parameters)\n \n \ndef _check_generic_specialization(cls,arguments):\n ''\n\n\n \n expected_len=len(cls.__parameters__)\n if not expected_len:\n  raise TypeError(f\"{cls} is not a generic class\")\n actual_len=len(arguments)\n if actual_len !=expected_len:\n \n  if actual_len <expected_len:\n  \n  \n  \n  \n  \n  \n  \n   if cls.__parameters__[actual_len].has_default():\n    return\n    \n   expected_len -=sum(p.has_default()for p in cls.__parameters__)\n   expect_val=f\"at least {expected_len}\"\n  else:\n   expect_val=expected_len\n   \n  raise TypeError(f\"Too {'many'if actual_len >expected_len else 'few'} arguments\"\n  f\" for {cls}; actual {actual_len}, expected {expect_val}\")\n  \n  \ndef _unpack_args(*args):\n newargs=[]\n for arg in args:\n  subargs=getattr(arg,'__typing_unpacked_tuple_args__',None)\n  if subargs is not None and not(subargs and subargs[-1]is ...):\n   newargs.extend(subargs)\n  else:\n   newargs.append(arg)\n return newargs\n \ndef _deduplicate(params,*,unhashable_fallback=False):\n\n try:\n  return dict.fromkeys(params)\n except TypeError:\n  if not unhashable_fallback:\n   raise\n   \n  return _deduplicate_unhashable(params)\n  \ndef _deduplicate_unhashable(unhashable_params):\n new_unhashable=[]\n for t in unhashable_params:\n  if t not in new_unhashable:\n   new_unhashable.append(t)\n return new_unhashable\n \ndef _compare_args_orderless(first_args,second_args):\n first_unhashable=_deduplicate_unhashable(first_args)\n second_unhashable=_deduplicate_unhashable(second_args)\n t=list(second_unhashable)\n try:\n  for elem in first_unhashable:\n   t.remove(elem)\n except ValueError:\n  return False\n return not t\n \ndef _remove_dups_flatten(parameters):\n ''\n\n\n \n \n params=[]\n for p in parameters:\n  if isinstance(p,(_UnionGenericAlias,types.UnionType)):\n   params.extend(p.__args__)\n  else:\n   params.append(p)\n   \n return tuple(_deduplicate(params,unhashable_fallback=True))\n \n \ndef _flatten_literal_params(parameters):\n ''\n params=[]\n for p in parameters:\n  if isinstance(p,_LiteralGenericAlias):\n   params.extend(p.__args__)\n  else:\n   params.append(p)\n return tuple(params)\n \n \n_cleanups=[]\n_caches={}\n\n\ndef _tp_cache(func=None,/,*,typed=False):\n ''\n\n\n \n def decorator(func):\n \n \n \n \n \n  cache=functools.lru_cache(typed=typed)(func)\n  _caches[func]=cache\n  _cleanups.append(cache.cache_clear)\n  del cache\n  \n  @functools.wraps(func)\n  def inner(*args,**kwds):\n   try:\n    return _caches[func](*args,**kwds)\n   except TypeError:\n    pass\n   return func(*args,**kwds)\n  return inner\n  \n if func is not None:\n  return decorator(func)\n  \n return decorator\n \n \ndef _deprecation_warning_for_no_type_params_passed(funcname:str)->None:\n import warnings\n \n depr_message=(\n f\"Failing to pass a value to the 'type_params' parameter \"\n f\"of {funcname !r} is deprecated, as it leads to incorrect behaviour \"\n f\"when calling {funcname} on a stringified annotation \"\n f\"that references a PEP 695 type parameter. \"\n f\"It will be disallowed in Python 3.15.\"\n )\n warnings.warn(depr_message,category=DeprecationWarning,stacklevel=3)\n \n \nclass _Sentinel:\n __slots__=()\n def __repr__(self):\n  return '<sentinel>'\n  \n  \n_sentinel=_Sentinel()\n\n\ndef _eval_type(t,globalns,localns,type_params=_sentinel,*,recursive_guard=frozenset()):\n ''\n\n\n\n\n \n if type_params is _sentinel:\n  _deprecation_warning_for_no_type_params_passed(\"typing._eval_type\")\n  type_params=()\n if isinstance(t,ForwardRef):\n  return t._evaluate(globalns,localns,type_params,recursive_guard=recursive_guard)\n if isinstance(t,(_GenericAlias,GenericAlias,types.UnionType)):\n  if isinstance(t,GenericAlias):\n   args=tuple(\n   ForwardRef(arg)if isinstance(arg,str)else arg\n   for arg in t.__args__\n   )\n   is_unpacked=t.__unpacked__\n   if _should_unflatten_callable_args(t,args):\n    t=t.__origin__[(args[:-1],args[-1])]\n   else:\n    t=t.__origin__[args]\n   if is_unpacked:\n    t=Unpack[t]\n    \n  ev_args=tuple(\n  _eval_type(\n  a,globalns,localns,type_params,recursive_guard=recursive_guard\n  )\n  for a in t.__args__\n  )\n  if ev_args ==t.__args__:\n   return t\n  if isinstance(t,GenericAlias):\n   return GenericAlias(t.__origin__,ev_args)\n  if isinstance(t,types.UnionType):\n   return functools.reduce(operator.or_,ev_args)\n  else:\n   return t.copy_with(ev_args)\n return t\n \n \nclass _Final:\n ''\n \n __slots__=('__weakref__',)\n \n def __init_subclass__(cls,/,*args,**kwds):\n  if '_root'not in kwds:\n   raise TypeError(\"Cannot subclass special typing classes\")\n   \n   \nclass _NotIterable:\n ''\n\n\n\n\n\n\n\n\n\n\n \n \n __slots__=()\n __iter__=None\n \n \n \n \nclass _SpecialForm(_Final,_NotIterable,_root=True):\n __slots__=('_name','__doc__','_getitem')\n \n def __init__(self,getitem):\n  self._getitem=getitem\n  self._name=getitem.__name__\n  self.__doc__=getitem.__doc__\n  \n def __getattr__(self,item):\n  if item in{'__name__','__qualname__'}:\n   return self._name\n   \n  raise AttributeError(item)\n  \n def __mro_entries__(self,bases):\n  raise TypeError(f\"Cannot subclass {self !r}\")\n  \n def __repr__(self):\n  return 'typing.'+self._name\n  \n def __reduce__(self):\n  return self._name\n  \n def __call__(self,*args,**kwds):\n  raise TypeError(f\"Cannot instantiate {self !r}\")\n  \n def __or__(self,other):\n  return Union[self,other]\n  \n def __ror__(self,other):\n  return Union[other,self]\n  \n def __instancecheck__(self,obj):\n  raise TypeError(f\"{self} cannot be used with isinstance()\")\n  \n def __subclasscheck__(self,cls):\n  raise TypeError(f\"{self} cannot be used with issubclass()\")\n  \n @_tp_cache\n def __getitem__(self,parameters):\n  return self._getitem(self,parameters)\n  \n  \nclass _TypedCacheSpecialForm(_SpecialForm,_root=True):\n def __getitem__(self,parameters):\n  if not isinstance(parameters,tuple):\n   parameters=(parameters,)\n  return self._getitem(self,*parameters)\n  \n  \nclass _AnyMeta(type):\n def __instancecheck__(self,obj):\n  if self is Any:\n   raise TypeError(\"typing.Any cannot be used with isinstance()\")\n  return super().__instancecheck__(obj)\n  \n def __repr__(self):\n  if self is Any:\n   return \"typing.Any\"\n  return super().__repr__()\n  \n  \nclass Any(metaclass=_AnyMeta):\n ''\n\n\n\n\n\n\n\n\n \n \n def __new__(cls,*args,**kwargs):\n  if cls is Any:\n   raise TypeError(\"Any cannot be instantiated\")\n  return super().__new__(cls)\n  \n  \n@_SpecialForm\ndef NoReturn(self,parameters):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n \n raise TypeError(f\"{self} is not subscriptable\")\n \n \n \n \n@_SpecialForm\ndef Never(self,parameters):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n raise TypeError(f\"{self} is not subscriptable\")\n \n \n@_SpecialForm\ndef Self(self,parameters):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n raise TypeError(f\"{self} is not subscriptable\")\n \n \n@_SpecialForm\ndef LiteralString(self,parameters):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n raise TypeError(f\"{self} is not subscriptable\")\n \n \n@_SpecialForm\ndef ClassVar(self,parameters):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n item=_type_check(parameters,f'{self} accepts only single type.',allow_special_forms=True)\n return _GenericAlias(self,(item,))\n \n@_SpecialForm\ndef Final(self,parameters):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n item=_type_check(parameters,f'{self} accepts only single type.',allow_special_forms=True)\n return _GenericAlias(self,(item,))\n \n@_SpecialForm\ndef Union(self,parameters):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n if parameters ==():\n  raise TypeError(\"Cannot take a Union of no types.\")\n if not isinstance(parameters,tuple):\n  parameters=(parameters,)\n msg=\"Union[arg, ...]: each arg must be a type.\"\n parameters=tuple(_type_check(p,msg)for p in parameters)\n parameters=_remove_dups_flatten(parameters)\n if len(parameters)==1:\n  return parameters[0]\n if len(parameters)==2 and type(None)in parameters:\n  return _UnionGenericAlias(self,parameters,name=\"Optional\")\n return _UnionGenericAlias(self,parameters)\n \ndef _make_union(left,right):\n ''\n\n\n\n\n \n return Union[left,right]\n \n@_SpecialForm\ndef Optional(self,parameters):\n ''\n arg=_type_check(parameters,f\"{self} requires a single type.\")\n return Union[arg,type(None)]\n \n@_TypedCacheSpecialForm\n@_tp_cache(typed=True)\ndef Literal(self,*parameters):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n parameters=_flatten_literal_params(parameters)\n \n try:\n  parameters=tuple(p for p,_ in _deduplicate(list(_value_and_type_iter(parameters))))\n except TypeError:\n  pass\n  \n return _LiteralGenericAlias(self,parameters)\n \n \n@_SpecialForm\ndef TypeAlias(self,parameters):\n ''\n\n\n\n\n\n\n\n\n\n\n \n raise TypeError(f\"{self} is not subscriptable\")\n \n \n@_SpecialForm\ndef Concatenate(self,parameters):\n ''\n\n\n\n\n\n\n\n\n\n\n \n if parameters ==():\n  raise TypeError(\"Cannot take a Concatenate of no types.\")\n if not isinstance(parameters,tuple):\n  parameters=(parameters,)\n if not(parameters[-1]is ...or isinstance(parameters[-1],ParamSpec)):\n  raise TypeError(\"The last parameter to Concatenate should be a \"\n  \"ParamSpec variable or ellipsis.\")\n msg=\"Concatenate[arg, ...]: each arg must be a type.\"\n parameters=(*(_type_check(p,msg)for p in parameters[:-1]),parameters[-1])\n return _ConcatenateGenericAlias(self,parameters)\n \n \n@_SpecialForm\ndef TypeGuard(self,parameters):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n item=_type_check(parameters,f'{self} accepts only single type.')\n return _GenericAlias(self,(item,))\n \n \n@_SpecialForm\ndef TypeIs(self,parameters):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n item=_type_check(parameters,f'{self} accepts only single type.')\n return _GenericAlias(self,(item,))\n \n \nclass ForwardRef(_Final,_root=True):\n ''\n \n __slots__=('__forward_arg__','__forward_code__',\n '__forward_evaluated__','__forward_value__',\n '__forward_is_argument__','__forward_is_class__',\n '__forward_module__')\n \n def __init__(self,arg,is_argument=True,module=None,*,is_class=False):\n  if not isinstance(arg,str):\n   raise TypeError(f\"Forward reference must be a string -- got {arg !r}\")\n   \n   \n   \n   \n  if arg.startswith('*'):\n   arg_to_compile=f'({arg},)[0]'\n  else:\n   arg_to_compile=arg\n  try:\n   code=compile(arg_to_compile,'<string>','eval')\n  except SyntaxError:\n   raise SyntaxError(f\"Forward reference must be an expression -- got {arg !r}\")\n   \n  self.__forward_arg__=arg\n  self.__forward_code__=code\n  self.__forward_evaluated__=False\n  self.__forward_value__=None\n  self.__forward_is_argument__=is_argument\n  self.__forward_is_class__=is_class\n  self.__forward_module__=module\n  \n def _evaluate(self,globalns,localns,type_params=_sentinel,*,recursive_guard):\n  if type_params is _sentinel:\n   _deprecation_warning_for_no_type_params_passed(\"typing.ForwardRef._evaluate\")\n   type_params=()\n  if self.__forward_arg__ in recursive_guard:\n   return self\n  if not self.__forward_evaluated__ or localns is not globalns:\n   if globalns is None and localns is None:\n    globalns=localns={}\n   elif globalns is None:\n    globalns=localns\n   elif localns is None:\n    localns=globalns\n   if self.__forward_module__ is not None:\n    globalns=getattr(\n    sys.modules.get(self.__forward_module__,None),'__dict__',globalns\n    )\n    \n    \n    \n    \n    \n    \n    \n    \n   if type_params:\n    globalns,localns=dict(globalns),dict(localns)\n    for param in type_params:\n     param_name=param.__name__\n     if not self.__forward_is_class__ or param_name not in globalns:\n      globalns[param_name]=param\n      localns.pop(param_name,None)\n      \n   type_=_type_check(\n   eval(self.__forward_code__,globalns,localns),\n   \"Forward references must evaluate to types.\",\n   is_argument=self.__forward_is_argument__,\n   allow_special_forms=self.__forward_is_class__,\n   )\n   self.__forward_value__=_eval_type(\n   type_,\n   globalns,\n   localns,\n   type_params,\n   recursive_guard=(recursive_guard |{self.__forward_arg__}),\n   )\n   self.__forward_evaluated__=True\n  return self.__forward_value__\n  \n def __eq__(self,other):\n  if not isinstance(other,ForwardRef):\n   return NotImplemented\n  if self.__forward_evaluated__ and other.__forward_evaluated__:\n   return(self.__forward_arg__ ==other.__forward_arg__ and\n   self.__forward_value__ ==other.__forward_value__)\n  return(self.__forward_arg__ ==other.__forward_arg__ and\n  self.__forward_module__ ==other.__forward_module__)\n  \n def __hash__(self):\n  return hash((self.__forward_arg__,self.__forward_module__))\n  \n def __or__(self,other):\n  return Union[self,other]\n  \n def __ror__(self,other):\n  return Union[other,self]\n  \n def __repr__(self):\n  if self.__forward_module__ is None:\n   module_repr=''\n  else:\n   module_repr=f', module={self.__forward_module__ !r}'\n  return f'ForwardRef({self.__forward_arg__ !r}{module_repr})'\n  \n  \ndef _is_unpacked_typevartuple(x:Any)->bool:\n return((not isinstance(x,type))and\n getattr(x,'__typing_is_unpacked_typevartuple__',False))\n \n \ndef _is_typevar_like(x:Any)->bool:\n return isinstance(x,(TypeVar,ParamSpec))or _is_unpacked_typevartuple(x)\n \n \ndef _typevar_subst(self,arg):\n msg=\"Parameters to generic types must be types.\"\n arg=_type_check(arg,msg,is_argument=True)\n if((isinstance(arg,_GenericAlias)and arg.__origin__ is Unpack)or\n (isinstance(arg,GenericAlias)and getattr(arg,'__unpacked__',False))):\n  raise TypeError(f\"{arg} is not valid as type argument\")\n return arg\n \n \ndef _typevartuple_prepare_subst(self,alias,args):\n params=alias.__parameters__\n typevartuple_index=params.index(self)\n for param in params[typevartuple_index+1:]:\n  if isinstance(param,TypeVarTuple):\n   raise TypeError(f\"More than one TypeVarTuple parameter in {alias}\")\n   \n alen=len(args)\n plen=len(params)\n left=typevartuple_index\n right=plen -typevartuple_index -1\n var_tuple_index=None\n fillarg=None\n for k,arg in enumerate(args):\n  if not isinstance(arg,type):\n   subargs=getattr(arg,'__typing_unpacked_tuple_args__',None)\n   if subargs and len(subargs)==2 and subargs[-1]is ...:\n    if var_tuple_index is not None:\n     raise TypeError(\"More than one unpacked arbitrary-length tuple argument\")\n    var_tuple_index=k\n    fillarg=subargs[0]\n if var_tuple_index is not None:\n  left=min(left,var_tuple_index)\n  right=min(right,alen -var_tuple_index -1)\n elif left+right >alen:\n  raise TypeError(f\"Too few arguments for {alias};\"\n  f\" actual {alen}, expected at least {plen -1}\")\n if left ==alen -right and self.has_default():\n  replacement=_unpack_args(self.__default__)\n else:\n  replacement=args[left:alen -right]\n  \n return(\n *args[:left],\n *([fillarg]*(typevartuple_index -left)),\n replacement,\n *([fillarg]*(plen -right -left -typevartuple_index -1)),\n *args[alen -right:],\n )\n \n \ndef _paramspec_subst(self,arg):\n if isinstance(arg,(list,tuple)):\n  arg=tuple(_type_check(a,\"Expected a type.\")for a in arg)\n elif not _is_param_expr(arg):\n  raise TypeError(f\"Expected a list of types, an ellipsis, \"\n  f\"ParamSpec, or Concatenate. Got {arg}\")\n return arg\n \n \ndef _paramspec_prepare_subst(self,alias,args):\n params=alias.__parameters__\n i=params.index(self)\n if i ==len(args)and self.has_default():\n  args=[*args,self.__default__]\n if i >=len(args):\n  raise TypeError(f\"Too few arguments for {alias}\")\n  \n if len(params)==1 and not _is_param_expr(args[0]):\n  assert i ==0\n  args=(args,)\n  \n elif isinstance(args[i],list):\n  args=(*args[:i],tuple(args[i]),*args[i+1:])\n return args\n \n \n@_tp_cache\ndef _generic_class_getitem(cls,args):\n ''\n\n\n\n\n\n\n\n \n if not isinstance(args,tuple):\n  args=(args,)\n  \n args=tuple(_type_convert(p)for p in args)\n is_generic_or_protocol=cls in(Generic,Protocol)\n \n if is_generic_or_protocol:\n \n  if not args:\n   raise TypeError(\n   f\"Parameter list to {cls.__qualname__}[...] cannot be empty\"\n   )\n  if not all(_is_typevar_like(p)for p in args):\n   raise TypeError(\n   f\"Parameters to {cls.__name__}[...] must all be type variables \"\n   f\"or parameter specification variables.\")\n  if len(set(args))!=len(args):\n   raise TypeError(\n   f\"Parameters to {cls.__name__}[...] must all be unique\")\n else:\n \n  for param in cls.__parameters__:\n   prepare=getattr(param,'__typing_prepare_subst__',None)\n   if prepare is not None:\n    args=prepare(cls,args)\n  _check_generic_specialization(cls,args)\n  \n  new_args=[]\n  for param,new_arg in zip(cls.__parameters__,args):\n   if isinstance(param,TypeVarTuple):\n    new_args.extend(new_arg)\n   else:\n    new_args.append(new_arg)\n  args=tuple(new_args)\n  \n return _GenericAlias(cls,args)\n \n \ndef _generic_init_subclass(cls,*args,**kwargs):\n super(Generic,cls).__init_subclass__(*args,**kwargs)\n tvars=[]\n if '__orig_bases__'in cls.__dict__:\n  error=Generic in cls.__orig_bases__\n else:\n  error=(Generic in cls.__bases__ and\n  cls.__name__ !='Protocol'and\n  type(cls)!=_TypedDictMeta)\n if error:\n  raise TypeError(\"Cannot inherit from plain Generic\")\n if '__orig_bases__'in cls.__dict__:\n  tvars=_collect_type_parameters(cls.__orig_bases__)\n  \n  \n  \n  \n  \n  gvars=None\n  for base in cls.__orig_bases__:\n   if(isinstance(base,_GenericAlias)and\n   base.__origin__ is Generic):\n    if gvars is not None:\n     raise TypeError(\n     \"Cannot inherit from Generic[...] multiple times.\")\n    gvars=base.__parameters__\n  if gvars is not None:\n   tvarset=set(tvars)\n   gvarset=set(gvars)\n   if not tvarset <=gvarset:\n    s_vars=', '.join(str(t)for t in tvars if t not in gvarset)\n    s_args=', '.join(str(g)for g in gvars)\n    raise TypeError(f\"Some type variables ({s_vars}) are\"\n    f\" not listed in Generic[{s_args}]\")\n   tvars=gvars\n cls.__parameters__=tuple(tvars)\n \n \ndef _is_dunder(attr):\n return attr.startswith('__')and attr.endswith('__')\n \nclass _BaseGenericAlias(_Final,_root=True):\n ''\n\n\n\n\n\n\n \n \n def __init__(self,origin,*,inst=True,name=None):\n  self._inst=inst\n  self._name=name\n  self.__origin__=origin\n  self.__slots__=None\n  \n def __call__(self,*args,**kwargs):\n  if not self._inst:\n   raise TypeError(f\"Type {self._name} cannot be instantiated; \"\n   f\"use {self.__origin__.__name__}() instead\")\n  result=self.__origin__(*args,**kwargs)\n  try:\n   result.__orig_class__=self\n   \n   \n  except Exception:\n   pass\n  return result\n  \n def __mro_entries__(self,bases):\n  res=[]\n  if self.__origin__ not in bases:\n   res.append(self.__origin__)\n   \n   \n   \n   \n   \n   \n   \n  i=bases.index(self)\n  for b in bases[i+1:]:\n   if isinstance(b,_BaseGenericAlias):\n    break\n   if not isinstance(b,type):\n    meth=getattr(b,\"__mro_entries__\",None)\n    new_bases=meth(bases)if meth else None\n    if(\n    isinstance(new_bases,tuple)and\n    any(\n    isinstance(b2,type)and issubclass(b2,Generic)\n    for b2 in new_bases\n    )\n    ):\n     break\n   elif issubclass(b,Generic):\n    break\n  else:\n   res.append(Generic)\n  return tuple(res)\n  \n def __getattr__(self,attr):\n  if attr in{'__name__','__qualname__'}:\n   return self._name or self.__origin__.__name__\n   \n   \n   \n  if '__origin__'in self.__dict__ and not _is_dunder(attr):\n   return getattr(self.__origin__,attr)\n  raise AttributeError(attr)\n  \n def __setattr__(self,attr,val):\n  if _is_dunder(attr)or attr in{'_name','_inst','_nparams','_defaults'}:\n   super().__setattr__(attr,val)\n  else:\n   setattr(self.__origin__,attr,val)\n   \n def __instancecheck__(self,obj):\n  return self.__subclasscheck__(type(obj))\n  \n def __subclasscheck__(self,cls):\n  raise TypeError(\"Subscripted generics cannot be used with\"\n  \" class and instance checks\")\n  \n def __dir__(self):\n  return list(set(super().__dir__()\n  +[attr for attr in dir(self.__origin__)if not _is_dunder(attr)]))\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \nclass _GenericAlias(_BaseGenericAlias,_root=True):\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n def __init__(self,origin,args,*,inst=True,name=None):\n  super().__init__(origin,inst=inst,name=name)\n  if not isinstance(args,tuple):\n   args=(args,)\n  self.__args__=tuple(...if a is _TypingEllipsis else\n  a for a in args)\n  enforce_default_ordering=origin in(Generic,Protocol)\n  self.__parameters__=_collect_type_parameters(\n  args,\n  enforce_default_ordering=enforce_default_ordering,\n  )\n  if not name:\n   self.__module__=origin.__module__\n   \n def __eq__(self,other):\n  if not isinstance(other,_GenericAlias):\n   return NotImplemented\n  return(self.__origin__ ==other.__origin__\n  and self.__args__ ==other.__args__)\n  \n def __hash__(self):\n  return hash((self.__origin__,self.__args__))\n  \n def __or__(self,right):\n  return Union[self,right]\n  \n def __ror__(self,left):\n  return Union[left,self]\n  \n @_tp_cache\n def __getitem__(self,args):\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n  if self.__origin__ in(Generic,Protocol):\n  \n   raise TypeError(f\"Cannot subscript already-subscripted {self}\")\n  if not self.__parameters__:\n   raise TypeError(f\"{self} is not a generic class\")\n   \n   \n  if not isinstance(args,tuple):\n   args=(args,)\n  args=_unpack_args(*(_type_convert(p)for p in args))\n  new_args=self._determine_new_args(args)\n  r=self.copy_with(new_args)\n  return r\n  \n def _determine_new_args(self,args):\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n  params=self.__parameters__\n  \n  for param in params:\n   prepare=getattr(param,'__typing_prepare_subst__',None)\n   if prepare is not None:\n    args=prepare(self,args)\n  alen=len(args)\n  plen=len(params)\n  if alen !=plen:\n   raise TypeError(f\"Too {'many'if alen >plen else 'few'} arguments for {self};\"\n   f\" actual {alen}, expected {plen}\")\n  new_arg_by_param=dict(zip(params,args))\n  return tuple(self._make_substitution(self.__args__,new_arg_by_param))\n  \n def _make_substitution(self,args,new_arg_by_param):\n  ''\n  new_args=[]\n  for old_arg in args:\n   if isinstance(old_arg,type):\n    new_args.append(old_arg)\n    continue\n    \n   substfunc=getattr(old_arg,'__typing_subst__',None)\n   if substfunc:\n    new_arg=substfunc(new_arg_by_param[old_arg])\n   else:\n    subparams=getattr(old_arg,'__parameters__',())\n    if not subparams:\n     new_arg=old_arg\n    else:\n     subargs=[]\n     for x in subparams:\n      if isinstance(x,TypeVarTuple):\n       subargs.extend(new_arg_by_param[x])\n      else:\n       subargs.append(new_arg_by_param[x])\n     new_arg=old_arg[tuple(subargs)]\n     \n   if self.__origin__ ==collections.abc.Callable and isinstance(new_arg,tuple):\n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n    new_args.extend(new_arg)\n   elif _is_unpacked_typevartuple(old_arg):\n   \n   \n   \n   \n   \n   \n   \n   \n   \n    new_args.extend(new_arg)\n   elif isinstance(old_arg,tuple):\n   \n   \n   \n   \n   \n   \n   \n    new_args.append(\n    tuple(self._make_substitution(old_arg,new_arg_by_param)),\n    )\n   else:\n    new_args.append(new_arg)\n  return new_args\n  \n def copy_with(self,args):\n  return self.__class__(self.__origin__,args,name=self._name,inst=self._inst)\n  \n def __repr__(self):\n  if self._name:\n   name='typing.'+self._name\n  else:\n   name=_type_repr(self.__origin__)\n  if self.__args__:\n   args=\", \".join([_type_repr(a)for a in self.__args__])\n  else:\n  \n   args=\"()\"\n  return f'{name}[{args}]'\n  \n def __reduce__(self):\n  if self._name:\n   origin=globals()[self._name]\n  else:\n   origin=self.__origin__\n  args=tuple(self.__args__)\n  if len(args)==1 and not isinstance(args[0],tuple):\n   args,=args\n  return operator.getitem,(origin,args)\n  \n def __mro_entries__(self,bases):\n  if isinstance(self.__origin__,_SpecialForm):\n   raise TypeError(f\"Cannot subclass {self !r}\")\n   \n  if self._name:\n   return super().__mro_entries__(bases)\n  if self.__origin__ is Generic:\n   if Protocol in bases:\n    return()\n   i=bases.index(self)\n   for b in bases[i+1:]:\n    if isinstance(b,_BaseGenericAlias)and b is not self:\n     return()\n  return(self.__origin__,)\n  \n def __iter__(self):\n  yield Unpack[self]\n  \n  \n  \n  \n  \n  \nclass _SpecialGenericAlias(_NotIterable,_BaseGenericAlias,_root=True):\n def __init__(self,origin,nparams,*,inst=True,name=None,defaults=()):\n  if name is None:\n   name=origin.__name__\n  super().__init__(origin,inst=inst,name=name)\n  self._nparams=nparams\n  self._defaults=defaults\n  if origin.__module__ =='builtins':\n   self.__doc__=f'A generic version of {origin.__qualname__}.'\n  else:\n   self.__doc__=f'A generic version of {origin.__module__}.{origin.__qualname__}.'\n   \n @_tp_cache\n def __getitem__(self,params):\n  if not isinstance(params,tuple):\n   params=(params,)\n  msg=\"Parameters to generic types must be types.\"\n  params=tuple(_type_check(p,msg)for p in params)\n  if(self._defaults\n  and len(params)<self._nparams\n  and len(params)+len(self._defaults)>=self._nparams\n  ):\n   params=(*params,*self._defaults[len(params)-self._nparams:])\n  actual_len=len(params)\n  \n  if actual_len !=self._nparams:\n   if self._defaults:\n    expected=f\"at least {self._nparams -len(self._defaults)}\"\n   else:\n    expected=str(self._nparams)\n   if not self._nparams:\n    raise TypeError(f\"{self} is not a generic class\")\n   raise TypeError(f\"Too {'many'if actual_len >self._nparams else 'few'} arguments for {self};\"\n   f\" actual {actual_len}, expected {expected}\")\n  return self.copy_with(params)\n  \n def copy_with(self,params):\n  return _GenericAlias(self.__origin__,params,\n  name=self._name,inst=self._inst)\n  \n def __repr__(self):\n  return 'typing.'+self._name\n  \n def __subclasscheck__(self,cls):\n  if isinstance(cls,_SpecialGenericAlias):\n   return issubclass(cls.__origin__,self.__origin__)\n  if not isinstance(cls,_GenericAlias):\n   return issubclass(cls,self.__origin__)\n  return super().__subclasscheck__(cls)\n  \n def __reduce__(self):\n  return self._name\n  \n def __or__(self,right):\n  return Union[self,right]\n  \n def __ror__(self,left):\n  return Union[left,self]\n  \n  \nclass _DeprecatedGenericAlias(_SpecialGenericAlias,_root=True):\n def __init__(\n self,origin,nparams,*,removal_version,inst=True,name=None\n ):\n  super().__init__(origin,nparams,inst=inst,name=name)\n  self._removal_version=removal_version\n  \n def __instancecheck__(self,inst):\n  import warnings\n  warnings._deprecated(\n  f\"{self.__module__}.{self._name}\",remove=self._removal_version\n  )\n  return super().__instancecheck__(inst)\n  \n  \nclass _CallableGenericAlias(_NotIterable,_GenericAlias,_root=True):\n def __repr__(self):\n  assert self._name =='Callable'\n  args=self.__args__\n  if len(args)==2 and _is_param_expr(args[0]):\n   return super().__repr__()\n  return(f'typing.Callable'\n  f'[[{\", \".join([_type_repr(a)for a in args[:-1]])}], '\n  f'{_type_repr(args[-1])}]')\n  \n def __reduce__(self):\n  args=self.__args__\n  if not(len(args)==2 and _is_param_expr(args[0])):\n   args=list(args[:-1]),args[-1]\n  return operator.getitem,(Callable,args)\n  \n  \nclass _CallableType(_SpecialGenericAlias,_root=True):\n def copy_with(self,params):\n  return _CallableGenericAlias(self.__origin__,params,\n  name=self._name,inst=self._inst)\n  \n def __getitem__(self,params):\n  if not isinstance(params,tuple)or len(params)!=2:\n   raise TypeError(\"Callable must be used as \"\n   \"Callable[[arg, ...], result].\")\n  args,result=params\n  \n  \n  \n  if isinstance(args,list):\n   params=(tuple(args),result)\n  else:\n   params=(args,result)\n  return self.__getitem_inner__(params)\n  \n @_tp_cache\n def __getitem_inner__(self,params):\n  args,result=params\n  msg=\"Callable[args, result]: result must be a type.\"\n  result=_type_check(result,msg)\n  if args is Ellipsis:\n   return self.copy_with((_TypingEllipsis,result))\n  if not isinstance(args,tuple):\n   args=(args,)\n  args=tuple(_type_convert(arg)for arg in args)\n  params=args+(result,)\n  return self.copy_with(params)\n  \n  \nclass _TupleType(_SpecialGenericAlias,_root=True):\n @_tp_cache\n def __getitem__(self,params):\n  if not isinstance(params,tuple):\n   params=(params,)\n  if len(params)>=2 and params[-1]is ...:\n   msg=\"Tuple[t, ...]: t must be a type.\"\n   params=tuple(_type_check(p,msg)for p in params[:-1])\n   return self.copy_with((*params,_TypingEllipsis))\n  msg=\"Tuple[t0, t1, ...]: each t must be a type.\"\n  params=tuple(_type_check(p,msg)for p in params)\n  return self.copy_with(params)\n  \n  \nclass _UnionGenericAlias(_NotIterable,_GenericAlias,_root=True):\n def copy_with(self,params):\n  return Union[params]\n  \n def __eq__(self,other):\n  if not isinstance(other,(_UnionGenericAlias,types.UnionType)):\n   return NotImplemented\n  try:\n   return set(self.__args__)==set(other.__args__)\n  except TypeError:\n   return _compare_args_orderless(self.__args__,other.__args__)\n   \n def __hash__(self):\n  return hash(frozenset(self.__args__))\n  \n def __repr__(self):\n  args=self.__args__\n  if len(args)==2:\n   if args[0]is type(None):\n    return f'typing.Optional[{_type_repr(args[1])}]'\n   elif args[1]is type(None):\n    return f'typing.Optional[{_type_repr(args[0])}]'\n  return super().__repr__()\n  \n def __instancecheck__(self,obj):\n  return self.__subclasscheck__(type(obj))\n  \n def __subclasscheck__(self,cls):\n  for arg in self.__args__:\n   if issubclass(cls,arg):\n    return True\n    \n def __reduce__(self):\n  func,(origin,args)=super().__reduce__()\n  return func,(Union,args)\n  \n  \ndef _value_and_type_iter(parameters):\n return((p,type(p))for p in parameters)\n \n \nclass _LiteralGenericAlias(_GenericAlias,_root=True):\n def __eq__(self,other):\n  if not isinstance(other,_LiteralGenericAlias):\n   return NotImplemented\n   \n  return set(_value_and_type_iter(self.__args__))==set(_value_and_type_iter(other.__args__))\n  \n def __hash__(self):\n  return hash(frozenset(_value_and_type_iter(self.__args__)))\n  \n  \nclass _ConcatenateGenericAlias(_GenericAlias,_root=True):\n def copy_with(self,params):\n  if isinstance(params[-1],(list,tuple)):\n   return(*params[:-1],*params[-1])\n  if isinstance(params[-1],_ConcatenateGenericAlias):\n   params=(*params[:-1],*params[-1].__args__)\n  return super().copy_with(params)\n  \n  \n@_SpecialForm\ndef Unpack(self,parameters):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n item=_type_check(parameters,f'{self} accepts only single type.')\n return _UnpackGenericAlias(origin=self,args=(item,))\n \n \nclass _UnpackGenericAlias(_GenericAlias,_root=True):\n def __repr__(self):\n \n \n  return f'typing.Unpack[{_type_repr(self.__args__[0])}]'\n  \n def __getitem__(self,args):\n  if self.__typing_is_unpacked_typevartuple__:\n   return args\n  return super().__getitem__(args)\n  \n @property\n def __typing_unpacked_tuple_args__(self):\n  assert self.__origin__ is Unpack\n  assert len(self.__args__)==1\n  arg,=self.__args__\n  if isinstance(arg,(_GenericAlias,types.GenericAlias)):\n   if arg.__origin__ is not tuple:\n    raise TypeError(\"Unpack[...] must be used with a tuple type\")\n   return arg.__args__\n  return None\n  \n @property\n def __typing_is_unpacked_typevartuple__(self):\n  assert self.__origin__ is Unpack\n  assert len(self.__args__)==1\n  return isinstance(self.__args__[0],TypeVarTuple)\n  \n  \nclass _TypingEllipsis:\n ''\n \n \n_TYPING_INTERNALS=frozenset({\n'__parameters__','__orig_bases__','__orig_class__',\n'_is_protocol','_is_runtime_protocol','__protocol_attrs__',\n'__non_callable_proto_members__','__type_params__',\n})\n\n_SPECIAL_NAMES=frozenset({\n'__abstractmethods__','__annotations__','__dict__','__doc__',\n'__init__','__module__','__new__','__slots__',\n'__subclasshook__','__weakref__','__class_getitem__',\n'__match_args__','__static_attributes__','__firstlineno__',\n})\n\n\nEXCLUDED_ATTRIBUTES=_TYPING_INTERNALS |_SPECIAL_NAMES |{'_MutableMapping__marker'}\n\n\ndef _get_protocol_attrs(cls):\n ''\n\n\n\n \n attrs=set()\n for base in cls.__mro__[:-1]:\n  if base.__name__ in{'Protocol','Generic'}:\n   continue\n  annotations=getattr(base,'__annotations__',{})\n  for attr in(*base.__dict__,*annotations):\n   if not attr.startswith('_abc_')and attr not in EXCLUDED_ATTRIBUTES:\n    attrs.add(attr)\n return attrs\n \n \ndef _no_init_or_replace_init(self,*args,**kwargs):\n cls=type(self)\n \n if cls._is_protocol:\n  raise TypeError('Protocols cannot be instantiated')\n  \n  \n  \n if cls.__init__ is not _no_init_or_replace_init:\n  return\n  \n  \n  \n  \n  \n  \n  \n for base in cls.__mro__:\n  init=base.__dict__.get('__init__',_no_init_or_replace_init)\n  if init is not _no_init_or_replace_init:\n   cls.__init__=init\n   break\n else:\n \n  cls.__init__=object.__init__\n  \n cls.__init__(self,*args,**kwargs)\n \n \ndef _caller(depth=1,default='__main__'):\n try:\n  return sys._getframemodulename(depth+1)or default\n except AttributeError:\n  pass\n try:\n  return sys._getframe(depth+1).f_globals.get('__name__',default)\n except(AttributeError,ValueError):\n  pass\n return None\n \ndef _allow_reckless_class_checks(depth=2):\n ''\n\n\n\n \n return _caller(depth)in{'abc','functools',None}\n \n \n_PROTO_ALLOWLIST={\n'collections.abc':[\n'Callable','Awaitable','Iterable','Iterator','AsyncIterable',\n'Hashable','Sized','Container','Collection','Reversible','Buffer',\n],\n'contextlib':['AbstractContextManager','AbstractAsyncContextManager'],\n}\n\n\n@functools.cache\ndef _lazy_load_getattr_static():\n\n\n from inspect import getattr_static\n return getattr_static\n \n \n_cleanups.append(_lazy_load_getattr_static.cache_clear)\n\ndef _pickle_psargs(psargs):\n return ParamSpecArgs,(psargs.__origin__,)\n \ncopyreg.pickle(ParamSpecArgs,_pickle_psargs)\n\ndef _pickle_pskwargs(pskwargs):\n return ParamSpecKwargs,(pskwargs.__origin__,)\n \ncopyreg.pickle(ParamSpecKwargs,_pickle_pskwargs)\n\ndel _pickle_psargs,_pickle_pskwargs\n\n\n\n\n\n\n_abc_instancecheck=ABCMeta.__instancecheck__\n_abc_subclasscheck=ABCMeta.__subclasscheck__\n\n\ndef _type_check_issubclass_arg_1(arg):\n ''\n\n\n\n\n\n\n\n\n\n \n if not isinstance(arg,type):\n \n  raise TypeError('issubclass() arg 1 must be a class')\n  \n  \nclass _ProtocolMeta(ABCMeta):\n\n\n def __new__(mcls,name,bases,namespace,/,**kwargs):\n  if name ==\"Protocol\"and bases ==(Generic,):\n   pass\n  elif Protocol in bases:\n   for base in bases:\n    if not(\n    base in{object,Generic}\n    or base.__name__ in _PROTO_ALLOWLIST.get(base.__module__,[])\n    or(\n    issubclass(base,Generic)\n    and getattr(base,\"_is_protocol\",False)\n    )\n    ):\n     raise TypeError(\n     f\"Protocols can only inherit from other protocols, \"\n     f\"got {base !r}\"\n     )\n  return super().__new__(mcls,name,bases,namespace,**kwargs)\n  \n def __init__(cls,*args,**kwargs):\n  super().__init__(*args,**kwargs)\n  if getattr(cls,\"_is_protocol\",False):\n   cls.__protocol_attrs__=_get_protocol_attrs(cls)\n   \n def __subclasscheck__(cls,other):\n  if cls is Protocol:\n   return type.__subclasscheck__(cls,other)\n  if(\n  getattr(cls,'_is_protocol',False)\n  and not _allow_reckless_class_checks()\n  ):\n   if not getattr(cls,'_is_runtime_protocol',False):\n    _type_check_issubclass_arg_1(other)\n    raise TypeError(\n    \"Instance and class checks can only be used with \"\n    \"@runtime_checkable protocols\"\n    )\n   if(\n   \n   cls.__non_callable_proto_members__\n   and cls.__dict__.get(\"__subclasshook__\")is _proto_hook\n   ):\n    _type_check_issubclass_arg_1(other)\n    non_method_attrs=sorted(cls.__non_callable_proto_members__)\n    raise TypeError(\n    \"Protocols with non-method members don't support issubclass().\"\n    f\" Non-method members: {str(non_method_attrs)[1:-1]}.\"\n    )\n  return _abc_subclasscheck(cls,other)\n  \n def __instancecheck__(cls,instance):\n \n \n  if cls is Protocol:\n   return type.__instancecheck__(cls,instance)\n  if not getattr(cls,\"_is_protocol\",False):\n  \n   return _abc_instancecheck(cls,instance)\n   \n  if(\n  not getattr(cls,'_is_runtime_protocol',False)and\n  not _allow_reckless_class_checks()\n  ):\n   raise TypeError(\"Instance and class checks can only be used with\"\n   \" @runtime_checkable protocols\")\n   \n  if _abc_instancecheck(cls,instance):\n   return True\n   \n  getattr_static=_lazy_load_getattr_static()\n  for attr in cls.__protocol_attrs__:\n   try:\n    val=getattr_static(instance,attr)\n   except AttributeError:\n    break\n    \n   if val is None and attr not in cls.__non_callable_proto_members__:\n    break\n  else:\n   return True\n   \n  return False\n  \n  \n@classmethod\ndef _proto_hook(cls,other):\n if not cls.__dict__.get('_is_protocol',False):\n  return NotImplemented\n  \n for attr in cls.__protocol_attrs__:\n  for base in other.__mro__:\n  \n   if attr in base.__dict__:\n    if base.__dict__[attr]is None:\n     return NotImplemented\n    break\n    \n    \n   annotations=getattr(base,'__annotations__',{})\n   if(isinstance(annotations,collections.abc.Mapping)and\n   attr in annotations and\n   issubclass(other,Generic)and getattr(other,'_is_protocol',False)):\n    break\n  else:\n   return NotImplemented\n return True\n \n \nclass Protocol(Generic,metaclass=_ProtocolMeta):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n __slots__=()\n _is_protocol=True\n _is_runtime_protocol=False\n \n def __init_subclass__(cls,*args,**kwargs):\n  super().__init_subclass__(*args,**kwargs)\n  \n  \n  if not cls.__dict__.get('_is_protocol',False):\n   cls._is_protocol=any(b is Protocol for b in cls.__bases__)\n   \n   \n  if '__subclasshook__'not in cls.__dict__:\n   cls.__subclasshook__=_proto_hook\n   \n   \n  if cls._is_protocol and cls.__init__ is Protocol.__init__:\n   cls.__init__=_no_init_or_replace_init\n   \n   \nclass _AnnotatedAlias(_NotIterable,_GenericAlias,_root=True):\n ''\n\n\n\n\n\n\n\n \n \n def __init__(self,origin,metadata):\n  if isinstance(origin,_AnnotatedAlias):\n   metadata=origin.__metadata__+metadata\n   origin=origin.__origin__\n  super().__init__(origin,origin,name='Annotated')\n  self.__metadata__=metadata\n  \n def copy_with(self,params):\n  assert len(params)==1\n  new_type=params[0]\n  return _AnnotatedAlias(new_type,self.__metadata__)\n  \n def __repr__(self):\n  return \"typing.Annotated[{}, {}]\".format(\n  _type_repr(self.__origin__),\n  \", \".join(repr(a)for a in self.__metadata__)\n  )\n  \n def __reduce__(self):\n  return operator.getitem,(\n  Annotated,(self.__origin__,)+self.__metadata__\n  )\n  \n def __eq__(self,other):\n  if not isinstance(other,_AnnotatedAlias):\n   return NotImplemented\n  return(self.__origin__ ==other.__origin__\n  and self.__metadata__ ==other.__metadata__)\n  \n def __hash__(self):\n  return hash((self.__origin__,self.__metadata__))\n  \n def __getattr__(self,attr):\n  if attr in{'__name__','__qualname__'}:\n   return 'Annotated'\n  return super().__getattr__(attr)\n  \n def __mro_entries__(self,bases):\n  return(self.__origin__,)\n  \n  \n@_TypedCacheSpecialForm\n@_tp_cache(typed=True)\ndef Annotated(self,*params):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n if len(params)<2:\n  raise TypeError(\"Annotated[...] should be used \"\n  \"with at least two arguments (a type and an \"\n  \"annotation).\")\n if _is_unpacked_typevartuple(params[0]):\n  raise TypeError(\"Annotated[...] should not be used with an \"\n  \"unpacked TypeVarTuple\")\n msg=\"Annotated[t, ...]: t must be a type.\"\n origin=_type_check(params[0],msg,allow_special_forms=True)\n metadata=tuple(params[1:])\n return _AnnotatedAlias(origin,metadata)\n \n \ndef runtime_checkable(cls):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n if not issubclass(cls,Generic)or not getattr(cls,'_is_protocol',False):\n  raise TypeError('@runtime_checkable can be only applied to protocol classes,'\n  ' got %r'%cls)\n cls._is_runtime_protocol=True\n \n \n \n \n cls.__non_callable_proto_members__=set()\n for attr in cls.__protocol_attrs__:\n  try:\n   is_callable=callable(getattr(cls,attr,None))\n  except Exception as e:\n   raise TypeError(\n   f\"Failed to determine whether protocol member {attr !r} \"\n   \"is a method member\"\n   )from e\n  else:\n   if not is_callable:\n    cls.__non_callable_proto_members__.add(attr)\n return cls\n \n \ndef cast(typ,val):\n ''\n\n\n\n\n\n \n return val\n \n \ndef assert_type(val,typ,/):\n ''\n\n\n\n\n\n\n\n\n\n\n \n return val\n \n \n_allowed_types=(types.FunctionType,types.BuiltinFunctionType,\ntypes.MethodType,types.ModuleType,\nWrapperDescriptorType,MethodWrapperType,MethodDescriptorType)\n\n\ndef get_type_hints(obj,globalns=None,localns=None,include_extras=False):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n if getattr(obj,'__no_type_check__',None):\n  return{}\n  \n if isinstance(obj,type):\n  hints={}\n  for base in reversed(obj.__mro__):\n   if globalns is None:\n    base_globals=getattr(sys.modules.get(base.__module__,None),'__dict__',{})\n   else:\n    base_globals=globalns\n   ann=base.__dict__.get('__annotations__',{})\n   if isinstance(ann,types.GetSetDescriptorType):\n    ann={}\n   base_locals=dict(vars(base))if localns is None else localns\n   if localns is None and globalns is None:\n   \n   \n   \n   \n   \n   \n    base_globals,base_locals=base_locals,base_globals\n   for name,value in ann.items():\n    if value is None:\n     value=type(None)\n    if isinstance(value,str):\n     value=ForwardRef(value,is_argument=False,is_class=True)\n    value=_eval_type(value,base_globals,base_locals,base.__type_params__)\n    hints[name]=value\n  return hints if include_extras else{k:_strip_annotations(t)for k,t in hints.items()}\n  \n if globalns is None:\n  if isinstance(obj,types.ModuleType):\n   globalns=obj.__dict__\n  else:\n   nsobj=obj\n   \n   while hasattr(nsobj,'__wrapped__'):\n    nsobj=nsobj.__wrapped__\n   globalns=getattr(nsobj,'__globals__',{})\n  if localns is None:\n   localns=globalns\n elif localns is None:\n  localns=globalns\n hints=getattr(obj,'__annotations__',None)\n if hints is None:\n \n  if isinstance(obj,_allowed_types):\n   return{}\n  else:\n   raise TypeError('{!r} is not a module, class, method, '\n   'or function.'.format(obj))\n hints=dict(hints)\n type_params=getattr(obj,\"__type_params__\",())\n for name,value in hints.items():\n  if value is None:\n   value=type(None)\n  if isinstance(value,str):\n  \n  \n   value=ForwardRef(\n   value,\n   is_argument=not isinstance(obj,types.ModuleType),\n   is_class=False,\n   )\n  hints[name]=_eval_type(value,globalns,localns,type_params)\n return hints if include_extras else{k:_strip_annotations(t)for k,t in hints.items()}\n \n \ndef _strip_annotations(t):\n ''\n if isinstance(t,_AnnotatedAlias):\n  return _strip_annotations(t.__origin__)\n if hasattr(t,\"__origin__\")and t.__origin__ in(Required,NotRequired,ReadOnly):\n  return _strip_annotations(t.__args__[0])\n if isinstance(t,_GenericAlias):\n  stripped_args=tuple(_strip_annotations(a)for a in t.__args__)\n  if stripped_args ==t.__args__:\n   return t\n  return t.copy_with(stripped_args)\n if isinstance(t,GenericAlias):\n  stripped_args=tuple(_strip_annotations(a)for a in t.__args__)\n  if stripped_args ==t.__args__:\n   return t\n  return GenericAlias(t.__origin__,stripped_args)\n if isinstance(t,types.UnionType):\n  stripped_args=tuple(_strip_annotations(a)for a in t.__args__)\n  if stripped_args ==t.__args__:\n   return t\n  return functools.reduce(operator.or_,stripped_args)\n  \n return t\n \n \ndef get_origin(tp):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n if isinstance(tp,_AnnotatedAlias):\n  return Annotated\n if isinstance(tp,(_BaseGenericAlias,GenericAlias,\n ParamSpecArgs,ParamSpecKwargs)):\n  return tp.__origin__\n if tp is Generic:\n  return Generic\n if isinstance(tp,types.UnionType):\n  return types.UnionType\n return None\n \n \ndef get_args(tp):\n ''\n\n\n\n\n\n\n\n\n\n\n\n \n if isinstance(tp,_AnnotatedAlias):\n  return(tp.__origin__,)+tp.__metadata__\n if isinstance(tp,(_GenericAlias,GenericAlias)):\n  res=tp.__args__\n  if _should_unflatten_callable_args(tp,res):\n   res=(list(res[:-1]),res[-1])\n  return res\n if isinstance(tp,types.UnionType):\n  return tp.__args__\n return()\n \n \ndef is_typeddict(tp):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n \n return isinstance(tp,_TypedDictMeta)\n \n \n_ASSERT_NEVER_REPR_MAX_LENGTH=100\n\n\ndef assert_never(arg:Never,/)->Never:\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n value=repr(arg)\n if len(value)>_ASSERT_NEVER_REPR_MAX_LENGTH:\n  value=value[:_ASSERT_NEVER_REPR_MAX_LENGTH]+'...'\n raise AssertionError(f\"Expected code to be unreachable, but got: {value}\")\n \n \ndef no_type_check(arg):\n ''\n\n\n\n\n\n\n \n if isinstance(arg,type):\n  for key in dir(arg):\n   obj=getattr(arg,key)\n   if(\n   not hasattr(obj,'__qualname__')\n   or obj.__qualname__ !=f'{arg.__qualname__}.{obj.__name__}'\n   or getattr(obj,'__module__',None)!=arg.__module__\n   ):\n   \n   \n   \n    continue\n    \n   if isinstance(obj,types.FunctionType):\n    obj.__no_type_check__=True\n   if isinstance(obj,types.MethodType):\n    obj.__func__.__no_type_check__=True\n    \n   if isinstance(obj,type):\n    no_type_check(obj)\n try:\n  arg.__no_type_check__=True\n except TypeError:\n  pass\n return arg\n \n \ndef no_type_check_decorator(decorator):\n ''\n\n\n\n \n import warnings\n warnings._deprecated(\"typing.no_type_check_decorator\",remove=(3,15))\n @functools.wraps(decorator)\n def wrapped_decorator(*args,**kwds):\n  func=decorator(*args,**kwds)\n  func=no_type_check(func)\n  return func\n  \n return wrapped_decorator\n \n \ndef _overload_dummy(*args,**kwds):\n ''\n raise NotImplementedError(\n \"You should not call an overloaded function. \"\n \"A series of @overload-decorated functions \"\n \"outside a stub module should always be followed \"\n \"by an implementation that is not @overload-ed.\")\n \n \n \n_overload_registry=defaultdict(functools.partial(defaultdict,dict))\n\n\ndef overload(func):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n f=getattr(func,\"__func__\",func)\n try:\n  _overload_registry[f.__module__][f.__qualname__][f.__code__.co_firstlineno]=func\n except AttributeError:\n \n  pass\n return _overload_dummy\n \n \ndef get_overloads(func):\n ''\n \n f=getattr(func,\"__func__\",func)\n if f.__module__ not in _overload_registry:\n  return[]\n mod_dict=_overload_registry[f.__module__]\n if f.__qualname__ not in mod_dict:\n  return[]\n return list(mod_dict[f.__qualname__].values())\n \n \ndef clear_overloads():\n ''\n _overload_registry.clear()\n \n \ndef final(f):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n try:\n  f.__final__=True\n except(AttributeError,TypeError):\n \n \n \n  pass\n return f\n \n \n \n \n \nT=TypeVar('T')\nKT=TypeVar('KT')\nVT=TypeVar('VT')\nT_co=TypeVar('T_co',covariant=True)\nV_co=TypeVar('V_co',covariant=True)\nVT_co=TypeVar('VT_co',covariant=True)\nT_contra=TypeVar('T_contra',contravariant=True)\n\nCT_co=TypeVar('CT_co',covariant=True,bound=type)\n\n\n\n\nAnyStr=TypeVar('AnyStr',bytes,str)\n\n\n\n_alias=_SpecialGenericAlias\n\nHashable=_alias(collections.abc.Hashable,0)\nAwaitable=_alias(collections.abc.Awaitable,1)\nCoroutine=_alias(collections.abc.Coroutine,3)\nAsyncIterable=_alias(collections.abc.AsyncIterable,1)\nAsyncIterator=_alias(collections.abc.AsyncIterator,1)\nIterable=_alias(collections.abc.Iterable,1)\nIterator=_alias(collections.abc.Iterator,1)\nReversible=_alias(collections.abc.Reversible,1)\nSized=_alias(collections.abc.Sized,0)\nContainer=_alias(collections.abc.Container,1)\nCollection=_alias(collections.abc.Collection,1)\nCallable=_CallableType(collections.abc.Callable,2)\nCallable.__doc__=\\\n\"\"\"Deprecated alias to collections.abc.Callable.\n\n    Callable[[int], str] signifies a function that takes a single\n    parameter of type int and returns a str.\n\n    The subscription syntax must always be used with exactly two\n    values: the argument list and the return type.\n    The argument list must be a list of types, a ParamSpec,\n    Concatenate or ellipsis. The return type must be a single type.\n\n    There is no syntax to indicate optional or keyword arguments;\n    such function types are rarely used as callback types.\n    \"\"\"\nAbstractSet=_alias(collections.abc.Set,1,name='AbstractSet')\nMutableSet=_alias(collections.abc.MutableSet,1)\n\nMapping=_alias(collections.abc.Mapping,2)\nMutableMapping=_alias(collections.abc.MutableMapping,2)\nSequence=_alias(collections.abc.Sequence,1)\nMutableSequence=_alias(collections.abc.MutableSequence,1)\nByteString=_DeprecatedGenericAlias(\ncollections.abc.ByteString,0,removal_version=(3,14)\n)\n\nTuple=_TupleType(tuple,-1,inst=False,name='Tuple')\nTuple.__doc__=\\\n\"\"\"Deprecated alias to builtins.tuple.\n\n    Tuple[X, Y] is the cross-product type of X and Y.\n\n    Example: Tuple[T1, T2] is a tuple of two elements corresponding\n    to type variables T1 and T2.  Tuple[int, float, str] is a tuple\n    of an int, a float and a string.\n\n    To specify a variable-length tuple of homogeneous type, use Tuple[T, ...].\n    \"\"\"\nList=_alias(list,1,inst=False,name='List')\nDeque=_alias(collections.deque,1,name='Deque')\nSet=_alias(set,1,inst=False,name='Set')\nFrozenSet=_alias(frozenset,1,inst=False,name='FrozenSet')\nMappingView=_alias(collections.abc.MappingView,1)\nKeysView=_alias(collections.abc.KeysView,1)\nItemsView=_alias(collections.abc.ItemsView,2)\nValuesView=_alias(collections.abc.ValuesView,1)\nDict=_alias(dict,2,inst=False,name='Dict')\nDefaultDict=_alias(collections.defaultdict,2,name='DefaultDict')\nOrderedDict=_alias(collections.OrderedDict,2)\nCounter=_alias(collections.Counter,1)\nChainMap=_alias(collections.ChainMap,2)\nGenerator=_alias(collections.abc.Generator,3,defaults=(types.NoneType,types.NoneType))\nAsyncGenerator=_alias(collections.abc.AsyncGenerator,2,defaults=(types.NoneType,))\nType=_alias(type,1,inst=False,name='Type')\nType.__doc__=\\\n\"\"\"Deprecated alias to builtins.type.\n\n    builtins.type or typing.Type can be used to annotate class objects.\n    For example, suppose we have the following classes::\n\n        class User: ...  # Abstract base for User classes\n        class BasicUser(User): ...\n        class ProUser(User): ...\n        class TeamUser(User): ...\n\n    And a function that takes a class argument that's a subclass of\n    User and returns an instance of the corresponding class::\n\n        def new_user[U](user_class: Type[U]) -> U:\n            user = user_class()\n            # (Here we could write the user object to a database)\n            return user\n\n        joe = new_user(BasicUser)\n\n    At this point the type checker knows that joe has type BasicUser.\n    \"\"\"\n\n\n@runtime_checkable\nclass SupportsInt(Protocol):\n ''\n \n __slots__=()\n \n @abstractmethod\n def __int__(self)->int:\n  pass\n  \n  \n@runtime_checkable\nclass SupportsFloat(Protocol):\n ''\n \n __slots__=()\n \n @abstractmethod\n def __float__(self)->float:\n  pass\n  \n  \n@runtime_checkable\nclass SupportsComplex(Protocol):\n ''\n \n __slots__=()\n \n @abstractmethod\n def __complex__(self)->complex:\n  pass\n  \n  \n@runtime_checkable\nclass SupportsBytes(Protocol):\n ''\n \n __slots__=()\n \n @abstractmethod\n def __bytes__(self)->bytes:\n  pass\n  \n  \n@runtime_checkable\nclass SupportsIndex(Protocol):\n ''\n \n __slots__=()\n \n @abstractmethod\n def __index__(self)->int:\n  pass\n  \n  \n@runtime_checkable\nclass SupportsAbs[T](Protocol):\n ''\n \n __slots__=()\n \n @abstractmethod\n def __abs__(self)->T:\n  pass\n  \n  \n@runtime_checkable\nclass SupportsRound[T](Protocol):\n ''\n \n __slots__=()\n \n @abstractmethod\n def __round__(self,ndigits:int=0)->T:\n  pass\n  \n  \ndef _make_nmtuple(name,types,module,defaults=()):\n fields=[n for n,t in types]\n types={n:_type_check(t,f\"field {n} annotation must be a type\")\n for n,t in types}\n nm_tpl=collections.namedtuple(name,fields,\n defaults=defaults,module=module)\n nm_tpl.__annotations__=nm_tpl.__new__.__annotations__=types\n return nm_tpl\n \n \n \n_prohibited=frozenset({'__new__','__init__','__slots__','__getnewargs__',\n'_fields','_field_defaults',\n'_make','_replace','_asdict','_source'})\n\n_special=frozenset({'__module__','__name__','__annotations__'})\n\n\nclass NamedTupleMeta(type):\n def __new__(cls,typename,bases,ns):\n  assert _NamedTuple in bases\n  for base in bases:\n   if base is not _NamedTuple and base is not Generic:\n    raise TypeError(\n    'can only inherit from a NamedTuple type and Generic')\n  bases=tuple(tuple if base is _NamedTuple else base for base in bases)\n  types=ns.get('__annotations__',{})\n  default_names=[]\n  for field_name in types:\n   if field_name in ns:\n    default_names.append(field_name)\n   elif default_names:\n    raise TypeError(f\"Non-default namedtuple field {field_name} \"\n    f\"cannot follow default field\"\n    f\"{'s'if len(default_names)>1 else ''} \"\n    f\"{', '.join(default_names)}\")\n  nm_tpl=_make_nmtuple(typename,types.items(),\n  defaults=[ns[n]for n in default_names],\n  module=ns['__module__'])\n  nm_tpl.__bases__=bases\n  if Generic in bases:\n   class_getitem=_generic_class_getitem\n   nm_tpl.__class_getitem__=classmethod(class_getitem)\n   \n  for key,val in ns.items():\n   if key in _prohibited:\n    raise AttributeError(\"Cannot overwrite NamedTuple attribute \"+key)\n   elif key not in _special:\n    if key not in nm_tpl._fields:\n     setattr(nm_tpl,key,val)\n    try:\n     set_name=type(val).__set_name__\n    except AttributeError:\n     pass\n    else:\n     try:\n      set_name(val,nm_tpl,key)\n     except BaseException as e:\n      e.add_note(\n      f\"Error calling __set_name__ on {type(val).__name__ !r} \"\n      f\"instance {key !r} in {typename !r}\"\n      )\n      raise\n      \n  if Generic in bases:\n   nm_tpl.__init_subclass__()\n  return nm_tpl\n  \n  \ndef NamedTuple(typename,fields=_sentinel,/,**kwargs):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n if fields is _sentinel:\n  if kwargs:\n   deprecated_thing=\"Creating NamedTuple classes using keyword arguments\"\n   deprecation_msg=(\n   \"{name} is deprecated and will be disallowed in Python {remove}. \"\n   \"Use the class-based or functional syntax instead.\"\n   )\n  else:\n   deprecated_thing=\"Failing to pass a value for the 'fields' parameter\"\n   example=f\"`{typename} = NamedTuple({typename !r}, [])`\"\n   deprecation_msg=(\n   \"{name} is deprecated and will be disallowed in Python {remove}. \"\n   \"To create a NamedTuple class with 0 fields \"\n   \"using the functional syntax, \"\n   \"pass an empty list, e.g. \"\n   )+example+\".\"\n elif fields is None:\n  if kwargs:\n   raise TypeError(\n   \"Cannot pass `None` as the 'fields' parameter \"\n   \"and also specify fields using keyword arguments\"\n   )\n  else:\n   deprecated_thing=\"Passing `None` as the 'fields' parameter\"\n   example=f\"`{typename} = NamedTuple({typename !r}, [])`\"\n   deprecation_msg=(\n   \"{name} is deprecated and will be disallowed in Python {remove}. \"\n   \"To create a NamedTuple class with 0 fields \"\n   \"using the functional syntax, \"\n   \"pass an empty list, e.g. \"\n   )+example+\".\"\n elif kwargs:\n  raise TypeError(\"Either list of fields or keywords\"\n  \" can be provided to NamedTuple, not both\")\n if fields is _sentinel or fields is None:\n  import warnings\n  warnings._deprecated(deprecated_thing,message=deprecation_msg,remove=(3,15))\n  fields=kwargs.items()\n nt=_make_nmtuple(typename,fields,module=_caller())\n nt.__orig_bases__=(NamedTuple,)\n return nt\n \n_NamedTuple=type.__new__(NamedTupleMeta,'NamedTuple',(),{})\n\ndef _namedtuple_mro_entries(bases):\n assert NamedTuple in bases\n return(_NamedTuple,)\n \nNamedTuple.__mro_entries__=_namedtuple_mro_entries\n\n\ndef _get_typeddict_qualifiers(annotation_type):\n while True:\n  annotation_origin=get_origin(annotation_type)\n  if annotation_origin is Annotated:\n   annotation_args=get_args(annotation_type)\n   if annotation_args:\n    annotation_type=annotation_args[0]\n   else:\n    break\n  elif annotation_origin is Required:\n   yield Required\n   (annotation_type,)=get_args(annotation_type)\n  elif annotation_origin is NotRequired:\n   yield NotRequired\n   (annotation_type,)=get_args(annotation_type)\n  elif annotation_origin is ReadOnly:\n   yield ReadOnly\n   (annotation_type,)=get_args(annotation_type)\n  else:\n   break\n   \n   \nclass _TypedDictMeta(type):\n def __new__(cls,name,bases,ns,total=True):\n  ''\n\n\n\n\n\n  \n  for base in bases:\n   if type(base)is not _TypedDictMeta and base is not Generic:\n    raise TypeError('cannot inherit from both a TypedDict type '\n    'and a non-TypedDict base class')\n    \n  if any(issubclass(b,Generic)for b in bases):\n   generic_base=(Generic,)\n  else:\n   generic_base=()\n   \n  tp_dict=type.__new__(_TypedDictMeta,name,(*generic_base,dict),ns)\n  \n  if not hasattr(tp_dict,'__orig_bases__'):\n   tp_dict.__orig_bases__=bases\n   \n  annotations={}\n  own_annotations=ns.get('__annotations__',{})\n  msg=\"TypedDict('Name', {f0: t0, f1: t1, ...}); each t must be a type\"\n  own_annotations={\n  n:_type_check(tp,msg,module=tp_dict.__module__)\n  for n,tp in own_annotations.items()\n  }\n  required_keys=set()\n  optional_keys=set()\n  readonly_keys=set()\n  mutable_keys=set()\n  \n  for base in bases:\n   annotations.update(base.__dict__.get('__annotations__',{}))\n   \n   base_required=base.__dict__.get('__required_keys__',set())\n   required_keys |=base_required\n   optional_keys -=base_required\n   \n   base_optional=base.__dict__.get('__optional_keys__',set())\n   required_keys -=base_optional\n   optional_keys |=base_optional\n   \n   readonly_keys.update(base.__dict__.get('__readonly_keys__',()))\n   mutable_keys.update(base.__dict__.get('__mutable_keys__',()))\n   \n  annotations.update(own_annotations)\n  for annotation_key,annotation_type in own_annotations.items():\n   qualifiers=set(_get_typeddict_qualifiers(annotation_type))\n   if Required in qualifiers:\n    is_required=True\n   elif NotRequired in qualifiers:\n    is_required=False\n   else:\n    is_required=total\n    \n   if is_required:\n    required_keys.add(annotation_key)\n    optional_keys.discard(annotation_key)\n   else:\n    optional_keys.add(annotation_key)\n    required_keys.discard(annotation_key)\n    \n   if ReadOnly in qualifiers:\n    if annotation_key in mutable_keys:\n     raise TypeError(\n     f\"Cannot override mutable key {annotation_key !r}\"\n     \" with read-only key\"\n     )\n    readonly_keys.add(annotation_key)\n   else:\n    mutable_keys.add(annotation_key)\n    readonly_keys.discard(annotation_key)\n    \n  assert required_keys.isdisjoint(optional_keys),(\n  f\"Required keys overlap with optional keys in {name}:\"\n  f\" {required_keys=}, {optional_keys=}\"\n  )\n  tp_dict.__annotations__=annotations\n  tp_dict.__required_keys__=frozenset(required_keys)\n  tp_dict.__optional_keys__=frozenset(optional_keys)\n  tp_dict.__readonly_keys__=frozenset(readonly_keys)\n  tp_dict.__mutable_keys__=frozenset(mutable_keys)\n  tp_dict.__total__=total\n  return tp_dict\n  \n __call__=dict\n \n def __subclasscheck__(cls,other):\n \n  raise TypeError('TypedDict does not support instance and class checks')\n  \n __instancecheck__=__subclasscheck__\n \n \ndef TypedDict(typename,fields=_sentinel,/,*,total=True):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n if fields is _sentinel or fields is None:\n  import warnings\n  \n  if fields is _sentinel:\n   deprecated_thing=\"Failing to pass a value for the 'fields' parameter\"\n  else:\n   deprecated_thing=\"Passing `None` as the 'fields' parameter\"\n   \n  example=f\"`{typename} = TypedDict({typename !r}, {{{{}}}})`\"\n  deprecation_msg=(\n  \"{name} is deprecated and will be disallowed in Python {remove}. \"\n  \"To create a TypedDict class with 0 fields \"\n  \"using the functional syntax, \"\n  \"pass an empty dictionary, e.g. \"\n  )+example+\".\"\n  warnings._deprecated(deprecated_thing,message=deprecation_msg,remove=(3,15))\n  fields={}\n  \n ns={'__annotations__':dict(fields)}\n module=_caller()\n if module is not None:\n \n  ns['__module__']=module\n  \n td=_TypedDictMeta(typename,(),ns,total=total)\n td.__orig_bases__=(TypedDict,)\n return td\n \n_TypedDict=type.__new__(_TypedDictMeta,'TypedDict',(),{})\nTypedDict.__mro_entries__=lambda bases:(_TypedDict,)\n\n\n@_SpecialForm\ndef Required(self,parameters):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n item=_type_check(parameters,f'{self._name} accepts only a single type.')\n return _GenericAlias(self,(item,))\n \n \n@_SpecialForm\ndef NotRequired(self,parameters):\n ''\n\n\n\n\n\n\n\n\n\n\n\n \n item=_type_check(parameters,f'{self._name} accepts only a single type.')\n return _GenericAlias(self,(item,))\n \n \n@_SpecialForm\ndef ReadOnly(self,parameters):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n \n item=_type_check(parameters,f'{self._name} accepts only a single type.')\n return _GenericAlias(self,(item,))\n \n \nclass NewType:\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n __call__=_idfunc\n \n def __init__(self,name,tp):\n  self.__qualname__=name\n  if '.'in name:\n   name=name.rpartition('.')[-1]\n  self.__name__=name\n  self.__supertype__=tp\n  def_mod=_caller()\n  if def_mod !='typing':\n   self.__module__=def_mod\n   \n def __mro_entries__(self,bases):\n \n \n  superclass_name=self.__name__\n  \n  class Dummy:\n   def __init_subclass__(cls):\n    subclass_name=cls.__name__\n    raise TypeError(\n    f\"Cannot subclass an instance of NewType. Perhaps you were looking for: \"\n    f\"`{subclass_name} = NewType({subclass_name !r}, {superclass_name})`\"\n    )\n    \n  return(Dummy,)\n  \n def __repr__(self):\n  return f'{self.__module__}.{self.__qualname__}'\n  \n def __reduce__(self):\n  return self.__qualname__\n  \n def __or__(self,other):\n  return Union[self,other]\n  \n def __ror__(self,other):\n  return Union[other,self]\n  \n  \n  \nText=str\n\n\n\nTYPE_CHECKING=False\n\n\nclass IO(Generic[AnyStr]):\n ''\n\n\n\n\n\n\n\n\n\n \n \n __slots__=()\n \n @property\n @abstractmethod\n def mode(self)->str:\n  pass\n  \n @property\n @abstractmethod\n def name(self)->str:\n  pass\n  \n @abstractmethod\n def close(self)->None:\n  pass\n  \n @property\n @abstractmethod\n def closed(self)->bool:\n  pass\n  \n @abstractmethod\n def fileno(self)->int:\n  pass\n  \n @abstractmethod\n def flush(self)->None:\n  pass\n  \n @abstractmethod\n def isatty(self)->bool:\n  pass\n  \n @abstractmethod\n def read(self,n:int=-1)->AnyStr:\n  pass\n  \n @abstractmethod\n def readable(self)->bool:\n  pass\n  \n @abstractmethod\n def readline(self,limit:int=-1)->AnyStr:\n  pass\n  \n @abstractmethod\n def readlines(self,hint:int=-1)->List[AnyStr]:\n  pass\n  \n @abstractmethod\n def seek(self,offset:int,whence:int=0)->int:\n  pass\n  \n @abstractmethod\n def seekable(self)->bool:\n  pass\n  \n @abstractmethod\n def tell(self)->int:\n  pass\n  \n @abstractmethod\n def truncate(self,size:int=None)->int:\n  pass\n  \n @abstractmethod\n def writable(self)->bool:\n  pass\n  \n @abstractmethod\n def write(self,s:AnyStr)->int:\n  pass\n  \n @abstractmethod\n def writelines(self,lines:List[AnyStr])->None:\n  pass\n  \n @abstractmethod\n def __enter__(self)->'IO[AnyStr]':\n  pass\n  \n @abstractmethod\n def __exit__(self,type,value,traceback)->None:\n  pass\n  \n  \nclass BinaryIO(IO[bytes]):\n ''\n \n __slots__=()\n \n @abstractmethod\n def write(self,s:Union[bytes,bytearray])->int:\n  pass\n  \n @abstractmethod\n def __enter__(self)->'BinaryIO':\n  pass\n  \n  \nclass TextIO(IO[str]):\n ''\n \n __slots__=()\n \n @property\n @abstractmethod\n def buffer(self)->BinaryIO:\n  pass\n  \n @property\n @abstractmethod\n def encoding(self)->str:\n  pass\n  \n @property\n @abstractmethod\n def errors(self)->Optional[str]:\n  pass\n  \n @property\n @abstractmethod\n def line_buffering(self)->bool:\n  pass\n  \n @property\n @abstractmethod\n def newlines(self)->Any:\n  pass\n  \n @abstractmethod\n def __enter__(self)->'TextIO':\n  pass\n  \n  \ndef reveal_type[T](obj:T,/)->T:\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n \n print(f\"Runtime type is {type(obj).__name__ !r}\",file=sys.stderr)\n return obj\n \n \nclass _IdentityCallable(Protocol):\n def __call__[T](self,arg:T,/)->T:\n  ...\n  \n  \ndef dataclass_transform(\n*,\neq_default:bool=True,\norder_default:bool=False,\nkw_only_default:bool=False,\nfrozen_default:bool=False,\nfield_specifiers:tuple[type[Any]|Callable[...,Any],...]=(),\n**kwargs:Any,\n)->_IdentityCallable:\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n def decorator(cls_or_fn):\n  cls_or_fn.__dataclass_transform__={\n  \"eq_default\":eq_default,\n  \"order_default\":order_default,\n  \"kw_only_default\":kw_only_default,\n  \"frozen_default\":frozen_default,\n  \"field_specifiers\":field_specifiers,\n  \"kwargs\":kwargs,\n  }\n  return cls_or_fn\n return decorator\n \n \ntype _Func=Callable[...,Any]\n\n\ndef override[F:_Func](method:F,/)->F:\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n try:\n  method.__override__=True\n except(AttributeError,TypeError):\n \n \n \n  pass\n return method\n \n \ndef is_protocol(tp:type,/)->bool:\n ''\n\n\n\n\n\n\n\n\n\n\n\n \n return(\n isinstance(tp,type)\n and getattr(tp,'_is_protocol',False)\n and tp !=Protocol\n )\n \n \ndef get_protocol_members(tp:type,/)->frozenset[str]:\n ''\n\n\n\n\n\n\n\n\n\n\n\n \n if not is_protocol(tp):\n  raise TypeError(f'{tp !r} is not a Protocol')\n return frozenset(tp.__protocol_attrs__)\n \n \ndef __getattr__(attr):\n ''\n\n\n\n \n if attr in{\"Pattern\",\"Match\"}:\n  import re\n  obj=_alias(getattr(re,attr),1)\n elif attr in{\"ContextManager\",\"AsyncContextManager\"}:\n  import contextlib\n  obj=_alias(getattr(contextlib,f\"Abstract{attr}\"),2,name=attr,defaults=(bool |None,))\n elif attr ==\"_collect_parameters\":\n  import warnings\n  \n  depr_message=(\n  \"The private _collect_parameters function is deprecated and will be\"\n  \" removed in a future version of Python. Any use of private functions\"\n  \" is discouraged and may break in the future.\"\n  )\n  warnings.warn(depr_message,category=DeprecationWarning,stacklevel=2)\n  obj=_collect_type_parameters\n else:\n  raise AttributeError(f\"module {__name__ !r} has no attribute {attr !r}\")\n globals()[attr]=obj\n return obj\n", ["_typing", "abc", "collections", "collections.abc", "contextlib", "copyreg", "functools", "inspect", "operator", "re", "sys", "types", "warnings"]], "_aio": [".py", "from browser.aio import run,sleep,Future\n\n\ndef _task(coro,Id,block):\n async def _task():\n  block[Id]=None\n  try:\n   block[Id]=await coro\n  except Exception as e:\n   block[Id]=e\n   \n  if not block[Id]:\n   del block[Id]\n return _task()\n \n \nasync def gather(*coros,rate=0):\n dones={}\n counts=0\n for c in coros:\n  run(_task(c,f'task{counts}',dones))\n  counts +=1\n while not all(dones.values()):\n  await sleep(rate)\n return dones\n \n \nclass QueueEmpty(Exception):\n pass\n \n \nclass QueueFull(Exception):\n pass\n \n \nclass Queue(object):\n\n def __init__(self,maxsize=0):\n  from collections import deque\n  self.maxsize=maxsize\n  self.data=deque(maxlen=maxsize or None)\n  self.readers=deque()\n  self.writers=deque()\n  self.joiners=deque()\n  self.tasks=0\n  \n def qsize(self):\n  return len(self.data)\n  \n def empty(self):\n  return self.qsize()==0\n  \n def full(self):\n  return self.maxsize and self.qsize()==self.maxsize\n  \n async def get(self):\n  if self.empty():\n   future=Future()\n   def reader(val):\n    future.set_result(val)\n   self.readers.append(reader)\n   return await future\n   \n  item=self.get_nowait()\n  if self.writers:\n  \n   writer=self.writers.popleft()\n   writer()\n  return item\n  \n def get_nowait(self):\n  try:\n   return self.data.popleft()\n  except IndexError:\n   raise QueueEmpty()\n   \n async def put(self,item):\n  if self.full():\n   future=Future()\n   def writer():\n    self.put_nowait(item)\n    future.set_result(True)\n   self.writers.append(writer)\n   await future\n   return\n   \n  if self.readers:\n  \n   self.tasks +=1\n   reader=self.readers.popleft()\n   reader(item)\n  else:\n  \n   self.put_nowait(item)\n   \n def put_nowait(self,item):\n  if self.full():\n   raise QueueFull()\n  self.data.append(item)\n  self.tasks +=1\n  \n async def join(self):\n  if self.tasks >0:\n   future=Future()\n   def setres():\n    future.set_result(True)\n   await future\n   \n def task_done(self):\n  if self.tasks ==0:\n   raise ValueError(\"no tasks\")\n  self.tasks -=1\n  if tasks ==0:\n   for joiner in self.joiners:\n    joiner()\n", ["browser.aio", "collections"]], "_collections": [".py", "\n\n\n\n\n\n\n\n\n\nimport operator\n\n\n\ndef _thread_ident():\n return -1\n \n \nn=30\nLFTLNK=n\nRGTLNK=n+1\nBLOCKSIZ=n+2\n\n\n\n\n\n\n\n\nclass deque:\n\n def __new__(cls,iterable=(),*args,**kw):\n \n \n  self=object.__new__(cls,*args,**kw)\n  self.clear()\n  return self\n  \n def __init__(self,iterable=(),maxlen=None):\n  object.__init__(self)\n  self.clear()\n  if maxlen is not None:\n   if maxlen <0:\n    raise ValueError(\"maxlen must be non-negative\")\n  self._maxlen=maxlen\n  add=self.append\n  for elem in iterable:\n   add(elem)\n   \n @property\n def maxlen(self):\n  return self._maxlen\n  \n def clear(self):\n  self.right=self.left=[None]*BLOCKSIZ\n  self.rightndx=n //2\n  self.leftndx=n //2+1\n  self.length=0\n  self.state=0\n  \n def append(self,x):\n  self.state +=1\n  self.rightndx +=1\n  if self.rightndx ==n:\n   newblock=[None]*BLOCKSIZ\n   self.right[RGTLNK]=newblock\n   newblock[LFTLNK]=self.right\n   self.right=newblock\n   self.rightndx=0\n  self.length +=1\n  self.right[self.rightndx]=x\n  if self.maxlen is not None and self.length >self.maxlen:\n   self.popleft()\n   \n def appendleft(self,x):\n  self.state +=1\n  self.leftndx -=1\n  if self.leftndx ==-1:\n   newblock=[None]*BLOCKSIZ\n   self.left[LFTLNK]=newblock\n   newblock[RGTLNK]=self.left\n   self.left=newblock\n   self.leftndx=n -1\n  self.length +=1\n  self.left[self.leftndx]=x\n  if self.maxlen is not None and self.length >self.maxlen:\n   self.pop()\n   \n def extend(self,iterable):\n  if iterable is self:\n   iterable=list(iterable)\n  for elem in iterable:\n   self.append(elem)\n   \n def extendleft(self,iterable):\n  if iterable is self:\n   iterable=list(iterable)\n  for elem in iterable:\n   self.appendleft(elem)\n   \n def pop(self):\n  if self.left is self.right and self.leftndx >self.rightndx:\n  \n   raise IndexError(\"pop from an empty deque\")\n  x=self.right[self.rightndx]\n  self.right[self.rightndx]=None\n  self.length -=1\n  self.rightndx -=1\n  self.state +=1\n  if self.rightndx ==-1:\n   prevblock=self.right[LFTLNK]\n   if prevblock is None:\n   \n    self.rightndx=n //2\n    self.leftndx=n //2+1\n   else:\n    prevblock[RGTLNK]=None\n    self.right[LFTLNK]=None\n    self.right=prevblock\n    self.rightndx=n -1\n  return x\n  \n def popleft(self):\n  if self.left is self.right and self.leftndx >self.rightndx:\n  \n   raise IndexError(\"pop from an empty deque\")\n  x=self.left[self.leftndx]\n  self.left[self.leftndx]=None\n  self.length -=1\n  self.leftndx +=1\n  self.state +=1\n  if self.leftndx ==n:\n   prevblock=self.left[RGTLNK]\n   if prevblock is None:\n   \n    self.rightndx=n //2\n    self.leftndx=n //2+1\n   else:\n    prevblock[LFTLNK]=None\n    self.left[RGTLNK]=None\n    self.left=prevblock\n    self.leftndx=0\n  return x\n  \n def count(self,value):\n  c=0\n  for item in self:\n   if item ==value:\n    c +=1\n  return c\n  \n def remove(self,value):\n \n  for i in range(len(self)):\n   if self[i]==value:\n    del self[i]\n    return\n  raise ValueError(\"deque.remove(x): x not in deque\")\n  \n def rotate(self,n=1):\n  length=len(self)\n  if length ==0:\n   return\n  halflen=(length+1)>>1\n  if n >halflen or n <-halflen:\n   n %=length\n   if n >halflen:\n    n -=length\n   elif n <-halflen:\n    n +=length\n  while n >0:\n   self.appendleft(self.pop())\n   n -=1\n  while n <0:\n   self.append(self.popleft())\n   n +=1\n   \n def reverse(self):\n  ''\n  leftblock=self.left\n  rightblock=self.right\n  leftindex=self.leftndx\n  rightindex=self.rightndx\n  for i in range(self.length //2):\n  \n   assert leftblock !=rightblock or leftindex <rightindex\n   \n   \n   (rightblock[rightindex],leftblock[leftindex])=(\n   leftblock[leftindex],rightblock[rightindex])\n   \n   \n   leftindex +=1\n   if leftindex ==n:\n    leftblock=leftblock[RGTLNK]\n    assert leftblock is not None\n    leftindex=0\n    \n    \n   rightindex -=1\n   if rightindex ==-1:\n    rightblock=rightblock[LFTLNK]\n    assert rightblock is not None\n    rightindex=n -1\n    \n def __repr__(self):\n  threadlocalattr='__repr'+str(_thread_ident())\n  if threadlocalattr in self.__dict__:\n   return 'deque([...])'\n  else:\n   self.__dict__[threadlocalattr]=True\n   try:\n    if self.maxlen is not None:\n     return 'deque(%r, maxlen=%s)'%(list(self),self.maxlen)\n    else:\n     return 'deque(%r)'%(list(self),)\n   finally:\n    del self.__dict__[threadlocalattr]\n    \n def __iter__(self):\n  return deque_iterator(self,self._iter_impl)\n  \n def _iter_impl(self,original_state,giveup):\n  if self.state !=original_state:\n   giveup()\n  block=self.left\n  while block:\n   l,r=0,n\n   if block is self.left:\n    l=self.leftndx\n   if block is self.right:\n    r=self.rightndx+1\n   for elem in block[l:r]:\n    yield elem\n    if self.state !=original_state:\n     giveup()\n   block=block[RGTLNK]\n   \n def __reversed__(self):\n  return deque_iterator(self,self._reversed_impl)\n  \n def _reversed_impl(self,original_state,giveup):\n  if self.state !=original_state:\n   giveup()\n  block=self.right\n  while block:\n   l,r=0,n\n   if block is self.left:\n    l=self.leftndx\n   if block is self.right:\n    r=self.rightndx+1\n   for elem in reversed(block[l:r]):\n    yield elem\n    if self.state !=original_state:\n     giveup()\n   block=block[LFTLNK]\n   \n def __len__(self):\n \n \n \n \n \n \n  return self.length\n  \n def __getref(self,index):\n  if index >=0:\n   block=self.left\n   while block:\n    l,r=0,n\n    if block is self.left:\n     l=self.leftndx\n    if block is self.right:\n     r=self.rightndx+1\n    span=r -l\n    if index <span:\n     return block,l+index\n    index -=span\n    block=block[RGTLNK]\n  else:\n   block=self.right\n   while block:\n    l,r=0,n\n    if block is self.left:\n     l=self.leftndx\n    if block is self.right:\n     r=self.rightndx+1\n    negative_span=l -r\n    if index >=negative_span:\n     return block,r+index\n    index -=negative_span\n    block=block[LFTLNK]\n  raise IndexError(\"deque index out of range\")\n  \n def __getitem__(self,index):\n  block,index=self.__getref(index)\n  return block[index]\n  \n def __setitem__(self,index,value):\n  block,index=self.__getref(index)\n  block[index]=value\n  \n def __delitem__(self,index):\n  length=len(self)\n  if index >=0:\n   if index >=length:\n    raise IndexError(\"deque index out of range\")\n   self.rotate(-index)\n   self.popleft()\n   self.rotate(index)\n  else:\n  \n   index=index ^(2 **31)\n   if index >=length:\n    raise IndexError(\"deque index out of range\")\n   self.rotate(index)\n   self.pop()\n   self.rotate(-index)\n   \n def __reduce_ex__(self,proto):\n  return type(self),(list(self),self.maxlen)\n  \n def __hash__(self):\n \n  raise TypeError(\"deque objects are unhashable\")\n  \n def __copy__(self):\n  return self.__class__(self,self.maxlen)\n  \n  \n def __eq__(self,other):\n  if isinstance(other,deque):\n   return list(self)==list(other)\n  else:\n   return NotImplemented\n   \n def __ne__(self,other):\n  if isinstance(other,deque):\n   return list(self)!=list(other)\n  else:\n   return NotImplemented\n   \n def __lt__(self,other):\n  if isinstance(other,deque):\n   return list(self)<list(other)\n  else:\n   return NotImplemented\n   \n def __le__(self,other):\n  if isinstance(other,deque):\n   return list(self)<=list(other)\n  else:\n   return NotImplemented\n   \n def __gt__(self,other):\n  if isinstance(other,deque):\n   return list(self)>list(other)\n  else:\n   return NotImplemented\n   \n def __ge__(self,other):\n  if isinstance(other,deque):\n   return list(self)>=list(other)\n  else:\n   return NotImplemented\n   \n def __iadd__(self,other):\n  self.extend(other)\n  return self\n  \n  \nclass deque_iterator(object):\n\n def __init__(self,deq,itergen):\n  self.counter=len(deq)\n  def giveup():\n   self.counter=0\n   \n   raise RuntimeError(\"deque mutated during iteration\")\n  self._gen=itergen(deq.state,giveup)\n  \n def __next__(self):\n  res=self._gen.__next__()\n  self.counter -=1\n  return res\n  \n def __iter__(self):\n  return self\n  \nclass defaultdict(dict):\n\n def __init__(self,*args,**kwds):\n  if len(args)>0:\n   default_factory=args[0]\n   args=args[1:]\n   if not callable(default_factory)and default_factory is not None:\n    raise TypeError(\"first argument must be callable\")\n  else:\n   default_factory=None\n  dict.__init__(self,*args,**kwds)\n  self.default_factory=default_factory\n  self.update(*args,**kwds)\n  super(defaultdict,self).__init__(*args,**kwds)\n  \n def __missing__(self,key):\n \n  if self.default_factory is None:\n   raise KeyError(key)\n  self[key]=value=self.default_factory()\n  return value\n  \n def __repr__(self,recurse=set()):\n  if id(self)in recurse:\n   return \"defaultdict(...)\"\n  try:\n   recurse.add(id(self))\n   return \"defaultdict(%s, %s)\"%(repr(self.default_factory),super(defaultdict,self).__repr__())\n  finally:\n   recurse.remove(id(self))\n   \n def copy(self):\n  return type(self)(self.default_factory,self)\n  \n def __copy__(self):\n  return self.copy()\n  \n def __reduce__(self):\n \n \n \n \n \n \n \n \n \n \n \n  return(type(self),(self.default_factory,),None,None,self.items())\n  \nfrom operator import itemgetter as _itemgetter\nfrom keyword import iskeyword as _iskeyword\nimport sys as _sys\n\ndef namedtuple(typename,field_names,verbose=False,rename=False):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n if isinstance(field_names,str):\n  field_names=field_names.replace(',',' ').split()\n field_names=tuple(map(str,field_names))\n if rename:\n  names=list(field_names)\n  seen=set()\n  for i,name in enumerate(names):\n   if(not min(c.isalnum()or c =='_'for c in name)or _iskeyword(name)\n   or not name or name[0].isdigit()or name.startswith('_')\n   or name in seen):\n    names[i]='_%d'%i\n   seen.add(name)\n  field_names=tuple(names)\n for name in(typename,)+field_names:\n  if not min(c.isalnum()or c =='_'for c in name):\n   raise ValueError('Type names and field names can only contain alphanumeric characters and underscores: %r'%name)\n  if _iskeyword(name):\n   raise ValueError('Type names and field names cannot be a keyword: %r'%name)\n  if name[0].isdigit():\n   raise ValueError('Type names and field names cannot start with a number: %r'%name)\n seen_names=set()\n for name in field_names:\n  if name.startswith('_')and not rename:\n   raise ValueError('Field names cannot start with an underscore: %r'%name)\n  if name in seen_names:\n   raise ValueError('Encountered duplicate field name: %r'%name)\n  seen_names.add(name)\n  \n  \n numfields=len(field_names)\n argtxt=repr(field_names).replace(\"'\",\"\")[1:-1]\n reprtxt=', '.join('%s=%%r'%name for name in field_names)\n \n template='''class %(typename)s(tuple):\n        '%(typename)s(%(argtxt)s)' \\n\n        __slots__ = () \\n\n        _fields = %(field_names)r \\n\n        def __new__(_cls, %(argtxt)s):\n            return tuple.__new__(_cls, (%(argtxt)s)) \\n\n        @classmethod\n        def _make(cls, iterable, new=tuple.__new__, len=len):\n            'Make a new %(typename)s object from a sequence or iterable'\n            result = new(cls, iterable)\n            if len(result) != %(numfields)d:\n                raise TypeError('Expected %(numfields)d arguments, got %%d' %% len(result))\n            return result \\n\n        def __repr__(self):\n            return '%(typename)s(%(reprtxt)s)' %% self \\n\n        def _asdict(self):\n            'Return a new dict which maps field names to their values'\n            return dict(zip(self._fields, self)) \\n\n        def _replace(_self, **kwds):\n            'Return a new %(typename)s object replacing specified fields with new values'\n            result = _self._make(map(kwds.pop, %(field_names)r, _self))\n            if kwds:\n                raise ValueError('Got unexpected field names: %%r' %% kwds.keys())\n            return result \\n\n        def __getnewargs__(self):\n            return tuple(self) \\n\\n'''%locals()\n for i,name in enumerate(field_names):\n  template +='        %s = _property(_itemgetter(%d))\\n'%(name,i)\n  \n if verbose:\n  print(template)\n  \n  \n namespace=dict(_itemgetter=_itemgetter,__name__='namedtuple_%s'%typename,\n _property=property,_tuple=tuple)\n try:\n  exec(template,namespace)\n except SyntaxError as e:\n  raise SyntaxError(e.message+':\\n'+template)\n result=namespace[typename]\n \n \n \n \n \n try:\n  result.__module__=_sys._getframe(1).f_globals.get('__name__','__main__')\n except(AttributeError,ValueError):\n  pass\n  \n return result\n \nif __name__ =='__main__':\n Point=namedtuple('Point',['x','y'])\n p=Point(11,y=22)\n print(p[0]+p[1])\n x,y=p\n print(x,y)\n print(p.x+p.y)\n print(p)\n", ["keyword", "operator", "sys"]], "_compression": [".py", "''\n\nimport io\nimport sys\n\nBUFFER_SIZE=io.DEFAULT_BUFFER_SIZE\n\n\nclass BaseStream(io.BufferedIOBase):\n ''\n \n def _check_not_closed(self):\n  if self.closed:\n   raise ValueError(\"I/O operation on closed file\")\n   \n def _check_can_read(self):\n  if not self.readable():\n   raise io.UnsupportedOperation(\"File not open for reading\")\n   \n def _check_can_write(self):\n  if not self.writable():\n   raise io.UnsupportedOperation(\"File not open for writing\")\n   \n def _check_can_seek(self):\n  if not self.readable():\n   raise io.UnsupportedOperation(\"Seeking is only supported \"\n   \"on files open for reading\")\n  if not self.seekable():\n   raise io.UnsupportedOperation(\"The underlying file object \"\n   \"does not support seeking\")\n   \n   \nclass DecompressReader(io.RawIOBase):\n ''\n \n def readable(self):\n  return True\n  \n def __init__(self,fp,decomp_factory,trailing_error=(),**decomp_args):\n  self._fp=fp\n  self._eof=False\n  self._pos=0\n  \n  \n  self._size=-1\n  \n  \n  \n  \n  \n  self._decomp_factory=decomp_factory\n  self._decomp_args=decomp_args\n  self._decompressor=self._decomp_factory(**self._decomp_args)\n  \n  \n  \n  self._trailing_error=trailing_error\n  \n def close(self):\n  self._decompressor=None\n  return super().close()\n  \n def seekable(self):\n  return self._fp.seekable()\n  \n def readinto(self,b):\n  with memoryview(b)as view,view.cast(\"B\")as byte_view:\n   data=self.read(len(byte_view))\n   byte_view[:len(data)]=data\n  return len(data)\n  \n def read(self,size=-1):\n  if size <0:\n   return self.readall()\n   \n  if not size or self._eof:\n   return b\"\"\n  data=None\n  \n  \n  while True:\n   if self._decompressor.eof:\n    rawblock=(self._decompressor.unused_data or\n    self._fp.read(BUFFER_SIZE))\n    if not rawblock:\n     break\n     \n    self._decompressor=self._decomp_factory(\n    **self._decomp_args)\n    try:\n     data=self._decompressor.decompress(rawblock,size)\n    except self._trailing_error:\n    \n     break\n   else:\n    if self._decompressor.needs_input:\n     rawblock=self._fp.read(BUFFER_SIZE)\n     if not rawblock:\n      raise EOFError(\"Compressed file ended before the \"\n      \"end-of-stream marker was reached\")\n    else:\n     rawblock=b\"\"\n    data=self._decompressor.decompress(rawblock,size)\n   if data:\n    break\n  if not data:\n   self._eof=True\n   self._size=self._pos\n   return b\"\"\n  self._pos +=len(data)\n  return data\n  \n def readall(self):\n  chunks=[]\n  \n  \n  \n  while data :=self.read(sys.maxsize):\n   chunks.append(data)\n   \n  return b\"\".join(chunks)\n  \n  \n def _rewind(self):\n  self._fp.seek(0)\n  self._eof=False\n  self._pos=0\n  self._decompressor=self._decomp_factory(**self._decomp_args)\n  \n def seek(self,offset,whence=io.SEEK_SET):\n \n  if whence ==io.SEEK_SET:\n   pass\n  elif whence ==io.SEEK_CUR:\n   offset=self._pos+offset\n  elif whence ==io.SEEK_END:\n  \n   if self._size <0:\n    while self.read(io.DEFAULT_BUFFER_SIZE):\n     pass\n   offset=self._size+offset\n  else:\n   raise ValueError(\"Invalid value for whence: {}\".format(whence))\n   \n   \n  if offset <self._pos:\n   self._rewind()\n  else:\n   offset -=self._pos\n   \n   \n  while offset >0:\n   data=self.read(min(io.DEFAULT_BUFFER_SIZE,offset))\n   if not data:\n    break\n   offset -=len(data)\n   \n  return self._pos\n  \n def tell(self):\n  ''\n  return self._pos\n", ["io", "sys"]], "_functools": [".py", "from reprlib import recursive_repr\n\nclass partial:\n ''\n\n \n \n __slots__=\"func\",\"args\",\"keywords\",\"__dict__\",\"__weakref__\"\n \n def __new__(*args,**keywords):\n  if not args:\n   raise TypeError(\"descriptor '__new__' of partial needs an argument\")\n  if len(args)<2:\n   raise TypeError(\"type 'partial' takes at least one argument\")\n  cls,func,*args=args\n  if not callable(func):\n   raise TypeError(\"the first argument must be callable\")\n  args=tuple(args)\n  \n  if hasattr(func,\"func\")and isinstance(func.args,tuple):\n   args=func.args+args\n   tmpkw=func.keywords.copy()\n   tmpkw.update(keywords)\n   keywords=tmpkw\n   del tmpkw\n   func=func.func\n   \n  self=super(partial,cls).__new__(cls)\n  \n  self.func=func\n  self.args=args\n  self.keywords=keywords\n  return self\n  \n def __call__(*args,**keywords):\n  if not args:\n   raise TypeError(\"descriptor '__call__' of partial needs an argument\")\n  self,*args=args\n  newkeywords=self.keywords.copy()\n  newkeywords.update(keywords)\n  return self.func(*self.args,*args,**newkeywords)\n  \n @recursive_repr()\n def __repr__(self):\n  qualname=type(self).__qualname__\n  args=[repr(self.func)]\n  args.extend(repr(x)for x in self.args)\n  args.extend(f\"{k}={v !r}\"for(k,v)in self.keywords.items())\n  if type(self).__module__ ==\"functools\":\n   return f\"functools.{qualname}({', '.join(args)})\"\n  return f\"{qualname}({', '.join(args)})\"\n  \n def __reduce__(self):\n  return type(self),(self.func,),(self.func,self.args,\n  self.keywords or None,self.__dict__ or None)\n  \n def __setstate__(self,state):\n  if not isinstance(state,tuple):\n   raise TypeError(\"argument to __setstate__ must be a tuple\")\n  if len(state)!=4:\n   raise TypeError(f\"expected 4 items in state, got {len(state)}\")\n  func,args,kwds,namespace=state\n  if(not callable(func)or not isinstance(args,tuple)or\n  (kwds is not None and not isinstance(kwds,dict))or\n  (namespace is not None and not isinstance(namespace,dict))):\n   raise TypeError(\"invalid partial state\")\n   \n  args=tuple(args)\n  if kwds is None:\n   kwds={}\n  elif type(kwds)is not dict:\n   kwds=dict(kwds)\n  if namespace is None:\n   namespace={}\n   \n  self.__dict__=namespace\n  self.func=func\n  self.args=args\n  self.keywords=kwds\n  \ndef reduce(func,iterable,initializer=None):\n args=iter(iterable)\n if initializer is not None:\n  res=initializer\n else:\n  res=next(args)\n while True:\n  try:\n   res=func(res,next(args))\n  except StopIteration:\n   return res\n", ["reprlib"]], "_io": [".py", "''\n\n\n\nimport os\nimport abc\nimport codecs\nimport errno\n\ntry:\n from _thread import allocate_lock as Lock\nexcept ImportError:\n from _dummy_thread import allocate_lock as Lock\n \n \nfrom _io_classes import *\nimport _io_classes\n_IOBase=_io_classes._IOBase\n_RawIOBase=_io_classes._RawIOBase\n_BufferedIOBase=_io_classes._BufferedIOBase\n_TextIOBase=_io_classes._TextIOBase\n\nSEEK_SET=0\nSEEK_CUR=1\nSEEK_END=2\n\nvalid_seek_flags={0,1,2}\nif hasattr(os,'SEEK_HOLE'):\n valid_seek_flags.add(os.SEEK_HOLE)\n valid_seek_flags.add(os.SEEK_DATA)\n \n \nDEFAULT_BUFFER_SIZE=8 *1024\n\n\n\n\n\n\nBlockingIOError=BlockingIOError\n\n\ndef __open(file,mode=\"r\",buffering=-1,encoding=None,errors=None,\nnewline=None,closefd=True,opener=None):\n\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n if not isinstance(file,(str,bytes,int)):\n  raise TypeError(\"invalid file: %r\"%file)\n if not isinstance(mode,str):\n  raise TypeError(\"invalid mode: %r\"%mode)\n if not isinstance(buffering,int):\n  raise TypeError(\"invalid buffering: %r\"%buffering)\n if encoding is not None and not isinstance(encoding,str):\n  raise TypeError(\"invalid encoding: %r\"%encoding)\n if errors is not None and not isinstance(errors,str):\n  raise TypeError(\"invalid errors: %r\"%errors)\n modes=set(mode)\n if modes -set(\"axrwb+tU\")or len(mode)>len(modes):\n  raise ValueError(\"invalid mode: %r\"%mode)\n creating=\"x\"in modes\n reading=\"r\"in modes\n writing=\"w\"in modes\n appending=\"a\"in modes\n updating=\"+\"in modes\n text=\"t\"in modes\n binary=\"b\"in modes\n if \"U\"in modes:\n  if creating or writing or appending:\n   raise ValueError(\"can't use U and writing mode at once\")\n  reading=True\n if text and binary:\n  raise ValueError(\"can't have text and binary mode at once\")\n if creating+reading+writing+appending >1:\n  raise ValueError(\"can't have read/write/append mode at once\")\n if not(creating or reading or writing or appending):\n  raise ValueError(\"must have exactly one of read/write/append mode\")\n if binary and encoding is not None:\n  raise ValueError(\"binary mode doesn't take an encoding argument\")\n if binary and errors is not None:\n  raise ValueError(\"binary mode doesn't take an errors argument\")\n if binary and newline is not None:\n  raise ValueError(\"binary mode doesn't take a newline argument\")\n raw=FileIO(file,\n (creating and \"x\"or \"\")+\n (reading and \"r\"or \"\")+\n (writing and \"w\"or \"\")+\n (appending and \"a\"or \"\")+\n (updating and \"+\"or \"\"),\n closefd,opener=opener)\n line_buffering=False\n if buffering ==1 or buffering <0 and raw.isatty():\n  buffering=-1\n  line_buffering=True\n if buffering <0:\n  buffering=DEFAULT_BUFFER_SIZE\n  try:\n   bs=os.fstat(raw.fileno()).st_blksize\n  except(os.error,AttributeError):\n   pass\n  else:\n   if bs >1:\n    buffering=bs\n if buffering <0:\n  raise ValueError(\"invalid buffering size\")\n if buffering ==0:\n  if binary:\n   return raw\n  raise ValueError(\"can't have unbuffered text I/O\")\n if updating:\n  buffer=BufferedRandom(raw,buffering)\n elif creating or writing or appending:\n  buffer=BufferedWriter(raw,buffering)\n elif reading:\n  buffer=BufferedReader(raw,buffering)\n else:\n  raise ValueError(\"unknown mode: %r\"%mode)\n if binary:\n  return buffer\n text=TextIOWrapper(buffer,encoding,errors,newline,line_buffering)\n text.mode=mode\n return text\n \nopen=__open\n\ndef open_code(file):\n return __builtins__.open(file,encoding=\"utf-8\")\n \ndef text_encoding(encoding,stacklevel=2):\n if encoding is None:\n  return \"locale\"\n return encoding\n \nclass DocDescriptor:\n ''\n \n def __get__(self,obj,typ):\n  return(\n  \"open(file, mode='r', buffering=-1, encoding=None, \"\n  \"errors=None, newline=None, closefd=True)\\n\\n\"+\n  open.__doc__)\n  \nclass OpenWrapper:\n ''\n\n\n\n\n\n \n __doc__=DocDescriptor()\n \n def __new__(cls,*args,**kwargs):\n  return open(*args,**kwargs)\n  \n  \n  \n  \nclass UnsupportedOperation(ValueError,IOError):\n pass\n \n", ["_dummy_thread", "_io_classes", "_thread", "abc", "codecs", "errno", "os"]], "_struct": [".py", "\n\n\n\n\n\n\n\n\n\n\n\"\"\"Functions to convert between Python values and C structs.\nPython strings are used to hold the data representing the C struct\nand also as format strings to describe the layout of data in the C struct.\n\nThe optional first format char indicates byte order, size and alignment:\n @: native order, size & alignment (default)\n =: native order, std. size & alignment\n <: little-endian, std. size & alignment\n >: big-endian, std. size & alignment\n !: same as >\n\nThe remaining chars indicate types of args and must match exactly;\nthese can be preceded by a decimal repeat count:\n   x: pad byte (no data);\n   c:char;\n   b:signed byte;\n   B:unsigned byte;\n   h:short;\n   H:unsigned short;\n   i:int;\n   I:unsigned int;\n   l:long;\n   L:unsigned long;\n   f:float;\n   d:double.\nSpecial cases (preceding decimal count indicates length):\n   s:string (array of char); p: pascal string (with count byte).\nSpecial case (only available in native format):\n   P:an integer type that is wide enough to hold a pointer.\nSpecial case (not in native mode unless 'long long' in platform C):\n   q:long long;\n   Q:unsigned long long\nWhitespace between formats is ignored.\n\nThe variable struct.error is an exception raised on errors.\"\"\"\n\nimport math\nimport re\nimport sys\n\n\nclass StructError(Exception):\n pass\n \n \nerror=StructError\n\ndef _normalize(fmt):\n ''\n \n if re.search(r\"\\d\\s+\",fmt):\n  raise StructError(\"bad char in struct format\")\n return fmt.replace(\" \",\"\")\n \ndef unpack_int(data,index,size,le):\n bytes=[b for b in data[index:index+size]]\n if le =='little':\n  bytes.reverse()\n number=0\n for b in bytes:\n  number=number <<8 |b\n return int(number)\n \ndef unpack_signed_int(data,index,size,le):\n number=unpack_int(data,index,size,le)\n max=2 **(size *8)\n if number >2 **(size *8 -1)-1:\n  number=int(-1 *(max -number))\n return number\n \nINFINITY=1e200 *1e200\nNAN=INFINITY /INFINITY\n\nBIG_ENDIAN=0\nLITTLE_ENDIAN=1\n\ndef unpack_char(data,index,size,le):\n return data[index:index+size]\n \ndef pack_int(number,size,le):\n x=number\n res=[]\n for i in range(size):\n  res.append(x&0xff)\n  x >>=8\n if le =='big':\n  res.reverse()\n return bytes(res)\n \ndef pack_signed_int(number,size,le):\n if not isinstance(number,int):\n  raise StructError(\"argument for i,I,l,L,q,Q,h,H must be integer\")\n if number >2 **(8 *size -1)-1 or number <-1 *2 **(8 *size -1):\n  raise OverflowError(\"Number:%i too large to convert\"%number)\n return pack_int(number,size,le)\n \ndef pack_unsigned_int(number,size,le):\n if not isinstance(number,int):\n  raise StructError(\"argument for i,I,l,L,q,Q,h,H must be integer\")\n if number <0:\n  raise TypeError(\"can't convert negative long to unsigned\")\n if number >2 **(8 *size)-1:\n  raise OverflowError(\"Number:%i too large to convert\"%number)\n return pack_int(number,size,le)\n \ndef pack_char(char,size,le):\n return bytes(char)\n \ndef isinf(x):\n return x !=0.0 and x /2 ==x\n \ndef isnan(v):\n return v !=v *1.0 or(v ==1.0 and v ==2.0)\n \ndef pack_float(x,size,le):\n unsigned=float_pack(x,size)\n result=[]\n for i in range(size):\n  result.append((unsigned >>(i *8))&0xFF)\n if le ==\"big\":\n  result.reverse()\n return bytes(result)\n \ndef unpack_float(data,index,size,le):\n binary=[data[i]for i in range(index,index+size)]\n if le ==\"big\":\n  binary.reverse()\n unsigned=0\n for i in range(size):\n  unsigned |=binary[i]<<(i *8)\n return float_unpack(unsigned,size,le)\n \ndef round_to_nearest(x):\n ''\n\n\n\n\n\n\n\n\n \n int_part=int(x)\n frac_part=x -int_part\n if frac_part >0.5 or frac_part ==0.5 and int_part&1 ==1:\n  int_part +=1\n return int_part\n \ndef float_unpack(Q,size,order=LITTLE_ENDIAN):\n ''\n \n \n if size ==8:\n  MIN_EXP=-1021\n  MAX_EXP=1024\n  MANT_DIG=53\n  BITS=64\n elif size ==4:\n  MIN_EXP=-125\n  MAX_EXP=128\n  MANT_DIG=24\n  BITS=32\n else:\n  raise ValueError(\"invalid size value\")\n  \n if Q >>BITS:\n  raise ValueError(\"input out of range\")\n  \n  \n sign=Q >>BITS -1\n exp=(Q&((1 <<BITS -1)-(1 <<MANT_DIG -1)))>>MANT_DIG -1\n mant=Q&((1 <<MANT_DIG -1)-1)\n \n if exp ==MAX_EXP -MIN_EXP+2:\n \n  result=float('nan')if mant else float('inf')\n elif exp ==0:\n \n  result=math.ldexp(float(mant),MIN_EXP -MANT_DIG)\n else:\n \n  mant +=1 <<MANT_DIG -1\n  result=math.ldexp(float(mant),exp+MIN_EXP -MANT_DIG -1)\n return -result if sign else result\n \n \ndef float_pack(x,size,order=LITTLE_ENDIAN):\n ''\n \n \n if size ==8:\n  MIN_EXP=-1021\n  MAX_EXP=1024\n  MANT_DIG=53\n  BITS=64\n elif size ==4:\n  MIN_EXP=-125\n  MAX_EXP=128\n  MANT_DIG=24\n  BITS=32\n else:\n  raise ValueError(\"invalid size value\")\n  \n sign=math.copysign(1.0,x)<0.0\n if math.isinf(x):\n  mant=0\n  exp=MAX_EXP -MIN_EXP+2\n elif math.isnan(x):\n  mant=1 <<(MANT_DIG -2)\n  exp=MAX_EXP -MIN_EXP+2\n elif x ==0.0:\n  mant=0\n  exp=0\n else:\n  m,e=math.frexp(abs(x))\n  exp=e -(MIN_EXP -1)\n  if exp >0:\n  \n   mant=round_to_nearest(m *(1 <<MANT_DIG))\n   mant -=1 <<MANT_DIG -1\n  else:\n  \n   if exp+MANT_DIG -1 >=0:\n    mant=round_to_nearest(m *(1 <<exp+MANT_DIG -1))\n   else:\n    mant=0\n   exp=0\n   \n   \n  assert 0 <=mant <=1 <<MANT_DIG -1\n  if mant ==1 <<MANT_DIG -1:\n   mant=0\n   exp +=1\n   \n   \n   \n  if exp >=MAX_EXP -MIN_EXP+2:\n   raise OverflowError(\"float too large to pack in this format\")\n   \n   \n assert 0 <=mant <1 <<MANT_DIG -1\n assert 0 <=exp <=MAX_EXP -MIN_EXP+2\n assert 0 <=sign <=1\n return((sign <<BITS -1)|(exp <<MANT_DIG -1))|mant\n \n \nbig_endian_format={\n'x':{'size':1,'alignment':0,'pack':None,'unpack':None},\n'b':{'size':1,'alignment':0,'pack':pack_signed_int,'unpack':unpack_signed_int},\n'B':{'size':1,'alignment':0,'pack':pack_unsigned_int,'unpack':unpack_int},\n'c':{'size':1,'alignment':0,'pack':pack_char,'unpack':unpack_char},\n's':{'size':1,'alignment':0,'pack':None,'unpack':None},\n'p':{'size':1,'alignment':0,'pack':None,'unpack':None},\n'h':{'size':2,'alignment':0,'pack':pack_signed_int,'unpack':unpack_signed_int},\n'H':{'size':2,'alignment':0,'pack':pack_unsigned_int,'unpack':unpack_int},\n'i':{'size':4,'alignment':0,'pack':pack_signed_int,'unpack':unpack_signed_int},\n'I':{'size':4,'alignment':0,'pack':pack_unsigned_int,'unpack':unpack_int},\n'l':{'size':4,'alignment':0,'pack':pack_signed_int,'unpack':unpack_signed_int},\n'L':{'size':4,'alignment':0,'pack':pack_unsigned_int,'unpack':unpack_int},\n'q':{'size':8,'alignment':0,'pack':pack_signed_int,'unpack':unpack_signed_int},\n'Q':{'size':8,'alignment':0,'pack':pack_unsigned_int,'unpack':unpack_int},\n'f':{'size':4,'alignment':0,'pack':pack_float,'unpack':unpack_float},\n'd':{'size':8,'alignment':0,'pack':pack_float,'unpack':unpack_float},\n'P':{'size':8,'alignment':0,'pack':pack_unsigned_int,'unpack':unpack_int}\n}\n\ndefault=big_endian_format\n\nformatmode={'<':(default,'little'),\n'>':(default,'big'),\n'!':(default,'big'),\n'=':(default,sys.byteorder),\n'@':(default,sys.byteorder)\n}\n\ndef _getmode(fmt):\n try:\n  formatdef,endianness=formatmode[fmt[0]]\n  alignment=fmt[0]not in formatmode or fmt[0]=='@'\n  index=1\n except(IndexError,KeyError):\n  formatdef,endianness=formatmode['@']\n  alignment=True\n  index=0\n return formatdef,endianness,index,alignment\n \ndef _getnum(fmt,i):\n num=None\n cur=fmt[i]\n while('0'<=cur)and(cur <='9'):\n  if num ==None:\n   num=int(cur)\n  else:\n   num=10 *num+int(cur)\n  i +=1\n  cur=fmt[i]\n return num,i\n \ndef calcsize(fmt):\n ''\n\n \n if isinstance(fmt,bytes):\n  fmt=fmt.decode(\"ascii\")\n  \n fmt=_normalize(fmt)\n \n formatdef,endianness,i,alignment=_getmode(fmt)\n num=0\n result=0\n while i <len(fmt):\n  num,i=_getnum(fmt,i)\n  cur=fmt[i]\n  try:\n   format=formatdef[cur]\n  except KeyError:\n   raise StructError(\"%s is not a valid format\"%cur)\n  if num !=None:\n   result +=num *format['size']\n  else:\n  \n  \n   if alignment and result:\n    result +=format['size']-result %format['size']\n   result +=format['size']\n  num=0\n  i +=1\n return result\n \ndef pack(fmt,*args):\n ''\n\n \n fmt=_normalize(fmt)\n formatdef,endianness,i,alignment=_getmode(fmt)\n args=list(args)\n n_args=len(args)\n result=[]\n while i <len(fmt):\n  num,i=_getnum(fmt,i)\n  cur=fmt[i]\n  try:\n   format=formatdef[cur]\n  except KeyError:\n   raise StructError(\"%s is not a valid format\"%cur)\n  if num ==None:\n   num_s=0\n   num=1\n  else:\n   num_s=num\n   \n  if cur =='x':\n   result +=[b'\\0'*num]\n  elif cur =='s':\n   if isinstance(args[0],bytes):\n    padding=num -len(args[0])\n    result +=[args[0][:num]+b'\\0'*padding]\n    args.pop(0)\n   else:\n    raise StructError(\"arg for string format not a string\")\n  elif cur =='p':\n   if isinstance(args[0],bytes):\n    padding=num -len(args[0])-1\n    \n    if padding >0:\n     result +=[bytes([len(args[0])])+args[0][:num -1]+\n     b'\\0'*padding]\n    else:\n     if num <255:\n      result +=[bytes([num -1])+args[0][:num -1]]\n     else:\n      result +=[bytes([255])+args[0][:num -1]]\n    args.pop(0)\n   else:\n    raise StructError(\"arg for string format not a string\")\n    \n  else:\n   if len(args)<num:\n    raise StructError(\"insufficient arguments to pack\")\n   if len(result)and alignment:\n   \n    padding=format['size']-len(result)%format['size']\n    result +=[bytes([0])]*padding\n   for var in args[:num]:\n    result +=[format['pack'](var,format['size'],endianness)]\n   args=args[num:]\n  num=None\n  i +=1\n if len(args)!=0:\n  raise StructError(\"too many arguments for pack format\")\n return b''.join(result)\n \ndef unpack(fmt,data):\n ''\n\n\n \n fmt=_normalize(fmt)\n formatdef,endianness,i,alignment=_getmode(fmt)\n j=0\n num=0\n result=[]\n length=calcsize(fmt)\n if length !=len(data):\n  raise StructError(\"unpack str size does not match format\")\n while i <len(fmt):\n  num,i=_getnum(fmt,i)\n  cur=fmt[i]\n  i +=1\n  try:\n   format=formatdef[cur]\n  except KeyError:\n   raise StructError(\"%s is not a valid format\"%cur)\n   \n  if not num:\n   num=1\n   \n  if cur =='x':\n   j +=num\n  elif cur =='s':\n   result.append(data[j:j+num])\n   j +=num\n  elif cur =='p':\n   n=data[j]\n   if n >=num:\n    n=num -1\n   result.append(data[j+1:j+n+1])\n   j +=num\n  else:\n  \n   if j >0 and alignment:\n    padding=format['size']-j %format['size']\n    j +=padding\n   for n in range(num):\n    result +=[format['unpack'](data,j,format['size'],\n    endianness)]\n    j +=format['size']\n    \n return tuple(result)\n \ndef pack_into(fmt,buf,offset,*args):\n data=pack(fmt,*args)\n buf[offset:offset+len(data)]=data\n \ndef unpack_from(fmt,buf,offset=0):\n size=calcsize(fmt)\n data=buf[offset:offset+size]\n if len(data)!=size:\n  raise error(\"unpack_from requires a buffer of at least %d bytes\"\n  %(size,))\n return unpack(fmt,data)\n \ndef _clearcache():\n ''\n \n \nclass Struct:\n\n def __init__(self,fmt):\n  self.format=fmt\n  \n def pack(self,*args):\n  return pack(self.format,*args)\n  \n def pack_into(self,*args):\n  return pack_into(self.format,*args)\n  \n def unpack(self,*args):\n  return unpack(self.format,*args)\n  \n def unpack_from(self,*args):\n  return unpack_from(self.format,*args)\n  \nif __name__ =='__main__':\n t=pack('Bf',1,2)\n print(t,len(t))\n print(unpack('Bf',t))\n print(calcsize('Bf'))\n \n", ["math", "re", "sys"]], "_typing": [".py", "\n\nGenericAlias=type(list[str])\n\nclass Typing:\n\n def __getattr__(self,attr):\n  import typing\n  return getattr(typing,attr)\n  \ntyping=Typing()\n\nNoDefault=\"typing.NoDefault\"\n\ndef _idfunc(_,x):\n return x\n \ndef _caller():\n import sys\n frame=sys._getframe()\n module_name=frame.f_back.f_globals[\"__name__\"]\n return sys.modules[module_name]\n \ndef _call_typing_func(name,*args,**kwargs):\n import typing\n func=getattr(typing,name)\n return func(*args,**kwargs)\n \ndef _get_typing_obj(name):\n import typing\n return getattr(typing,name)\n \ndef _type_check(t,msg):\n assert isinstance(t,type),msg\n \ndef _type_convert(arg,module=None,*,allow_special_forms=False):\n ''\n if arg is None:\n  return type(None)\n if isinstance(arg,str):\n  return ForwardRef(arg,module=module,is_class=allow_special_forms)\n return arg\n \nclass ForwardRef:\n ''\n \n __slots__=('__forward_arg__','__forward_code__',\n '__forward_evaluated__','__forward_value__',\n '__forward_is_argument__','__forward_is_class__',\n '__forward_module__')\n \n def __init__(self,arg,is_argument=True,module=None,*,is_class=False):\n  if not isinstance(arg,str):\n   raise TypeError(f\"Forward reference must be a string -- got {arg !r}\")\n   \n   \n   \n   \n  if arg[0]=='*':\n   arg_to_compile=f'({arg},)[0]'\n  else:\n   arg_to_compile=arg\n  try:\n   code=compile(arg_to_compile,'<string>','eval')\n  except SyntaxError:\n   raise SyntaxError(f\"Forward reference must be an expression -- got {arg !r}\")\n   \n  self.__forward_arg__=arg\n  self.__forward_code__=code\n  self.__forward_evaluated__=False\n  self.__forward_value__=None\n  self.__forward_is_argument__=is_argument\n  self.__forward_is_class__=is_class\n  self.__forward_module__=module\n  \n def _evaluate(self,globalns,localns,recursive_guard):\n  if self.__forward_arg__ in recursive_guard:\n   return self\n  if not self.__forward_evaluated__ or localns is not globalns:\n   if globalns is None and localns is None:\n    globalns=localns={}\n   elif globalns is None:\n    globalns=localns\n   elif localns is None:\n    localns=globalns\n   if self.__forward_module__ is not None:\n    globalns=getattr(\n    sys.modules.get(self.__forward_module__,None),'__dict__',globalns\n    )\n   type_=_type_check(\n   eval(self.__forward_code__,globalns,localns),\n   \"Forward references must evaluate to types.\",\n   is_argument=self.__forward_is_argument__,\n   allow_special_forms=self.__forward_is_class__,\n   )\n   self.__forward_value__=_eval_type(\n   type_,globalns,localns,recursive_guard |{self.__forward_arg__}\n   )\n   self.__forward_evaluated__=True\n  return self.__forward_value__\n  \n def __eq__(self,other):\n  if not isinstance(other,ForwardRef):\n   return NotImplemented\n  if self.__forward_evaluated__ and other.__forward_evaluated__:\n   return(self.__forward_arg__ ==other.__forward_arg__ and\n   self.__forward_value__ ==other.__forward_value__)\n  return(self.__forward_arg__ ==other.__forward_arg__ and\n  self.__forward_module__ ==other.__forward_module__)\n  \n def __hash__(self):\n  return hash((self.__forward_arg__,self.__forward_module__))\n  \n def __or__(self,other):\n  return Union[self,other]\n  \n def __ror__(self,other):\n  return Union[other,self]\n  \n def __repr__(self):\n  if self.__forward_module__ is None:\n   module_repr=''\n  else:\n   module_repr=f', module={self.__forward_module__ !r}'\n  return f'ForwardRef({self.__forward_arg__ !r}{module_repr})'\n  \nclass TypeVar:\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n __module__='typing'\n \n \n def __init__(self,name,*constraints,bound=None,\n covariant=False,contravariant=False,\n infer_variance=False,default=NoDefault):\n  self.__name__=name\n  if constraints and bound is not None:\n   raise TypeError(\"Constraints cannot be combined with bound=...\")\n  if constraints and len(constraints)==1:\n   raise TypeError(\"A single constraint is not allowed\")\n  msg=\"TypeVar(name, constraint, ...): constraints must be types.\"\n  self.__bound__=bound\n  self.__constraints__=tuple(_type_check(t,msg)for t in constraints)\n  self.__module__='typing'\n  self.__covariant__=covariant\n  self.__contravariant__=contravariant\n  self.__default__=default\n  self.__infer_variance__=infer_variance\n  self._has_default=default !=NoDefault\n  self._lazy_eval={}\n  \n def __typing_prepare_subst__(self,alias,args):\n  params=alias.__parameters__\n  if self not in params:\n   return\n  i=params.index(self)\n  if i <len(args):\n   return args\n  elif i ==len(args):\n   default=self.__default__\n   if default !=NoDefault:\n    return(default,)+args\n  raise TypeError(\n  \"Too few arguments for %S; actual %d, expected at least %d\".format(\n  alias,len(args),i+1))\n  \n def __typing_subst__(self,arg):\n  msg=\"Parameters to generic types must be types.\"\n  arg=_type_check(arg,msg,is_argument=True)\n  if((isinstance(arg,_GenericAlias)and arg.__origin__ is Unpack)or\n  (isinstance(arg,GenericAlias)and getattr(arg,'__unpacked__',False))):\n   raise TypeError(f\"{arg} is not valid as type argument\")\n  return arg\n  \n def __repr__(self):\n  if self.__infer_variance__:\n   return self.__name__\n   \n  variance='+'if self.__covariant__ else\\\n  '-'if self.__contravariant__ else '~'\n  return f\"{variance}{self.__name__}\"\n  \n def _set_lazy_eval(self,attr,func):\n  self._lazy_eval[attr]=func\n  \n def __getattribute__(self,attr):\n  try:\n   _lazy_eval=object.__getattribute__(self,'_lazy_eval')\n  except AttributeError:\n   return super().__getattribute__(attr)\n  if attr in _lazy_eval:\n   try:\n    return _lazy_eval[attr]()\n   except Exception as exc:\n    tb=exc.__traceback__\n    exc.__traceback__=exc.__traceback__.tb_next\n    raise\n  return super().__getattribute__(attr)\n  \n def has_default(self):\n  return self._has_default\n  \nclass TypeVarTuple:\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n __module__='typing'\n \n def __init__(self,name):\n  self.__name__=name\n  \n  \n  def_mod=_caller()\n  if def_mod !='typing':\n   self.__module__=def_mod\n   \n def __iter__(self):\n  yield Unpack[self]\n  \n def __repr__(self):\n  return self.__name__\n  \n def __typing_subst__(self,arg):\n  raise TypeError(\"Substitution of bare TypeVarTuple is not supported\")\n  \n def __typing_prepare_subst__(self,alias,args):\n  params=alias.__parameters__\n  typevartuple_index=params.index(self)\n  for param in params[typevartuple_index+1:]:\n   if isinstance(param,TypeVarTuple):\n    raise TypeError(f\"More than one TypeVarTuple parameter in {alias}\")\n    \n  alen=len(args)\n  plen=len(params)\n  left=typevartuple_index\n  right=plen -typevartuple_index -1\n  var_tuple_index=None\n  fillarg=None\n  for k,arg in enumerate(args):\n   if not isinstance(arg,type):\n    subargs=getattr(arg,'__typing_unpacked_tuple_args__',None)\n    if subargs and len(subargs)==2 and subargs[-1]is ...:\n     if var_tuple_index is not None:\n      raise TypeError(\"More than one unpacked arbitrary-length tuple argument\")\n     var_tuple_index=k\n     fillarg=subargs[0]\n  if var_tuple_index is not None:\n   left=min(left,var_tuple_index)\n   right=min(right,alen -var_tuple_index -1)\n  elif left+right >alen:\n   raise TypeError(f\"Too few arguments for {alias};\"\n   f\" actual {alen}, expected at least {plen -1}\")\n   \n  return(\n  *args[:left],\n  *([fillarg]*(typevartuple_index -left)),\n  tuple(args[left:alen -right]),\n  *([fillarg]*(plen -right -left -typevartuple_index -1)),\n  *args[alen -right:],\n  )\n  \n  \nclass ParamSpecArgs:\n ''\n\n\n\n\n\n\n\n\n\n \n \n __module__='typing'\n \n def __init__(self,origin):\n  self.__origin__=origin\n  \n def __repr__(self):\n  return f\"{self.__origin__.__name__}.args\"\n  \n def __eq__(self,other):\n  if not isinstance(other,ParamSpecArgs):\n   return NotImplemented\n  return self.__origin__ ==other.__origin__\n  \n  \nclass ParamSpecKwargs:\n ''\n\n\n\n\n\n\n\n\n\n \n \n __module__='typing'\n \n def __init__(self,origin):\n  self.__origin__=origin\n  \n def __repr__(self):\n  return f\"{self.__origin__.__name__}.kwargs\"\n  \n def __eq__(self,other):\n  if not isinstance(other,ParamSpecKwargs):\n   return NotImplemented\n  return self.__origin__ ==other.__origin__\n  \n  \nclass ParamSpec:\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n __module__='typing'\n \n @property\n def args(self):\n  return ParamSpecArgs(self)\n  \n @property\n def kwargs(self):\n  return ParamSpecKwargs(self)\n  \n def __init__(self,name,*,bound=None,\n covariant=False,contravariant=False,\n infer_variance=True,\n default=None):\n  self.__name__=name\n  super().__init__(bound,covariant,contravariant)\n  def_mod=_caller()\n  if def_mod !='typing':\n   self.__module__=def_mod\n  self.__module__='typing'\n  self.__covariant__=covariant\n  self.__contravariant__=contravariant\n  self.__infer_variance__=infer_variance\n  self.default=default\n  \n def __repr__(self):\n  if self.__infer_variance__:\n   return self.__name__\n   \n  variance='+'if self.__covariant__ else\\\n  '-'if self.__contravariant__ else '~'\n  return f\"{variance}{self.__name__}\"\n  \n def __typing_subst__(self,arg):\n  if isinstance(arg,(list,tuple)):\n   arg=tuple(_type_check(a,\"Expected a type.\")for a in arg)\n  elif not _is_param_expr(arg):\n   raise TypeError(f\"Expected a list of types, an ellipsis, \"\n   f\"ParamSpec, or Concatenate. Got {arg}\")\n  return arg\n  \n def __typing_prepare_subst__(self,alias,args):\n  params=alias.__parameters__\n  i=params.index(self)\n  if i >=len(args):\n   raise TypeError(f\"Too few arguments for {alias}\")\n   \n  if len(params)==1 and not _is_param_expr(args[0]):\n   assert i ==0\n   args=(args,)\n   \n  elif isinstance(args[i],list):\n   args=(*args[:i],tuple(args[i]),*args[i+1:])\n  return args\n  \n def has_default(self):\n  return self.default is not None\n  \n  \nclass Generic:\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n __slots__=()\n _is_protocol=False\n \n def __class_getitem__(cls,params):\n  ''\n\n\n\n\n\n\n\n  \n  return typing._generic_class_getitem(cls,params)\n  \n def __init_subclass__(cls,*args,**kwargs):\n  return typing._generic_init_subclass(cls,*args,**kwargs)\n  \nclass TypeAliasType:\n\n def __init__(self,name,value,type_params=None):\n  self.__name__=name\n  self.__qualname__=name\n  self.__type_params__=()if type_params is None else type_params\n  self._value=value\n  \n def __getitem__(self,params):\n  if not hasattr(self,'__type_params__'):\n   raise TypeError(\"Only generic type aliases are subscriptable\")\n  return GenericAlias(self,params)\n  \n @property\n def __value__(self):\n  return self._value()\n", ["sys", "typing"]], "browser": [".py", "", [], 1], "browser.ajax": [".py", "from _ajax import *\n", ["_ajax"]], "browser.highlight": [".py", "import re\n\nfrom browser import html\n\nletters='abcdefghijklmnopqrstuvwxyz'\nletters +=letters.upper()+'_'\ndigits='0123456789'\n\nbuiltin_funcs=\"\"\"abs|dict|help|min|setattr|\nall|dir|hex|next|slice|\nany|divmod|id|object|sorted|\nascii|enumerate|input|oct|staticmethod|\nbin|eval|int|open|str|\nbool|exec|isinstance|ord|sum|\nbytearray|filter|issubclass|pow|super|\nbytes|float|iter|print|tuple|\ncallable|format|len|property|type|\nchr|frozenset|list|range|vars|\nclassmethod|getattr|locals|repr|zip|\ncompile|globals|map|reversed|__import__|\ncomplex|hasattr|max|round|\ndelattr|hash|memoryview|set|\n\"\"\"\n\nkeywords=[\n'False',\n'None',\n'True',\n'and',\n'as',\n'assert',\n'async',\n'await',\n'break',\n'class',\n'continue',\n'def',\n'del',\n'elif',\n'else',\n'except',\n'finally',\n'for',\n'from',\n'global',\n'if',\n'import',\n'in',\n'is',\n'lambda',\n'nonlocal',\n'not',\n'or',\n'pass',\n'raise',\n'return',\n'try',\n'while',\n'with',\n'yield',\n]\nkw_pattern='^('+'|'.join(keywords)+')$'\nbf_pattern='^('+builtin_funcs.replace(\"\\n\",\"\")+')$'\n\ndef escape(txt):\n txt=txt.replace('<','&lt;')\n txt=txt.replace('>','&gt;')\n return txt\n \ndef highlight(txt):\n res=html.PRE()\n i=0\n name=''\n while i <len(txt):\n  car=txt[i]\n  if car in[\"'\",'\"']:\n   mul_car=txt[i:i+3]\n   if mul_car in[\"'''\",'\"\"\"']:\n    car=mul_car\n   found_match=False\n   k=i+len(car)\n   while k <len(txt):\n    k=txt.find(car,k)\n    if k !=-1:\n     nb_as,j=0,k -1\n     while txt[j]=='\\\\':\n      nb_as +=1\n      j -=1\n     if nb_as %2 ==0:\n      res <=name+html.SPAN(escape(txt[i:k+len(car)]),\n      Class=\"python-string\")\n      i=k+len(car)-1\n      name=''\n      found_match=True\n      break\n    else:\n     break\n    k +=len(car)\n   if not found_match:\n    name +=car\n  elif car =='#':\n   end=txt.find('\\n',i)\n   if end ==-1:\n    res <=html.SPAN(escape(txt[i:]),Class=\"python-comment\")\n    break\n   else:\n    res <=html.SPAN(escape(txt[i:end]),Class=\"python-comment\")\n    i=end -1\n  elif car in letters:\n   name +=car\n  elif car in digits and name:\n   name +=car\n  else:\n   if name:\n    if re.search(kw_pattern,name):\n     res <=html.SPAN(name,Class=\"python-keyword\")\n    elif re.search(bf_pattern,name):\n     res <=html.SPAN(name,Class=\"python-builtin\")\n    else:\n     res <=name\n    name=''\n   res <=car\n  i +=1\n res <=name\n return res\n", ["browser", "re"]], "browser.markdown": [".py", "\n\nimport re\n\nimport random\n\nletters='abcdefghijklmnopqrstuvwxyz'\nletters +=letters.upper()+'0123456789'\n\nclass URL:\n\n def __init__(self,src):\n  elts=src.split(maxsplit=1)\n  self.href=elts[0]\n  self.alt=''\n  if len(elts)==2:\n   alt=elts[1]\n   if alt[0]=='\"'and alt[-1]=='\"':\n    self.alt=alt[1:-1]\n   elif alt[0]==\"'\"and alt[-1]==\"'\":\n    self.alt=alt[1:-1]\n   elif alt[0]==\"(\"and alt[-1]==\")\":\n    self.alt=alt[1:-1]\n    \n    \nclass CodeBlock:\n\n def __init__(self,line):\n  self.lines=[line]\n  if line.startswith(\"```\"):\n   if len(line)>3:\n    self.info=line[3:]\n   else:\n    self.info=\"block\"\n  elif line.startswith(\"`\")and len(line)>1:\n   self.info=line[1:]\n  elif line.startswith(\">>>\"):\n   self.info=\"python-console\"\n  else:\n   self.info=None\n   \n def to_html(self):\n  if self.lines[0].startswith(\"`\"):\n   self.lines.pop(0)\n  res=escape('\\n'.join(self.lines))\n  res=unmark(res)\n  _class=self.info or \"marked\"\n  res='<pre class=\"%s\">%s</pre>\\n'%(_class,res)\n  return res,[]\n  \n  \nclass Marked:\n\n def __init__(self,line=''):\n  self.line=line\n  self.children=[]\n  \n def to_html(self):\n  return apply_markdown(self.line)\n  \n  \nclass Script:\n\n def __init__(self,src):\n  self.src=src\n  \n def to_html(self):\n  return self.src,[]\n  \n  \n  \nrefs={}\nref_pattern=r\"^\\[(.*)\\]:\\s+(.*)\"\n\ndef mark(src):\n\n global refs\n refs={}\n \n \n \n \n \n \n \n \n src=src.replace('\\r\\n','\\n')\n \n \n src=re.sub(r'(.*?)\\n=+\\n','\\n# \\\\1\\n',src)\n src=re.sub(r'(.*?)\\n-+\\n','\\n## \\\\1\\n',src)\n \n lines=src.split('\\n')+['']\n \n i=bq=0\n ul=ol=0\n \n while i <len(lines):\n \n \n  if lines[i].startswith('>'):\n   nb=1\n   while nb <len(lines[i])and lines[i][nb]=='>':\n    nb +=1\n   lines[i]=lines[i][nb:]\n   if nb >bq:\n    lines.insert(i,'<blockquote>'*(nb -bq))\n    i +=1\n    bq=nb\n   elif nb <bq:\n    lines.insert(i,'</blockquote>'*(bq -nb))\n    i +=1\n    bq=nb\n  elif bq >0:\n   lines.insert(i,'</blockquote>'*bq)\n   i +=1\n   bq=0\n   \n   \n  if(lines[i].strip()and lines[i].lstrip()[0]in '-+*'\n  and len(lines[i].lstrip())>1\n  and lines[i].lstrip()[1]==' '\n  and(i ==0 or ul or not lines[i -1].strip())):\n  \n   nb=1+len(lines[i])-len(lines[i].lstrip())\n   lines[i]='<li>'+lines[i][nb:]\n   if nb >ul:\n    lines.insert(i,'<ul>'*(nb -ul))\n    i +=1\n   elif nb <ul:\n    lines.insert(i,'</ul>'*(ul -nb))\n    i +=1\n   ul=nb\n  elif ul and not lines[i].strip():\n   if(i <len(lines)-1 and lines[i+1].strip()\n   and not lines[i+1].startswith(' ')):\n    nline=lines[i+1].lstrip()\n    if nline[0]in '-+*'and len(nline)>1 and nline[1]==' ':\n     pass\n    else:\n     lines.insert(i,'</ul>'*ul)\n     i +=1\n     ul=0\n     \n     \n  mo=re.search(r'^(\\d+\\.)',lines[i])\n  if mo:\n   if not ol:\n    lines.insert(i,'<ol>')\n    i +=1\n   lines[i]='<li>'+lines[i][len(mo.groups()[0]):]\n   ol=1\n  elif(ol and not lines[i].strip()and i <len(lines)-1\n  and not lines[i+1].startswith(' ')\n  and not re.search(r'^(\\d+\\.)',lines[i+1])):\n   lines.insert(i,'</ol>')\n   i +=1\n   ol=0\n   \n  i +=1\n  \n if ul:\n  lines.append('</ul>'*ul)\n if ol:\n  lines.append('</ol>'*ol)\n if bq:\n  lines.append('</blockquote>'*bq)\n  \n sections=[]\n scripts=[]\n section=Marked()\n \n i=0\n while i <len(lines):\n  line=lines[i]\n  if line.strip()and line.startswith('    '):\n   if isinstance(section,Marked)and section.line:\n    sections.append(section)\n   section=CodeBlock(line[4:])\n   j=i+1\n   while j <len(lines)and lines[j].startswith('    '):\n    section.lines.append(lines[j][4:])\n    j +=1\n   sections.append(section)\n   section=Marked()\n   i=j\n   continue\n   \n  elif line.strip()and line.startswith(\"```\"):\n  \n   if isinstance(section,Marked)and section.line:\n    sections.append(section)\n   section=CodeBlock(line)\n   j=i+1\n   while j <len(lines)and not lines[j].startswith(\"```\"):\n    section.lines.append(lines[j])\n    j +=1\n   sections.append(section)\n   section=Marked()\n   i=j+1\n   continue\n   \n  elif line.lower().startswith('<script'):\n   if isinstance(section,Marked)and section.line:\n    sections.append(section)\n   j=i+1\n   while j <len(lines):\n    if lines[j].lower().startswith('</script>'):\n     sections.append(Script('\\n'.join(lines[i:j+1])))\n     for k in range(i,j+1):\n      lines[k]=''\n     section=Marked()\n     break\n    j +=1\n   i=j\n   continue\n   \n   \n  elif line.startswith('#'):\n   level=1\n   line=lines[i]\n   while level <len(line)and line[level]=='#'and level <=6:\n    level +=1\n   if not line[level+1:].strip():\n    if level ==1:\n     i +=1\n     continue\n    else:\n     lines[i]='<H%s>%s</H%s>\\n'%(level -1,'#',level -1)\n   else:\n    lines[i]='<H%s>%s</H%s>\\n'%(level,line[level+1:],level)\n    \n  else:\n   mo=re.search(ref_pattern,line)\n   if mo is not None:\n    if isinstance(section,Marked)and section.line:\n     sections.append(section)\n     section=Marked()\n    key=mo.groups()[0]\n    value=URL(mo.groups()[1])\n    refs[key.lower()]=value\n   else:\n    if not line.strip():\n     line='<p></p>'\n    if section.line:\n     section.line +='\\n'\n    section.line +=line\n    \n   i +=1\n   \n if isinstance(section,Marked)and section.line:\n  sections.append(section)\n  \n res=''\n for section in sections:\n  mk,_scripts=section.to_html()\n  res +=mk\n  scripts +=_scripts\n  \n return res,scripts\n \ndef escape(czone):\n czone=czone.replace('&','&amp;')\n czone=czone.replace('<','&lt;')\n czone=czone.replace('>','&gt;')\n czone=czone.replace('_','&#95;')\n czone=czone.replace('*','&#42;')\n return czone\n \ndef s_escape(mo):\n\n czone=mo.string[mo.start():mo.end()]\n return escape(czone)\n \ndef unmark(code_zone):\n\n code_zone=code_zone.replace('_','&#95;')\n return code_zone\n \ndef s_unmark(mo):\n\n code_zone=mo.string[mo.start():mo.end()]\n code_zone=code_zone.replace('_','&#95;')\n return code_zone\n \ndef apply_markdown(src):\n\n scripts=[]\n key=None\n \n i=0\n while i <len(src):\n  if src[i]=='[':\n   img_link=i >0 and src[i -1]=='!'\n   start_a=i+1\n   nb=1\n   while True:\n    end_a=src.find(']',i)\n    if end_a ==-1:\n     break\n    nb +=src[i+1:end_a].count('[')-1\n    i=end_a+1\n    if nb ==0:\n     break\n   if end_a >-1 and src[start_a:end_a].find('\\n')==-1:\n    link=src[start_a:end_a]\n    rest=src[end_a+1:].lstrip()\n    if rest and rest[0]=='(':\n     j=0\n     while True:\n      end_href=rest.find(')',j)\n      if end_href ==-1:\n       break\n      if rest[end_href -1]=='\\\\':\n       j=end_href+1\n      else:\n       break\n     if end_href >-1 and rest[:end_href].find('\\n')==-1:\n      if img_link:\n       tag=('<img src=\"'+rest[1:end_href]+\n       '\" alt=\"'+link+'\">')\n       src=src[:start_a -2]+tag+rest[end_href+1:]\n      else:\n       tag=('<a href=\"'+rest[1:end_href]+'\">'+link\n       +'</a>')\n       src=src[:start_a -1]+tag+rest[end_href+1:]\n      i=start_a+len(tag)\n    elif rest and rest[0]=='[':\n     j=0\n     while True:\n      end_key=rest.find(']',j)\n      if end_key ==-1:\n       break\n      if rest[end_key -1]=='\\\\':\n       j=end_key+1\n      else:\n       break\n     if end_key >-1 and rest[:end_key].find('\\n')==-1:\n      if not key:\n       key=link\n      if key.lower()not in refs:\n       raise KeyError('unknown reference %s'%key)\n      url=refs[key.lower()]\n      tag='<a href=\"'+url+'\">'+link+'</a>'\n      src=src[:start_a -1]+tag+rest[end_key+1:]\n      i=start_a+len(tag)\n      \n  i +=1\n  \n  \n  \n  \n  \n  \n  \n  \n  \n rstr=' '+''.join(random.choice(letters)for i in range(16))+' '\n \n i=0\n state=None\n start=-1\n data=''\n tags=[]\n while i <len(src):\n  if src[i]=='<':\n   j=i+1\n   while j <len(src):\n    if src[j]=='\"'or src[j]==\"'\":\n     if state ==src[j]and src[j -1]!='\\\\':\n      state=None\n      j=start+len(data)+1\n      data=''\n     elif state is None:\n      state=src[j]\n      start=j\n     else:\n      data +=src[j]\n    elif src[j]=='>'and state is None:\n     tags.append(src[i:j+1])\n     src=src[:i]+rstr+src[j+1:]\n     i +=len(rstr)\n     break\n    elif state =='\"'or state ==\"'\":\n     data +=src[j]\n    elif src[j]=='\\n':\n    \n    \n     src=src[:i]+'&lt;'+src[i+1:]\n     j=i+4\n     break\n    j +=1\n  elif src[i]=='`'and i >0:\n   if src[i -1]!='\\\\':\n   \n    j=i+1\n    while j <len(src):\n     if src[j]=='`'and src[j -1]!='\\\\':\n      break\n     j +=1\n    i=j\n   else:\n   \n    src=src[:i -1]+\"&#96;\"+src[i+1:]\n  i +=1\n  \n  \n code_pattern=r'\\`(.*?)\\`'\n src=re.sub(code_pattern,s_escape,src)\n \n \n src=src.replace(r'\\\\`','&#96;')\n src=src.replace(r'\\_','&#95;')\n src=src.replace(r'\\*','&#42;')\n \n \n strong_patterns=[('STRONG',r'\\*\\*(.+?)\\*\\*'),('B',r'__(.+?)__')]\n for tag,strong_pattern in strong_patterns:\n  src=re.sub(strong_pattern,r'<%s>\\1</%s>'%(tag,tag),src)\n  \n  \n src=re.sub(r'\\*(.+?)\\*',r'<%s>\\1</%s>'%('EM','EM'),src)\n \n \n \n src=re.sub(r'\\b_(.*?)_\\b',r'<I>\\1</I>',src,\n flags=re.M)\n \n \n code_pattern=r'\\`(.*?)\\`'\n src=re.sub(code_pattern,r'<code>\\1</code>',src)\n \n \n while True:\n  pos=src.rfind(rstr)\n  if pos ==-1:\n   break\n  repl=tags.pop()\n  src=src[:pos]+repl+src[pos+len(rstr):]\n  \n src='<p>'+src+'</p>'\n \n return src,scripts\n", ["random", "re"]], "browser.timer": [".py", "from browser import self as window\n\n\nclear_interval=window.clearInterval\n\nclear_timeout=window.clearTimeout\n\ndef set_interval(func,interval,*args):\n return window.setInterval(func,interval,*args)\n \ndef set_timeout(func,interval,*args):\n return int(window.setTimeout(func,interval,*args))\n \ndef request_animation_frame(func):\n if func.__code__.co_argcount ==0:\n  raise TypeError(f'function {func.__code__.co_name}() '+\n  'should take a single argument')\n return int(window.requestAnimationFrame(func))\n \ndef cancel_animation_frame(int_id):\n window.cancelAnimationFrame(int_id)\n \ndef set_loop_timeout(x):\n\n assert isinstance(x,int)\n __BRYTHON__.loop_timeout=x\n", ["browser"]], "browser.webcomponent": [".py", "from _webcomponent import *\n", ["_webcomponent"]], "browser.worker": [".py", "from _webworker import *\n", ["_webworker"]], "browser.widgets.menu": [".py", "from browser import console,document,html,window,alert\n\nstyle_sheet=\"\"\"\n/* Classes for brython.widgets.menu */\n\n:root {\n  --brython-menu-font-family: Arial;\n  --brython-menu-font-size: 100%;\n  --brython-menu-navbar-bgcolor: CadetBlue;\n  --brython-menu-navbar-bgcolor-selected: SkyBlue;\n  --brython-menu-navbar-color: #fff;\n  --brython-menu-color: #000;\n  --brython-menu-submenu-bgcolor: #fff;\n  --brython-menu-submenu-bgcolor-selected: SkyBlue;\n}\n\n/* Item in the main horizontal navigation bar */\n.brython-menu-navbar-item {\n    font-family: var(--brython-menu-font-family);\n    font-size: var(--brython-menu-font-size);\n    background-color: var(--brython-menu-navbar-bgcolor);\n    color: var(--brython-menu-navbar-color);\n    padding: 0.5em 1em 0.5em 1em;\n    cursor: default;\n}\n\n.brython-menu-navbar-item:hover {\n    background-color: var(--brython-menu-navbar-bgcolor-selected);\n}\n\n.brython-menu-navbar-item-selected {\n    background-color: var(--brython-menu-navbar-bgcolor-selected);\n}\n\n/* Table for a submenu, opened by a click on an item */\n.brython-menu-submenu {\n    font-family: var(--brython-menu-font-family);\n    font-size: var(--brython-menu-font-size);\n    background-color: var(--brython-menu-submenu-bgcolor);\n    position: absolute;\n    border-style: solid;\n    border-width: 1px;\n    border-color: var(--brython-menu-color);\n    border-spacing: 0;\n}\n\n/* TR for a submenu item row */\n.brython-menu-submenu-row:hover {\n    color: var(--brython-menu-color);\n    background-color: var(--brython-menu-submenu-bgcolor-selected);\n}\n\n.brython-menu-submenu-row-selected {\n    color: var(--brython-menu-color);\n    background-color: var(--brython-menu-submenu-bgcolor-selected);\n}\n\n/*\n   TD for a cell in a submenu row\n   Each row has two cells, one for the item label, the other one\n   filled with a > if the item has a submenu\n*/\n.brython-menu-submenu-item {\n    font-family: var(--brython-menu-font-family);\n    padding: 0.3em 0.3em 0.3em 1em;\n    cursor: default;\n}\n\n/* end of browser.widgets.menu classes */\n\n\"\"\"\n\n\nclass Menu:\n\n def __init__(self,container=document.body,parent=None,default_css=True):\n  ''\n\n  \n  self.container=container\n  self.parent=parent\n  \n  if default_css:\n  \n   for stylesheet in document.styleSheets:\n    if stylesheet.ownerNode.id ==\"brython-menu\":\n     break\n   else:\n    document <=html.STYLE(style_sheet,id=\"brython-menu\")\n    \n  self.default_css=default_css\n  \n  if parent:\n   parent.submenu=html.TABLE(Class=\"brython-menu-submenu\")\n   parent.submenu.style.position=\"absolute\"\n   parent.submenu.style.display=\"none\"\n   self.container <=parent.submenu\n   \n   parent.bind(\"click\",self.unfold)\n   \n  if not hasattr(self.container,\"bind_document\"):\n  \n   document.bind(\"click\",self.hide_menus)\n   self.container.bind_document=True\n   \n def add_item(self,label,callback=None,menu=False):\n  if self.parent is None:\n  \n   item=html.SPAN(label,Class=\"brython-menu-navbar-item\")\n   self.container <=item\n   item.bind(\"click\",self.hide_menus)\n  else:\n  \n   item=html.TR(Class=\"brython-menu-submenu-row\")\n   self.parent.submenu <=item\n   item <=html.TD(label,Class=\"brython-menu-submenu-item\")\n   item <=html.TD(\">\"if menu else \"&nbsp;\",\n   Class=\"brython-menu-submenu-item\",\n   paddingLeft=\"2em\")\n   \n  if callback is not None:\n   item.bind(\"click\",callback)\n   \n  return item\n  \n def add_link(self,label,href):\n  ''\n  if self.parent is None:\n  \n   item=html.A(label,Class=\"brython-menu-navbar-link\",href=href)\n   self.container <=item\n  else:\n  \n   item=html.TR(Class=\"brython-menu-submenu-row\")\n   self.parent.submenu <=item\n   item <=html.TD(html.A(label,Class=\"brython-menu-submenu-link\",\n   href=href))\n   \n  return item\n  \n def add_menu(self,label):\n  ''\n  \n  item=self.add_item(label,menu=True)\n  \n  if self.parent is None:\n  \n   span=html.SPAN(Class=\"brython-menu-submenu\")\n   span.style.position=\"absolute\"\n   \n  return Menu(self.container,item,default_css=self.default_css)\n  \n def hide_menus(self,*args):\n  ''\n  for css in[\".brython-menu-navbar-item-selected\",\n  \".brython-menu-submenu-row-selected\"]:\n   for item in document.select(css):\n    item.classList.remove(css[1:])\n  for div in document.select(\".brython-menu-submenu\"):\n   if div.style.display !=\"none\":\n    div.style.display=\"none\"\n    \n def hide_submenus(self,table):\n  ''\n  for row in table.select(\"TR\"):\n   if hasattr(row,\"submenu\"):\n    row.submenu.style.display=\"none\"\n    self.hide_submenus(row.submenu)\n    \n def unfold(self,ev):\n  ''\n  target=ev.target\n  if target.nodeName ==\"SPAN\":\n  \n   selected=document.select(\".brython-menu-navbar-item-selected\")\n   \n   if selected:\n    self.hide_menus()\n    \n   for item in selected:\n    item.classList.remove(\"brython-menu-navbar-item-selected\")\n    \n   submenu=target.submenu\n   \n   target.classList.add(\"brython-menu-navbar-item-selected\")\n   submenu.style.left=f\"{target.abs_left}px\"\n   submenu.style.top=f\"{target.abs_top+target.offsetHeight}px\"\n   \n   \n   \n   if not selected:\n    for item in document.select(\".brython-menu-navbar-item\"):\n     item.bind(\"mouseenter\",self.unfold)\n     \n     \n   submenu.style.display=\"block\"\n   \n  else:\n   target=target.closest(\"TR\")\n   \n   \n   table=target.closest(\"TABLE\")\n   self.hide_submenus(table)\n   \n   \n   selected=table.select(\".brython-menu-submenu-row-selected\")\n   for row in selected:\n    row.classList.remove(\"brython-menu-submenu-row-selected\")\n    \n    \n   target.classList.add(\"brython-menu-submenu-row-selected\")\n   \n   if hasattr(target,\"submenu\"):\n   \n    target.submenu.style.top=f\"{target.abs_top}px\"\n    target.submenu.style.left=\\\n    f\"{target.abs_left+target.offsetWidth}px\"\n    target.submenu.style.display=\"block\"\n    \n   if not selected:\n   \n   \n    for row in table.select(\"TR\"):\n     row.bind(\"mouseenter\",self.unfold)\n     \n     \n     \n     \n  ev.stopPropagation()\n", ["browser"]], "browser.widgets": [".py", "", [], 1], "collections": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n__all__=[\n'ChainMap',\n'Counter',\n'OrderedDict',\n'UserDict',\n'UserList',\n'UserString',\n'defaultdict',\n'deque',\n'namedtuple',\n]\n\nimport _collections_abc\nimport sys as _sys\n\nfrom itertools import chain as _chain\nfrom itertools import repeat as _repeat\nfrom itertools import starmap as _starmap\nfrom keyword import iskeyword as _iskeyword\nfrom operator import eq as _eq\nfrom operator import itemgetter as _itemgetter\nfrom reprlib import recursive_repr as _recursive_repr\nfrom _weakref import proxy as _proxy\n\ntry:\n from _collections import deque\nexcept ImportError:\n pass\nelse:\n _collections_abc.MutableSequence.register(deque)\n \ntry:\n from _collections import _deque_iterator\nexcept ImportError:\n pass\n \ntry:\n from _collections import defaultdict\nexcept ImportError:\n pass\n \n \n \n \n \n \nclass _OrderedDictKeysView(_collections_abc.KeysView):\n\n def __reversed__(self):\n  yield from reversed(self._mapping)\n  \nclass _OrderedDictItemsView(_collections_abc.ItemsView):\n\n def __reversed__(self):\n  for key in reversed(self._mapping):\n   yield(key,self._mapping[key])\n   \nclass _OrderedDictValuesView(_collections_abc.ValuesView):\n\n def __reversed__(self):\n  for key in reversed(self._mapping):\n   yield self._mapping[key]\n   \nclass _Link(object):\n __slots__='prev','next','key','__weakref__'\n \nclass OrderedDict(dict):\n ''\n \n \n \n \n \n \n \n \n \n \n \n \n \n def __new__(cls,/,*args,**kwds):\n  ''\n  self=dict.__new__(cls)\n  self.__hardroot=_Link()\n  self.__root=root=_proxy(self.__hardroot)\n  root.prev=root.next=root\n  self.__map={}\n  return self\n  \n def __init__(self,other=(),/,**kwds):\n  ''\n\n  \n  self.__update(other,**kwds)\n  \n def __setitem__(self,key,value,\n dict_setitem=dict.__setitem__,proxy=_proxy,Link=_Link):\n  ''\n  \n  \n  if key not in self:\n   self.__map[key]=link=Link()\n   root=self.__root\n   last=root.prev\n   link.prev,link.next,link.key=last,root,key\n   last.next=link\n   root.prev=proxy(link)\n  dict_setitem(self,key,value)\n  \n def __delitem__(self,key,dict_delitem=dict.__delitem__):\n  ''\n  \n  \n  dict_delitem(self,key)\n  link=self.__map.pop(key)\n  link_prev=link.prev\n  link_next=link.next\n  link_prev.next=link_next\n  link_next.prev=link_prev\n  link.prev=None\n  link.next=None\n  \n def __iter__(self):\n  ''\n  \n  root=self.__root\n  curr=root.next\n  while curr is not root:\n   yield curr.key\n   curr=curr.next\n   \n def __reversed__(self):\n  ''\n  \n  root=self.__root\n  curr=root.prev\n  while curr is not root:\n   yield curr.key\n   curr=curr.prev\n   \n def clear(self):\n  ''\n  root=self.__root\n  root.prev=root.next=root\n  self.__map.clear()\n  dict.clear(self)\n  \n def popitem(self,last=True):\n  ''\n\n\n  \n  if not self:\n   raise KeyError('dictionary is empty')\n  root=self.__root\n  if last:\n   link=root.prev\n   link_prev=link.prev\n   link_prev.next=root\n   root.prev=link_prev\n  else:\n   link=root.next\n   link_next=link.next\n   root.next=link_next\n   link_next.prev=root\n  key=link.key\n  del self.__map[key]\n  value=dict.pop(self,key)\n  return key,value\n  \n def move_to_end(self,key,last=True):\n  ''\n\n\n  \n  link=self.__map[key]\n  link_prev=link.prev\n  link_next=link.next\n  soft_link=link_next.prev\n  link_prev.next=link_next\n  link_next.prev=link_prev\n  root=self.__root\n  if last:\n   last=root.prev\n   link.prev=last\n   link.next=root\n   root.prev=soft_link\n   last.next=link\n  else:\n   first=root.next\n   link.prev=root\n   link.next=first\n   first.prev=soft_link\n   root.next=link\n   \n def __sizeof__(self):\n  sizeof=_sys.getsizeof\n  n=len(self)+1\n  size=sizeof(self.__dict__)\n  size +=sizeof(self.__map)*2\n  size +=sizeof(self.__hardroot)*n\n  size +=sizeof(self.__root)*n\n  return size\n  \n update=__update=_collections_abc.MutableMapping.update\n \n def keys(self):\n  ''\n  return _OrderedDictKeysView(self)\n  \n def items(self):\n  ''\n  return _OrderedDictItemsView(self)\n  \n def values(self):\n  ''\n  return _OrderedDictValuesView(self)\n  \n __ne__=_collections_abc.MutableMapping.__ne__\n \n __marker=object()\n \n def pop(self,key,default=__marker):\n  ''\n\n\n\n  \n  marker=self.__marker\n  result=dict.pop(self,key,marker)\n  if result is not marker:\n  \n   link=self.__map.pop(key)\n   link_prev=link.prev\n   link_next=link.next\n   link_prev.next=link_next\n   link_next.prev=link_prev\n   link.prev=None\n   link.next=None\n   return result\n  if default is marker:\n   raise KeyError(key)\n  return default\n  \n def setdefault(self,key,default=None):\n  ''\n\n\n  \n  if key in self:\n   return self[key]\n  self[key]=default\n  return default\n  \n @_recursive_repr()\n def __repr__(self):\n  ''\n  if not self:\n   return '%s()'%(self.__class__.__name__,)\n  return '%s(%r)'%(self.__class__.__name__,dict(self.items()))\n  \n def __reduce__(self):\n  ''\n  state=self.__getstate__()\n  if state:\n   if isinstance(state,tuple):\n    state,slots=state\n   else:\n    slots={}\n   state=state.copy()\n   slots=slots.copy()\n   for k in vars(OrderedDict()):\n    state.pop(k,None)\n    slots.pop(k,None)\n   if slots:\n    state=state,slots\n   else:\n    state=state or None\n  return self.__class__,(),state,None,iter(self.items())\n  \n def copy(self):\n  ''\n  return self.__class__(self)\n  \n @classmethod\n def fromkeys(cls,iterable,value=None):\n  ''\n  \n  self=cls()\n  for key in iterable:\n   self[key]=value\n  return self\n  \n def __eq__(self,other):\n  ''\n\n\n  \n  if isinstance(other,OrderedDict):\n   return dict.__eq__(self,other)and all(map(_eq,self,other))\n  return dict.__eq__(self,other)\n  \n def __ior__(self,other):\n  self.update(other)\n  return self\n  \n def __or__(self,other):\n  if not isinstance(other,dict):\n   return NotImplemented\n  new=self.__class__(self)\n  new.update(other)\n  return new\n  \n def __ror__(self,other):\n  if not isinstance(other,dict):\n   return NotImplemented\n  new=self.__class__(other)\n  new.update(self)\n  return new\n  \n  \ntry:\n from _collections import OrderedDict\nexcept ImportError:\n\n pass\n \n \n \n \n \n \ntry:\n from _collections import _tuplegetter\nexcept ImportError:\n _tuplegetter=lambda index,doc:property(_itemgetter(index),doc=doc)\n \ndef namedtuple(typename,field_names,*,rename=False,defaults=None,module=None):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n if isinstance(field_names,str):\n  field_names=field_names.replace(',',' ').split()\n field_names=list(map(str,field_names))\n typename=_sys.intern(str(typename))\n \n if rename:\n  seen=set()\n  for index,name in enumerate(field_names):\n   if(not name.isidentifier()\n   or _iskeyword(name)\n   or name.startswith('_')\n   or name in seen):\n    field_names[index]=f'_{index}'\n   seen.add(name)\n   \n for name in[typename]+field_names:\n  if type(name)is not str:\n   raise TypeError('Type names and field names must be strings')\n  if not name.isidentifier():\n   raise ValueError('Type names and field names must be valid '\n   f'identifiers: {name !r}')\n  if _iskeyword(name):\n   raise ValueError('Type names and field names cannot be a '\n   f'keyword: {name !r}')\n   \n seen=set()\n for name in field_names:\n  if name.startswith('_')and not rename:\n   raise ValueError('Field names cannot start with an underscore: '\n   f'{name !r}')\n  if name in seen:\n   raise ValueError(f'Encountered duplicate field name: {name !r}')\n  seen.add(name)\n  \n field_defaults={}\n if defaults is not None:\n  defaults=tuple(defaults)\n  if len(defaults)>len(field_names):\n   raise TypeError('Got more default values than field names')\n  field_defaults=dict(reversed(list(zip(reversed(field_names),\n  reversed(defaults)))))\n  \n  \n field_names=tuple(map(_sys.intern,field_names))\n num_fields=len(field_names)\n arg_list=', '.join(field_names)\n if num_fields ==1:\n  arg_list +=','\n repr_fmt='('+', '.join(f'{name}=%r'for name in field_names)+')'\n tuple_new=tuple.__new__\n _dict,_tuple,_len,_map,_zip=dict,tuple,len,map,zip\n \n \n \n namespace={\n '_tuple_new':tuple_new,\n '__builtins__':{},\n '__name__':f'namedtuple_{typename}',\n }\n code=f'lambda _cls, {arg_list}: _tuple_new(_cls, ({arg_list}))'\n __new__=eval(code,namespace)\n __new__.__name__='__new__'\n __new__.__doc__=f'Create new instance of {typename}({arg_list})'\n if defaults is not None:\n  __new__.__defaults__=defaults\n  \n @classmethod\n def _make(cls,iterable):\n  result=tuple_new(cls,iterable)\n  if _len(result)!=num_fields:\n   raise TypeError(f'Expected {num_fields} arguments, got {len(result)}')\n  return result\n  \n _make.__func__.__doc__=(f'Make a new {typename} object from a sequence '\n 'or iterable')\n \n def _replace(self,/,**kwds):\n  result=self._make(_map(kwds.pop,field_names,self))\n  if kwds:\n   raise TypeError(f'Got unexpected field names: {list(kwds)!r}')\n  return result\n  \n _replace.__doc__=(f'Return a new {typename} object replacing specified '\n 'fields with new values')\n \n def __repr__(self):\n  ''\n  return self.__class__.__name__+repr_fmt %self\n  \n def _asdict(self):\n  ''\n  return _dict(_zip(self._fields,self))\n  \n def __getnewargs__(self):\n  ''\n  return _tuple(self)\n  \n  \n for method in(\n __new__,\n _make.__func__,\n _replace,\n __repr__,\n _asdict,\n __getnewargs__,\n ):\n  method.__qualname__=f'{typename}.{method.__name__}'\n  \n  \n  \n class_namespace={\n '__doc__':f'{typename}({arg_list})',\n '__slots__':(),\n '_fields':field_names,\n '_field_defaults':field_defaults,\n '__new__':__new__,\n '_make':_make,\n '__replace__':_replace,\n '_replace':_replace,\n '__repr__':__repr__,\n '_asdict':_asdict,\n '__getnewargs__':__getnewargs__,\n '__match_args__':field_names,\n }\n for index,name in enumerate(field_names):\n  doc=_sys.intern(f'Alias for field number {index}')\n  class_namespace[name]=_tuplegetter(index,doc)\n  \n result=type(typename,(tuple,),class_namespace)\n \n \n \n \n \n \n if module is None:\n  try:\n   module=_sys._getframemodulename(1)or '__main__'\n  except AttributeError:\n   try:\n    module=_sys._getframe(1).f_globals.get('__name__','__main__')\n   except(AttributeError,ValueError):\n    pass\n if module is not None:\n  result.__module__=module\n  \n return result\n \n \n \n \n \n \ndef _count_elements(mapping,iterable):\n ''\n mapping_get=mapping.get\n for elem in iterable:\n  mapping[elem]=mapping_get(elem,0)+1\n  \ntry:\n from _collections import _count_elements\nexcept ImportError:\n pass\n \nclass Counter(dict):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n def __init__(self,iterable=None,/,**kwds):\n  ''\n\n\n\n\n\n\n\n\n  \n  super().__init__()\n  self.update(iterable,**kwds)\n  \n def __missing__(self,key):\n  ''\n  \n  return 0\n  \n def total(self):\n  ''\n  return sum(self.values())\n  \n def most_common(self,n=None):\n  ''\n\n\n\n\n\n  \n  \n  if n is None:\n   return sorted(self.items(),key=_itemgetter(1),reverse=True)\n   \n   \n  import heapq\n  return heapq.nlargest(n,self.items(),key=_itemgetter(1))\n  \n def elements(self):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  return _chain.from_iterable(_starmap(_repeat,self.items()))\n  \n  \n  \n @classmethod\n def fromkeys(cls,iterable,v=None):\n \n \n \n \n \n \n \n  raise NotImplementedError(\n  'Counter.fromkeys() is undefined.  Use Counter(iterable) instead.')\n  \n def update(self,iterable=None,/,**kwds):\n  ''\n\n\n\n\n\n\n\n\n\n\n  \n  \n  \n  \n  \n  \n  \n  \n  if iterable is not None:\n   if isinstance(iterable,_collections_abc.Mapping):\n    if self:\n     self_get=self.get\n     for elem,count in iterable.items():\n      self[elem]=count+self_get(elem,0)\n    else:\n    \n     super().update(iterable)\n   else:\n    _count_elements(self,iterable)\n  if kwds:\n   self.update(kwds)\n   \n def subtract(self,iterable=None,/,**kwds):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  if iterable is not None:\n   self_get=self.get\n   if isinstance(iterable,_collections_abc.Mapping):\n    for elem,count in iterable.items():\n     self[elem]=self_get(elem,0)-count\n   else:\n    for elem in iterable:\n     self[elem]=self_get(elem,0)-1\n  if kwds:\n   self.subtract(kwds)\n   \n def copy(self):\n  ''\n  return self.__class__(self)\n  \n def __reduce__(self):\n  return self.__class__,(dict(self),)\n  \n def __delitem__(self,elem):\n  ''\n  if elem in self:\n   super().__delitem__(elem)\n   \n def __repr__(self):\n  if not self:\n   return f'{self.__class__.__name__}()'\n  try:\n  \n   d=dict(self.most_common())\n  except TypeError:\n  \n   d=dict(self)\n  return f'{self.__class__.__name__}({d !r})'\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n def __eq__(self,other):\n  ''\n  if not isinstance(other,Counter):\n   return NotImplemented\n  return all(self[e]==other[e]for c in(self,other)for e in c)\n  \n def __ne__(self,other):\n  ''\n  if not isinstance(other,Counter):\n   return NotImplemented\n  return not self ==other\n  \n def __le__(self,other):\n  ''\n  if not isinstance(other,Counter):\n   return NotImplemented\n  return all(self[e]<=other[e]for c in(self,other)for e in c)\n  \n def __lt__(self,other):\n  ''\n  if not isinstance(other,Counter):\n   return NotImplemented\n  return self <=other and self !=other\n  \n def __ge__(self,other):\n  ''\n  if not isinstance(other,Counter):\n   return NotImplemented\n  return all(self[e]>=other[e]for c in(self,other)for e in c)\n  \n def __gt__(self,other):\n  ''\n  if not isinstance(other,Counter):\n   return NotImplemented\n  return self >=other and self !=other\n  \n def __add__(self,other):\n  ''\n\n\n\n\n  \n  if not isinstance(other,Counter):\n   return NotImplemented\n  result=Counter()\n  for elem,count in self.items():\n   newcount=count+other[elem]\n   if newcount >0:\n    result[elem]=newcount\n  for elem,count in other.items():\n   if elem not in self and count >0:\n    result[elem]=count\n  return result\n  \n def __sub__(self,other):\n  ''\n\n\n\n\n  \n  if not isinstance(other,Counter):\n   return NotImplemented\n  result=Counter()\n  for elem,count in self.items():\n   newcount=count -other[elem]\n   if newcount >0:\n    result[elem]=newcount\n  for elem,count in other.items():\n   if elem not in self and count <0:\n    result[elem]=0 -count\n  return result\n  \n def __or__(self,other):\n  ''\n\n\n\n\n  \n  if not isinstance(other,Counter):\n   return NotImplemented\n  result=Counter()\n  for elem,count in self.items():\n   other_count=other[elem]\n   newcount=other_count if count <other_count else count\n   if newcount >0:\n    result[elem]=newcount\n  for elem,count in other.items():\n   if elem not in self and count >0:\n    result[elem]=count\n  return result\n  \n def __and__(self,other):\n  ''\n\n\n\n\n  \n  if not isinstance(other,Counter):\n   return NotImplemented\n  result=Counter()\n  for elem,count in self.items():\n   other_count=other[elem]\n   newcount=count if count <other_count else other_count\n   if newcount >0:\n    result[elem]=newcount\n  return result\n  \n def __pos__(self):\n  ''\n  result=Counter()\n  for elem,count in self.items():\n   if count >0:\n    result[elem]=count\n  return result\n  \n def __neg__(self):\n  ''\n\n\n  \n  result=Counter()\n  for elem,count in self.items():\n   if count <0:\n    result[elem]=0 -count\n  return result\n  \n def _keep_positive(self):\n  ''\n  nonpositive=[elem for elem,count in self.items()if not count >0]\n  for elem in nonpositive:\n   del self[elem]\n  return self\n  \n def __iadd__(self,other):\n  ''\n\n\n\n\n\n\n  \n  for elem,count in other.items():\n   self[elem]+=count\n  return self._keep_positive()\n  \n def __isub__(self,other):\n  ''\n\n\n\n\n\n\n  \n  for elem,count in other.items():\n   self[elem]-=count\n  return self._keep_positive()\n  \n def __ior__(self,other):\n  ''\n\n\n\n\n\n\n  \n  for elem,other_count in other.items():\n   count=self[elem]\n   if other_count >count:\n    self[elem]=other_count\n  return self._keep_positive()\n  \n def __iand__(self,other):\n  ''\n\n\n\n\n\n\n  \n  for elem,count in self.items():\n   other_count=other[elem]\n   if other_count <count:\n    self[elem]=other_count\n  return self._keep_positive()\n  \n  \n  \n  \n  \n  \nclass ChainMap(_collections_abc.MutableMapping):\n ''\n\n\n\n\n\n\n\n\n\n\n \n \n def __init__(self,*maps):\n  ''\n\n\n  \n  self.maps=list(maps)or[{}]\n  \n def __missing__(self,key):\n  raise KeyError(key)\n  \n def __getitem__(self,key):\n  for mapping in self.maps:\n   try:\n    return mapping[key]\n   except KeyError:\n    pass\n  return self.__missing__(key)\n  \n def get(self,key,default=None):\n  return self[key]if key in self else default\n  \n def __len__(self):\n  return len(set().union(*self.maps))\n  \n def __iter__(self):\n  d={}\n  for mapping in map(dict.fromkeys,reversed(self.maps)):\n   d |=mapping\n  return iter(d)\n  \n def __contains__(self,key):\n  return any(key in m for m in self.maps)\n  \n def __bool__(self):\n  return any(self.maps)\n  \n @_recursive_repr()\n def __repr__(self):\n  return f'{self.__class__.__name__}({\", \".join(map(repr,self.maps))})'\n  \n @classmethod\n def fromkeys(cls,iterable,value=None,/):\n  ''\n  return cls(dict.fromkeys(iterable,value))\n  \n def copy(self):\n  ''\n  return self.__class__(self.maps[0].copy(),*self.maps[1:])\n  \n __copy__=copy\n \n def new_child(self,m=None,**kwargs):\n  ''\n\n\n  \n  if m is None:\n   m=kwargs\n  elif kwargs:\n   m.update(kwargs)\n  return self.__class__(m,*self.maps)\n  \n @property\n def parents(self):\n  ''\n  return self.__class__(*self.maps[1:])\n  \n def __setitem__(self,key,value):\n  self.maps[0][key]=value\n  \n def __delitem__(self,key):\n  try:\n   del self.maps[0][key]\n  except KeyError:\n   raise KeyError(f'Key not found in the first mapping: {key !r}')\n   \n def popitem(self):\n  ''\n  try:\n   return self.maps[0].popitem()\n  except KeyError:\n   raise KeyError('No keys found in the first mapping.')\n   \n def pop(self,key,*args):\n  ''\n  try:\n   return self.maps[0].pop(key,*args)\n  except KeyError:\n   raise KeyError(f'Key not found in the first mapping: {key !r}')\n   \n def clear(self):\n  ''\n  self.maps[0].clear()\n  \n def __ior__(self,other):\n  self.maps[0].update(other)\n  return self\n  \n def __or__(self,other):\n  if not isinstance(other,_collections_abc.Mapping):\n   return NotImplemented\n  m=self.copy()\n  m.maps[0].update(other)\n  return m\n  \n def __ror__(self,other):\n  if not isinstance(other,_collections_abc.Mapping):\n   return NotImplemented\n  m=dict(other)\n  for child in reversed(self.maps):\n   m.update(child)\n  return self.__class__(m)\n  \n  \n  \n  \n  \n  \nclass UserDict(_collections_abc.MutableMapping):\n\n\n def __init__(self,dict=None,/,**kwargs):\n  self.data={}\n  if dict is not None:\n   self.update(dict)\n  if kwargs:\n   self.update(kwargs)\n   \n def __len__(self):\n  return len(self.data)\n  \n def __getitem__(self,key):\n  if key in self.data:\n   return self.data[key]\n  if hasattr(self.__class__,\"__missing__\"):\n   return self.__class__.__missing__(self,key)\n  raise KeyError(key)\n  \n def __setitem__(self,key,item):\n  self.data[key]=item\n  \n def __delitem__(self,key):\n  del self.data[key]\n  \n def __iter__(self):\n  return iter(self.data)\n  \n  \n  \n def __contains__(self,key):\n  return key in self.data\n  \n def get(self,key,default=None):\n  if key in self:\n   return self[key]\n  return default\n  \n  \n  \n def __repr__(self):\n  return repr(self.data)\n  \n def __or__(self,other):\n  if isinstance(other,UserDict):\n   return self.__class__(self.data |other.data)\n  if isinstance(other,dict):\n   return self.__class__(self.data |other)\n  return NotImplemented\n  \n def __ror__(self,other):\n  if isinstance(other,UserDict):\n   return self.__class__(other.data |self.data)\n  if isinstance(other,dict):\n   return self.__class__(other |self.data)\n  return NotImplemented\n  \n def __ior__(self,other):\n  if isinstance(other,UserDict):\n   self.data |=other.data\n  else:\n   self.data |=other\n  return self\n  \n def __copy__(self):\n  inst=self.__class__.__new__(self.__class__)\n  inst.__dict__.update(self.__dict__)\n  \n  inst.__dict__[\"data\"]=self.__dict__[\"data\"].copy()\n  return inst\n  \n def copy(self):\n  if self.__class__ is UserDict:\n   return UserDict(self.data.copy())\n  import copy\n  data=self.data\n  try:\n   self.data={}\n   c=copy.copy(self)\n  finally:\n   self.data=data\n  c.update(self)\n  return c\n  \n @classmethod\n def fromkeys(cls,iterable,value=None):\n  d=cls()\n  for key in iterable:\n   d[key]=value\n  return d\n  \n  \n  \n  \n  \n  \nclass UserList(_collections_abc.MutableSequence):\n ''\n \n def __init__(self,initlist=None):\n  self.data=[]\n  if initlist is not None:\n  \n   if type(initlist)==type(self.data):\n    self.data[:]=initlist\n   elif isinstance(initlist,UserList):\n    self.data[:]=initlist.data[:]\n   else:\n    self.data=list(initlist)\n    \n def __repr__(self):\n  return repr(self.data)\n  \n def __lt__(self,other):\n  return self.data <self.__cast(other)\n  \n def __le__(self,other):\n  return self.data <=self.__cast(other)\n  \n def __eq__(self,other):\n  return self.data ==self.__cast(other)\n  \n def __gt__(self,other):\n  return self.data >self.__cast(other)\n  \n def __ge__(self,other):\n  return self.data >=self.__cast(other)\n  \n def __cast(self,other):\n  return other.data if isinstance(other,UserList)else other\n  \n def __contains__(self,item):\n  return item in self.data\n  \n def __len__(self):\n  return len(self.data)\n  \n def __getitem__(self,i):\n  if isinstance(i,slice):\n   return self.__class__(self.data[i])\n  else:\n   return self.data[i]\n   \n def __setitem__(self,i,item):\n  self.data[i]=item\n  \n def __delitem__(self,i):\n  del self.data[i]\n  \n def __add__(self,other):\n  if isinstance(other,UserList):\n   return self.__class__(self.data+other.data)\n  elif isinstance(other,type(self.data)):\n   return self.__class__(self.data+other)\n  return self.__class__(self.data+list(other))\n  \n def __radd__(self,other):\n  if isinstance(other,UserList):\n   return self.__class__(other.data+self.data)\n  elif isinstance(other,type(self.data)):\n   return self.__class__(other+self.data)\n  return self.__class__(list(other)+self.data)\n  \n def __iadd__(self,other):\n  if isinstance(other,UserList):\n   self.data +=other.data\n  elif isinstance(other,type(self.data)):\n   self.data +=other\n  else:\n   self.data +=list(other)\n  return self\n  \n def __mul__(self,n):\n  return self.__class__(self.data *n)\n  \n __rmul__=__mul__\n \n def __imul__(self,n):\n  self.data *=n\n  return self\n  \n def __copy__(self):\n  inst=self.__class__.__new__(self.__class__)\n  inst.__dict__.update(self.__dict__)\n  \n  inst.__dict__[\"data\"]=self.__dict__[\"data\"][:]\n  return inst\n  \n def append(self,item):\n  self.data.append(item)\n  \n def insert(self,i,item):\n  self.data.insert(i,item)\n  \n def pop(self,i=-1):\n  return self.data.pop(i)\n  \n def remove(self,item):\n  self.data.remove(item)\n  \n def clear(self):\n  self.data.clear()\n  \n def copy(self):\n  return self.__class__(self)\n  \n def count(self,item):\n  return self.data.count(item)\n  \n def index(self,item,*args):\n  return self.data.index(item,*args)\n  \n def reverse(self):\n  self.data.reverse()\n  \n def sort(self,/,*args,**kwds):\n  self.data.sort(*args,**kwds)\n  \n def extend(self,other):\n  if isinstance(other,UserList):\n   self.data.extend(other.data)\n  else:\n   self.data.extend(other)\n   \n   \n   \n   \n   \n   \nclass UserString(_collections_abc.Sequence):\n\n def __init__(self,seq):\n  if isinstance(seq,str):\n   self.data=seq\n  elif isinstance(seq,UserString):\n   self.data=seq.data[:]\n  else:\n   self.data=str(seq)\n   \n def __str__(self):\n  return str(self.data)\n  \n def __repr__(self):\n  return repr(self.data)\n  \n def __int__(self):\n  return int(self.data)\n  \n def __float__(self):\n  return float(self.data)\n  \n def __complex__(self):\n  return complex(self.data)\n  \n def __hash__(self):\n  return hash(self.data)\n  \n def __getnewargs__(self):\n  return(self.data[:],)\n  \n def __eq__(self,string):\n  if isinstance(string,UserString):\n   return self.data ==string.data\n  return self.data ==string\n  \n def __lt__(self,string):\n  if isinstance(string,UserString):\n   return self.data <string.data\n  return self.data <string\n  \n def __le__(self,string):\n  if isinstance(string,UserString):\n   return self.data <=string.data\n  return self.data <=string\n  \n def __gt__(self,string):\n  if isinstance(string,UserString):\n   return self.data >string.data\n  return self.data >string\n  \n def __ge__(self,string):\n  if isinstance(string,UserString):\n   return self.data >=string.data\n  return self.data >=string\n  \n def __contains__(self,char):\n  if isinstance(char,UserString):\n   char=char.data\n  return char in self.data\n  \n def __len__(self):\n  return len(self.data)\n  \n def __getitem__(self,index):\n  return self.__class__(self.data[index])\n  \n def __add__(self,other):\n  if isinstance(other,UserString):\n   return self.__class__(self.data+other.data)\n  elif isinstance(other,str):\n   return self.__class__(self.data+other)\n  return self.__class__(self.data+str(other))\n  \n def __radd__(self,other):\n  if isinstance(other,str):\n   return self.__class__(other+self.data)\n  return self.__class__(str(other)+self.data)\n  \n def __mul__(self,n):\n  return self.__class__(self.data *n)\n  \n __rmul__=__mul__\n \n def __mod__(self,args):\n  return self.__class__(self.data %args)\n  \n def __rmod__(self,template):\n  return self.__class__(str(template)%self)\n  \n  \n def capitalize(self):\n  return self.__class__(self.data.capitalize())\n  \n def casefold(self):\n  return self.__class__(self.data.casefold())\n  \n def center(self,width,*args):\n  return self.__class__(self.data.center(width,*args))\n  \n def count(self,sub,start=0,end=_sys.maxsize):\n  if isinstance(sub,UserString):\n   sub=sub.data\n  return self.data.count(sub,start,end)\n  \n def removeprefix(self,prefix,/):\n  if isinstance(prefix,UserString):\n   prefix=prefix.data\n  return self.__class__(self.data.removeprefix(prefix))\n  \n def removesuffix(self,suffix,/):\n  if isinstance(suffix,UserString):\n   suffix=suffix.data\n  return self.__class__(self.data.removesuffix(suffix))\n  \n def encode(self,encoding='utf-8',errors='strict'):\n  encoding='utf-8'if encoding is None else encoding\n  errors='strict'if errors is None else errors\n  return self.data.encode(encoding,errors)\n  \n def endswith(self,suffix,start=0,end=_sys.maxsize):\n  return self.data.endswith(suffix,start,end)\n  \n def expandtabs(self,tabsize=8):\n  return self.__class__(self.data.expandtabs(tabsize))\n  \n def find(self,sub,start=0,end=_sys.maxsize):\n  if isinstance(sub,UserString):\n   sub=sub.data\n  return self.data.find(sub,start,end)\n  \n def format(self,/,*args,**kwds):\n  return self.data.format(*args,**kwds)\n  \n def format_map(self,mapping):\n  return self.data.format_map(mapping)\n  \n def index(self,sub,start=0,end=_sys.maxsize):\n  return self.data.index(sub,start,end)\n  \n def isalpha(self):\n  return self.data.isalpha()\n  \n def isalnum(self):\n  return self.data.isalnum()\n  \n def isascii(self):\n  return self.data.isascii()\n  \n def isdecimal(self):\n  return self.data.isdecimal()\n  \n def isdigit(self):\n  return self.data.isdigit()\n  \n def isidentifier(self):\n  return self.data.isidentifier()\n  \n def islower(self):\n  return self.data.islower()\n  \n def isnumeric(self):\n  return self.data.isnumeric()\n  \n def isprintable(self):\n  return self.data.isprintable()\n  \n def isspace(self):\n  return self.data.isspace()\n  \n def istitle(self):\n  return self.data.istitle()\n  \n def isupper(self):\n  return self.data.isupper()\n  \n def join(self,seq):\n  return self.data.join(seq)\n  \n def ljust(self,width,*args):\n  return self.__class__(self.data.ljust(width,*args))\n  \n def lower(self):\n  return self.__class__(self.data.lower())\n  \n def lstrip(self,chars=None):\n  return self.__class__(self.data.lstrip(chars))\n  \n maketrans=str.maketrans\n \n def partition(self,sep):\n  return self.data.partition(sep)\n  \n def replace(self,old,new,maxsplit=-1):\n  if isinstance(old,UserString):\n   old=old.data\n  if isinstance(new,UserString):\n   new=new.data\n  return self.__class__(self.data.replace(old,new,maxsplit))\n  \n def rfind(self,sub,start=0,end=_sys.maxsize):\n  if isinstance(sub,UserString):\n   sub=sub.data\n  return self.data.rfind(sub,start,end)\n  \n def rindex(self,sub,start=0,end=_sys.maxsize):\n  return self.data.rindex(sub,start,end)\n  \n def rjust(self,width,*args):\n  return self.__class__(self.data.rjust(width,*args))\n  \n def rpartition(self,sep):\n  return self.data.rpartition(sep)\n  \n def rstrip(self,chars=None):\n  return self.__class__(self.data.rstrip(chars))\n  \n def split(self,sep=None,maxsplit=-1):\n  return self.data.split(sep,maxsplit)\n  \n def rsplit(self,sep=None,maxsplit=-1):\n  return self.data.rsplit(sep,maxsplit)\n  \n def splitlines(self,keepends=False):\n  return self.data.splitlines(keepends)\n  \n def startswith(self,prefix,start=0,end=_sys.maxsize):\n  return self.data.startswith(prefix,start,end)\n  \n def strip(self,chars=None):\n  return self.__class__(self.data.strip(chars))\n  \n def swapcase(self):\n  return self.__class__(self.data.swapcase())\n  \n def title(self):\n  return self.__class__(self.data.title())\n  \n def translate(self,*args):\n  return self.__class__(self.data.translate(*args))\n  \n def upper(self):\n  return self.__class__(self.data.upper())\n  \n def zfill(self,width):\n  return self.__class__(self.data.zfill(width))\n", ["_collections", "_collections_abc", "_weakref", "copy", "heapq", "itertools", "keyword", "operator", "reprlib", "sys"], 1], "concurrent": [".py", "", [], 1], "concurrent.futures._base": [".py", "\n\n\n__author__='Brian Quinlan (brian@sweetapp.com)'\n\nimport collections\nimport logging\nimport threading\nimport time\nimport types\n\nFIRST_COMPLETED='FIRST_COMPLETED'\nFIRST_EXCEPTION='FIRST_EXCEPTION'\nALL_COMPLETED='ALL_COMPLETED'\n_AS_COMPLETED='_AS_COMPLETED'\n\n\nPENDING='PENDING'\nRUNNING='RUNNING'\n\nCANCELLED='CANCELLED'\n\nCANCELLED_AND_NOTIFIED='CANCELLED_AND_NOTIFIED'\nFINISHED='FINISHED'\n\n_FUTURE_STATES=[\nPENDING,\nRUNNING,\nCANCELLED,\nCANCELLED_AND_NOTIFIED,\nFINISHED\n]\n\n_STATE_TO_DESCRIPTION_MAP={\nPENDING:\"pending\",\nRUNNING:\"running\",\nCANCELLED:\"cancelled\",\nCANCELLED_AND_NOTIFIED:\"cancelled\",\nFINISHED:\"finished\"\n}\n\n\nLOGGER=logging.getLogger(\"concurrent.futures\")\n\nclass Error(Exception):\n ''\n pass\n \nclass CancelledError(Error):\n ''\n pass\n \nTimeoutError=TimeoutError\n\nclass InvalidStateError(Error):\n ''\n pass\n \nclass _Waiter(object):\n ''\n def __init__(self):\n  self.event=threading.Event()\n  self.finished_futures=[]\n  \n def add_result(self,future):\n  self.finished_futures.append(future)\n  \n def add_exception(self,future):\n  self.finished_futures.append(future)\n  \n def add_cancelled(self,future):\n  self.finished_futures.append(future)\n  \nclass _AsCompletedWaiter(_Waiter):\n ''\n \n def __init__(self):\n  super(_AsCompletedWaiter,self).__init__()\n  self.lock=threading.Lock()\n  \n def add_result(self,future):\n  with self.lock:\n   super(_AsCompletedWaiter,self).add_result(future)\n   self.event.set()\n   \n def add_exception(self,future):\n  with self.lock:\n   super(_AsCompletedWaiter,self).add_exception(future)\n   self.event.set()\n   \n def add_cancelled(self,future):\n  with self.lock:\n   super(_AsCompletedWaiter,self).add_cancelled(future)\n   self.event.set()\n   \nclass _FirstCompletedWaiter(_Waiter):\n ''\n \n def add_result(self,future):\n  super().add_result(future)\n  self.event.set()\n  \n def add_exception(self,future):\n  super().add_exception(future)\n  self.event.set()\n  \n def add_cancelled(self,future):\n  super().add_cancelled(future)\n  self.event.set()\n  \nclass _AllCompletedWaiter(_Waiter):\n ''\n \n def __init__(self,num_pending_calls,stop_on_exception):\n  self.num_pending_calls=num_pending_calls\n  self.stop_on_exception=stop_on_exception\n  self.lock=threading.Lock()\n  super().__init__()\n  \n def _decrement_pending_calls(self):\n  with self.lock:\n   self.num_pending_calls -=1\n   if not self.num_pending_calls:\n    self.event.set()\n    \n def add_result(self,future):\n  super().add_result(future)\n  self._decrement_pending_calls()\n  \n def add_exception(self,future):\n  super().add_exception(future)\n  if self.stop_on_exception:\n   self.event.set()\n  else:\n   self._decrement_pending_calls()\n   \n def add_cancelled(self,future):\n  super().add_cancelled(future)\n  self._decrement_pending_calls()\n  \nclass _AcquireFutures(object):\n ''\n \n def __init__(self,futures):\n  self.futures=sorted(futures,key=id)\n  \n def __enter__(self):\n  for future in self.futures:\n   future._condition.acquire()\n   \n def __exit__(self,*args):\n  for future in self.futures:\n   future._condition.release()\n   \ndef _create_and_install_waiters(fs,return_when):\n if return_when ==_AS_COMPLETED:\n  waiter=_AsCompletedWaiter()\n elif return_when ==FIRST_COMPLETED:\n  waiter=_FirstCompletedWaiter()\n else:\n  pending_count=sum(\n  f._state not in[CANCELLED_AND_NOTIFIED,FINISHED]for f in fs)\n  \n  if return_when ==FIRST_EXCEPTION:\n   waiter=_AllCompletedWaiter(pending_count,stop_on_exception=True)\n  elif return_when ==ALL_COMPLETED:\n   waiter=_AllCompletedWaiter(pending_count,stop_on_exception=False)\n  else:\n   raise ValueError(\"Invalid return condition: %r\"%return_when)\n   \n for f in fs:\n  f._waiters.append(waiter)\n  \n return waiter\n \n \ndef _yield_finished_futures(fs,waiter,ref_collect):\n ''\n\n\n\n\n\n\n\n\n \n while fs:\n  f=fs[-1]\n  for futures_set in ref_collect:\n   futures_set.remove(f)\n  with f._condition:\n   f._waiters.remove(waiter)\n  del f\n  \n  yield fs.pop()\n  \n  \ndef as_completed(fs,timeout=None):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n if timeout is not None:\n  end_time=timeout+time.monotonic()\n  \n fs=set(fs)\n total_futures=len(fs)\n with _AcquireFutures(fs):\n  finished=set(\n  f for f in fs\n  if f._state in[CANCELLED_AND_NOTIFIED,FINISHED])\n  pending=fs -finished\n  waiter=_create_and_install_waiters(fs,_AS_COMPLETED)\n finished=list(finished)\n try:\n  yield from _yield_finished_futures(finished,waiter,\n  ref_collect=(fs,))\n  \n  while pending:\n   if timeout is None:\n    wait_timeout=None\n   else:\n    wait_timeout=end_time -time.monotonic()\n    if wait_timeout <0:\n     raise TimeoutError(\n     '%d (of %d) futures unfinished'%(\n     len(pending),total_futures))\n     \n   waiter.event.wait(wait_timeout)\n   \n   with waiter.lock:\n    finished=waiter.finished_futures\n    waiter.finished_futures=[]\n    waiter.event.clear()\n    \n    \n   finished.reverse()\n   yield from _yield_finished_futures(finished,waiter,\n   ref_collect=(fs,pending))\n   \n finally:\n \n  for f in fs:\n   with f._condition:\n    f._waiters.remove(waiter)\n    \nDoneAndNotDoneFutures=collections.namedtuple(\n'DoneAndNotDoneFutures','done not_done')\ndef wait(fs,timeout=None,return_when=ALL_COMPLETED):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n fs=set(fs)\n with _AcquireFutures(fs):\n  done={f for f in fs\n  if f._state in[CANCELLED_AND_NOTIFIED,FINISHED]}\n  not_done=fs -done\n  if(return_when ==FIRST_COMPLETED)and done:\n   return DoneAndNotDoneFutures(done,not_done)\n  elif(return_when ==FIRST_EXCEPTION)and done:\n   if any(f for f in done\n   if not f.cancelled()and f.exception()is not None):\n    return DoneAndNotDoneFutures(done,not_done)\n    \n  if len(done)==len(fs):\n   return DoneAndNotDoneFutures(done,not_done)\n   \n  waiter=_create_and_install_waiters(fs,return_when)\n  \n waiter.event.wait(timeout)\n for f in fs:\n  with f._condition:\n   f._waiters.remove(waiter)\n   \n done.update(waiter.finished_futures)\n return DoneAndNotDoneFutures(done,fs -done)\n \n \ndef _result_or_cancel(fut,timeout=None):\n try:\n  try:\n   return fut.result(timeout)\n  finally:\n   fut.cancel()\n finally:\n \n  del fut\n  \n  \nclass Future(object):\n ''\n \n def __init__(self):\n  ''\n  self._condition=threading.Condition()\n  self._state=PENDING\n  self._result=None\n  self._exception=None\n  self._waiters=[]\n  self._done_callbacks=[]\n  \n def _invoke_callbacks(self):\n  for callback in self._done_callbacks:\n   try:\n    callback(self)\n   except Exception:\n    LOGGER.exception('exception calling callback for %r',self)\n    \n def __repr__(self):\n  with self._condition:\n   if self._state ==FINISHED:\n    if self._exception:\n     return '<%s at %#x state=%s raised %s>'%(\n     self.__class__.__name__,\n     id(self),\n     _STATE_TO_DESCRIPTION_MAP[self._state],\n     self._exception.__class__.__name__)\n    else:\n     return '<%s at %#x state=%s returned %s>'%(\n     self.__class__.__name__,\n     id(self),\n     _STATE_TO_DESCRIPTION_MAP[self._state],\n     self._result.__class__.__name__)\n   return '<%s at %#x state=%s>'%(\n   self.__class__.__name__,\n   id(self),\n   _STATE_TO_DESCRIPTION_MAP[self._state])\n   \n def cancel(self):\n  ''\n\n\n\n  \n  with self._condition:\n   if self._state in[RUNNING,FINISHED]:\n    return False\n    \n   if self._state in[CANCELLED,CANCELLED_AND_NOTIFIED]:\n    return True\n    \n   self._state=CANCELLED\n   self._condition.notify_all()\n   \n  self._invoke_callbacks()\n  return True\n  \n def cancelled(self):\n  ''\n  with self._condition:\n   return self._state in[CANCELLED,CANCELLED_AND_NOTIFIED]\n   \n def running(self):\n  ''\n  with self._condition:\n   return self._state ==RUNNING\n   \n def done(self):\n  ''\n  with self._condition:\n   return self._state in[CANCELLED,CANCELLED_AND_NOTIFIED,FINISHED]\n   \n def __get_result(self):\n  if self._exception:\n   try:\n    raise self._exception\n   finally:\n   \n    self=None\n  else:\n   return self._result\n   \n def add_done_callback(self,fn):\n  ''\n\n\n\n\n\n\n\n\n  \n  with self._condition:\n   if self._state not in[CANCELLED,CANCELLED_AND_NOTIFIED,FINISHED]:\n    self._done_callbacks.append(fn)\n    return\n  try:\n   fn(self)\n  except Exception:\n   LOGGER.exception('exception calling callback for %r',self)\n   \n def result(self,timeout=None):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  try:\n   with self._condition:\n    if self._state in[CANCELLED,CANCELLED_AND_NOTIFIED]:\n     raise CancelledError()\n    elif self._state ==FINISHED:\n     return self.__get_result()\n     \n    self._condition.wait(timeout)\n    \n    if self._state in[CANCELLED,CANCELLED_AND_NOTIFIED]:\n     raise CancelledError()\n    elif self._state ==FINISHED:\n     return self.__get_result()\n    else:\n     raise TimeoutError()\n  finally:\n  \n   self=None\n   \n def exception(self,timeout=None):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  with self._condition:\n   if self._state in[CANCELLED,CANCELLED_AND_NOTIFIED]:\n    raise CancelledError()\n   elif self._state ==FINISHED:\n    return self._exception\n    \n   self._condition.wait(timeout)\n   \n   if self._state in[CANCELLED,CANCELLED_AND_NOTIFIED]:\n    raise CancelledError()\n   elif self._state ==FINISHED:\n    return self._exception\n   else:\n    raise TimeoutError()\n    \n    \n def set_running_or_notify_cancel(self):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  with self._condition:\n   if self._state ==CANCELLED:\n    self._state=CANCELLED_AND_NOTIFIED\n    for waiter in self._waiters:\n     waiter.add_cancelled(self)\n     \n     \n    return False\n   elif self._state ==PENDING:\n    self._state=RUNNING\n    return True\n   else:\n    LOGGER.critical('Future %s in unexpected state: %s',\n    id(self),\n    self._state)\n    raise RuntimeError('Future in unexpected state')\n    \n def set_result(self,result):\n  ''\n\n\n  \n  with self._condition:\n   if self._state in{CANCELLED,CANCELLED_AND_NOTIFIED,FINISHED}:\n    raise InvalidStateError('{}: {!r}'.format(self._state,self))\n   self._result=result\n   self._state=FINISHED\n   for waiter in self._waiters:\n    waiter.add_result(self)\n   self._condition.notify_all()\n  self._invoke_callbacks()\n  \n def set_exception(self,exception):\n  ''\n\n\n  \n  with self._condition:\n   if self._state in{CANCELLED,CANCELLED_AND_NOTIFIED,FINISHED}:\n    raise InvalidStateError('{}: {!r}'.format(self._state,self))\n   self._exception=exception\n   self._state=FINISHED\n   for waiter in self._waiters:\n    waiter.add_exception(self)\n   self._condition.notify_all()\n  self._invoke_callbacks()\n  \n __class_getitem__=classmethod(types.GenericAlias)\n \nclass Executor(object):\n ''\n \n def submit(self,fn,/,*args,**kwargs):\n  ''\n\n\n\n\n\n\n  \n  raise NotImplementedError()\n  \n def map(self,fn,*iterables,timeout=None,chunksize=1):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  if timeout is not None:\n   end_time=timeout+time.monotonic()\n   \n  fs=[self.submit(fn,*args)for args in zip(*iterables)]\n  \n  \n  \n  def result_iterator():\n   try:\n   \n    fs.reverse()\n    while fs:\n    \n     if timeout is None:\n      yield _result_or_cancel(fs.pop())\n     else:\n      yield _result_or_cancel(fs.pop(),end_time -time.monotonic())\n   finally:\n    for future in fs:\n     future.cancel()\n  return result_iterator()\n  \n def shutdown(self,wait=True,*,cancel_futures=False):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n  \n  pass\n  \n def __enter__(self):\n  return self\n  \n def __exit__(self,exc_type,exc_val,exc_tb):\n  self.shutdown(wait=True)\n  return False\n  \n  \nclass BrokenExecutor(RuntimeError):\n ''\n\n \n", ["collections", "logging", "threading", "time", "types"]], "concurrent.futures": [".py", "\n\n\n\"\"\"Execute computations asynchronously using threads or processes.\"\"\"\n\n__author__='Brian Quinlan (brian@sweetapp.com)'\n\nfrom concurrent.futures._base import(FIRST_COMPLETED,\nFIRST_EXCEPTION,\nALL_COMPLETED,\nCancelledError,\nTimeoutError,\nInvalidStateError,\nBrokenExecutor,\nFuture,\nExecutor,\nwait,\nas_completed)\n\n__all__=(\n'FIRST_COMPLETED',\n'FIRST_EXCEPTION',\n'ALL_COMPLETED',\n'CancelledError',\n'TimeoutError',\n'BrokenExecutor',\n'Future',\n'Executor',\n'wait',\n'as_completed',\n'ProcessPoolExecutor',\n'ThreadPoolExecutor',\n)\n\n\ndef __dir__():\n return __all__+('__author__','__doc__')\n \n \ndef __getattr__(name):\n global ProcessPoolExecutor,ThreadPoolExecutor\n \n if name =='ProcessPoolExecutor':\n  from.process import ProcessPoolExecutor as pe\n  ProcessPoolExecutor=pe\n  return pe\n  \n if name =='ThreadPoolExecutor':\n  from.thread import ThreadPoolExecutor as te\n  ThreadPoolExecutor=te\n  return te\n  \n raise AttributeError(f\"module {__name__ !r} has no attribute {name !r}\")\n", ["concurrent.futures._base", "concurrent.futures.process", "concurrent.futures.thread"], 1], "email.generator": [".py", "\n\n\n\n\"\"\"Classes to generate plain text from a message object tree.\"\"\"\n\n__all__=['Generator','DecodedGenerator','BytesGenerator']\n\nimport re\nimport sys\nimport time\nimport random\n\nfrom copy import deepcopy\nfrom io import StringIO,BytesIO\nfrom email.utils import _has_surrogates\n\nUNDERSCORE='_'\nNL='\\n'\n\nNLCRE=re.compile(r'\\r\\n|\\r|\\n')\nfcre=re.compile(r'^From ',re.MULTILINE)\n\n\nclass Generator:\n ''\n\n\n\n \n \n \n \n \n def __init__(self,outfp,mangle_from_=None,maxheaderlen=None,*,\n policy=None):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  if mangle_from_ is None:\n   mangle_from_=True if policy is None else policy.mangle_from_\n  self._fp=outfp\n  self._mangle_from_=mangle_from_\n  self.maxheaderlen=maxheaderlen\n  self.policy=policy\n  \n def write(self,s):\n \n  self._fp.write(s)\n  \n def flatten(self,msg,unixfrom=False,linesep=None):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  \n  \n  \n  policy=msg.policy if self.policy is None else self.policy\n  if linesep is not None:\n   policy=policy.clone(linesep=linesep)\n  if self.maxheaderlen is not None:\n   policy=policy.clone(max_line_length=self.maxheaderlen)\n  self._NL=policy.linesep\n  self._encoded_NL=self._encode(self._NL)\n  self._EMPTY=''\n  self._encoded_EMPTY=self._encode(self._EMPTY)\n  \n  \n  \n  \n  old_gen_policy=self.policy\n  old_msg_policy=msg.policy\n  try:\n   self.policy=policy\n   msg.policy=policy\n   if unixfrom:\n    ufrom=msg.get_unixfrom()\n    if not ufrom:\n     ufrom='From nobody '+time.ctime(time.time())\n    self.write(ufrom+self._NL)\n   self._write(msg)\n  finally:\n   self.policy=old_gen_policy\n   msg.policy=old_msg_policy\n   \n def clone(self,fp):\n  ''\n  return self.__class__(fp,\n  self._mangle_from_,\n  None,\n  policy=self.policy)\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n def _new_buffer(self):\n \n  return StringIO()\n  \n def _encode(self,s):\n \n  return s\n  \n def _write_lines(self,lines):\n \n  if not lines:\n   return\n  lines=NLCRE.split(lines)\n  for line in lines[:-1]:\n   self.write(line)\n   self.write(self._NL)\n  if lines[-1]:\n   self.write(lines[-1])\n   \n   \n   \n   \n   \n   \n def _write(self,msg):\n \n \n \n \n \n \n \n \n \n \n \n  oldfp=self._fp\n  try:\n   self._munge_cte=None\n   self._fp=sfp=self._new_buffer()\n   self._dispatch(msg)\n  finally:\n   self._fp=oldfp\n   munge_cte=self._munge_cte\n   del self._munge_cte\n   \n  if munge_cte:\n   msg=deepcopy(msg)\n   \n   if msg.get('content-transfer-encoding')is None:\n    msg['Content-Transfer-Encoding']=munge_cte[0]\n   else:\n    msg.replace_header('content-transfer-encoding',munge_cte[0])\n   msg.replace_header('content-type',munge_cte[1])\n   \n   \n  meth=getattr(msg,'_write_headers',None)\n  if meth is None:\n   self._write_headers(msg)\n  else:\n   meth(self)\n  self._fp.write(sfp.getvalue())\n  \n def _dispatch(self,msg):\n \n \n \n \n  main=msg.get_content_maintype()\n  sub=msg.get_content_subtype()\n  specific=UNDERSCORE.join((main,sub)).replace('-','_')\n  meth=getattr(self,'_handle_'+specific,None)\n  if meth is None:\n   generic=main.replace('-','_')\n   meth=getattr(self,'_handle_'+generic,None)\n   if meth is None:\n    meth=self._writeBody\n  meth(msg)\n  \n  \n  \n  \n  \n def _write_headers(self,msg):\n  for h,v in msg.raw_items():\n   self.write(self.policy.fold(h,v))\n   \n  self.write(self._NL)\n  \n  \n  \n  \n  \n def _handle_text(self,msg):\n  payload=msg.get_payload()\n  if payload is None:\n   return\n  if not isinstance(payload,str):\n   raise TypeError('string payload expected: %s'%type(payload))\n  if _has_surrogates(msg._payload):\n   charset=msg.get_param('charset')\n   if charset is not None:\n   \n   \n    msg=deepcopy(msg)\n    del msg['content-transfer-encoding']\n    msg.set_payload(msg._payload,charset)\n    payload=msg.get_payload()\n    self._munge_cte=(msg['content-transfer-encoding'],\n    msg['content-type'])\n  if self._mangle_from_:\n   payload=fcre.sub('>From ',payload)\n  self._write_lines(payload)\n  \n  \n _writeBody=_handle_text\n \n def _handle_multipart(self,msg):\n \n \n \n  msgtexts=[]\n  subparts=msg.get_payload()\n  if subparts is None:\n   subparts=[]\n  elif isinstance(subparts,str):\n  \n   self.write(subparts)\n   return\n  elif not isinstance(subparts,list):\n  \n   subparts=[subparts]\n  for part in subparts:\n   s=self._new_buffer()\n   g=self.clone(s)\n   g.flatten(part,unixfrom=False,linesep=self._NL)\n   msgtexts.append(s.getvalue())\n   \n  boundary=msg.get_boundary()\n  if not boundary:\n  \n  \n   alltext=self._encoded_NL.join(msgtexts)\n   boundary=self._make_boundary(alltext)\n   msg.set_boundary(boundary)\n   \n  if msg.preamble is not None:\n   if self._mangle_from_:\n    preamble=fcre.sub('>From ',msg.preamble)\n   else:\n    preamble=msg.preamble\n   self._write_lines(preamble)\n   self.write(self._NL)\n   \n  self.write('--'+boundary+self._NL)\n  \n  if msgtexts:\n   self._fp.write(msgtexts.pop(0))\n   \n   \n   \n  for body_part in msgtexts:\n  \n   self.write(self._NL+'--'+boundary+self._NL)\n   \n   self._fp.write(body_part)\n   \n  self.write(self._NL+'--'+boundary+'--'+self._NL)\n  if msg.epilogue is not None:\n   if self._mangle_from_:\n    epilogue=fcre.sub('>From ',msg.epilogue)\n   else:\n    epilogue=msg.epilogue\n   self._write_lines(epilogue)\n   \n def _handle_multipart_signed(self,msg):\n \n \n \n  p=self.policy\n  self.policy=p.clone(max_line_length=0)\n  try:\n   self._handle_multipart(msg)\n  finally:\n   self.policy=p\n   \n def _handle_message_delivery_status(self,msg):\n \n \n \n  blocks=[]\n  for part in msg.get_payload():\n   s=self._new_buffer()\n   g=self.clone(s)\n   g.flatten(part,unixfrom=False,linesep=self._NL)\n   text=s.getvalue()\n   lines=text.split(self._encoded_NL)\n   \n   if lines and lines[-1]==self._encoded_EMPTY:\n    blocks.append(self._encoded_NL.join(lines[:-1]))\n   else:\n    blocks.append(text)\n    \n    \n    \n  self._fp.write(self._encoded_NL.join(blocks))\n  \n def _handle_message(self,msg):\n  s=self._new_buffer()\n  g=self.clone(s)\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  payload=msg._payload\n  if isinstance(payload,list):\n   g.flatten(msg.get_payload(0),unixfrom=False,linesep=self._NL)\n   payload=s.getvalue()\n  else:\n   payload=self._encode(payload)\n  self._fp.write(payload)\n  \n  \n  \n  \n  \n  \n @classmethod\n def _make_boundary(cls,text=None):\n \n \n  token=random.randrange(sys.maxsize)\n  boundary=('='*15)+(_fmt %token)+'=='\n  if text is None:\n   return boundary\n  b=boundary\n  counter=0\n  while True:\n   cre=cls._compile_re('^--'+re.escape(b)+'(--)?$',re.MULTILINE)\n   if not cre.search(text):\n    break\n   b=boundary+'.'+str(counter)\n   counter +=1\n  return b\n  \n @classmethod\n def _compile_re(cls,s,flags):\n  return re.compile(s,flags)\n  \n  \nclass BytesGenerator(Generator):\n ''\n\n\n\n\n\n\n\n\n\n \n \n def write(self,s):\n  self._fp.write(s.encode('ascii','surrogateescape'))\n  \n def _new_buffer(self):\n  return BytesIO()\n  \n def _encode(self,s):\n  return s.encode('ascii')\n  \n def _write_headers(self,msg):\n \n \n  for h,v in msg.raw_items():\n   self._fp.write(self.policy.fold_binary(h,v))\n   \n  self.write(self._NL)\n  \n def _handle_text(self,msg):\n \n \n  if msg._payload is None:\n   return\n  if _has_surrogates(msg._payload)and not self.policy.cte_type =='7bit':\n   if self._mangle_from_:\n    msg._payload=fcre.sub(\">From \",msg._payload)\n   self._write_lines(msg._payload)\n  else:\n   super(BytesGenerator,self)._handle_text(msg)\n   \n   \n _writeBody=_handle_text\n \n @classmethod\n def _compile_re(cls,s,flags):\n  return re.compile(s.encode('ascii'),flags)\n  \n  \n_FMT='[Non-text (%(type)s) part of message omitted, filename %(filename)s]'\n\nclass DecodedGenerator(Generator):\n ''\n\n\n\n \n def __init__(self,outfp,mangle_from_=None,maxheaderlen=None,fmt=None,*,\n policy=None):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  Generator.__init__(self,outfp,mangle_from_,maxheaderlen,\n  policy=policy)\n  if fmt is None:\n   self._fmt=_FMT\n  else:\n   self._fmt=fmt\n   \n def _dispatch(self,msg):\n  for part in msg.walk():\n   maintype=part.get_content_maintype()\n   if maintype =='text':\n    print(part.get_payload(decode=False),file=self)\n   elif maintype =='multipart':\n   \n    pass\n   else:\n    print(self._fmt %{\n    'type':part.get_content_type(),\n    'maintype':part.get_content_maintype(),\n    'subtype':part.get_content_subtype(),\n    'filename':part.get_filename('[no filename]'),\n    'description':part.get('Content-Description',\n    '[no description]'),\n    'encoding':part.get('Content-Transfer-Encoding',\n    '[no encoding]'),\n    },file=self)\n    \n    \n    \n_width=len(repr(sys.maxsize -1))\n_fmt='%%0%dd'%_width\n\n\n_make_boundary=Generator._make_boundary\n", ["copy", "email.utils", "io", "random", "re", "sys", "time"]], "email.header": [".py", "\n\n\n\n\"\"\"Header encoding and decoding functionality.\"\"\"\n\n__all__=[\n'Header',\n'decode_header',\n'make_header',\n]\n\nimport re\nimport binascii\n\nimport email.quoprimime\nimport email.base64mime\n\nfrom email.errors import HeaderParseError\nfrom email import charset as _charset\nCharset=_charset.Charset\n\nNL='\\n'\nSPACE=' '\nBSPACE=b' '\nSPACE8=' '*8\nEMPTYSTRING=''\nMAXLINELEN=78\nFWS=' \\t'\n\nUSASCII=Charset('us-ascii')\nUTF8=Charset('utf-8')\n\n\necre=re.compile(r'''\n  =\\?                   # literal =?\n  (?P<charset>[^?]*?)   # non-greedy up to the next ? is the charset\n  \\?                    # literal ?\n  (?P<encoding>[qQbB])  # either a \"q\" or a \"b\", case insensitive\n  \\?                    # literal ?\n  (?P<encoded>.*?)      # non-greedy up to the next ?= is the encoded string\n  \\?=                   # literal ?=\n  ''',re.VERBOSE |re.MULTILINE)\n\n\n\n\nfcre=re.compile(r'[\\041-\\176]+:$')\n\n\n\n_embedded_header=re.compile(r'\\n[^ \\t]+:')\n\n\n\n_max_append=email.quoprimime._max_append\n\n\ndef decode_header(header):\n ''\n\n\n\n\n\n\n\n\n\n\n\n \n \n if hasattr(header,'_chunks'):\n  return[(_charset._encode(string,str(charset)),str(charset))\n  for string,charset in header._chunks]\n  \n if not ecre.search(header):\n  return[(header,None)]\n  \n  \n  \n words=[]\n for line in header.splitlines():\n  parts=ecre.split(line)\n  first=True\n  while parts:\n   unencoded=parts.pop(0)\n   if first:\n    unencoded=unencoded.lstrip()\n    first=False\n   if unencoded:\n    words.append((unencoded,None,None))\n   if parts:\n    charset=parts.pop(0).lower()\n    encoding=parts.pop(0).lower()\n    encoded=parts.pop(0)\n    words.append((encoded,encoding,charset))\n    \n    \n droplist=[]\n for n,w in enumerate(words):\n  if n >1 and w[1]and words[n -2][1]and words[n -1][0].isspace():\n   droplist.append(n -1)\n for d in reversed(droplist):\n  del words[d]\n  \n  \n  \n  \n decoded_words=[]\n for encoded_string,encoding,charset in words:\n  if encoding is None:\n  \n   decoded_words.append((encoded_string,charset))\n  elif encoding =='q':\n   word=email.quoprimime.header_decode(encoded_string)\n   decoded_words.append((word,charset))\n  elif encoding =='b':\n   paderr=len(encoded_string)%4\n   if paderr:\n    encoded_string +='==='[:4 -paderr]\n   try:\n    word=email.base64mime.decode(encoded_string)\n   except binascii.Error:\n    raise HeaderParseError('Base64 decoding error')\n   else:\n    decoded_words.append((word,charset))\n  else:\n   raise AssertionError('Unexpected encoding: '+encoding)\n   \n   \n collapsed=[]\n last_word=last_charset=None\n for word,charset in decoded_words:\n  if isinstance(word,str):\n   word=bytes(word,'raw-unicode-escape')\n  if last_word is None:\n   last_word=word\n   last_charset=charset\n  elif charset !=last_charset:\n   collapsed.append((last_word,last_charset))\n   last_word=word\n   last_charset=charset\n  elif last_charset is None:\n   last_word +=BSPACE+word\n  else:\n   last_word +=word\n collapsed.append((last_word,last_charset))\n return collapsed\n \n \ndef make_header(decoded_seq,maxlinelen=None,header_name=None,\ncontinuation_ws=' '):\n ''\n\n\n\n\n\n\n\n\n \n h=Header(maxlinelen=maxlinelen,header_name=header_name,\n continuation_ws=continuation_ws)\n for s,charset in decoded_seq:\n \n  if charset is not None and not isinstance(charset,Charset):\n   charset=Charset(charset)\n  h.append(s,charset)\n return h\n \n \nclass Header:\n def __init__(self,s=None,charset=None,\n maxlinelen=None,header_name=None,\n continuation_ws=' ',errors='strict'):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  if charset is None:\n   charset=USASCII\n  elif not isinstance(charset,Charset):\n   charset=Charset(charset)\n  self._charset=charset\n  self._continuation_ws=continuation_ws\n  self._chunks=[]\n  if s is not None:\n   self.append(s,charset,errors)\n  if maxlinelen is None:\n   maxlinelen=MAXLINELEN\n  self._maxlinelen=maxlinelen\n  if header_name is None:\n   self._headerlen=0\n  else:\n  \n   self._headerlen=len(header_name)+2\n   \n def __str__(self):\n  ''\n  self._normalize()\n  uchunks=[]\n  lastcs=None\n  lastspace=None\n  for string,charset in self._chunks:\n  \n  \n  \n  \n  \n  \n   nextcs=charset\n   if nextcs ==_charset.UNKNOWN8BIT:\n    original_bytes=string.encode('ascii','surrogateescape')\n    string=original_bytes.decode('ascii','replace')\n   if uchunks:\n    hasspace=string and self._nonctext(string[0])\n    if lastcs not in(None,'us-ascii'):\n     if nextcs in(None,'us-ascii')and not hasspace:\n      uchunks.append(SPACE)\n      nextcs=None\n    elif nextcs not in(None,'us-ascii')and not lastspace:\n     uchunks.append(SPACE)\n   lastspace=string and self._nonctext(string[-1])\n   lastcs=nextcs\n   uchunks.append(string)\n  return EMPTYSTRING.join(uchunks)\n  \n  \n  \n def __eq__(self,other):\n \n \n \n  return other ==str(self)\n  \n def append(self,s,charset=None,errors='strict'):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  if charset is None:\n   charset=self._charset\n  elif not isinstance(charset,Charset):\n   charset=Charset(charset)\n  if not isinstance(s,str):\n   input_charset=charset.input_codec or 'us-ascii'\n   if input_charset ==_charset.UNKNOWN8BIT:\n    s=s.decode('us-ascii','surrogateescape')\n   else:\n    s=s.decode(input_charset,errors)\n    \n    \n  output_charset=charset.output_codec or 'us-ascii'\n  if output_charset !=_charset.UNKNOWN8BIT:\n   try:\n    s.encode(output_charset,errors)\n   except UnicodeEncodeError:\n    if output_charset !='us-ascii':\n     raise\n    charset=UTF8\n  self._chunks.append((s,charset))\n  \n def _nonctext(self,s):\n  ''\n  \n  return s.isspace()or s in('(',')','\\\\')\n  \n def encode(self,splitchars=';, \\t',maxlinelen=None,linesep='\\n'):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  self._normalize()\n  if maxlinelen is None:\n   maxlinelen=self._maxlinelen\n   \n   \n   \n  if maxlinelen ==0:\n   maxlinelen=1000000\n  formatter=_ValueFormatter(self._headerlen,maxlinelen,\n  self._continuation_ws,splitchars)\n  lastcs=None\n  hasspace=lastspace=None\n  for string,charset in self._chunks:\n   if hasspace is not None:\n    hasspace=string and self._nonctext(string[0])\n    if lastcs not in(None,'us-ascii'):\n     if not hasspace or charset not in(None,'us-ascii'):\n      formatter.add_transition()\n    elif charset not in(None,'us-ascii')and not lastspace:\n     formatter.add_transition()\n   lastspace=string and self._nonctext(string[-1])\n   lastcs=charset\n   hasspace=False\n   lines=string.splitlines()\n   if lines:\n    formatter.feed('',lines[0],charset)\n   else:\n    formatter.feed('','',charset)\n   for line in lines[1:]:\n    formatter.newline()\n    if charset.header_encoding is not None:\n     formatter.feed(self._continuation_ws,' '+line.lstrip(),\n     charset)\n    else:\n     sline=line.lstrip()\n     fws=line[:len(line)-len(sline)]\n     formatter.feed(fws,sline,charset)\n   if len(lines)>1:\n    formatter.newline()\n  if self._chunks:\n   formatter.add_transition()\n  value=formatter._str(linesep)\n  if _embedded_header.search(value):\n   raise HeaderParseError(\"header value appears to contain \"\n   \"an embedded header: {!r}\".format(value))\n  return value\n  \n def _normalize(self):\n \n \n  chunks=[]\n  last_charset=None\n  last_chunk=[]\n  for string,charset in self._chunks:\n   if charset ==last_charset:\n    last_chunk.append(string)\n   else:\n    if last_charset is not None:\n     chunks.append((SPACE.join(last_chunk),last_charset))\n    last_chunk=[string]\n    last_charset=charset\n  if last_chunk:\n   chunks.append((SPACE.join(last_chunk),last_charset))\n  self._chunks=chunks\n  \n  \nclass _ValueFormatter:\n def __init__(self,headerlen,maxlen,continuation_ws,splitchars):\n  self._maxlen=maxlen\n  self._continuation_ws=continuation_ws\n  self._continuation_ws_len=len(continuation_ws)\n  self._splitchars=splitchars\n  self._lines=[]\n  self._current_line=_Accumulator(headerlen)\n  \n def _str(self,linesep):\n  self.newline()\n  return linesep.join(self._lines)\n  \n def __str__(self):\n  return self._str(NL)\n  \n def newline(self):\n  end_of_line=self._current_line.pop()\n  if end_of_line !=(' ',''):\n   self._current_line.push(*end_of_line)\n  if len(self._current_line)>0:\n   if self._current_line.is_onlyws()and self._lines:\n    self._lines[-1]+=str(self._current_line)\n   else:\n    self._lines.append(str(self._current_line))\n  self._current_line.reset()\n  \n def add_transition(self):\n  self._current_line.push(' ','')\n  \n def feed(self,fws,string,charset):\n \n \n \n \n \n  if charset.header_encoding is None:\n   self._ascii_split(fws,string,self._splitchars)\n   return\n   \n   \n   \n   \n   \n   \n   \n  encoded_lines=charset.header_encode_lines(string,self._maxlengths())\n  \n  \n  try:\n   first_line=encoded_lines.pop(0)\n  except IndexError:\n  \n   return\n  if first_line is not None:\n   self._append_chunk(fws,first_line)\n  try:\n   last_line=encoded_lines.pop()\n  except IndexError:\n  \n   return\n  self.newline()\n  self._current_line.push(self._continuation_ws,last_line)\n  \n  for line in encoded_lines:\n   self._lines.append(self._continuation_ws+line)\n   \n def _maxlengths(self):\n \n  yield self._maxlen -len(self._current_line)\n  while True:\n   yield self._maxlen -self._continuation_ws_len\n   \n def _ascii_split(self,fws,string,splitchars):\n \n \n \n \n \n \n \n \n \n \n \n \n \n  parts=re.split(\"([\"+FWS+\"]+)\",fws+string)\n  if parts[0]:\n   parts[:0]=['']\n  else:\n   parts.pop(0)\n  for fws,part in zip(*[iter(parts)]*2):\n   self._append_chunk(fws,part)\n   \n def _append_chunk(self,fws,string):\n  self._current_line.push(fws,string)\n  if len(self._current_line)>self._maxlen:\n  \n  \n   for ch in self._splitchars:\n    for i in range(self._current_line.part_count()-1,0,-1):\n     if ch.isspace():\n      fws=self._current_line[i][0]\n      if fws and fws[0]==ch:\n       break\n     prevpart=self._current_line[i -1][1]\n     if prevpart and prevpart[-1]==ch:\n      break\n    else:\n     continue\n    break\n   else:\n    fws,part=self._current_line.pop()\n    if self._current_line._initial_size >0:\n    \n     self.newline()\n     if not fws:\n     \n     \n      fws=' '\n    self._current_line.push(fws,part)\n    return\n   remainder=self._current_line.pop_from(i)\n   self._lines.append(str(self._current_line))\n   self._current_line.reset(remainder)\n   \n   \nclass _Accumulator(list):\n\n def __init__(self,initial_size=0):\n  self._initial_size=initial_size\n  super().__init__()\n  \n def push(self,fws,string):\n  self.append((fws,string))\n  \n def pop_from(self,i=0):\n  popped=self[i:]\n  self[i:]=[]\n  return popped\n  \n def pop(self):\n  if self.part_count()==0:\n   return('','')\n  return super().pop()\n  \n def __len__(self):\n  return sum((len(fws)+len(part)for fws,part in self),\n  self._initial_size)\n  \n def __str__(self):\n  return EMPTYSTRING.join((EMPTYSTRING.join((fws,part))\n  for fws,part in self))\n  \n def reset(self,startval=None):\n  if startval is None:\n   startval=[]\n  self[:]=startval\n  self._initial_size=0\n  \n def is_onlyws(self):\n  return self._initial_size ==0 and(not self or str(self).isspace())\n  \n def part_count(self):\n  return super().__len__()\n", ["binascii", "email", "email.base64mime", "email.charset", "email.errors", "email.quoprimime", "re"]], "email.iterators": [".py", "\n\n\n\n\"\"\"Various types of useful iterators and generators.\"\"\"\n\n__all__=[\n'body_line_iterator',\n'typed_subpart_iterator',\n'walk',\n\n]\n\nimport sys\nfrom io import StringIO\n\n\n\ndef walk(self):\n ''\n\n\n\n \n yield self\n if self.is_multipart():\n  for subpart in self.get_payload():\n   yield from subpart.walk()\n   \n   \n   \ndef body_line_iterator(msg,decode=False):\n ''\n\n\n \n for subpart in msg.walk():\n  payload=subpart.get_payload(decode=decode)\n  if isinstance(payload,str):\n   yield from StringIO(payload)\n   \n   \ndef typed_subpart_iterator(msg,maintype='text',subtype=None):\n ''\n\n\n\n\n \n for subpart in msg.walk():\n  if subpart.get_content_maintype()==maintype:\n   if subtype is None or subpart.get_content_subtype()==subtype:\n    yield subpart\n    \n    \ndef _structure(msg,fp=None,level=0,include_default=False):\n ''\n if fp is None:\n  fp=sys.stdout\n tab=' '*(level *4)\n print(tab+msg.get_content_type(),end='',file=fp)\n if include_default:\n  print(' [%s]'%msg.get_default_type(),file=fp)\n else:\n  print(file=fp)\n if msg.is_multipart():\n  for subpart in msg.get_payload():\n   _structure(subpart,fp,level+1,include_default)\n", ["io", "sys"]], "email.parser": [".py", "\n\n\n\n\"\"\"A parser of RFC 2822 and MIME email messages.\"\"\"\n\n__all__=['Parser','HeaderParser','BytesParser','BytesHeaderParser',\n'FeedParser','BytesFeedParser']\n\nfrom io import StringIO,TextIOWrapper\n\nfrom email.feedparser import FeedParser,BytesFeedParser\nfrom email._policybase import compat32\n\n\nclass Parser:\n def __init__(self,_class=None,*,policy=compat32):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  self._class=_class\n  self.policy=policy\n  \n def parse(self,fp,headersonly=False):\n  ''\n\n\n\n\n\n  \n  feedparser=FeedParser(self._class,policy=self.policy)\n  if headersonly:\n   feedparser._set_headersonly()\n  while data :=fp.read(8192):\n   feedparser.feed(data)\n  return feedparser.close()\n  \n def parsestr(self,text,headersonly=False):\n  ''\n\n\n\n\n\n  \n  return self.parse(StringIO(text),headersonly=headersonly)\n  \n  \nclass HeaderParser(Parser):\n def parse(self,fp,headersonly=True):\n  return Parser.parse(self,fp,True)\n  \n def parsestr(self,text,headersonly=True):\n  return Parser.parsestr(self,text,True)\n  \n  \nclass BytesParser:\n\n def __init__(self,*args,**kw):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  self.parser=Parser(*args,**kw)\n  \n def parse(self,fp,headersonly=False):\n  ''\n\n\n\n\n\n  \n  fp=TextIOWrapper(fp,encoding='ascii',errors='surrogateescape')\n  try:\n   return self.parser.parse(fp,headersonly)\n  finally:\n   fp.detach()\n   \n   \n def parsebytes(self,text,headersonly=False):\n  ''\n\n\n\n\n\n  \n  text=text.decode('ASCII',errors='surrogateescape')\n  return self.parser.parsestr(text,headersonly)\n  \n  \nclass BytesHeaderParser(BytesParser):\n def parse(self,fp,headersonly=True):\n  return BytesParser.parse(self,fp,headersonly=True)\n  \n def parsebytes(self,text,headersonly=True):\n  return BytesParser.parsebytes(self,text,headersonly=True)\n", ["email._policybase", "email.feedparser", "io"]], "email.utils": [".py", "\n\n\n\n\"\"\"Miscellaneous utilities.\"\"\"\n\n__all__=[\n'collapse_rfc2231_value',\n'decode_params',\n'decode_rfc2231',\n'encode_rfc2231',\n'formataddr',\n'formatdate',\n'format_datetime',\n'getaddresses',\n'make_msgid',\n'mktime_tz',\n'parseaddr',\n'parsedate',\n'parsedate_tz',\n'parsedate_to_datetime',\n'unquote',\n]\n\nimport os\nimport re\nimport time\nimport datetime\nimport urllib.parse\n\nfrom email._parseaddr import quote\nfrom email._parseaddr import AddressList as _AddressList\nfrom email._parseaddr import mktime_tz\n\nfrom email._parseaddr import parsedate,parsedate_tz,_parsedate_tz\n\nCOMMASPACE=', '\nEMPTYSTRING=''\nUEMPTYSTRING=''\nCRLF='\\r\\n'\nTICK=\"'\"\n\nspecialsre=re.compile(r'[][\\\\()<>@,:;\".]')\nescapesre=re.compile(r'[\\\\\"]')\n\n\ndef _has_surrogates(s):\n ''\n \n \n \n try:\n  s.encode()\n  return False\n except UnicodeEncodeError:\n  return True\n  \n  \n  \ndef _sanitize(string):\n\n\n\n\n original_bytes=string.encode('utf-8','surrogateescape')\n return original_bytes.decode('utf-8','replace')\n \n \n \n \n \ndef formataddr(pair,charset='utf-8'):\n ''\n\n\n\n\n\n\n\n\n\n\n \n name,address=pair\n \n address.encode('ascii')\n if name:\n  try:\n   name.encode('ascii')\n  except UnicodeEncodeError:\n   if isinstance(charset,str):\n   \n    from email.charset import Charset\n    charset=Charset(charset)\n   encoded_name=charset.header_encode(name)\n   return \"%s <%s>\"%(encoded_name,address)\n  else:\n   quotes=''\n   if specialsre.search(name):\n    quotes='\"'\n   name=escapesre.sub(r'\\\\\\g<0>',name)\n   return '%s%s%s <%s>'%(quotes,name,quotes,address)\n return address\n \n \ndef _iter_escaped_chars(addr):\n pos=0\n escape=False\n for pos,ch in enumerate(addr):\n  if escape:\n   yield(pos,'\\\\'+ch)\n   escape=False\n  elif ch =='\\\\':\n   escape=True\n  else:\n   yield(pos,ch)\n if escape:\n  yield(pos,'\\\\')\n  \n  \ndef _strip_quoted_realnames(addr):\n ''\n if '\"'not in addr:\n \n  return addr\n  \n start=0\n open_pos=None\n result=[]\n for pos,ch in _iter_escaped_chars(addr):\n  if ch =='\"':\n   if open_pos is None:\n    open_pos=pos\n   else:\n    if start !=open_pos:\n     result.append(addr[start:open_pos])\n    start=pos+1\n    open_pos=None\n    \n if start <len(addr):\n  result.append(addr[start:])\n  \n return ''.join(result)\n \n \nsupports_strict_parsing=True\n\ndef getaddresses(fieldvalues,*,strict=True):\n ''\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n if not strict:\n  all=COMMASPACE.join(str(v)for v in fieldvalues)\n  a=_AddressList(all)\n  return a.addresslist\n  \n fieldvalues=[str(v)for v in fieldvalues]\n fieldvalues=_pre_parse_validation(fieldvalues)\n addr=COMMASPACE.join(fieldvalues)\n a=_AddressList(addr)\n result=_post_parse_validation(a.addresslist)\n \n \n \n n=0\n for v in fieldvalues:\n \n \n  v=_strip_quoted_realnames(v)\n  \n  n +=1+v.count(',')\n if len(result)!=n:\n  return[('','')]\n  \n return result\n \n \ndef _check_parenthesis(addr):\n\n addr=_strip_quoted_realnames(addr)\n \n opens=0\n for pos,ch in _iter_escaped_chars(addr):\n  if ch =='(':\n   opens +=1\n  elif ch ==')':\n   opens -=1\n   if opens <0:\n    return False\n return(opens ==0)\n \n \ndef _pre_parse_validation(email_header_fields):\n accepted_values=[]\n for v in email_header_fields:\n  if not _check_parenthesis(v):\n   v=\"('', '')\"\n  accepted_values.append(v)\n  \n return accepted_values\n \n \ndef _post_parse_validation(parsed_email_header_tuples):\n accepted_values=[]\n \n \n for v in parsed_email_header_tuples:\n  if '['in v[1]:\n   v=('','')\n  accepted_values.append(v)\n  \n return accepted_values\n \n \ndef _format_timetuple_and_zone(timetuple,zone):\n return '%s, %02d %s %04d %02d:%02d:%02d %s'%(\n ['Mon','Tue','Wed','Thu','Fri','Sat','Sun'][timetuple[6]],\n timetuple[2],\n ['Jan','Feb','Mar','Apr','May','Jun',\n 'Jul','Aug','Sep','Oct','Nov','Dec'][timetuple[1]-1],\n timetuple[0],timetuple[3],timetuple[4],timetuple[5],\n zone)\n \ndef formatdate(timeval=None,localtime=False,usegmt=False):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n if timeval is None:\n  timeval=time.time()\n dt=datetime.datetime.fromtimestamp(timeval,datetime.timezone.utc)\n \n if localtime:\n  dt=dt.astimezone()\n  usegmt=False\n elif not usegmt:\n  dt=dt.replace(tzinfo=None)\n return format_datetime(dt,usegmt)\n \ndef format_datetime(dt,usegmt=False):\n ''\n\n\n\n\n \n now=dt.timetuple()\n if usegmt:\n  if dt.tzinfo is None or dt.tzinfo !=datetime.timezone.utc:\n   raise ValueError(\"usegmt option requires a UTC datetime\")\n  zone='GMT'\n elif dt.tzinfo is None:\n  zone='-0000'\n else:\n  zone=dt.strftime(\"%z\")\n return _format_timetuple_and_zone(now,zone)\n \n \ndef make_msgid(idstring=None,domain=None):\n ''\n\n\n\n\n\n\n\n \n \n \n import random\n import socket\n \n timeval=int(time.time()*100)\n pid=os.getpid()\n randint=random.getrandbits(64)\n if idstring is None:\n  idstring=''\n else:\n  idstring='.'+idstring\n if domain is None:\n  domain=socket.getfqdn()\n msgid='<%d.%d.%d%s@%s>'%(timeval,pid,randint,idstring,domain)\n return msgid\n \n \ndef parsedate_to_datetime(data):\n parsed_date_tz=_parsedate_tz(data)\n if parsed_date_tz is None:\n  raise ValueError('Invalid date value or format \"%s\"'%str(data))\n *dtuple,tz=parsed_date_tz\n if tz is None:\n  return datetime.datetime(*dtuple[:6])\n return datetime.datetime(*dtuple[:6],\n tzinfo=datetime.timezone(datetime.timedelta(seconds=tz)))\n \n \ndef parseaddr(addr,*,strict=True):\n ''\n\n\n\n\n\n\n \n if not strict:\n  addrs=_AddressList(addr).addresslist\n  if not addrs:\n   return('','')\n  return addrs[0]\n  \n if isinstance(addr,list):\n  addr=addr[0]\n  \n if not isinstance(addr,str):\n  return('','')\n  \n addr=_pre_parse_validation([addr])[0]\n addrs=_post_parse_validation(_AddressList(addr).addresslist)\n \n if not addrs or len(addrs)>1:\n  return('','')\n  \n return addrs[0]\n \n \n \ndef unquote(str):\n ''\n if len(str)>1:\n  if str.startswith('\"')and str.endswith('\"'):\n   return str[1:-1].replace('\\\\\\\\','\\\\').replace('\\\\\"','\"')\n  if str.startswith('<')and str.endswith('>'):\n   return str[1:-1]\n return str\n \n \n \n \ndef decode_rfc2231(s):\n ''\n parts=s.split(TICK,2)\n if len(parts)<=2:\n  return None,None,s\n return parts\n \n \ndef encode_rfc2231(s,charset=None,language=None):\n ''\n\n\n\n\n \n s=urllib.parse.quote(s,safe='',encoding=charset or 'ascii')\n if charset is None and language is None:\n  return s\n if language is None:\n  language=''\n return \"%s'%s'%s\"%(charset,language,s)\n \n \nrfc2231_continuation=re.compile(r'^(?P<name>\\w+)\\*((?P<num>[0-9]+)\\*?)?$',\nre.ASCII)\n\ndef decode_params(params):\n ''\n\n\n \n new_params=[params[0]]\n \n \n \n rfc2231_params={}\n for name,value in params[1:]:\n  encoded=name.endswith('*')\n  value=unquote(value)\n  mo=rfc2231_continuation.match(name)\n  if mo:\n   name,num=mo.group('name','num')\n   if num is not None:\n    num=int(num)\n   rfc2231_params.setdefault(name,[]).append((num,value,encoded))\n  else:\n   new_params.append((name,'\"%s\"'%quote(value)))\n if rfc2231_params:\n  for name,continuations in rfc2231_params.items():\n   value=[]\n   extended=False\n   \n   continuations.sort()\n   \n   \n   \n   \n   \n   for num,s,encoded in continuations:\n    if encoded:\n    \n    \n    \n     s=urllib.parse.unquote(s,encoding=\"latin-1\")\n     extended=True\n    value.append(s)\n   value=quote(EMPTYSTRING.join(value))\n   if extended:\n    charset,language,value=decode_rfc2231(value)\n    new_params.append((name,(charset,language,'\"%s\"'%value)))\n   else:\n    new_params.append((name,'\"%s\"'%value))\n return new_params\n \ndef collapse_rfc2231_value(value,errors='replace',\nfallback_charset='us-ascii'):\n if not isinstance(value,tuple)or len(value)!=3:\n  return unquote(value)\n  \n  \n  \n charset,language,text=value\n if charset is None:\n \n \n  charset=fallback_charset\n rawbytes=bytes(text,'raw-unicode-escape')\n try:\n  return str(rawbytes,charset,errors)\n except LookupError:\n \n  return unquote(text)\n  \n  \n  \n  \n  \n  \n  \n  \ndef localtime(dt=None,isdst=None):\n ''\n\n\n\n\n\n\n\n \n if isdst is not None:\n  import warnings\n  warnings._deprecated(\n  \"The 'isdst' parameter to 'localtime'\",\n  message='{name} is deprecated and slated for removal in Python {remove}',\n  remove=(3,14),\n  )\n if dt is None:\n  dt=datetime.datetime.now()\n return dt.astimezone()\n", ["datetime", "email._parseaddr", "email.charset", "os", "random", "re", "socket", "time", "urllib.parse", "warnings"]], "email": [".py", "\n\n\n\n\"\"\"A package for parsing, handling, and generating email messages.\"\"\"\n\n__all__=[\n'base64mime',\n'charset',\n'encoders',\n'errors',\n'feedparser',\n'generator',\n'header',\n'iterators',\n'message',\n'message_from_file',\n'message_from_binary_file',\n'message_from_string',\n'message_from_bytes',\n'mime',\n'parser',\n'quoprimime',\n'utils',\n]\n\n\n\n\n\ndef message_from_string(s,*args,**kws):\n ''\n\n\n \n from email.parser import Parser\n return Parser(*args,**kws).parsestr(s)\n \ndef message_from_bytes(s,*args,**kws):\n ''\n\n\n \n from email.parser import BytesParser\n return BytesParser(*args,**kws).parsebytes(s)\n \ndef message_from_file(fp,*args,**kws):\n ''\n\n\n \n from email.parser import Parser\n return Parser(*args,**kws).parse(fp)\n \ndef message_from_binary_file(fp,*args,**kws):\n ''\n\n\n \n from email.parser import BytesParser\n return BytesParser(*args,**kws).parse(fp)\n", ["email.parser"], 1], "email.mime.base": [".py", "\n\n\n\n\"\"\"Base class for MIME specializations.\"\"\"\n\n__all__=['MIMEBase']\n\nimport email.policy\n\nfrom email import message\n\n\nclass MIMEBase(message.Message):\n ''\n \n def __init__(self,_maintype,_subtype,*,policy=None,**_params):\n  ''\n\n\n\n\n  \n  if policy is None:\n   policy=email.policy.compat32\n  message.Message.__init__(self,policy=policy)\n  ctype='%s/%s'%(_maintype,_subtype)\n  self.add_header('Content-Type',ctype,**_params)\n  self['MIME-Version']='1.0'\n", ["email", "email.message", "email.policy"]], "email.mime": [".py", "", [], 1], "encodings.aliases": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\naliases={\n\n\n\n\n'646':'ascii',\n'ansi_x3.4_1968':'ascii',\n'ansi_x3_4_1968':'ascii',\n'ansi_x3.4_1986':'ascii',\n'cp367':'ascii',\n'csascii':'ascii',\n'ibm367':'ascii',\n'iso646_us':'ascii',\n'iso_646.irv_1991':'ascii',\n'iso_ir_6':'ascii',\n'us':'ascii',\n'us_ascii':'ascii',\n\n\n'base64':'base64_codec',\n'base_64':'base64_codec',\n\n\n'big5_tw':'big5',\n'csbig5':'big5',\n\n\n'big5_hkscs':'big5hkscs',\n'hkscs':'big5hkscs',\n\n\n'bz2':'bz2_codec',\n\n\n'037':'cp037',\n'csibm037':'cp037',\n'ebcdic_cp_ca':'cp037',\n'ebcdic_cp_nl':'cp037',\n'ebcdic_cp_us':'cp037',\n'ebcdic_cp_wt':'cp037',\n'ibm037':'cp037',\n'ibm039':'cp037',\n\n\n'1026':'cp1026',\n'csibm1026':'cp1026',\n'ibm1026':'cp1026',\n\n\n'1125':'cp1125',\n'ibm1125':'cp1125',\n'cp866u':'cp1125',\n'ruscii':'cp1125',\n\n\n'1140':'cp1140',\n'ibm1140':'cp1140',\n\n\n'1250':'cp1250',\n'windows_1250':'cp1250',\n\n\n'1251':'cp1251',\n'windows_1251':'cp1251',\n\n\n'1252':'cp1252',\n'windows_1252':'cp1252',\n\n\n'1253':'cp1253',\n'windows_1253':'cp1253',\n\n\n'1254':'cp1254',\n'windows_1254':'cp1254',\n\n\n'1255':'cp1255',\n'windows_1255':'cp1255',\n\n\n'1256':'cp1256',\n'windows_1256':'cp1256',\n\n\n'1257':'cp1257',\n'windows_1257':'cp1257',\n\n\n'1258':'cp1258',\n'windows_1258':'cp1258',\n\n\n'273':'cp273',\n'ibm273':'cp273',\n'csibm273':'cp273',\n\n\n'424':'cp424',\n'csibm424':'cp424',\n'ebcdic_cp_he':'cp424',\n'ibm424':'cp424',\n\n\n'437':'cp437',\n'cspc8codepage437':'cp437',\n'ibm437':'cp437',\n\n\n'500':'cp500',\n'csibm500':'cp500',\n'ebcdic_cp_be':'cp500',\n'ebcdic_cp_ch':'cp500',\n'ibm500':'cp500',\n\n\n'775':'cp775',\n'cspc775baltic':'cp775',\n'ibm775':'cp775',\n\n\n'850':'cp850',\n'cspc850multilingual':'cp850',\n'ibm850':'cp850',\n\n\n'852':'cp852',\n'cspcp852':'cp852',\n'ibm852':'cp852',\n\n\n'855':'cp855',\n'csibm855':'cp855',\n'ibm855':'cp855',\n\n\n'857':'cp857',\n'csibm857':'cp857',\n'ibm857':'cp857',\n\n\n'858':'cp858',\n'csibm858':'cp858',\n'ibm858':'cp858',\n\n\n'860':'cp860',\n'csibm860':'cp860',\n'ibm860':'cp860',\n\n\n'861':'cp861',\n'cp_is':'cp861',\n'csibm861':'cp861',\n'ibm861':'cp861',\n\n\n'862':'cp862',\n'cspc862latinhebrew':'cp862',\n'ibm862':'cp862',\n\n\n'863':'cp863',\n'csibm863':'cp863',\n'ibm863':'cp863',\n\n\n'864':'cp864',\n'csibm864':'cp864',\n'ibm864':'cp864',\n\n\n'865':'cp865',\n'csibm865':'cp865',\n'ibm865':'cp865',\n\n\n'866':'cp866',\n'csibm866':'cp866',\n'ibm866':'cp866',\n\n\n'869':'cp869',\n'cp_gr':'cp869',\n'csibm869':'cp869',\n'ibm869':'cp869',\n\n\n'932':'cp932',\n'ms932':'cp932',\n'mskanji':'cp932',\n'ms_kanji':'cp932',\n'windows_31j':'cp932',\n\n\n'949':'cp949',\n'ms949':'cp949',\n'uhc':'cp949',\n\n\n'950':'cp950',\n'ms950':'cp950',\n\n\n'jisx0213':'euc_jis_2004',\n'eucjis2004':'euc_jis_2004',\n'euc_jis2004':'euc_jis_2004',\n\n\n'eucjisx0213':'euc_jisx0213',\n\n\n'eucjp':'euc_jp',\n'ujis':'euc_jp',\n'u_jis':'euc_jp',\n\n\n'euckr':'euc_kr',\n'korean':'euc_kr',\n'ksc5601':'euc_kr',\n'ks_c_5601':'euc_kr',\n'ks_c_5601_1987':'euc_kr',\n'ksx1001':'euc_kr',\n'ks_x_1001':'euc_kr',\n\n\n'gb18030_2000':'gb18030',\n\n\n'chinese':'gb2312',\n'csiso58gb231280':'gb2312',\n'euc_cn':'gb2312',\n'euccn':'gb2312',\n'eucgb2312_cn':'gb2312',\n'gb2312_1980':'gb2312',\n'gb2312_80':'gb2312',\n'iso_ir_58':'gb2312',\n\n\n'936':'gbk',\n'cp936':'gbk',\n'ms936':'gbk',\n\n\n'hex':'hex_codec',\n\n\n'roman8':'hp_roman8',\n'r8':'hp_roman8',\n'csHPRoman8':'hp_roman8',\n'cp1051':'hp_roman8',\n'ibm1051':'hp_roman8',\n\n\n'hzgb':'hz',\n'hz_gb':'hz',\n'hz_gb_2312':'hz',\n\n\n'csiso2022jp':'iso2022_jp',\n'iso2022jp':'iso2022_jp',\n'iso_2022_jp':'iso2022_jp',\n\n\n'iso2022jp_1':'iso2022_jp_1',\n'iso_2022_jp_1':'iso2022_jp_1',\n\n\n'iso2022jp_2':'iso2022_jp_2',\n'iso_2022_jp_2':'iso2022_jp_2',\n\n\n'iso_2022_jp_2004':'iso2022_jp_2004',\n'iso2022jp_2004':'iso2022_jp_2004',\n\n\n'iso2022jp_3':'iso2022_jp_3',\n'iso_2022_jp_3':'iso2022_jp_3',\n\n\n'iso2022jp_ext':'iso2022_jp_ext',\n'iso_2022_jp_ext':'iso2022_jp_ext',\n\n\n'csiso2022kr':'iso2022_kr',\n'iso2022kr':'iso2022_kr',\n'iso_2022_kr':'iso2022_kr',\n\n\n'csisolatin6':'iso8859_10',\n'iso_8859_10':'iso8859_10',\n'iso_8859_10_1992':'iso8859_10',\n'iso_ir_157':'iso8859_10',\n'l6':'iso8859_10',\n'latin6':'iso8859_10',\n\n\n'thai':'iso8859_11',\n'iso_8859_11':'iso8859_11',\n'iso_8859_11_2001':'iso8859_11',\n\n\n'iso_8859_13':'iso8859_13',\n'l7':'iso8859_13',\n'latin7':'iso8859_13',\n\n\n'iso_8859_14':'iso8859_14',\n'iso_8859_14_1998':'iso8859_14',\n'iso_celtic':'iso8859_14',\n'iso_ir_199':'iso8859_14',\n'l8':'iso8859_14',\n'latin8':'iso8859_14',\n\n\n'iso_8859_15':'iso8859_15',\n'l9':'iso8859_15',\n'latin9':'iso8859_15',\n\n\n'iso_8859_16':'iso8859_16',\n'iso_8859_16_2001':'iso8859_16',\n'iso_ir_226':'iso8859_16',\n'l10':'iso8859_16',\n'latin10':'iso8859_16',\n\n\n'csisolatin2':'iso8859_2',\n'iso_8859_2':'iso8859_2',\n'iso_8859_2_1987':'iso8859_2',\n'iso_ir_101':'iso8859_2',\n'l2':'iso8859_2',\n'latin2':'iso8859_2',\n\n\n'csisolatin3':'iso8859_3',\n'iso_8859_3':'iso8859_3',\n'iso_8859_3_1988':'iso8859_3',\n'iso_ir_109':'iso8859_3',\n'l3':'iso8859_3',\n'latin3':'iso8859_3',\n\n\n'csisolatin4':'iso8859_4',\n'iso_8859_4':'iso8859_4',\n'iso_8859_4_1988':'iso8859_4',\n'iso_ir_110':'iso8859_4',\n'l4':'iso8859_4',\n'latin4':'iso8859_4',\n\n\n'csisolatincyrillic':'iso8859_5',\n'cyrillic':'iso8859_5',\n'iso_8859_5':'iso8859_5',\n'iso_8859_5_1988':'iso8859_5',\n'iso_ir_144':'iso8859_5',\n\n\n'arabic':'iso8859_6',\n'asmo_708':'iso8859_6',\n'csisolatinarabic':'iso8859_6',\n'ecma_114':'iso8859_6',\n'iso_8859_6':'iso8859_6',\n'iso_8859_6_1987':'iso8859_6',\n'iso_ir_127':'iso8859_6',\n\n\n'csisolatingreek':'iso8859_7',\n'ecma_118':'iso8859_7',\n'elot_928':'iso8859_7',\n'greek':'iso8859_7',\n'greek8':'iso8859_7',\n'iso_8859_7':'iso8859_7',\n'iso_8859_7_1987':'iso8859_7',\n'iso_ir_126':'iso8859_7',\n\n\n'csisolatinhebrew':'iso8859_8',\n'hebrew':'iso8859_8',\n'iso_8859_8':'iso8859_8',\n'iso_8859_8_1988':'iso8859_8',\n'iso_ir_138':'iso8859_8',\n\n\n'csisolatin5':'iso8859_9',\n'iso_8859_9':'iso8859_9',\n'iso_8859_9_1989':'iso8859_9',\n'iso_ir_148':'iso8859_9',\n'l5':'iso8859_9',\n'latin5':'iso8859_9',\n\n\n'cp1361':'johab',\n'ms1361':'johab',\n\n\n'cskoi8r':'koi8_r',\n\n\n'kz_1048':'kz1048',\n'rk1048':'kz1048',\n'strk1048_2002':'kz1048',\n\n\n\n\n\n\n\n\n'8859':'latin_1',\n'cp819':'latin_1',\n'csisolatin1':'latin_1',\n'ibm819':'latin_1',\n'iso8859':'latin_1',\n'iso8859_1':'latin_1',\n'iso_8859_1':'latin_1',\n'iso_8859_1_1987':'latin_1',\n'iso_ir_100':'latin_1',\n'l1':'latin_1',\n'latin':'latin_1',\n'latin1':'latin_1',\n\n\n'maccyrillic':'mac_cyrillic',\n\n\n'macgreek':'mac_greek',\n\n\n'maciceland':'mac_iceland',\n\n\n'maccentraleurope':'mac_latin2',\n'mac_centeuro':'mac_latin2',\n'maclatin2':'mac_latin2',\n\n\n'macintosh':'mac_roman',\n'macroman':'mac_roman',\n\n\n'macturkish':'mac_turkish',\n\n\n'ansi':'mbcs',\n'dbcs':'mbcs',\n\n\n'csptcp154':'ptcp154',\n'pt154':'ptcp154',\n'cp154':'ptcp154',\n'cyrillic_asian':'ptcp154',\n\n\n'quopri':'quopri_codec',\n'quoted_printable':'quopri_codec',\n'quotedprintable':'quopri_codec',\n\n\n'rot13':'rot_13',\n\n\n'csshiftjis':'shift_jis',\n'shiftjis':'shift_jis',\n'sjis':'shift_jis',\n's_jis':'shift_jis',\n\n\n'shiftjis2004':'shift_jis_2004',\n'sjis_2004':'shift_jis_2004',\n's_jis_2004':'shift_jis_2004',\n\n\n'shiftjisx0213':'shift_jisx0213',\n'sjisx0213':'shift_jisx0213',\n's_jisx0213':'shift_jisx0213',\n\n\n'tis620':'tis_620',\n'tis_620_0':'tis_620',\n'tis_620_2529_0':'tis_620',\n'tis_620_2529_1':'tis_620',\n'iso_ir_166':'tis_620',\n\n\n'u16':'utf_16',\n'utf16':'utf_16',\n\n\n'unicodebigunmarked':'utf_16_be',\n'utf_16be':'utf_16_be',\n\n\n'unicodelittleunmarked':'utf_16_le',\n'utf_16le':'utf_16_le',\n\n\n'u32':'utf_32',\n'utf32':'utf_32',\n\n\n'utf_32be':'utf_32_be',\n\n\n'utf_32le':'utf_32_le',\n\n\n'u7':'utf_7',\n'utf7':'utf_7',\n'unicode_1_1_utf_7':'utf_7',\n\n\n'u8':'utf_8',\n'utf':'utf_8',\n'utf8':'utf_8',\n'utf8_ucs2':'utf_8',\n'utf8_ucs4':'utf_8',\n'cp65001':'utf_8',\n\n\n'uu':'uu_codec',\n\n\n'zip':'zlib_codec',\n'zlib':'zlib_codec',\n\n\n'x_mac_japanese':'shift_jis',\n'x_mac_korean':'euc_kr',\n'x_mac_simp_chinese':'gb2312',\n'x_mac_trad_chinese':'big5',\n}\n", []], "encodings.ascii": [".py", "''\n\n\n\n\n\n\n\nimport codecs\n\n\n\nclass Codec(codecs.Codec):\n\n\n\n encode=codecs.ascii_encode\n decode=codecs.ascii_decode\n \nclass IncrementalEncoder(codecs.IncrementalEncoder):\n def encode(self,input,final=False):\n  return codecs.ascii_encode(input,self.errors)[0]\n  \nclass IncrementalDecoder(codecs.IncrementalDecoder):\n def decode(self,input,final=False):\n  return codecs.ascii_decode(input,self.errors)[0]\n  \nclass StreamWriter(Codec,codecs.StreamWriter):\n pass\n \nclass StreamReader(Codec,codecs.StreamReader):\n pass\n \nclass StreamConverter(StreamWriter,StreamReader):\n\n encode=codecs.ascii_decode\n decode=codecs.ascii_encode\n \n \n \ndef getregentry():\n return codecs.CodecInfo(\n name='ascii',\n encode=Codec.encode,\n decode=Codec.decode,\n incrementalencoder=IncrementalEncoder,\n incrementaldecoder=IncrementalDecoder,\n streamwriter=StreamWriter,\n streamreader=StreamReader,\n )\n", ["codecs"]], "encodings.cp932": [".py", "\n\n\n\n\n\nimport _codecs_jp,codecs\nimport _multibytecodec as mbc\n\ncodec=_codecs_jp.getcodec('cp932')\n\nclass Codec(codecs.Codec):\n encode=codec.encode\n decode=codec.decode\n \nclass IncrementalEncoder(mbc.MultibyteIncrementalEncoder,\ncodecs.IncrementalEncoder):\n codec=codec\n \nclass IncrementalDecoder(mbc.MultibyteIncrementalDecoder,\ncodecs.IncrementalDecoder):\n codec=codec\n \nclass StreamReader(Codec,mbc.MultibyteStreamReader,codecs.StreamReader):\n codec=codec\n \nclass StreamWriter(Codec,mbc.MultibyteStreamWriter,codecs.StreamWriter):\n codec=codec\n \ndef getregentry():\n return codecs.CodecInfo(\n name='cp932',\n encode=Codec().encode,\n decode=Codec().decode,\n incrementalencoder=IncrementalEncoder,\n incrementaldecoder=IncrementalDecoder,\n streamreader=StreamReader,\n streamwriter=StreamWriter,\n )\n", ["_codecs_jp", "_multibytecodec", "codecs"]], "encodings": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport codecs\nimport sys\nfrom. import aliases\n\n_cache={}\n_unknown='--unknown--'\n_import_tail=['*']\n_aliases=aliases.aliases\n\nclass CodecRegistryError(LookupError,SystemError):\n pass\n \ndef normalize_encoding(encoding):\n\n ''\n\n\n\n\n\n\n\n\n \n if isinstance(encoding,bytes):\n  encoding=str(encoding,\"ascii\")\n  \n chars=[]\n punct=False\n for c in encoding:\n  if c.isalnum()or c =='.':\n   if punct and chars:\n    chars.append('_')\n   if c.isascii():\n    chars.append(c)\n   punct=False\n  else:\n   punct=True\n return ''.join(chars)\n \ndef search_function(encoding):\n\n\n entry=_cache.get(encoding,_unknown)\n if entry is not _unknown:\n  return entry\n  \n  \n  \n  \n  \n  \n  \n  \n norm_encoding=normalize_encoding(encoding)\n aliased_encoding=_aliases.get(norm_encoding)or\\\n _aliases.get(norm_encoding.replace('.','_'))\n if aliased_encoding is not None:\n  modnames=[aliased_encoding,\n  norm_encoding]\n else:\n  modnames=[norm_encoding]\n for modname in modnames:\n  if not modname or '.'in modname:\n   continue\n  try:\n  \n  \n   mod=__import__('encodings.'+modname,fromlist=_import_tail,\n   level=0)\n  except ImportError:\n  \n  \n   pass\n  else:\n   break\n else:\n  mod=None\n  \n try:\n  getregentry=mod.getregentry\n except AttributeError:\n \n  mod=None\n  \n if mod is None:\n \n  _cache[encoding]=None\n  return None\n  \n  \n entry=getregentry()\n if not isinstance(entry,codecs.CodecInfo):\n  if not 4 <=len(entry)<=7:\n   raise CodecRegistryError('module \"%s\" (%s) failed to register'\n   %(mod.__name__,mod.__file__))\n  if not callable(entry[0])or not callable(entry[1])or\\\n  (entry[2]is not None and not callable(entry[2]))or\\\n  (entry[3]is not None and not callable(entry[3]))or\\\n  (len(entry)>4 and entry[4]is not None and not callable(entry[4]))or\\\n  (len(entry)>5 and entry[5]is not None and not callable(entry[5])):\n   raise CodecRegistryError('incompatible codecs in module \"%s\" (%s)'\n   %(mod.__name__,mod.__file__))\n  if len(entry)<7 or entry[6]is None:\n   entry +=(None,)*(6 -len(entry))+(mod.__name__.split(\".\",1)[1],)\n  entry=codecs.CodecInfo(*entry)\n  \n  \n _cache[encoding]=entry\n \n \n \n try:\n  codecaliases=mod.getaliases()\n except AttributeError:\n  pass\n else:\n  for alias in codecaliases:\n   if alias not in _aliases:\n    _aliases[alias]=modname\n    \n    \n return entry\n \n \ncodecs.register(search_function)\n\nif sys.platform =='win32':\n\n\n\n\n def _alias_mbcs(encoding):\n  try:\n   import _winapi\n   ansi_code_page=\"cp%s\"%_winapi.GetACP()\n   if encoding ==ansi_code_page:\n    import encodings.mbcs\n    return encodings.mbcs.getregentry()\n  except ImportError:\n  \n   pass\n   \n codecs.register(_alias_mbcs)\n", ["_winapi", "codecs", "encodings", "encodings.aliases", "encodings.mbcs", "sys"], 1], "html.parser": [".py", "''\n\n\n\n\n\n\n\n\n\nimport re\nimport _markupbase\n\nfrom html import unescape\n\n\n__all__=['HTMLParser']\n\n\n\ninteresting_normal=re.compile('[&<]')\nincomplete=re.compile('&[a-zA-Z#]')\n\nentityref=re.compile('&([a-zA-Z][-.a-zA-Z0-9]*)[^a-zA-Z0-9]')\ncharref=re.compile('&#(?:[0-9]+|[xX][0-9a-fA-F]+)[^0-9a-fA-F]')\n\nstarttagopen=re.compile('<[a-zA-Z]')\npiclose=re.compile('>')\ncommentclose=re.compile(r'--\\s*>')\n\n\n\n\n\n\ntagfind_tolerant=re.compile(r'([a-zA-Z][^\\t\\n\\r\\f />\\x00]*)(?:\\s|/(?!>))*')\nattrfind_tolerant=re.compile(\nr'((?<=[\\'\"\\s/])[^\\s/>][^\\s/=>]*)(\\s*=+\\s*'\nr'(\\'[^\\']*\\'|\"[^\"]*\"|(?![\\'\"])[^>\\s]*))?(?:\\s|/(?!>))*')\nlocatestarttagend_tolerant=re.compile(r\"\"\"\n  <[a-zA-Z][^\\t\\n\\r\\f />\\x00]*       # tag name\n  (?:[\\s/]*                          # optional whitespace before attribute name\n    (?:(?<=['\"\\s/])[^\\s/>][^\\s/=>]*  # attribute name\n      (?:\\s*=+\\s*                    # value indicator\n        (?:'[^']*'                   # LITA-enclosed value\n          |\"[^\"]*\"                   # LIT-enclosed value\n          |(?!['\"])[^>\\s]*           # bare value\n         )\n        \\s*                          # possibly followed by a space\n       )?(?:\\s|/(?!>))*\n     )*\n   )?\n  \\s*                                # trailing whitespace\n\"\"\",re.VERBOSE)\nendendtag=re.compile('>')\n\n\nendtagfind=re.compile(r'</\\s*([a-zA-Z][-.a-zA-Z0-9:_]*)\\s*>')\n\n\n\nclass HTMLParser(_markupbase.ParserBase):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n CDATA_CONTENT_ELEMENTS=(\"script\",\"style\")\n \n def __init__(self,*,convert_charrefs=True):\n  ''\n\n\n\n  \n  super().__init__()\n  self.convert_charrefs=convert_charrefs\n  self.reset()\n  \n def reset(self):\n  ''\n  self.rawdata=''\n  self.lasttag='???'\n  self.interesting=interesting_normal\n  self.cdata_elem=None\n  super().reset()\n  \n def feed(self,data):\n  ''\n\n\n\n  \n  self.rawdata=self.rawdata+data\n  self.goahead(0)\n  \n def close(self):\n  ''\n  self.goahead(1)\n  \n __starttag_text=None\n \n def get_starttag_text(self):\n  ''\n  return self.__starttag_text\n  \n def set_cdata_mode(self,elem):\n  self.cdata_elem=elem.lower()\n  self.interesting=re.compile(r'</\\s*%s\\s*>'%self.cdata_elem,re.I)\n  \n def clear_cdata_mode(self):\n  self.interesting=interesting_normal\n  self.cdata_elem=None\n  \n  \n  \n  \n def goahead(self,end):\n  rawdata=self.rawdata\n  i=0\n  n=len(rawdata)\n  while i <n:\n   if self.convert_charrefs and not self.cdata_elem:\n    j=rawdata.find('<',i)\n    if j <0:\n    \n    \n    \n    \n    \n    \n     amppos=rawdata.rfind('&',max(i,n -34))\n     if(amppos >=0 and\n     not re.compile(r'[\\s;]').search(rawdata,amppos)):\n      break\n     j=n\n   else:\n    match=self.interesting.search(rawdata,i)\n    if match:\n     j=match.start()\n    else:\n     if self.cdata_elem:\n      break\n     j=n\n   if i <j:\n    if self.convert_charrefs and not self.cdata_elem:\n     self.handle_data(unescape(rawdata[i:j]))\n    else:\n     self.handle_data(rawdata[i:j])\n   i=self.updatepos(i,j)\n   if i ==n:break\n   startswith=rawdata.startswith\n   if startswith('<',i):\n    if starttagopen.match(rawdata,i):\n     k=self.parse_starttag(i)\n    elif startswith(\"</\",i):\n     k=self.parse_endtag(i)\n    elif startswith(\"<!--\",i):\n     k=self.parse_comment(i)\n    elif startswith(\"<?\",i):\n     k=self.parse_pi(i)\n    elif startswith(\"<!\",i):\n     k=self.parse_html_declaration(i)\n    elif(i+1)<n:\n     self.handle_data(\"<\")\n     k=i+1\n    else:\n     break\n    if k <0:\n     if not end:\n      break\n     k=rawdata.find('>',i+1)\n     if k <0:\n      k=rawdata.find('<',i+1)\n      if k <0:\n       k=i+1\n     else:\n      k +=1\n     if self.convert_charrefs and not self.cdata_elem:\n      self.handle_data(unescape(rawdata[i:k]))\n     else:\n      self.handle_data(rawdata[i:k])\n    i=self.updatepos(i,k)\n   elif startswith(\"&#\",i):\n    match=charref.match(rawdata,i)\n    if match:\n     name=match.group()[2:-1]\n     self.handle_charref(name)\n     k=match.end()\n     if not startswith(';',k -1):\n      k=k -1\n     i=self.updatepos(i,k)\n     continue\n    else:\n     if \";\"in rawdata[i:]:\n      self.handle_data(rawdata[i:i+2])\n      i=self.updatepos(i,i+2)\n     break\n   elif startswith('&',i):\n    match=entityref.match(rawdata,i)\n    if match:\n     name=match.group(1)\n     self.handle_entityref(name)\n     k=match.end()\n     if not startswith(';',k -1):\n      k=k -1\n     i=self.updatepos(i,k)\n     continue\n    match=incomplete.match(rawdata,i)\n    if match:\n    \n     if end and match.group()==rawdata[i:]:\n      k=match.end()\n      if k <=i:\n       k=n\n      i=self.updatepos(i,i+1)\n      \n     break\n    elif(i+1)<n:\n    \n    \n     self.handle_data(\"&\")\n     i=self.updatepos(i,i+1)\n    else:\n     break\n   else:\n    assert 0,\"interesting.search() lied\"\n    \n  if end and i <n and not self.cdata_elem:\n   if self.convert_charrefs and not self.cdata_elem:\n    self.handle_data(unescape(rawdata[i:n]))\n   else:\n    self.handle_data(rawdata[i:n])\n   i=self.updatepos(i,n)\n  self.rawdata=rawdata[i:]\n  \n  \n  \n  \n def parse_html_declaration(self,i):\n  rawdata=self.rawdata\n  assert rawdata[i:i+2]=='<!',('unexpected call to '\n  'parse_html_declaration()')\n  if rawdata[i:i+4]=='<!--':\n  \n   return self.parse_comment(i)\n  elif rawdata[i:i+3]=='<![':\n   return self.parse_marked_section(i)\n  elif rawdata[i:i+9].lower()=='<!doctype':\n  \n   gtpos=rawdata.find('>',i+9)\n   if gtpos ==-1:\n    return -1\n   self.handle_decl(rawdata[i+2:gtpos])\n   return gtpos+1\n  else:\n   return self.parse_bogus_comment(i)\n   \n   \n   \n def parse_bogus_comment(self,i,report=1):\n  rawdata=self.rawdata\n  assert rawdata[i:i+2]in('<!','</'),('unexpected call to '\n  'parse_comment()')\n  pos=rawdata.find('>',i+2)\n  if pos ==-1:\n   return -1\n  if report:\n   self.handle_comment(rawdata[i+2:pos])\n  return pos+1\n  \n  \n def parse_pi(self,i):\n  rawdata=self.rawdata\n  assert rawdata[i:i+2]=='<?','unexpected call to parse_pi()'\n  match=piclose.search(rawdata,i+2)\n  if not match:\n   return -1\n  j=match.start()\n  self.handle_pi(rawdata[i+2:j])\n  j=match.end()\n  return j\n  \n  \n def parse_starttag(self,i):\n  self.__starttag_text=None\n  endpos=self.check_for_whole_start_tag(i)\n  if endpos <0:\n   return endpos\n  rawdata=self.rawdata\n  self.__starttag_text=rawdata[i:endpos]\n  \n  \n  attrs=[]\n  match=tagfind_tolerant.match(rawdata,i+1)\n  assert match,'unexpected call to parse_starttag()'\n  k=match.end()\n  self.lasttag=tag=match.group(1).lower()\n  while k <endpos:\n   m=attrfind_tolerant.match(rawdata,k)\n   if not m:\n    break\n   attrname,rest,attrvalue=m.group(1,2,3)\n   if not rest:\n    attrvalue=None\n   elif attrvalue[:1]=='\\''==attrvalue[-1:]or\\\n   attrvalue[:1]=='\"'==attrvalue[-1:]:\n    attrvalue=attrvalue[1:-1]\n   if attrvalue:\n    attrvalue=unescape(attrvalue)\n   attrs.append((attrname.lower(),attrvalue))\n   k=m.end()\n   \n  end=rawdata[k:endpos].strip()\n  if end not in(\">\",\"/>\"):\n   self.handle_data(rawdata[i:endpos])\n   return endpos\n  if end.endswith('/>'):\n  \n   self.handle_startendtag(tag,attrs)\n  else:\n   self.handle_starttag(tag,attrs)\n   if tag in self.CDATA_CONTENT_ELEMENTS:\n    self.set_cdata_mode(tag)\n  return endpos\n  \n  \n  \n def check_for_whole_start_tag(self,i):\n  rawdata=self.rawdata\n  m=locatestarttagend_tolerant.match(rawdata,i)\n  if m:\n   j=m.end()\n   next=rawdata[j:j+1]\n   if next ==\">\":\n    return j+1\n   if next ==\"/\":\n    if rawdata.startswith(\"/>\",j):\n     return j+2\n    if rawdata.startswith(\"/\",j):\n    \n     return -1\n     \n    if j >i:\n     return j\n    else:\n     return i+1\n   if next ==\"\":\n   \n    return -1\n   if next in(\"abcdefghijklmnopqrstuvwxyz=/\"\n   \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"):\n   \n   \n    return -1\n   if j >i:\n    return j\n   else:\n    return i+1\n  raise AssertionError(\"we should not get here!\")\n  \n  \n def parse_endtag(self,i):\n  rawdata=self.rawdata\n  assert rawdata[i:i+2]==\"</\",\"unexpected call to parse_endtag\"\n  match=endendtag.search(rawdata,i+1)\n  if not match:\n   return -1\n  gtpos=match.end()\n  match=endtagfind.match(rawdata,i)\n  if not match:\n   if self.cdata_elem is not None:\n    self.handle_data(rawdata[i:gtpos])\n    return gtpos\n    \n   namematch=tagfind_tolerant.match(rawdata,i+2)\n   if not namematch:\n   \n    if rawdata[i:i+3]=='</>':\n     return i+3\n    else:\n     return self.parse_bogus_comment(i)\n   tagname=namematch.group(1).lower()\n   \n   \n   \n   \n   gtpos=rawdata.find('>',namematch.end())\n   self.handle_endtag(tagname)\n   return gtpos+1\n   \n  elem=match.group(1).lower()\n  if self.cdata_elem is not None:\n   if elem !=self.cdata_elem:\n    self.handle_data(rawdata[i:gtpos])\n    return gtpos\n    \n  self.handle_endtag(elem)\n  self.clear_cdata_mode()\n  return gtpos\n  \n  \n def handle_startendtag(self,tag,attrs):\n  self.handle_starttag(tag,attrs)\n  self.handle_endtag(tag)\n  \n  \n def handle_starttag(self,tag,attrs):\n  pass\n  \n  \n def handle_endtag(self,tag):\n  pass\n  \n  \n def handle_charref(self,name):\n  pass\n  \n  \n def handle_entityref(self,name):\n  pass\n  \n  \n def handle_data(self,data):\n  pass\n  \n  \n def handle_comment(self,data):\n  pass\n  \n  \n def handle_decl(self,decl):\n  pass\n  \n  \n def handle_pi(self,data):\n  pass\n  \n def unknown_decl(self,data):\n  pass\n", ["_markupbase", "html", "re"]], "html": [".py", "''\n\n\n\nimport re as _re\nfrom html.entities import html5 as _html5\n\n\n__all__=['escape','unescape']\n\n\ndef escape(s,quote=True):\n ''\n\n\n\n\n \n s=s.replace(\"&\",\"&amp;\")\n s=s.replace(\"<\",\"&lt;\")\n s=s.replace(\">\",\"&gt;\")\n if quote:\n  s=s.replace('\"',\"&quot;\")\n  s=s.replace('\\'',\"&#x27;\")\n return s\n \n \n \n \n_invalid_charrefs={\n0x00:'\\ufffd',\n0x0d:'\\r',\n0x80:'\\u20ac',\n0x81:'\\x81',\n0x82:'\\u201a',\n0x83:'\\u0192',\n0x84:'\\u201e',\n0x85:'\\u2026',\n0x86:'\\u2020',\n0x87:'\\u2021',\n0x88:'\\u02c6',\n0x89:'\\u2030',\n0x8a:'\\u0160',\n0x8b:'\\u2039',\n0x8c:'\\u0152',\n0x8d:'\\x8d',\n0x8e:'\\u017d',\n0x8f:'\\x8f',\n0x90:'\\x90',\n0x91:'\\u2018',\n0x92:'\\u2019',\n0x93:'\\u201c',\n0x94:'\\u201d',\n0x95:'\\u2022',\n0x96:'\\u2013',\n0x97:'\\u2014',\n0x98:'\\u02dc',\n0x99:'\\u2122',\n0x9a:'\\u0161',\n0x9b:'\\u203a',\n0x9c:'\\u0153',\n0x9d:'\\x9d',\n0x9e:'\\u017e',\n0x9f:'\\u0178',\n}\n\n_invalid_codepoints={\n\n0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,\n\n0xe,0xf,0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,\n0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,\n\n0x7f,0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8a,\n0x8b,0x8c,0x8d,0x8e,0x8f,0x90,0x91,0x92,0x93,0x94,0x95,0x96,\n0x97,0x98,0x99,0x9a,0x9b,0x9c,0x9d,0x9e,0x9f,\n\n0xfdd0,0xfdd1,0xfdd2,0xfdd3,0xfdd4,0xfdd5,0xfdd6,0xfdd7,0xfdd8,\n0xfdd9,0xfdda,0xfddb,0xfddc,0xfddd,0xfdde,0xfddf,0xfde0,0xfde1,\n0xfde2,0xfde3,0xfde4,0xfde5,0xfde6,0xfde7,0xfde8,0xfde9,0xfdea,\n0xfdeb,0xfdec,0xfded,0xfdee,0xfdef,\n\n0xb,0xfffe,0xffff,0x1fffe,0x1ffff,0x2fffe,0x2ffff,0x3fffe,0x3ffff,\n0x4fffe,0x4ffff,0x5fffe,0x5ffff,0x6fffe,0x6ffff,0x7fffe,0x7ffff,\n0x8fffe,0x8ffff,0x9fffe,0x9ffff,0xafffe,0xaffff,0xbfffe,0xbffff,\n0xcfffe,0xcffff,0xdfffe,0xdffff,0xefffe,0xeffff,0xffffe,0xfffff,\n0x10fffe,0x10ffff\n}\n\n\ndef _replace_charref(s):\n s=s.group(1)\n if s[0]=='#':\n \n  if s[1]in 'xX':\n   num=int(s[2:].rstrip(';'),16)\n  else:\n   num=int(s[1:].rstrip(';'))\n  if num in _invalid_charrefs:\n   return _invalid_charrefs[num]\n  if 0xD800 <=num <=0xDFFF or num >0x10FFFF:\n   return '\\uFFFD'\n  if num in _invalid_codepoints:\n   return ''\n  return chr(num)\n else:\n \n  if s in _html5:\n   return _html5[s]\n   \n  for x in range(len(s)-1,1,-1):\n   if s[:x]in _html5:\n    return _html5[s[:x]]+s[x:]\n  else:\n   return '&'+s\n   \n   \n_charref=_re.compile(r'&(#[0-9]+;?'\nr'|#[xX][0-9a-fA-F]+;?'\nr'|[^\\t\\n\\f <&#;]{1,32};?)')\n\ndef unescape(s):\n ''\n\n\n\n\n\n \n if '&'not in s:\n  return s\n return _charref.sub(_replace_charref,s)\n", ["html.entities", "re"], 1], "http": [".py", "from enum import StrEnum,IntEnum,_simple_enum\n\n__all__=['HTTPStatus','HTTPMethod']\n\n\n@_simple_enum(IntEnum)\nclass HTTPStatus:\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n def __new__(cls,value,phrase,description=''):\n  obj=int.__new__(cls,value)\n  obj._value_=value\n  obj.phrase=phrase\n  obj.description=description\n  return obj\n  \n @property\n def is_informational(self):\n  return 100 <=self <=199\n  \n @property\n def is_success(self):\n  return 200 <=self <=299\n  \n @property\n def is_redirection(self):\n  return 300 <=self <=399\n  \n @property\n def is_client_error(self):\n  return 400 <=self <=499\n  \n @property\n def is_server_error(self):\n  return 500 <=self <=599\n  \n  \n CONTINUE=100,'Continue','Request received, please continue'\n SWITCHING_PROTOCOLS=(101,'Switching Protocols',\n 'Switching to new protocol; obey Upgrade header')\n PROCESSING=102,'Processing'\n EARLY_HINTS=103,'Early Hints'\n \n \n OK=200,'OK','Request fulfilled, document follows'\n CREATED=201,'Created','Document created, URL follows'\n ACCEPTED=(202,'Accepted',\n 'Request accepted, processing continues off-line')\n NON_AUTHORITATIVE_INFORMATION=(203,\n 'Non-Authoritative Information','Request fulfilled from cache')\n NO_CONTENT=204,'No Content','Request fulfilled, nothing follows'\n RESET_CONTENT=205,'Reset Content','Clear input form for further input'\n PARTIAL_CONTENT=206,'Partial Content','Partial content follows'\n MULTI_STATUS=207,'Multi-Status'\n ALREADY_REPORTED=208,'Already Reported'\n IM_USED=226,'IM Used'\n \n \n MULTIPLE_CHOICES=(300,'Multiple Choices',\n 'Object has several resources -- see URI list')\n MOVED_PERMANENTLY=(301,'Moved Permanently',\n 'Object moved permanently -- see URI list')\n FOUND=302,'Found','Object moved temporarily -- see URI list'\n SEE_OTHER=303,'See Other','Object moved -- see Method and URL list'\n NOT_MODIFIED=(304,'Not Modified',\n 'Document has not changed since given time')\n USE_PROXY=(305,'Use Proxy',\n 'You must use proxy specified in Location to access this resource')\n TEMPORARY_REDIRECT=(307,'Temporary Redirect',\n 'Object moved temporarily -- see URI list')\n PERMANENT_REDIRECT=(308,'Permanent Redirect',\n 'Object moved permanently -- see URI list')\n \n \n BAD_REQUEST=(400,'Bad Request',\n 'Bad request syntax or unsupported method')\n UNAUTHORIZED=(401,'Unauthorized',\n 'No permission -- see authorization schemes')\n PAYMENT_REQUIRED=(402,'Payment Required',\n 'No payment -- see charging schemes')\n FORBIDDEN=(403,'Forbidden',\n 'Request forbidden -- authorization will not help')\n NOT_FOUND=(404,'Not Found',\n 'Nothing matches the given URI')\n METHOD_NOT_ALLOWED=(405,'Method Not Allowed',\n 'Specified method is invalid for this resource')\n NOT_ACCEPTABLE=(406,'Not Acceptable',\n 'URI not available in preferred format')\n PROXY_AUTHENTICATION_REQUIRED=(407,\n 'Proxy Authentication Required',\n 'You must authenticate with this proxy before proceeding')\n REQUEST_TIMEOUT=(408,'Request Timeout',\n 'Request timed out; try again later')\n CONFLICT=409,'Conflict','Request conflict'\n GONE=(410,'Gone',\n 'URI no longer exists and has been permanently removed')\n LENGTH_REQUIRED=(411,'Length Required',\n 'Client must specify Content-Length')\n PRECONDITION_FAILED=(412,'Precondition Failed',\n 'Precondition in headers is false')\n CONTENT_TOO_LARGE=(413,'Content Too Large',\n 'Content is too large')\n REQUEST_ENTITY_TOO_LARGE=CONTENT_TOO_LARGE\n URI_TOO_LONG=(414,'URI Too Long',\n 'URI is too long')\n REQUEST_URI_TOO_LONG=URI_TOO_LONG\n UNSUPPORTED_MEDIA_TYPE=(415,'Unsupported Media Type',\n 'Entity body in unsupported format')\n RANGE_NOT_SATISFIABLE=(416,'Range Not Satisfiable',\n 'Cannot satisfy request range')\n REQUESTED_RANGE_NOT_SATISFIABLE=RANGE_NOT_SATISFIABLE\n EXPECTATION_FAILED=(417,'Expectation Failed',\n 'Expect condition could not be satisfied')\n IM_A_TEAPOT=(418,'I\\'m a Teapot',\n 'Server refuses to brew coffee because it is a teapot.')\n MISDIRECTED_REQUEST=(421,'Misdirected Request',\n 'Server is not able to produce a response')\n UNPROCESSABLE_CONTENT=422,'Unprocessable Content'\n UNPROCESSABLE_ENTITY=UNPROCESSABLE_CONTENT\n LOCKED=423,'Locked'\n FAILED_DEPENDENCY=424,'Failed Dependency'\n TOO_EARLY=425,'Too Early'\n UPGRADE_REQUIRED=426,'Upgrade Required'\n PRECONDITION_REQUIRED=(428,'Precondition Required',\n 'The origin server requires the request to be conditional')\n TOO_MANY_REQUESTS=(429,'Too Many Requests',\n 'The user has sent too many requests in '\n 'a given amount of time (\"rate limiting\")')\n REQUEST_HEADER_FIELDS_TOO_LARGE=(431,\n 'Request Header Fields Too Large',\n 'The server is unwilling to process the request because its header '\n 'fields are too large')\n UNAVAILABLE_FOR_LEGAL_REASONS=(451,\n 'Unavailable For Legal Reasons',\n 'The server is denying access to the '\n 'resource as a consequence of a legal demand')\n \n \n INTERNAL_SERVER_ERROR=(500,'Internal Server Error',\n 'Server got itself in trouble')\n NOT_IMPLEMENTED=(501,'Not Implemented',\n 'Server does not support this operation')\n BAD_GATEWAY=(502,'Bad Gateway',\n 'Invalid responses from another server/proxy')\n SERVICE_UNAVAILABLE=(503,'Service Unavailable',\n 'The server cannot process the request due to a high load')\n GATEWAY_TIMEOUT=(504,'Gateway Timeout',\n 'The gateway server did not receive a timely response')\n HTTP_VERSION_NOT_SUPPORTED=(505,'HTTP Version Not Supported',\n 'Cannot fulfill request')\n VARIANT_ALSO_NEGOTIATES=506,'Variant Also Negotiates'\n INSUFFICIENT_STORAGE=507,'Insufficient Storage'\n LOOP_DETECTED=508,'Loop Detected'\n NOT_EXTENDED=510,'Not Extended'\n NETWORK_AUTHENTICATION_REQUIRED=(511,\n 'Network Authentication Required',\n 'The client needs to authenticate to gain network access')\n \n \n@_simple_enum(StrEnum)\nclass HTTPMethod:\n ''\n\n\n\n\n\n \n def __new__(cls,value,description):\n  obj=str.__new__(cls,value)\n  obj._value_=value\n  obj.description=description\n  return obj\n  \n def __repr__(self):\n  return \"<%s.%s>\"%(self.__class__.__name__,self._name_)\n  \n CONNECT='CONNECT','Establish a connection to the server.'\n DELETE='DELETE','Remove the target.'\n GET='GET','Retrieve the target.'\n HEAD='HEAD','Same as GET, but only retrieve the status line and header section.'\n OPTIONS='OPTIONS','Describe the communication options for the target.'\n PATCH='PATCH','Apply partial modifications to a target.'\n POST='POST','Perform target-specific processing with the request payload.'\n PUT='PUT','Replace the target with the request payload.'\n TRACE='TRACE','Perform a message loop-back test along the path to the target.'\n", ["enum"], 1], "importlib.simple": [".py", "''\n\n\n\n\n\n\nfrom.resources.simple import(\nSimpleReader,ResourceHandle,ResourceContainer,TraversableReader,\n)\n\n__all__=[\n'SimpleReader','ResourceHandle','ResourceContainer','TraversableReader',\n]\n", ["importlib.resources.simple"]], "importlib.util": [".py", "''\nfrom._abc import Loader\nfrom._bootstrap import module_from_spec\nfrom._bootstrap import _resolve_name\nfrom._bootstrap import spec_from_loader\nfrom._bootstrap import _find_spec\nfrom._bootstrap_external import MAGIC_NUMBER\nfrom._bootstrap_external import _RAW_MAGIC_NUMBER\nfrom._bootstrap_external import cache_from_source\nfrom._bootstrap_external import decode_source\nfrom._bootstrap_external import source_from_cache\nfrom._bootstrap_external import spec_from_file_location\n\nfrom contextlib import contextmanager\nimport _imp\nimport functools\nimport sys\nimport types\nimport warnings\n\n\ndef source_hash(source_bytes):\n ''\n return _imp.source_hash(_RAW_MAGIC_NUMBER,source_bytes)\n \n \ndef resolve_name(name,package):\n ''\n if not name.startswith('.'):\n  return name\n elif not package:\n  raise ImportError(f'no package specified for {repr(name)} '\n  '(required for relative module names)')\n level=0\n for character in name:\n  if character !='.':\n   break\n  level +=1\n return _resolve_name(name[level:],package,level)\n \n \ndef _find_spec_from_path(name,path=None):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n \n if name not in sys.modules:\n  return _find_spec(name,path)\n else:\n  module=sys.modules[name]\n  if module is None:\n   return None\n  try:\n   spec=module.__spec__\n  except AttributeError:\n   raise ValueError('{}.__spec__ is not set'.format(name))from None\n  else:\n   if spec is None:\n    raise ValueError('{}.__spec__ is None'.format(name))\n   return spec\n   \n   \ndef find_spec(name,package=None):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n fullname=resolve_name(name,package)if name.startswith('.')else name\n if fullname not in sys.modules:\n  parent_name=fullname.rpartition('.')[0]\n  if parent_name:\n   parent=__import__(parent_name,fromlist=['__path__'])\n   try:\n    parent_path=parent.__path__\n   except AttributeError as e:\n    raise ModuleNotFoundError(\n    f\"__path__ attribute not found on {parent_name !r} \"\n    f\"while trying to find {fullname !r}\",name=fullname)from e\n  else:\n   parent_path=None\n  return _find_spec(fullname,parent_path)\n else:\n  module=sys.modules[fullname]\n  if module is None:\n   return None\n  try:\n   spec=module.__spec__\n  except AttributeError:\n   raise ValueError('{}.__spec__ is not set'.format(name))from None\n  else:\n   if spec is None:\n    raise ValueError('{}.__spec__ is None'.format(name))\n   return spec\n   \n   \n@contextmanager\ndef _module_to_load(name):\n is_reload=name in sys.modules\n \n module=sys.modules.get(name)\n if not is_reload:\n \n \n \n  module=type(sys)(name)\n  \n  \n  module.__initializing__=True\n  sys.modules[name]=module\n try:\n  yield module\n except Exception:\n  if not is_reload:\n   try:\n    del sys.modules[name]\n   except KeyError:\n    pass\n finally:\n  module.__initializing__=False\n  \n  \ndef set_package(fxn):\n ''\n\n\n\n \n @functools.wraps(fxn)\n def set_package_wrapper(*args,**kwargs):\n  warnings.warn('The import system now takes care of this automatically; '\n  'this decorator is slated for removal in Python 3.12',\n  DeprecationWarning,stacklevel=2)\n  module=fxn(*args,**kwargs)\n  if getattr(module,'__package__',None)is None:\n   module.__package__=module.__name__\n   if not hasattr(module,'__path__'):\n    module.__package__=module.__package__.rpartition('.')[0]\n  return module\n return set_package_wrapper\n \n \ndef set_loader(fxn):\n ''\n\n\n\n \n @functools.wraps(fxn)\n def set_loader_wrapper(self,*args,**kwargs):\n  warnings.warn('The import system now takes care of this automatically; '\n  'this decorator is slated for removal in Python 3.12',\n  DeprecationWarning,stacklevel=2)\n  module=fxn(self,*args,**kwargs)\n  if getattr(module,'__loader__',None)is None:\n   module.__loader__=self\n  return module\n return set_loader_wrapper\n \n \ndef module_for_loader(fxn):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n warnings.warn('The import system now takes care of this automatically; '\n 'this decorator is slated for removal in Python 3.12',\n DeprecationWarning,stacklevel=2)\n @functools.wraps(fxn)\n def module_for_loader_wrapper(self,fullname,*args,**kwargs):\n  with _module_to_load(fullname)as module:\n   module.__loader__=self\n   try:\n    is_package=self.is_package(fullname)\n   except(ImportError,AttributeError):\n    pass\n   else:\n    if is_package:\n     module.__package__=fullname\n    else:\n     module.__package__=fullname.rpartition('.')[0]\n     \n   return fxn(self,module,*args,**kwargs)\n   \n return module_for_loader_wrapper\n \n \nclass _LazyModule(types.ModuleType):\n\n ''\n \n def __getattribute__(self,attr):\n  ''\n  \n  \n  \n  self.__class__=types.ModuleType\n  \n  \n  original_name=self.__spec__.name\n  \n  \n  attrs_then=self.__spec__.loader_state['__dict__']\n  attrs_now=self.__dict__\n  attrs_updated={}\n  for key,value in attrs_now.items():\n  \n  \n   if key not in attrs_then:\n    attrs_updated[key]=value\n   elif id(attrs_now[key])!=id(attrs_then[key]):\n    attrs_updated[key]=value\n  self.__spec__.loader.exec_module(self)\n  \n  \n  if original_name in sys.modules:\n   if id(self)!=id(sys.modules[original_name]):\n    raise ValueError(f\"module object for {original_name !r} \"\n    \"substituted in sys.modules during a lazy \"\n    \"load\")\n    \n    \n  self.__dict__.update(attrs_updated)\n  return getattr(self,attr)\n  \n def __delattr__(self,attr):\n  ''\n  \n  \n  self.__getattribute__(attr)\n  delattr(self,attr)\n  \n  \nclass LazyLoader(Loader):\n\n ''\n \n @staticmethod\n def __check_eager_loader(loader):\n  if not hasattr(loader,'exec_module'):\n   raise TypeError('loader must define exec_module()')\n   \n @classmethod\n def factory(cls,loader):\n  ''\n  cls.__check_eager_loader(loader)\n  return lambda *args,**kwargs:cls(loader(*args,**kwargs))\n  \n def __init__(self,loader):\n  self.__check_eager_loader(loader)\n  self.loader=loader\n  \n def create_module(self,spec):\n  return self.loader.create_module(spec)\n  \n def exec_module(self,module):\n  ''\n  module.__spec__.loader=self.loader\n  module.__loader__=self.loader\n  \n  \n  \n  \n  loader_state={}\n  loader_state['__dict__']=module.__dict__.copy()\n  loader_state['__class__']=module.__class__\n  module.__spec__.loader_state=loader_state\n  module.__class__=_LazyModule\n", ["_imp", "contextlib", "functools", "importlib._abc", "importlib._bootstrap", "importlib._bootstrap_external", "sys", "types", "warnings"]], "importlib": [".py", "''\n__all__=['__import__','import_module','invalidate_caches','reload']\n\n\n\n\n\n\n\n\n\nimport _imp\nimport sys\n\ntry:\n import _frozen_importlib as _bootstrap\nexcept ImportError:\n from. import _bootstrap\n _bootstrap._setup(sys,_imp)\nelse:\n\n\n _bootstrap.__name__='importlib._bootstrap'\n _bootstrap.__package__='importlib'\n try:\n  _bootstrap.__file__=__file__.replace('__init__.py','_bootstrap.py')\n except NameError:\n \n \n  pass\n sys.modules['importlib._bootstrap']=_bootstrap\n \ntry:\n import _frozen_importlib_external as _bootstrap_external\nexcept ImportError:\n from. import _bootstrap_external\n _bootstrap_external._set_bootstrap_module(_bootstrap)\n _bootstrap._bootstrap_external=_bootstrap_external\nelse:\n _bootstrap_external.__name__='importlib._bootstrap_external'\n _bootstrap_external.__package__='importlib'\n try:\n  _bootstrap_external.__file__=__file__.replace('__init__.py','_bootstrap_external.py')\n except NameError:\n \n \n  pass\n sys.modules['importlib._bootstrap_external']=_bootstrap_external\n \n \n_pack_uint32=_bootstrap_external._pack_uint32\n_unpack_uint32=_bootstrap_external._unpack_uint32\n\n\n\n\n\n\n\nfrom._bootstrap import __import__\n\n\ndef invalidate_caches():\n ''\n \n for finder in sys.meta_path:\n  if hasattr(finder,'invalidate_caches'):\n   finder.invalidate_caches()\n   \n   \ndef import_module(name,package=None):\n ''\n\n\n\n\n\n \n level=0\n if name.startswith('.'):\n  if not package:\n   raise TypeError(\"the 'package' argument is required to perform a \"\n   f\"relative import for {name !r}\")\n  for character in name:\n   if character !='.':\n    break\n   level +=1\n return _bootstrap._gcd_import(name[level:],package,level)\n \n \n_RELOADING={}\n\n\ndef reload(module):\n ''\n\n\n\n \n try:\n  name=module.__spec__.name\n except AttributeError:\n  try:\n   name=module.__name__\n  except AttributeError:\n   raise TypeError(\"reload() argument must be a module\")\n   \n if sys.modules.get(name)is not module:\n  raise ImportError(f\"module {name} not in sys.modules\",name=name)\n if name in _RELOADING:\n  return _RELOADING[name]\n _RELOADING[name]=module\n try:\n  parent_name=name.rpartition('.')[0]\n  if parent_name:\n   try:\n    parent=sys.modules[parent_name]\n   except KeyError:\n    raise ImportError(f\"parent {parent_name !r} not in sys.modules\",\n    name=parent_name)from None\n   else:\n    pkgpath=parent.__path__\n  else:\n   pkgpath=None\n  target=module\n  spec=module.__spec__=_bootstrap._find_spec(name,pkgpath,target)\n  if spec is None:\n   raise ModuleNotFoundError(f\"spec not found for the module {name !r}\",name=name)\n  _bootstrap._exec(spec,module)\n  \n  return sys.modules[name]\n finally:\n  try:\n   del _RELOADING[name]\n  except KeyError:\n   pass\n", ["_frozen_importlib", "_frozen_importlib_external", "_imp", "importlib", "importlib._bootstrap", "importlib._bootstrap_external", "sys"], 1], "importlib.metadata._collections": [".py", "import collections\n\n\n\nclass FreezableDefaultDict(collections.defaultdict):\n ''\n\n\n\n\n\n\n\n\n\n\n\n \n \n def __missing__(self,key):\n  return getattr(self,'_frozen',super().__missing__)(key)\n  \n def freeze(self):\n  self._frozen=lambda key:self.default_factory()\n  \n  \nclass Pair(collections.namedtuple('Pair','name value')):\n @classmethod\n def parse(cls,text):\n  return cls(*map(str.strip,text.split(\"=\",1)))\n", ["collections"]], "importlib.metadata._functools": [".py", "import types\nimport functools\n\n\n\ndef method_cache(method,cache_wrapper=None):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n cache_wrapper=cache_wrapper or functools.lru_cache()\n \n def wrapper(self,*args,**kwargs):\n \n  bound_method=types.MethodType(method,self)\n  cached_method=cache_wrapper(bound_method)\n  setattr(self,method.__name__,cached_method)\n  return cached_method(*args,**kwargs)\n  \n  \n wrapper.cache_clear=lambda:None\n \n return wrapper\n \n \n \ndef pass_none(func):\n ''\n\n\n\n\n\n\n \n \n @functools.wraps(func)\n def wrapper(param,*args,**kwargs):\n  if param is not None:\n   return func(param,*args,**kwargs)\n   \n return wrapper\n", ["functools", "types"]], "importlib.metadata._itertools": [".py", "from itertools import filterfalse\n\n\ndef unique_everseen(iterable,key=None):\n ''\n \n \n seen=set()\n seen_add=seen.add\n if key is None:\n  for element in filterfalse(seen.__contains__,iterable):\n   seen_add(element)\n   yield element\n else:\n  for element in iterable:\n   k=key(element)\n   if k not in seen:\n    seen_add(k)\n    yield element\n    \n    \n    \ndef always_iterable(obj,base_type=(str,bytes)):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n if obj is None:\n  return iter(())\n  \n if(base_type is not None)and isinstance(obj,base_type):\n  return iter((obj,))\n  \n try:\n  return iter(obj)\n except TypeError:\n  return iter((obj,))\n", ["itertools"]], "importlib.metadata": [".py", "from __future__ import annotations\n\nimport os\nimport re\nimport abc\nimport sys\nimport json\nimport email\nimport types\nimport inspect\nimport pathlib\nimport zipfile\nimport operator\nimport textwrap\nimport warnings\nimport functools\nimport itertools\nimport posixpath\nimport collections\n\nfrom. import _meta\nfrom._collections import FreezableDefaultDict,Pair\nfrom._functools import method_cache,pass_none\nfrom._itertools import always_iterable,unique_everseen\nfrom._meta import PackageMetadata,SimplePath\n\nfrom contextlib import suppress\nfrom importlib import import_module\nfrom importlib.abc import MetaPathFinder\nfrom itertools import starmap\nfrom typing import Any,Iterable,List,Mapping,Match,Optional,Set,cast\n\n__all__=[\n'Distribution',\n'DistributionFinder',\n'PackageMetadata',\n'PackageNotFoundError',\n'distribution',\n'distributions',\n'entry_points',\n'files',\n'metadata',\n'packages_distributions',\n'requires',\n'version',\n]\n\n\nclass PackageNotFoundError(ModuleNotFoundError):\n ''\n \n def __str__(self)->str:\n  return f\"No package metadata was found for {self.name}\"\n  \n @property\n def name(self)->str:\n  (name,)=self.args\n  return name\n  \n  \nclass Sectioned:\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n _sample=textwrap.dedent(\n \"\"\"\n        [sec1]\n        # comments ignored\n        a = 1\n        b = 2\n\n        [sec2]\n        a = 2\n        \"\"\"\n ).lstrip()\n \n @classmethod\n def section_pairs(cls,text):\n  return(\n  section._replace(value=Pair.parse(section.value))\n  for section in cls.read(text,filter_=cls.valid)\n  if section.name is not None\n  )\n  \n @staticmethod\n def read(text,filter_=None):\n  lines=filter(filter_,map(str.strip,text.splitlines()))\n  name=None\n  for value in lines:\n   section_match=value.startswith('[')and value.endswith(']')\n   if section_match:\n    name=value.strip('[]')\n    continue\n   yield Pair(name,value)\n   \n @staticmethod\n def valid(line:str):\n  return line and not line.startswith('#')\n  \n  \nclass EntryPoint:\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n pattern=re.compile(\n r'(?P<module>[\\w.]+)\\s*'\n r'(:\\s*(?P<attr>[\\w.]+)\\s*)?'\n r'((?P<extras>\\[.*\\])\\s*)?$'\n )\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n name:str\n value:str\n group:str\n \n dist:Optional[Distribution]=None\n \n def __init__(self,name:str,value:str,group:str)->None:\n  vars(self).update(name=name,value=value,group=group)\n  \n def load(self)->Any:\n  ''\n\n\n  \n  match=cast(Match,self.pattern.match(self.value))\n  module=import_module(match.group('module'))\n  attrs=filter(None,(match.group('attr')or '').split('.'))\n  return functools.reduce(getattr,attrs,module)\n  \n @property\n def module(self)->str:\n  match=self.pattern.match(self.value)\n  assert match is not None\n  return match.group('module')\n  \n @property\n def attr(self)->str:\n  match=self.pattern.match(self.value)\n  assert match is not None\n  return match.group('attr')\n  \n @property\n def extras(self)->List[str]:\n  match=self.pattern.match(self.value)\n  assert match is not None\n  return re.findall(r'\\w+',match.group('extras')or '')\n  \n def _for(self,dist):\n  vars(self).update(dist=dist)\n  return self\n  \n def matches(self,**params):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  attrs=(getattr(self,param)for param in params)\n  return all(map(operator.eq,params.values(),attrs))\n  \n def _key(self):\n  return self.name,self.value,self.group\n  \n def __lt__(self,other):\n  return self._key()<other._key()\n  \n def __eq__(self,other):\n  return self._key()==other._key()\n  \n def __setattr__(self,name,value):\n  raise AttributeError(\"EntryPoint objects are immutable.\")\n  \n def __repr__(self):\n  return(\n  f'EntryPoint(name={self.name !r}, value={self.value !r}, '\n  f'group={self.group !r})'\n  )\n  \n def __hash__(self)->int:\n  return hash(self._key())\n  \n  \nclass EntryPoints(tuple):\n ''\n\n \n \n __slots__=()\n \n def __getitem__(self,name:str)->EntryPoint:\n  ''\n\n  \n  try:\n   return next(iter(self.select(name=name)))\n  except StopIteration:\n   raise KeyError(name)\n   \n def __repr__(self):\n  ''\n\n\n  \n  return '%s(%r)'%(self.__class__.__name__,tuple(self))\n  \n def select(self,**params)->EntryPoints:\n  ''\n\n\n  \n  return EntryPoints(ep for ep in self if ep.matches(**params))\n  \n @property\n def names(self)->Set[str]:\n  ''\n\n  \n  return{ep.name for ep in self}\n  \n @property\n def groups(self)->Set[str]:\n  ''\n\n  \n  return{ep.group for ep in self}\n  \n @classmethod\n def _from_text_for(cls,text,dist):\n  return cls(ep._for(dist)for ep in cls._from_text(text))\n  \n @staticmethod\n def _from_text(text):\n  return(\n  EntryPoint(name=item.value.name,value=item.value.value,group=item.name)\n  for item in Sectioned.section_pairs(text or '')\n  )\n  \n  \nclass PackagePath(pathlib.PurePosixPath):\n ''\n \n hash:Optional[FileHash]\n size:int\n dist:Distribution\n \n def read_text(self,encoding:str='utf-8')->str:\n  return self.locate().read_text(encoding=encoding)\n  \n def read_binary(self)->bytes:\n  return self.locate().read_bytes()\n  \n def locate(self)->SimplePath:\n  ''\n  return self.dist.locate_file(self)\n  \n  \nclass FileHash:\n def __init__(self,spec:str)->None:\n  self.mode,_,self.value=spec.partition('=')\n  \n def __repr__(self)->str:\n  return f'<FileHash mode: {self.mode} value: {self.value}>'\n  \n  \nclass DeprecatedNonAbstract:\n\n def __new__(cls,*args,**kwargs):\n  all_names={\n  name for subclass in inspect.getmro(cls)for name in vars(subclass)\n  }\n  abstract={\n  name\n  for name in all_names\n  if getattr(getattr(cls,name),'__isabstractmethod__',False)\n  }\n  if abstract:\n   warnings.warn(\n   f\"Unimplemented abstract methods {abstract}\",\n   DeprecationWarning,\n   stacklevel=2,\n   )\n  return super().__new__(cls)\n  \n  \nclass Distribution(DeprecatedNonAbstract):\n ''\n\n\n\n\n\n\n\n \n \n @abc.abstractmethod\n def read_text(self,filename)->Optional[str]:\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n @abc.abstractmethod\n def locate_file(self,path:str |os.PathLike[str])->SimplePath:\n  ''\n\n\n  \n  \n @classmethod\n def from_name(cls,name:str)->Distribution:\n  ''\n\n\n\n\n\n\n\n  \n  if not name:\n   raise ValueError(\"A distribution name is required.\")\n  try:\n   return next(iter(cls.discover(name=name)))\n  except StopIteration:\n   raise PackageNotFoundError(name)\n   \n @classmethod\n def discover(\n cls,*,context:Optional[DistributionFinder.Context]=None,**kwargs\n )->Iterable[Distribution]:\n  ''\n\n\n\n\n\n\n\n  \n  if context and kwargs:\n   raise ValueError(\"cannot accept context and kwargs\")\n  context=context or DistributionFinder.Context(**kwargs)\n  return itertools.chain.from_iterable(\n  resolver(context)for resolver in cls._discover_resolvers()\n  )\n  \n @staticmethod\n def at(path:str |os.PathLike[str])->Distribution:\n  ''\n\n\n\n  \n  return PathDistribution(pathlib.Path(path))\n  \n @staticmethod\n def _discover_resolvers():\n  ''\n  declared=(\n  getattr(finder,'find_distributions',None)for finder in sys.meta_path\n  )\n  return filter(None,declared)\n  \n @property\n def metadata(self)->_meta.PackageMetadata:\n  ''\n\n\n\n\n\n\n\n  \n  \n  from. import _adapters\n  \n  opt_text=(\n  self.read_text('METADATA')\n  or self.read_text('PKG-INFO')\n  \n  \n  \n  or self.read_text('')\n  )\n  text=cast(str,opt_text)\n  return _adapters.Message(email.message_from_string(text))\n  \n @property\n def name(self)->str:\n  ''\n  return self.metadata['Name']\n  \n @property\n def _normalized_name(self):\n  ''\n  return Prepared.normalize(self.name)\n  \n @property\n def version(self)->str:\n  ''\n  return self.metadata['Version']\n  \n @property\n def entry_points(self)->EntryPoints:\n  ''\n\n\n\n\n  \n  return EntryPoints._from_text_for(self.read_text('entry_points.txt'),self)\n  \n @property\n def files(self)->Optional[List[PackagePath]]:\n  ''\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  def make_file(name,hash=None,size_str=None):\n   result=PackagePath(name)\n   result.hash=FileHash(hash)if hash else None\n   result.size=int(size_str)if size_str else None\n   result.dist=self\n   return result\n   \n  @pass_none\n  def make_files(lines):\n  \n  \n   import csv\n   \n   return starmap(make_file,csv.reader(lines))\n   \n  @pass_none\n  def skip_missing_files(package_paths):\n   return list(filter(lambda path:path.locate().exists(),package_paths))\n   \n  return skip_missing_files(\n  make_files(\n  self._read_files_distinfo()\n  or self._read_files_egginfo_installed()\n  or self._read_files_egginfo_sources()\n  )\n  )\n  \n def _read_files_distinfo(self):\n  ''\n\n  \n  text=self.read_text('RECORD')\n  return text and text.splitlines()\n  \n def _read_files_egginfo_installed(self):\n  ''\n\n\n\n\n\n\n\n\n  \n  text=self.read_text('installed-files.txt')\n  \n  \n  \n  subdir=getattr(self,'_path',None)\n  if not text or not subdir:\n   return\n   \n  paths=(\n  (subdir /name)\n  .resolve()\n  .relative_to(self.locate_file('').resolve())\n  .as_posix()\n  for name in text.splitlines()\n  )\n  return map('\"{}\"'.format,paths)\n  \n def _read_files_egginfo_sources(self):\n  ''\n\n\n\n\n\n\n\n\n\n  \n  text=self.read_text('SOURCES.txt')\n  return text and map('\"{}\"'.format,text.splitlines())\n  \n @property\n def requires(self)->Optional[List[str]]:\n  ''\n  reqs=self._read_dist_info_reqs()or self._read_egg_info_reqs()\n  return reqs and list(reqs)\n  \n def _read_dist_info_reqs(self):\n  return self.metadata.get_all('Requires-Dist')\n  \n def _read_egg_info_reqs(self):\n  source=self.read_text('requires.txt')\n  return pass_none(self._deps_from_requires_text)(source)\n  \n @classmethod\n def _deps_from_requires_text(cls,source):\n  return cls._convert_egg_info_reqs_to_simple_reqs(Sectioned.read(source))\n  \n @staticmethod\n def _convert_egg_info_reqs_to_simple_reqs(sections):\n  ''\n\n\n\n\n\n\n\n  \n  \n  def make_condition(name):\n   return name and f'extra == \"{name}\"'\n   \n  def quoted_marker(section):\n   section=section or ''\n   extra,sep,markers=section.partition(':')\n   if extra and markers:\n    markers=f'({markers})'\n   conditions=list(filter(None,[markers,make_condition(extra)]))\n   return '; '+' and '.join(conditions)if conditions else ''\n   \n  def url_req_space(req):\n   ''\n\n\n   \n   \n   return ' '*('@'in req)\n   \n  for section in sections:\n   space=url_req_space(section.value)\n   yield section.value+space+quoted_marker(section.name)\n   \n @property\n def origin(self):\n  return self._load_json('direct_url.json')\n  \n def _load_json(self,filename):\n  return pass_none(json.loads)(\n  self.read_text(filename),\n  object_hook=lambda data:types.SimpleNamespace(**data),\n  )\n  \n  \nclass DistributionFinder(MetaPathFinder):\n ''\n\n\n\n\n \n \n class Context:\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  name=None\n  ''\n\n\n  \n  \n  def __init__(self,**kwargs):\n   vars(self).update(kwargs)\n   \n  @property\n  def path(self)->List[str]:\n   ''\n\n\n\n\n\n   \n   return vars(self).get('path',sys.path)\n   \n @abc.abstractmethod\n def find_distributions(self,context=Context())->Iterable[Distribution]:\n  ''\n\n\n\n\n\n  \n  \n  \nclass FastPath:\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n @functools.lru_cache()\n def __new__(cls,root):\n  return super().__new__(cls)\n  \n def __init__(self,root):\n  self.root=root\n  \n def joinpath(self,child):\n  return pathlib.Path(self.root,child)\n  \n def children(self):\n  with suppress(Exception):\n   return os.listdir(self.root or '.')\n  with suppress(Exception):\n   return self.zip_children()\n  return[]\n  \n def zip_children(self):\n  zip_path=zipfile.Path(self.root)\n  names=zip_path.root.namelist()\n  self.joinpath=zip_path.joinpath\n  \n  return dict.fromkeys(child.split(posixpath.sep,1)[0]for child in names)\n  \n def search(self,name):\n  return self.lookup(self.mtime).search(name)\n  \n @property\n def mtime(self):\n  with suppress(OSError):\n   return os.stat(self.root).st_mtime\n  self.lookup.cache_clear()\n  \n @method_cache\n def lookup(self,mtime):\n  return Lookup(self)\n  \n  \nclass Lookup:\n ''\n\n \n \n def __init__(self,path:FastPath):\n  ''\n\n\n\n\n\n  \n  \n  base=os.path.basename(path.root).lower()\n  base_is_egg=base.endswith(\".egg\")\n  self.infos=FreezableDefaultDict(list)\n  self.eggs=FreezableDefaultDict(list)\n  \n  for child in path.children():\n   low=child.lower()\n   if low.endswith((\".dist-info\",\".egg-info\")):\n   \n    name=low.rpartition(\".\")[0].partition(\"-\")[0]\n    normalized=Prepared.normalize(name)\n    self.infos[normalized].append(path.joinpath(child))\n   elif base_is_egg and low ==\"egg-info\":\n    name=base.rpartition(\".\")[0].partition(\"-\")[0]\n    legacy_normalized=Prepared.legacy_normalize(name)\n    self.eggs[legacy_normalized].append(path.joinpath(child))\n    \n  self.infos.freeze()\n  self.eggs.freeze()\n  \n def search(self,prepared:Prepared):\n  ''\n\n  \n  infos=(\n  self.infos[prepared.normalized]\n  if prepared\n  else itertools.chain.from_iterable(self.infos.values())\n  )\n  eggs=(\n  self.eggs[prepared.legacy_normalized]\n  if prepared\n  else itertools.chain.from_iterable(self.eggs.values())\n  )\n  return itertools.chain(infos,eggs)\n  \n  \nclass Prepared:\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n normalized=None\n legacy_normalized=None\n \n def __init__(self,name:Optional[str]):\n  self.name=name\n  if name is None:\n   return\n  self.normalized=self.normalize(name)\n  self.legacy_normalized=self.legacy_normalize(name)\n  \n @staticmethod\n def normalize(name):\n  ''\n\n  \n  return re.sub(r\"[-_.]+\",\"-\",name).lower().replace('-','_')\n  \n @staticmethod\n def legacy_normalize(name):\n  ''\n\n\n  \n  return name.lower().replace('-','_')\n  \n def __bool__(self):\n  return bool(self.name)\n  \n  \nclass MetadataPathFinder(DistributionFinder):\n @classmethod\n def find_distributions(\n cls,context=DistributionFinder.Context()\n )->Iterable[PathDistribution]:\n  ''\n\n\n\n\n\n\n  \n  found=cls._search_paths(context.name,context.path)\n  return map(PathDistribution,found)\n  \n @classmethod\n def _search_paths(cls,name,paths):\n  ''\n  prepared=Prepared(name)\n  return itertools.chain.from_iterable(\n  path.search(prepared)for path in map(FastPath,paths)\n  )\n  \n @classmethod\n def invalidate_caches(cls)->None:\n  FastPath.__new__.cache_clear()\n  \n  \nclass PathDistribution(Distribution):\n def __init__(self,path:SimplePath)->None:\n  ''\n\n\n  \n  self._path=path\n  \n def read_text(self,filename:str |os.PathLike[str])->Optional[str]:\n  with suppress(\n  FileNotFoundError,\n  IsADirectoryError,\n  KeyError,\n  NotADirectoryError,\n  PermissionError,\n  ):\n   return self._path.joinpath(filename).read_text(encoding='utf-8')\n   \n  return None\n  \n read_text.__doc__=Distribution.read_text.__doc__\n \n def locate_file(self,path:str |os.PathLike[str])->SimplePath:\n  return self._path.parent /path\n  \n @property\n def _normalized_name(self):\n  ''\n\n\n  \n  stem=os.path.basename(str(self._path))\n  return(\n  pass_none(Prepared.normalize)(self._name_from_stem(stem))\n  or super()._normalized_name\n  )\n  \n @staticmethod\n def _name_from_stem(stem):\n  ''\n\n\n\n\n\n\n\n  \n  filename,ext=os.path.splitext(stem)\n  if ext not in('.dist-info','.egg-info'):\n   return\n  name,sep,rest=filename.partition('-')\n  return name\n  \n  \ndef distribution(distribution_name:str)->Distribution:\n ''\n\n\n\n \n return Distribution.from_name(distribution_name)\n \n \ndef distributions(**kwargs)->Iterable[Distribution]:\n ''\n\n\n \n return Distribution.discover(**kwargs)\n \n \ndef metadata(distribution_name:str)->_meta.PackageMetadata:\n ''\n\n\n\n \n return Distribution.from_name(distribution_name).metadata\n \n \ndef version(distribution_name:str)->str:\n ''\n\n\n\n\n \n return distribution(distribution_name).version\n \n \n_unique=functools.partial(\nunique_everseen,\nkey=operator.attrgetter('_normalized_name'),\n)\n''\n\n\n\n\ndef entry_points(**params)->EntryPoints:\n ''\n\n\n\n\n\n\n \n eps=itertools.chain.from_iterable(\n dist.entry_points for dist in _unique(distributions())\n )\n return EntryPoints(eps).select(**params)\n \n \ndef files(distribution_name:str)->Optional[List[PackagePath]]:\n ''\n\n\n\n \n return distribution(distribution_name).files\n \n \ndef requires(distribution_name:str)->Optional[List[str]]:\n ''\n\n\n\n\n \n return distribution(distribution_name).requires\n \n \ndef packages_distributions()->Mapping[str,List[str]]:\n ''\n\n\n\n\n\n\n\n \n pkg_to_dist=collections.defaultdict(list)\n for dist in distributions():\n  for pkg in _top_level_declared(dist)or _top_level_inferred(dist):\n   pkg_to_dist[pkg].append(dist.metadata['Name'])\n return dict(pkg_to_dist)\n \n \ndef _top_level_declared(dist):\n return(dist.read_text('top_level.txt')or '').split()\n \n \ndef _topmost(name:PackagePath)->Optional[str]:\n ''\n\n \n top,*rest=name.parts\n return top if rest else None\n \n \ndef _get_toplevel_name(name:PackagePath)->str:\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n return _topmost(name)or(\n \n inspect.getmodulename(name)\n or str(name)\n )\n \n \ndef _top_level_inferred(dist):\n opt_names=set(map(_get_toplevel_name,always_iterable(dist.files)))\n \n def importable_name(name):\n  return '.'not in name\n  \n return filter(importable_name,opt_names)\n", ["__future__", "abc", "collections", "contextlib", "csv", "email", "functools", "importlib", "importlib.abc", "importlib.metadata", "importlib.metadata._adapters", "importlib.metadata._collections", "importlib.metadata._functools", "importlib.metadata._itertools", "importlib.metadata._meta", "inspect", "itertools", "json", "operator", "os", "pathlib", "posixpath", "re", "sys", "textwrap", "types", "typing", "warnings", "zipfile"], 1], "importlib.resources.simple": [".py", "''\n\n\n\nimport abc\nimport io\nimport itertools\nfrom typing import BinaryIO,List\n\nfrom.abc import Traversable,TraversableResources\n\n\nclass SimpleReader(abc.ABC):\n ''\n\n\n \n \n @property\n @abc.abstractmethod\n def package(self)->str:\n  ''\n\n  \n  \n @abc.abstractmethod\n def children(self)->List['SimpleReader']:\n  ''\n\n\n  \n  \n @abc.abstractmethod\n def resources(self)->List[str]:\n  ''\n\n  \n  \n @abc.abstractmethod\n def open_binary(self,resource:str)->BinaryIO:\n  ''\n\n  \n  \n @property\n def name(self):\n  return self.package.split('.')[-1]\n  \n  \nclass ResourceContainer(Traversable):\n ''\n\n \n \n def __init__(self,reader:SimpleReader):\n  self.reader=reader\n  \n def is_dir(self):\n  return True\n  \n def is_file(self):\n  return False\n  \n def iterdir(self):\n  files=(ResourceHandle(self,name)for name in self.reader.resources)\n  dirs=map(ResourceContainer,self.reader.children())\n  return itertools.chain(files,dirs)\n  \n def open(self,*args,**kwargs):\n  raise IsADirectoryError()\n  \n  \nclass ResourceHandle(Traversable):\n ''\n\n \n \n def __init__(self,parent:ResourceContainer,name:str):\n  self.parent=parent\n  self.name=name\n  \n def is_file(self):\n  return True\n  \n def is_dir(self):\n  return False\n  \n def open(self,mode='r',*args,**kwargs):\n  stream=self.parent.reader.open_binary(self.name)\n  if 'b'not in mode:\n   stream=io.TextIOWrapper(stream,*args,**kwargs)\n  return stream\n  \n def joinpath(self,name):\n  raise RuntimeError(\"Cannot traverse into a resource\")\n  \n  \nclass TraversableReader(TraversableResources,SimpleReader):\n ''\n\n\n\n \n \n def files(self):\n  return ResourceContainer(self)\n", ["abc", "importlib.resources.abc", "io", "itertools", "typing"]], "importlib.resources._itertools": [".py", "\ndef only(iterable,default=None,too_long=None):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n it=iter(iterable)\n first_value=next(it,default)\n \n try:\n  second_value=next(it)\n except StopIteration:\n  pass\n else:\n  msg=(\n  'Expected exactly one item in iterable, but got {!r}, {!r}, '\n  'and perhaps more.'.format(first_value,second_value)\n  )\n  raise too_long or ValueError(msg)\n  \n return first_value\n", []], "importlib.resources": [".py", "''\n\nfrom._common import(\nas_file,\nfiles,\nPackage,\nAnchor,\n)\n\nfrom._functional import(\ncontents,\nis_resource,\nopen_binary,\nopen_text,\npath,\nread_binary,\nread_text,\n)\n\nfrom.abc import ResourceReader\n\n\n__all__=[\n'Package',\n'Anchor',\n'ResourceReader',\n'as_file',\n'files',\n'contents',\n'is_resource',\n'open_binary',\n'open_text',\n'path',\n'read_binary',\n'read_text',\n]\n", ["importlib.resources._common", "importlib.resources._functional", "importlib.resources.abc"], 1], "json": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n__version__='2.0.9'\n__all__=[\n'dump','dumps','load','loads',\n'JSONDecoder','JSONDecodeError','JSONEncoder',\n]\n\n__author__='Bob Ippolito <bob@redivi.com>'\n\n\n\n\n\nclass codecs:\n\n BOM_UTF8=b'\\xef\\xbb\\xbf'\n BOM_LE=BOM_UTF16_LE=b'\\xff\\xfe'\n BOM_BE=BOM_UTF16_BE=b'\\xfe\\xff'\n BOM_UTF32_LE=b'\\xff\\xfe\\x00\\x00'\n BOM_UTF32_BE=b'\\x00\\x00\\xfe\\xff'\n \n \nimport _json\nfrom.encoder import JSONEncoder\n\nJSONDecoder=_json.JSONDecoder\n\nclass decoder:\n JSONDecoder=_json.JSONDecoder\n \nclass JSONDecodeError(ValueError):\n ''\n\n\n\n\n\n\n\n \n \n def __init__(self,msg,doc,pos):\n  lineno=doc.count('\\n',0,pos)+1\n  colno=pos -doc.rfind('\\n',0,pos)\n  errmsg='%s: line %d column %d (char %d)'%(msg,lineno,colno,pos)\n  ValueError.__init__(self,errmsg)\n  self.msg=msg\n  self.doc=doc\n  self.pos=pos\n  self.lineno=lineno\n  self.colno=colno\n  \n def __reduce__(self):\n  return self.__class__,(self.msg,self.doc,self.pos)\n  \ndef dump(obj,fp,**kw):\n fp.write(dumps(obj,**kw))\n \ndef dumps(obj,*,skipkeys=False,ensure_ascii=True,check_circular=True,\nallow_nan=True,cls=None,indent=None,separators=None,\ndefault=None,sort_keys=False,**kw):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n if cls is None:\n  return _json.dumps(obj,1,\n  skipkeys=skipkeys,ensure_ascii=ensure_ascii,\n  check_circular=check_circular,allow_nan=allow_nan,indent=indent,\n  separators=separators,default=default,sort_keys=sort_keys,\n  **kw)\n return cls(\n skipkeys=skipkeys,ensure_ascii=ensure_ascii,\n check_circular=check_circular,allow_nan=allow_nan,indent=indent,\n separators=separators,default=default,sort_keys=sort_keys,\n **kw).encode(obj)\n \ndef detect_encoding(b):\n bstartswith=b.startswith\n if bstartswith((codecs.BOM_UTF32_BE,codecs.BOM_UTF32_LE)):\n  return 'utf-32'\n if bstartswith((codecs.BOM_UTF16_BE,codecs.BOM_UTF16_LE)):\n  return 'utf-16'\n if bstartswith(codecs.BOM_UTF8):\n  return 'utf-8-sig'\n  \n if len(b)>=4:\n  if not b[0]:\n  \n  \n   return 'utf-16-be'if b[1]else 'utf-32-be'\n  if not b[1]:\n  \n  \n  \n   return 'utf-16-le'if b[2]or b[3]else 'utf-32-le'\n elif len(b)==2:\n  if not b[0]:\n  \n   return 'utf-16-be'\n  if not b[1]:\n  \n   return 'utf-16-le'\n   \n return 'utf-8'\n \n \ndef load(fp,*,cls=None,object_hook=None,parse_float=None,\nparse_int=None,parse_constant=None,object_pairs_hook=None,**kw):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n return loads(fp.read(),\n cls=cls,object_hook=object_hook,\n parse_float=parse_float,parse_int=parse_int,\n parse_constant=parse_constant,object_pairs_hook=object_pairs_hook,**kw)\n \n \ndef loads(s,*,cls=None,**kw):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n if isinstance(s,str):\n  if s.startswith('\\ufeff'):\n   raise JSONDecodeError(\"Unexpected UTF-8 BOM (decode using utf-8-sig)\",\n   s,0)\n else:\n  if not isinstance(s,(bytes,bytearray)):\n   raise TypeError(f'the JSON object must be str, bytes or bytearray, '\n   f'not {s.__class__.__name__}')\n  s=s.decode(detect_encoding(s),'surrogatepass')\n  \n  \n if \"encoding\"in kw:\n  import warnings\n  warnings.warn(\n  \"'encoding' is ignored and deprecated. It will be removed in Python 3.9\",\n  DeprecationWarning,\n  stacklevel=2\n  )\n  del kw['encoding']\n  \n if cls is None:\n \n \n  return _json.loads(s,**kw)\n if object_hook is not None:\n  kw['object_hook']=object_hook\n if object_pairs_hook is not None:\n  kw['object_pairs_hook']=object_pairs_hook\n if parse_float is not None:\n  kw['parse_float']=parse_float\n if parse_int is not None:\n  kw['parse_int']=parse_int\n if parse_constant is not None:\n  kw['parse_constant']=parse_constant\n return cls(**kw).decode(s)\n", ["_json", "json.encoder", "warnings"], 1], "logging.config": [".py", "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\"\"\"\nConfiguration functions for the logging package for Python. The core package\nis based on PEP 282 and comments thereto in comp.lang.python, and influenced\nby Apache's log4j system.\n\nCopyright (C) 2001-2022 Vinay Sajip. All Rights Reserved.\n\nTo use, simply 'import logging' and log away!\n\"\"\"\n\nimport errno\nimport functools\nimport io\nimport logging\nimport logging.handlers\nimport os\nimport queue\nimport re\nimport struct\nimport threading\nimport traceback\n\nfrom socketserver import ThreadingTCPServer,StreamRequestHandler\n\n\nDEFAULT_LOGGING_CONFIG_PORT=9030\n\nRESET_ERROR=errno.ECONNRESET\n\n\n\n\n\n\n_listener=None\n\ndef fileConfig(fname,defaults=None,disable_existing_loggers=True,encoding=None):\n ''\n\n\n\n\n\n\n \n import configparser\n \n if isinstance(fname,str):\n  if not os.path.exists(fname):\n   raise FileNotFoundError(f\"{fname} doesn't exist\")\n  elif not os.path.getsize(fname):\n   raise RuntimeError(f'{fname} is an empty file')\n   \n if isinstance(fname,configparser.RawConfigParser):\n  cp=fname\n else:\n  try:\n   cp=configparser.ConfigParser(defaults)\n   if hasattr(fname,'readline'):\n    cp.read_file(fname)\n   else:\n    encoding=io.text_encoding(encoding)\n    cp.read(fname,encoding=encoding)\n  except configparser.ParsingError as e:\n   raise RuntimeError(f'{fname} is invalid: {e}')\n   \n formatters=_create_formatters(cp)\n \n \n with logging._lock:\n  _clearExistingHandlers()\n  \n  \n  handlers=_install_handlers(cp,formatters)\n  _install_loggers(cp,handlers,disable_existing_loggers)\n  \n  \ndef _resolve(name):\n ''\n name=name.split('.')\n used=name.pop(0)\n found=__import__(used)\n for n in name:\n  used=used+'.'+n\n  try:\n   found=getattr(found,n)\n  except AttributeError:\n   __import__(used)\n   found=getattr(found,n)\n return found\n \ndef _strip_spaces(alist):\n return map(str.strip,alist)\n \ndef _create_formatters(cp):\n ''\n flist=cp[\"formatters\"][\"keys\"]\n if not len(flist):\n  return{}\n flist=flist.split(\",\")\n flist=_strip_spaces(flist)\n formatters={}\n for form in flist:\n  sectname=\"formatter_%s\"%form\n  fs=cp.get(sectname,\"format\",raw=True,fallback=None)\n  dfs=cp.get(sectname,\"datefmt\",raw=True,fallback=None)\n  stl=cp.get(sectname,\"style\",raw=True,fallback='%')\n  defaults=cp.get(sectname,\"defaults\",raw=True,fallback=None)\n  \n  c=logging.Formatter\n  class_name=cp[sectname].get(\"class\")\n  if class_name:\n   c=_resolve(class_name)\n   \n  if defaults is not None:\n   defaults=eval(defaults,vars(logging))\n   f=c(fs,dfs,stl,defaults=defaults)\n  else:\n   f=c(fs,dfs,stl)\n  formatters[form]=f\n return formatters\n \n \ndef _install_handlers(cp,formatters):\n ''\n hlist=cp[\"handlers\"][\"keys\"]\n if not len(hlist):\n  return{}\n hlist=hlist.split(\",\")\n hlist=_strip_spaces(hlist)\n handlers={}\n fixups=[]\n for hand in hlist:\n  section=cp[\"handler_%s\"%hand]\n  klass=section[\"class\"]\n  fmt=section.get(\"formatter\",\"\")\n  try:\n   klass=eval(klass,vars(logging))\n  except(AttributeError,NameError):\n   klass=_resolve(klass)\n  args=section.get(\"args\",'()')\n  args=eval(args,vars(logging))\n  kwargs=section.get(\"kwargs\",'{}')\n  kwargs=eval(kwargs,vars(logging))\n  h=klass(*args,**kwargs)\n  h.name=hand\n  if \"level\"in section:\n   level=section[\"level\"]\n   h.setLevel(level)\n  if len(fmt):\n   h.setFormatter(formatters[fmt])\n  if issubclass(klass,logging.handlers.MemoryHandler):\n   target=section.get(\"target\",\"\")\n   if len(target):\n    fixups.append((h,target))\n  handlers[hand]=h\n  \n for h,t in fixups:\n  h.setTarget(handlers[t])\n return handlers\n \ndef _handle_existing_loggers(existing,child_loggers,disable_existing):\n ''\n\n\n\n\n\n\n\n\n \n root=logging.root\n for log in existing:\n  logger=root.manager.loggerDict[log]\n  if log in child_loggers:\n   if not isinstance(logger,logging.PlaceHolder):\n    logger.setLevel(logging.NOTSET)\n    logger.handlers=[]\n    logger.propagate=True\n  else:\n   logger.disabled=disable_existing\n   \ndef _install_loggers(cp,handlers,disable_existing):\n ''\n \n \n llist=cp[\"loggers\"][\"keys\"]\n llist=llist.split(\",\")\n llist=list(_strip_spaces(llist))\n llist.remove(\"root\")\n section=cp[\"logger_root\"]\n root=logging.root\n log=root\n if \"level\"in section:\n  level=section[\"level\"]\n  log.setLevel(level)\n for h in root.handlers[:]:\n  root.removeHandler(h)\n hlist=section[\"handlers\"]\n if len(hlist):\n  hlist=hlist.split(\",\")\n  hlist=_strip_spaces(hlist)\n  for hand in hlist:\n   log.addHandler(handlers[hand])\n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n existing=list(root.manager.loggerDict.keys())\n \n \n \n \n existing.sort()\n \n \n child_loggers=[]\n \n for log in llist:\n  section=cp[\"logger_%s\"%log]\n  qn=section[\"qualname\"]\n  propagate=section.getint(\"propagate\",fallback=1)\n  logger=logging.getLogger(qn)\n  if qn in existing:\n   i=existing.index(qn)+1\n   prefixed=qn+\".\"\n   pflen=len(prefixed)\n   num_existing=len(existing)\n   while i <num_existing:\n    if existing[i][:pflen]==prefixed:\n     child_loggers.append(existing[i])\n    i +=1\n   existing.remove(qn)\n  if \"level\"in section:\n   level=section[\"level\"]\n   logger.setLevel(level)\n  for h in logger.handlers[:]:\n   logger.removeHandler(h)\n  logger.propagate=propagate\n  logger.disabled=0\n  hlist=section[\"handlers\"]\n  if len(hlist):\n   hlist=hlist.split(\",\")\n   hlist=_strip_spaces(hlist)\n   for hand in hlist:\n    logger.addHandler(handlers[hand])\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n _handle_existing_loggers(existing,child_loggers,disable_existing)\n \n \ndef _clearExistingHandlers():\n ''\n logging._handlers.clear()\n logging.shutdown(logging._handlerList[:])\n del logging._handlerList[:]\n \n \nIDENTIFIER=re.compile('^[a-z_][a-z0-9_]*$',re.I)\n\n\ndef valid_ident(s):\n m=IDENTIFIER.match(s)\n if not m:\n  raise ValueError('Not a valid Python identifier: %r'%s)\n return True\n \n \nclass ConvertingMixin(object):\n ''\n \n def convert_with_key(self,key,value,replace=True):\n  result=self.configurator.convert(value)\n  \n  if value is not result:\n   if replace:\n    self[key]=result\n   if type(result)in(ConvertingDict,ConvertingList,\n   ConvertingTuple):\n    result.parent=self\n    result.key=key\n  return result\n  \n def convert(self,value):\n  result=self.configurator.convert(value)\n  if value is not result:\n   if type(result)in(ConvertingDict,ConvertingList,\n   ConvertingTuple):\n    result.parent=self\n  return result\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \nclass ConvertingDict(dict,ConvertingMixin):\n ''\n \n def __getitem__(self,key):\n  value=dict.__getitem__(self,key)\n  return self.convert_with_key(key,value)\n  \n def get(self,key,default=None):\n  value=dict.get(self,key,default)\n  return self.convert_with_key(key,value)\n  \n def pop(self,key,default=None):\n  value=dict.pop(self,key,default)\n  return self.convert_with_key(key,value,replace=False)\n  \nclass ConvertingList(list,ConvertingMixin):\n ''\n def __getitem__(self,key):\n  value=list.__getitem__(self,key)\n  return self.convert_with_key(key,value)\n  \n def pop(self,idx=-1):\n  value=list.pop(self,idx)\n  return self.convert(value)\n  \nclass ConvertingTuple(tuple,ConvertingMixin):\n ''\n def __getitem__(self,key):\n  value=tuple.__getitem__(self,key)\n  \n  return self.convert_with_key(key,value,replace=False)\n  \nclass BaseConfigurator(object):\n ''\n\n \n \n CONVERT_PATTERN=re.compile(r'^(?P<prefix>[a-z]+)://(?P<suffix>.*)$')\n \n WORD_PATTERN=re.compile(r'^\\s*(\\w+)\\s*')\n DOT_PATTERN=re.compile(r'^\\.\\s*(\\w+)\\s*')\n INDEX_PATTERN=re.compile(r'^\\[([^\\[\\]]*)\\]\\s*')\n DIGIT_PATTERN=re.compile(r'^\\d+$')\n \n value_converters={\n 'ext':'ext_convert',\n 'cfg':'cfg_convert',\n }\n \n \n importer=staticmethod(__import__)\n \n def __init__(self,config):\n  self.config=ConvertingDict(config)\n  self.config.configurator=self\n  \n def resolve(self,s):\n  ''\n\n\n  \n  name=s.split('.')\n  used=name.pop(0)\n  try:\n   found=self.importer(used)\n   for frag in name:\n    used +='.'+frag\n    try:\n     found=getattr(found,frag)\n    except AttributeError:\n     self.importer(used)\n     found=getattr(found,frag)\n   return found\n  except ImportError as e:\n   v=ValueError('Cannot resolve %r: %s'%(s,e))\n   raise v from e\n   \n def ext_convert(self,value):\n  ''\n  return self.resolve(value)\n  \n def cfg_convert(self,value):\n  ''\n  rest=value\n  m=self.WORD_PATTERN.match(rest)\n  if m is None:\n   raise ValueError(\"Unable to convert %r\"%value)\n  else:\n   rest=rest[m.end():]\n   d=self.config[m.groups()[0]]\n   \n   while rest:\n    m=self.DOT_PATTERN.match(rest)\n    if m:\n     d=d[m.groups()[0]]\n    else:\n     m=self.INDEX_PATTERN.match(rest)\n     if m:\n      idx=m.groups()[0]\n      if not self.DIGIT_PATTERN.match(idx):\n       d=d[idx]\n      else:\n       try:\n        n=int(idx)\n        d=d[n]\n       except TypeError:\n        d=d[idx]\n    if m:\n     rest=rest[m.end():]\n    else:\n     raise ValueError('Unable to convert '\n     '%r at %r'%(value,rest))\n     \n  return d\n  \n def convert(self,value):\n  ''\n\n\n\n  \n  if not isinstance(value,ConvertingDict)and isinstance(value,dict):\n   value=ConvertingDict(value)\n   value.configurator=self\n  elif not isinstance(value,ConvertingList)and isinstance(value,list):\n   value=ConvertingList(value)\n   value.configurator=self\n  elif not isinstance(value,ConvertingTuple)and\\\n  isinstance(value,tuple)and not hasattr(value,'_fields'):\n   value=ConvertingTuple(value)\n   value.configurator=self\n  elif isinstance(value,str):\n   m=self.CONVERT_PATTERN.match(value)\n   if m:\n    d=m.groupdict()\n    prefix=d['prefix']\n    converter=self.value_converters.get(prefix,None)\n    if converter:\n     suffix=d['suffix']\n     converter=getattr(self,converter)\n     value=converter(suffix)\n  return value\n  \n def configure_custom(self,config):\n  ''\n  c=config.pop('()')\n  if not callable(c):\n   c=self.resolve(c)\n   \n  kwargs={k:config[k]for k in config if(k !='.'and valid_ident(k))}\n  result=c(**kwargs)\n  props=config.pop('.',None)\n  if props:\n   for name,value in props.items():\n    setattr(result,name,value)\n  return result\n  \n def as_tuple(self,value):\n  ''\n  if isinstance(value,list):\n   value=tuple(value)\n  return value\n  \nclass DictConfigurator(BaseConfigurator):\n ''\n\n\n \n \n def configure(self):\n  ''\n  \n  config=self.config\n  if 'version'not in config:\n   raise ValueError(\"dictionary doesn't specify a version\")\n  if config['version']!=1:\n   raise ValueError(\"Unsupported version: %s\"%config['version'])\n  incremental=config.pop('incremental',False)\n  EMPTY_DICT={}\n  with logging._lock:\n   if incremental:\n    handlers=config.get('handlers',EMPTY_DICT)\n    for name in handlers:\n     if name not in logging._handlers:\n      raise ValueError('No handler found with '\n      'name %r'%name)\n     else:\n      try:\n       handler=logging._handlers[name]\n       handler_config=handlers[name]\n       level=handler_config.get('level',None)\n       if level:\n        handler.setLevel(logging._checkLevel(level))\n      except Exception as e:\n       raise ValueError('Unable to configure handler '\n       '%r'%name)from e\n    loggers=config.get('loggers',EMPTY_DICT)\n    for name in loggers:\n     try:\n      self.configure_logger(name,loggers[name],True)\n     except Exception as e:\n      raise ValueError('Unable to configure logger '\n      '%r'%name)from e\n    root=config.get('root',None)\n    if root:\n     try:\n      self.configure_root(root,True)\n     except Exception as e:\n      raise ValueError('Unable to configure root '\n      'logger')from e\n   else:\n    disable_existing=config.pop('disable_existing_loggers',True)\n    \n    _clearExistingHandlers()\n    \n    \n    formatters=config.get('formatters',EMPTY_DICT)\n    for name in formatters:\n     try:\n      formatters[name]=self.configure_formatter(\n      formatters[name])\n     except Exception as e:\n      raise ValueError('Unable to configure '\n      'formatter %r'%name)from e\n      \n    filters=config.get('filters',EMPTY_DICT)\n    for name in filters:\n     try:\n      filters[name]=self.configure_filter(filters[name])\n     except Exception as e:\n      raise ValueError('Unable to configure '\n      'filter %r'%name)from e\n      \n      \n      \n      \n    handlers=config.get('handlers',EMPTY_DICT)\n    deferred=[]\n    for name in sorted(handlers):\n     try:\n      handler=self.configure_handler(handlers[name])\n      handler.name=name\n      handlers[name]=handler\n     except Exception as e:\n      if ' not configured yet'in str(e.__cause__):\n       deferred.append(name)\n      else:\n       raise ValueError('Unable to configure handler '\n       '%r'%name)from e\n       \n       \n    for name in deferred:\n     try:\n      handler=self.configure_handler(handlers[name])\n      handler.name=name\n      handlers[name]=handler\n     except Exception as e:\n      raise ValueError('Unable to configure handler '\n      '%r'%name)from e\n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n    root=logging.root\n    existing=list(root.manager.loggerDict.keys())\n    \n    \n    \n    \n    existing.sort()\n    \n    \n    child_loggers=[]\n    \n    loggers=config.get('loggers',EMPTY_DICT)\n    for name in loggers:\n     if name in existing:\n      i=existing.index(name)+1\n      prefixed=name+\".\"\n      pflen=len(prefixed)\n      num_existing=len(existing)\n      while i <num_existing:\n       if existing[i][:pflen]==prefixed:\n        child_loggers.append(existing[i])\n       i +=1\n      existing.remove(name)\n     try:\n      self.configure_logger(name,loggers[name])\n     except Exception as e:\n      raise ValueError('Unable to configure logger '\n      '%r'%name)from e\n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n    _handle_existing_loggers(existing,child_loggers,\n    disable_existing)\n    \n    \n    root=config.get('root',None)\n    if root:\n     try:\n      self.configure_root(root)\n     except Exception as e:\n      raise ValueError('Unable to configure root '\n      'logger')from e\n      \n def configure_formatter(self,config):\n  ''\n  if '()'in config:\n   factory=config['()']\n   try:\n    result=self.configure_custom(config)\n   except TypeError as te:\n    if \"'format'\"not in str(te):\n     raise\n     \n     \n     \n    config['fmt']=config.pop('format')\n    config['()']=factory\n    result=self.configure_custom(config)\n  else:\n   fmt=config.get('format',None)\n   dfmt=config.get('datefmt',None)\n   style=config.get('style','%')\n   cname=config.get('class',None)\n   defaults=config.get('defaults',None)\n   \n   if not cname:\n    c=logging.Formatter\n   else:\n    c=_resolve(cname)\n    \n   kwargs={}\n   \n   \n   \n   \n   if defaults is not None:\n    kwargs['defaults']=defaults\n    \n    \n    \n   if 'validate'in config:\n    result=c(fmt,dfmt,style,config['validate'],**kwargs)\n   else:\n    result=c(fmt,dfmt,style,**kwargs)\n    \n  return result\n  \n def configure_filter(self,config):\n  ''\n  if '()'in config:\n   result=self.configure_custom(config)\n  else:\n   name=config.get('name','')\n   result=logging.Filter(name)\n  return result\n  \n def add_filters(self,filterer,filters):\n  ''\n  for f in filters:\n   try:\n    if callable(f)or callable(getattr(f,'filter',None)):\n     filter_=f\n    else:\n     filter_=self.config['filters'][f]\n    filterer.addFilter(filter_)\n   except Exception as e:\n    raise ValueError('Unable to add filter %r'%f)from e\n    \n def _configure_queue_handler(self,klass,**kwargs):\n  if 'queue'in kwargs:\n   q=kwargs['queue']\n  else:\n   q=queue.Queue()\n  rhl=kwargs.get('respect_handler_level',False)\n  if 'listener'in kwargs:\n   lklass=kwargs['listener']\n  else:\n   lklass=logging.handlers.QueueListener\n  listener=lklass(q,*kwargs.get('handlers',[]),respect_handler_level=rhl)\n  handler=klass(q)\n  handler.listener=listener\n  return handler\n  \n def configure_handler(self,config):\n  ''\n  config_copy=dict(config)\n  formatter=config.pop('formatter',None)\n  if formatter:\n   try:\n    formatter=self.config['formatters'][formatter]\n   except Exception as e:\n    raise ValueError('Unable to set formatter '\n    '%r'%formatter)from e\n  level=config.pop('level',None)\n  filters=config.pop('filters',None)\n  if '()'in config:\n   c=config.pop('()')\n   if not callable(c):\n    c=self.resolve(c)\n   factory=c\n  else:\n   cname=config.pop('class')\n   if callable(cname):\n    klass=cname\n   else:\n    klass=self.resolve(cname)\n   if issubclass(klass,logging.handlers.MemoryHandler):\n    if 'flushLevel'in config:\n     config['flushLevel']=logging._checkLevel(config['flushLevel'])\n    if 'target'in config:\n    \n     try:\n      tn=config['target']\n      th=self.config['handlers'][tn]\n      if not isinstance(th,logging.Handler):\n       config.update(config_copy)\n       raise TypeError('target not configured yet')\n      config['target']=th\n     except Exception as e:\n      raise ValueError('Unable to set target handler %r'%tn)from e\n   elif issubclass(klass,logging.handlers.QueueHandler):\n   \n   \n   \n    if 'queue'in config:\n     from multiprocessing.queues import Queue as MPQueue\n     qspec=config['queue']\n     if not isinstance(qspec,(queue.Queue,MPQueue)):\n      if isinstance(qspec,str):\n       q=self.resolve(qspec)\n       if not callable(q):\n        raise TypeError('Invalid queue specifier %r'%qspec)\n       q=q()\n      elif isinstance(qspec,dict):\n       if '()'not in qspec:\n        raise TypeError('Invalid queue specifier %r'%qspec)\n       q=self.configure_custom(dict(qspec))\n      else:\n       raise TypeError('Invalid queue specifier %r'%qspec)\n      config['queue']=q\n    if 'listener'in config:\n     lspec=config['listener']\n     if isinstance(lspec,type):\n      if not issubclass(lspec,logging.handlers.QueueListener):\n       raise TypeError('Invalid listener specifier %r'%lspec)\n     else:\n      if isinstance(lspec,str):\n       listener=self.resolve(lspec)\n       if isinstance(listener,type)and\\\n       not issubclass(listener,logging.handlers.QueueListener):\n        raise TypeError('Invalid listener specifier %r'%lspec)\n      elif isinstance(lspec,dict):\n       if '()'not in lspec:\n        raise TypeError('Invalid listener specifier %r'%lspec)\n       listener=self.configure_custom(dict(lspec))\n      else:\n       raise TypeError('Invalid listener specifier %r'%lspec)\n      if not callable(listener):\n       raise TypeError('Invalid listener specifier %r'%lspec)\n      config['listener']=listener\n    if 'handlers'in config:\n     hlist=[]\n     try:\n      for hn in config['handlers']:\n       h=self.config['handlers'][hn]\n       if not isinstance(h,logging.Handler):\n        config.update(config_copy)\n        raise TypeError('Required handler %r '\n        'is not configured yet'%hn)\n       hlist.append(h)\n     except Exception as e:\n      raise ValueError('Unable to set required handler %r'%hn)from e\n     config['handlers']=hlist\n   elif issubclass(klass,logging.handlers.SMTPHandler)and\\\n   'mailhost'in config:\n    config['mailhost']=self.as_tuple(config['mailhost'])\n   elif issubclass(klass,logging.handlers.SysLogHandler)and\\\n   'address'in config:\n    config['address']=self.as_tuple(config['address'])\n   if issubclass(klass,logging.handlers.QueueHandler):\n    factory=functools.partial(self._configure_queue_handler,klass)\n   else:\n    factory=klass\n  kwargs={k:config[k]for k in config if(k !='.'and valid_ident(k))}\n  try:\n   result=factory(**kwargs)\n  except TypeError as te:\n   if \"'stream'\"not in str(te):\n    raise\n    \n    \n    \n    \n   kwargs['strm']=kwargs.pop('stream')\n   result=factory(**kwargs)\n  if formatter:\n   result.setFormatter(formatter)\n  if level is not None:\n   result.setLevel(logging._checkLevel(level))\n  if filters:\n   self.add_filters(result,filters)\n  props=config.pop('.',None)\n  if props:\n   for name,value in props.items():\n    setattr(result,name,value)\n  return result\n  \n def add_handlers(self,logger,handlers):\n  ''\n  for h in handlers:\n   try:\n    logger.addHandler(self.config['handlers'][h])\n   except Exception as e:\n    raise ValueError('Unable to add handler %r'%h)from e\n    \n def common_logger_config(self,logger,config,incremental=False):\n  ''\n\n  \n  level=config.get('level',None)\n  if level is not None:\n   logger.setLevel(logging._checkLevel(level))\n  if not incremental:\n  \n   for h in logger.handlers[:]:\n    logger.removeHandler(h)\n   handlers=config.get('handlers',None)\n   if handlers:\n    self.add_handlers(logger,handlers)\n   filters=config.get('filters',None)\n   if filters:\n    self.add_filters(logger,filters)\n    \n def configure_logger(self,name,config,incremental=False):\n  ''\n  logger=logging.getLogger(name)\n  self.common_logger_config(logger,config,incremental)\n  logger.disabled=False\n  propagate=config.get('propagate',None)\n  if propagate is not None:\n   logger.propagate=propagate\n   \n def configure_root(self,config,incremental=False):\n  ''\n  root=logging.getLogger()\n  self.common_logger_config(root,config,incremental)\n  \ndictConfigClass=DictConfigurator\n\ndef dictConfig(config):\n ''\n dictConfigClass(config).configure()\n \n \ndef listen(port=DEFAULT_LOGGING_CONFIG_PORT,verify=None):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n class ConfigStreamHandler(StreamRequestHandler):\n  ''\n\n\n\n\n  \n  def handle(self):\n   ''\n\n\n\n\n\n   \n   try:\n    conn=self.connection\n    chunk=conn.recv(4)\n    if len(chunk)==4:\n     slen=struct.unpack(\">L\",chunk)[0]\n     chunk=self.connection.recv(slen)\n     while len(chunk)<slen:\n      chunk=chunk+conn.recv(slen -len(chunk))\n     if self.server.verify is not None:\n      chunk=self.server.verify(chunk)\n     if chunk is not None:\n      chunk=chunk.decode(\"utf-8\")\n      try:\n       import json\n       d=json.loads(chunk)\n       assert isinstance(d,dict)\n       dictConfig(d)\n      except Exception:\n      \n      \n       file=io.StringIO(chunk)\n       try:\n        fileConfig(file)\n       except Exception:\n        traceback.print_exc()\n     if self.server.ready:\n      self.server.ready.set()\n   except OSError as e:\n    if e.errno !=RESET_ERROR:\n     raise\n     \n class ConfigSocketReceiver(ThreadingTCPServer):\n  ''\n\n  \n  \n  allow_reuse_address=1\n  \n  def __init__(self,host='localhost',port=DEFAULT_LOGGING_CONFIG_PORT,\n  handler=None,ready=None,verify=None):\n   ThreadingTCPServer.__init__(self,(host,port),handler)\n   with logging._lock:\n    self.abort=0\n   self.timeout=1\n   self.ready=ready\n   self.verify=verify\n   \n  def serve_until_stopped(self):\n   import select\n   abort=0\n   while not abort:\n    rd,wr,ex=select.select([self.socket.fileno()],\n    [],[],\n    self.timeout)\n    if rd:\n     self.handle_request()\n    with logging._lock:\n     abort=self.abort\n   self.server_close()\n   \n class Server(threading.Thread):\n \n  def __init__(self,rcvr,hdlr,port,verify):\n   super(Server,self).__init__()\n   self.rcvr=rcvr\n   self.hdlr=hdlr\n   self.port=port\n   self.verify=verify\n   self.ready=threading.Event()\n   \n  def run(self):\n   server=self.rcvr(port=self.port,handler=self.hdlr,\n   ready=self.ready,\n   verify=self.verify)\n   if self.port ==0:\n    self.port=server.server_address[1]\n   self.ready.set()\n   global _listener\n   with logging._lock:\n    _listener=server\n   server.serve_until_stopped()\n   \n return Server(ConfigSocketReceiver,ConfigStreamHandler,port,verify)\n \ndef stopListening():\n ''\n\n \n global _listener\n with logging._lock:\n  if _listener:\n   _listener.abort=1\n   _listener=None\n", ["configparser", "errno", "functools", "io", "json", "logging", "logging.handlers", "multiprocessing.queues", "os", "queue", "re", "select", "socketserver", "struct", "threading", "traceback"]], "logging": [".py", "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\"\"\"\nLogging package for Python. Based on PEP 282 and comments thereto in\ncomp.lang.python.\n\nCopyright (C) 2001-2022 Vinay Sajip. All Rights Reserved.\n\nTo use, simply 'import logging' and log away!\n\"\"\"\n\nimport sys,os,time,io,re,traceback,warnings,weakref,collections.abc\n\nfrom types import GenericAlias\nfrom string import Template\nfrom string import Formatter as StrFormatter\n\n\n__all__=['BASIC_FORMAT','BufferingFormatter','CRITICAL','DEBUG','ERROR',\n'FATAL','FileHandler','Filter','Formatter','Handler','INFO',\n'LogRecord','Logger','LoggerAdapter','NOTSET','NullHandler',\n'StreamHandler','WARN','WARNING','addLevelName','basicConfig',\n'captureWarnings','critical','debug','disable','error',\n'exception','fatal','getLevelName','getLogger','getLoggerClass',\n'info','log','makeLogRecord','setLoggerClass','shutdown',\n'warning','getLogRecordFactory','setLogRecordFactory',\n'lastResort','raiseExceptions','getLevelNamesMapping',\n'getHandlerByName','getHandlerNames']\n\nimport threading\n\n__author__=\"Vinay Sajip <vinay_sajip@red-dove.com>\"\n__status__=\"production\"\n\n__version__=\"0.5.1.2\"\n__date__=\"07 February 2010\"\n\n\n\n\n\n\n\n\n_startTime=time.time_ns()\n\n\n\n\n\nraiseExceptions=True\n\n\n\n\nlogThreads=True\n\n\n\n\nlogMultiprocessing=True\n\n\n\n\nlogProcesses=True\n\n\n\n\nlogAsyncioTasks=True\n\n\n\n\n\n\n\n\n\n\n\n\nCRITICAL=50\nFATAL=CRITICAL\nERROR=40\nWARNING=30\nWARN=WARNING\nINFO=20\nDEBUG=10\nNOTSET=0\n\n_levelToName={\nCRITICAL:'CRITICAL',\nERROR:'ERROR',\nWARNING:'WARNING',\nINFO:'INFO',\nDEBUG:'DEBUG',\nNOTSET:'NOTSET',\n}\n_nameToLevel={\n'CRITICAL':CRITICAL,\n'FATAL':FATAL,\n'ERROR':ERROR,\n'WARN':WARNING,\n'WARNING':WARNING,\n'INFO':INFO,\n'DEBUG':DEBUG,\n'NOTSET':NOTSET,\n}\n\ndef getLevelNamesMapping():\n return _nameToLevel.copy()\n \ndef getLevelName(level):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n result=_levelToName.get(level)\n if result is not None:\n  return result\n result=_nameToLevel.get(level)\n if result is not None:\n  return result\n return \"Level %s\"%level\n \ndef addLevelName(level,levelName):\n ''\n\n\n\n \n with _lock:\n  _levelToName[level]=levelName\n  _nameToLevel[levelName]=level\n  \nif hasattr(sys,\"_getframe\"):\n currentframe=lambda:sys._getframe(1)\nelse:\n def currentframe():\n  ''\n  try:\n   raise Exception\n  except Exception as exc:\n   return exc.__traceback__.tb_frame.f_back\n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n_srcfile=os.path.normcase(addLevelName.__code__.co_filename)\n\n\n\n\n\n\n\n\ndef _is_internal_frame(frame):\n ''\n filename=os.path.normcase(frame.f_code.co_filename)\n return filename ==_srcfile or(\n \"importlib\"in filename and \"_bootstrap\"in filename\n )\n \n \ndef _checkLevel(level):\n if isinstance(level,int):\n  rv=level\n elif str(level)==level:\n  if level not in _nameToLevel:\n   raise ValueError(\"Unknown level: %r\"%level)\n  rv=_nameToLevel[level]\n else:\n  raise TypeError(\"Level not an integer or a valid string: %r\"\n  %(level,))\n return rv\n \n \n \n \n \n \n \n \n \n \n \n \n \n_lock=threading.RLock()\n\ndef _prepareFork():\n ''\n\n\n\n \n \n \n try:\n  _lock.acquire()\n except BaseException:\n  _lock.release()\n  raise\n  \ndef _afterFork():\n ''\n\n\n\n \n _lock.release()\n \n \n \n \nif not hasattr(os,'register_at_fork'):\n def _register_at_fork_reinit_lock(instance):\n  pass\nelse:\n\n\n\n _at_fork_reinit_lock_weakset=weakref.WeakSet()\n \n def _register_at_fork_reinit_lock(instance):\n  with _lock:\n   _at_fork_reinit_lock_weakset.add(instance)\n   \n def _after_at_fork_child_reinit_locks():\n  for handler in _at_fork_reinit_lock_weakset:\n   handler._at_fork_reinit()\n   \n   \n   \n  _lock._at_fork_reinit()\n  \n os.register_at_fork(before=_prepareFork,\n after_in_child=_after_at_fork_child_reinit_locks,\n after_in_parent=_afterFork)\n \n \n \n \n \n \nclass LogRecord(object):\n ''\n\n\n\n\n\n\n\n\n\n \n def __init__(self,name,level,pathname,lineno,\n msg,args,exc_info,func=None,sinfo=None,**kwargs):\n  ''\n\n  \n  ct=time.time_ns()\n  self.name=name\n  self.msg=msg\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if(args and len(args)==1 and isinstance(args[0],collections.abc.Mapping)\n  and args[0]):\n   args=args[0]\n  self.args=args\n  self.levelname=getLevelName(level)\n  self.levelno=level\n  self.pathname=pathname\n  try:\n   self.filename=os.path.basename(pathname)\n   self.module=os.path.splitext(self.filename)[0]\n  except(TypeError,ValueError,AttributeError):\n   self.filename=pathname\n   self.module=\"Unknown module\"\n  self.exc_info=exc_info\n  self.exc_text=None\n  self.stack_info=sinfo\n  self.lineno=lineno\n  self.funcName=func\n  self.created=ct /1e9\n  \n  \n  \n  \n  self.msecs=(ct %1_000_000_000)//1_000_000+0.0\n  \n  self.relativeCreated=(ct -_startTime)/1e6\n  if logThreads:\n   self.thread=threading.get_ident()\n   self.threadName=threading.current_thread().name\n  else:\n   self.thread=None\n   self.threadName=None\n  if not logMultiprocessing:\n   self.processName=None\n  else:\n   self.processName='MainProcess'\n   mp=sys.modules.get('multiprocessing')\n   if mp is not None:\n   \n   \n   \n   \n    try:\n     self.processName=mp.current_process().name\n    except Exception:\n     pass\n  if logProcesses and hasattr(os,'getpid'):\n   self.process=os.getpid()\n  else:\n   self.process=None\n   \n  self.taskName=None\n  if logAsyncioTasks:\n   asyncio=sys.modules.get('asyncio')\n   if asyncio:\n    try:\n     self.taskName=asyncio.current_task().get_name()\n    except Exception:\n     pass\n     \n def __repr__(self):\n  return '<LogRecord: %s, %s, %s, %s, \"%s\">'%(self.name,self.levelno,\n  self.pathname,self.lineno,self.msg)\n  \n def getMessage(self):\n  ''\n\n\n\n\n  \n  msg=str(self.msg)\n  if self.args:\n   msg=msg %self.args\n  return msg\n  \n  \n  \n  \n_logRecordFactory=LogRecord\n\ndef setLogRecordFactory(factory):\n ''\n\n\n\n\n \n global _logRecordFactory\n _logRecordFactory=factory\n \ndef getLogRecordFactory():\n ''\n\n \n \n return _logRecordFactory\n \ndef makeLogRecord(dict):\n ''\n\n\n\n\n \n rv=_logRecordFactory(None,None,\"\",0,\"\",(),None,None)\n rv.__dict__.update(dict)\n return rv\n \n \n \n \n \n_str_formatter=StrFormatter()\ndel StrFormatter\n\n\nclass PercentStyle(object):\n\n default_format='%(message)s'\n asctime_format='%(asctime)s'\n asctime_search='%(asctime)'\n validation_pattern=re.compile(r'%\\(\\w+\\)[#0+ -]*(\\*|\\d+)?(\\.(\\*|\\d+))?[diouxefgcrsa%]',re.I)\n \n def __init__(self,fmt,*,defaults=None):\n  self._fmt=fmt or self.default_format\n  self._defaults=defaults\n  \n def usesTime(self):\n  return self._fmt.find(self.asctime_search)>=0\n  \n def validate(self):\n  ''\n  if not self.validation_pattern.search(self._fmt):\n   raise ValueError(\"Invalid format '%s' for '%s' style\"%(self._fmt,self.default_format[0]))\n   \n def _format(self,record):\n  if defaults :=self._defaults:\n   values=defaults |record.__dict__\n  else:\n   values=record.__dict__\n  return self._fmt %values\n  \n def format(self,record):\n  try:\n   return self._format(record)\n  except KeyError as e:\n   raise ValueError('Formatting field not found in record: %s'%e)\n   \n   \nclass StrFormatStyle(PercentStyle):\n default_format='{message}'\n asctime_format='{asctime}'\n asctime_search='{asctime'\n \n fmt_spec=re.compile(r'^(.?[<>=^])?[+ -]?#?0?(\\d+|{\\w+})?[,_]?(\\.(\\d+|{\\w+}))?[bcdefgnosx%]?$',re.I)\n field_spec=re.compile(r'^(\\d+|\\w+)(\\.\\w+|\\[[^]]+\\])*$')\n \n def _format(self,record):\n  if defaults :=self._defaults:\n   values=defaults |record.__dict__\n  else:\n   values=record.__dict__\n  return self._fmt.format(**values)\n  \n def validate(self):\n  ''\n  fields=set()\n  try:\n   for _,fieldname,spec,conversion in _str_formatter.parse(self._fmt):\n    if fieldname:\n     if not self.field_spec.match(fieldname):\n      raise ValueError('invalid field name/expression: %r'%fieldname)\n     fields.add(fieldname)\n    if conversion and conversion not in 'rsa':\n     raise ValueError('invalid conversion: %r'%conversion)\n    if spec and not self.fmt_spec.match(spec):\n     raise ValueError('bad specifier: %r'%spec)\n  except ValueError as e:\n   raise ValueError('invalid format: %s'%e)\n  if not fields:\n   raise ValueError('invalid format: no fields')\n   \n   \nclass StringTemplateStyle(PercentStyle):\n default_format='${message}'\n asctime_format='${asctime}'\n asctime_search='${asctime}'\n \n def __init__(self,*args,**kwargs):\n  super().__init__(*args,**kwargs)\n  self._tpl=Template(self._fmt)\n  \n def usesTime(self):\n  fmt=self._fmt\n  return fmt.find('$asctime')>=0 or fmt.find(self.asctime_search)>=0\n  \n def validate(self):\n  pattern=Template.pattern\n  fields=set()\n  for m in pattern.finditer(self._fmt):\n   d=m.groupdict()\n   if d['named']:\n    fields.add(d['named'])\n   elif d['braced']:\n    fields.add(d['braced'])\n   elif m.group(0)=='$':\n    raise ValueError('invalid format: bare \\'$\\' not allowed')\n  if not fields:\n   raise ValueError('invalid format: no fields')\n   \n def _format(self,record):\n  if defaults :=self._defaults:\n   values=defaults |record.__dict__\n  else:\n   values=record.__dict__\n  return self._tpl.substitute(**values)\n  \n  \nBASIC_FORMAT=\"%(levelname)s:%(name)s:%(message)s\"\n\n_STYLES={\n'%':(PercentStyle,BASIC_FORMAT),\n'{':(StrFormatStyle,'{levelname}:{name}:{message}'),\n'$':(StringTemplateStyle,'${levelname}:${name}:${message}'),\n}\n\nclass Formatter(object):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n converter=time.localtime\n \n def __init__(self,fmt=None,datefmt=None,style='%',validate=True,*,\n defaults=None):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  if style not in _STYLES:\n   raise ValueError('Style must be one of: %s'%','.join(\n   _STYLES.keys()))\n  self._style=_STYLES[style][0](fmt,defaults=defaults)\n  if validate:\n   self._style.validate()\n   \n  self._fmt=self._style._fmt\n  self.datefmt=datefmt\n  \n default_time_format='%Y-%m-%d %H:%M:%S'\n default_msec_format='%s,%03d'\n \n def formatTime(self,record,datefmt=None):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  ct=self.converter(record.created)\n  if datefmt:\n   s=time.strftime(datefmt,ct)\n  else:\n   s=time.strftime(self.default_time_format,ct)\n   if self.default_msec_format:\n    s=self.default_msec_format %(s,record.msecs)\n  return s\n  \n def formatException(self,ei):\n  ''\n\n\n\n\n  \n  sio=io.StringIO()\n  tb=ei[2]\n  \n  \n  \n  traceback.print_exception(ei[0],ei[1],tb,limit=None,file=sio)\n  s=sio.getvalue()\n  sio.close()\n  if s[-1:]==\"\\n\":\n   s=s[:-1]\n  return s\n  \n def usesTime(self):\n  ''\n\n  \n  return self._style.usesTime()\n  \n def formatMessage(self,record):\n  return self._style.format(record)\n  \n def formatStack(self,stack_info):\n  ''\n\n\n\n\n\n\n\n\n  \n  return stack_info\n  \n def format(self,record):\n  ''\n\n\n\n\n\n\n\n\n\n\n  \n  record.message=record.getMessage()\n  if self.usesTime():\n   record.asctime=self.formatTime(record,self.datefmt)\n  s=self.formatMessage(record)\n  if record.exc_info:\n  \n  \n   if not record.exc_text:\n    record.exc_text=self.formatException(record.exc_info)\n  if record.exc_text:\n   if s[-1:]!=\"\\n\":\n    s=s+\"\\n\"\n   s=s+record.exc_text\n  if record.stack_info:\n   if s[-1:]!=\"\\n\":\n    s=s+\"\\n\"\n   s=s+self.formatStack(record.stack_info)\n  return s\n  \n  \n  \n  \n_defaultFormatter=Formatter()\n\nclass BufferingFormatter(object):\n ''\n\n \n def __init__(self,linefmt=None):\n  ''\n\n\n  \n  if linefmt:\n   self.linefmt=linefmt\n  else:\n   self.linefmt=_defaultFormatter\n   \n def formatHeader(self,records):\n  ''\n\n  \n  return \"\"\n  \n def formatFooter(self,records):\n  ''\n\n  \n  return \"\"\n  \n def format(self,records):\n  ''\n\n  \n  rv=\"\"\n  if len(records)>0:\n   rv=rv+self.formatHeader(records)\n   for record in records:\n    rv=rv+self.linefmt.format(record)\n   rv=rv+self.formatFooter(records)\n  return rv\n  \n  \n  \n  \n  \nclass Filter(object):\n ''\n\n\n\n\n\n\n\n\n \n def __init__(self,name=''):\n  ''\n\n\n\n\n\n  \n  self.name=name\n  self.nlen=len(name)\n  \n def filter(self,record):\n  ''\n\n\n\n\n  \n  if self.nlen ==0:\n   return True\n  elif self.name ==record.name:\n   return True\n  elif record.name.find(self.name,0,self.nlen)!=0:\n   return False\n  return(record.name[self.nlen]==\".\")\n  \nclass Filterer(object):\n ''\n\n\n \n def __init__(self):\n  ''\n\n  \n  self.filters=[]\n  \n def addFilter(self,filter):\n  ''\n\n  \n  if not(filter in self.filters):\n   self.filters.append(filter)\n   \n def removeFilter(self,filter):\n  ''\n\n  \n  if filter in self.filters:\n   self.filters.remove(filter)\n   \n def filter(self,record):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  for f in self.filters:\n   if hasattr(f,'filter'):\n    result=f.filter(record)\n   else:\n    result=f(record)\n   if not result:\n    return False\n   if isinstance(result,LogRecord):\n    record=result\n  return record\n  \n  \n  \n  \n  \n_handlers=weakref.WeakValueDictionary()\n_handlerList=[]\n\ndef _removeHandlerRef(wr):\n ''\n\n \n \n \n \n \n handlers,lock=_handlerList,_lock\n if lock and handlers:\n  with lock:\n   try:\n    handlers.remove(wr)\n   except ValueError:\n    pass\n    \ndef _addHandlerRef(handler):\n ''\n\n \n with _lock:\n  _handlerList.append(weakref.ref(handler,_removeHandlerRef))\n  \n  \ndef getHandlerByName(name):\n ''\n\n\n \n return _handlers.get(name)\n \n \ndef getHandlerNames():\n ''\n\n \n return frozenset(_handlers)\n \n \nclass Handler(Filterer):\n ''\n\n\n\n\n\n\n \n def __init__(self,level=NOTSET):\n  ''\n\n\n  \n  Filterer.__init__(self)\n  self._name=None\n  self.level=_checkLevel(level)\n  self.formatter=None\n  self._closed=False\n  \n  _addHandlerRef(self)\n  self.createLock()\n  \n def get_name(self):\n  return self._name\n  \n def set_name(self,name):\n  with _lock:\n   if self._name in _handlers:\n    del _handlers[self._name]\n   self._name=name\n   if name:\n    _handlers[name]=self\n    \n name=property(get_name,set_name)\n \n def createLock(self):\n  ''\n\n  \n  self.lock=threading.RLock()\n  _register_at_fork_reinit_lock(self)\n  \n def _at_fork_reinit(self):\n  self.lock._at_fork_reinit()\n  \n def acquire(self):\n  ''\n\n  \n  if self.lock:\n   self.lock.acquire()\n   \n def release(self):\n  ''\n\n  \n  if self.lock:\n   self.lock.release()\n   \n def setLevel(self,level):\n  ''\n\n  \n  self.level=_checkLevel(level)\n  \n def format(self,record):\n  ''\n\n\n\n\n  \n  if self.formatter:\n   fmt=self.formatter\n  else:\n   fmt=_defaultFormatter\n  return fmt.format(record)\n  \n def emit(self,record):\n  ''\n\n\n\n\n  \n  raise NotImplementedError('emit must be implemented '\n  'by Handler subclasses')\n  \n def handle(self,record):\n  ''\n\n\n\n\n\n\n\n\n  \n  rv=self.filter(record)\n  if isinstance(rv,LogRecord):\n   record=rv\n  if rv:\n   with self.lock:\n    self.emit(record)\n  return rv\n  \n def setFormatter(self,fmt):\n  ''\n\n  \n  self.formatter=fmt\n  \n def flush(self):\n  ''\n\n\n\n\n  \n  pass\n  \n def close(self):\n  ''\n\n\n\n\n\n\n  \n  \n  with _lock:\n   self._closed=True\n   if self._name and self._name in _handlers:\n    del _handlers[self._name]\n    \n def handleError(self,record):\n  ''\n\n\n\n\n\n\n\n\n\n  \n  if raiseExceptions and sys.stderr:\n   exc=sys.exception()\n   try:\n    sys.stderr.write('--- Logging error ---\\n')\n    traceback.print_exception(exc,limit=None,file=sys.stderr)\n    sys.stderr.write('Call stack:\\n')\n    \n    \n    frame=exc.__traceback__.tb_frame\n    while(frame and os.path.dirname(frame.f_code.co_filename)==\n    __path__[0]):\n     frame=frame.f_back\n    if frame:\n     traceback.print_stack(frame,file=sys.stderr)\n    else:\n    \n     sys.stderr.write('Logged from file %s, line %s\\n'%(\n     record.filename,record.lineno))\n     \n    try:\n     sys.stderr.write('Message: %r\\n'\n     'Arguments: %s\\n'%(record.msg,\n     record.args))\n    except RecursionError:\n     raise\n    except Exception:\n     sys.stderr.write('Unable to print the message and arguments'\n     ' - possible formatting error.\\nUse the'\n     ' traceback above to help find the error.\\n'\n     )\n   except OSError:\n    pass\n   finally:\n    del exc\n    \n def __repr__(self):\n  level=getLevelName(self.level)\n  return '<%s (%s)>'%(self.__class__.__name__,level)\n  \nclass StreamHandler(Handler):\n ''\n\n\n\n \n \n terminator='\\n'\n \n def __init__(self,stream=None):\n  ''\n\n\n\n  \n  Handler.__init__(self)\n  if stream is None:\n   stream=sys.stderr\n  self.stream=stream\n  \n def flush(self):\n  ''\n\n  \n  with self.lock:\n   if self.stream and hasattr(self.stream,\"flush\"):\n    self.stream.flush()\n    \n def emit(self,record):\n  ''\n\n\n\n\n\n\n\n\n  \n  try:\n   msg=self.format(record)\n   stream=self.stream\n   \n   stream.write(msg+self.terminator)\n   self.flush()\n  except RecursionError:\n   raise\n  except Exception:\n   self.handleError(record)\n   \n def setStream(self,stream):\n  ''\n\n\n\n\n\n  \n  if stream is self.stream:\n   result=None\n  else:\n   result=self.stream\n   with self.lock:\n    self.flush()\n    self.stream=stream\n  return result\n  \n def __repr__(self):\n  level=getLevelName(self.level)\n  name=getattr(self.stream,'name','')\n  \n  name=str(name)\n  if name:\n   name +=' '\n  return '<%s %s(%s)>'%(self.__class__.__name__,name,level)\n  \n __class_getitem__=classmethod(GenericAlias)\n \n \nclass FileHandler(StreamHandler):\n ''\n\n \n def __init__(self,filename,mode='a',encoding=None,delay=False,errors=None):\n  ''\n\n  \n  \n  filename=os.fspath(filename)\n  \n  \n  self.baseFilename=os.path.abspath(filename)\n  self.mode=mode\n  self.encoding=encoding\n  if \"b\"not in mode:\n   self.encoding=io.text_encoding(encoding)\n  self.errors=errors\n  self.delay=delay\n  \n  \n  \n  self._builtin_open=open\n  if delay:\n  \n  \n   Handler.__init__(self)\n   self.stream=None\n  else:\n   StreamHandler.__init__(self,self._open())\n   \n def close(self):\n  ''\n\n  \n  with self.lock:\n   try:\n    if self.stream:\n     try:\n      self.flush()\n     finally:\n      stream=self.stream\n      self.stream=None\n      if hasattr(stream,\"close\"):\n       stream.close()\n   finally:\n   \n   \n   \n   \n    StreamHandler.close(self)\n    \n def _open(self):\n  ''\n\n\n  \n  open_func=self._builtin_open\n  return open_func(self.baseFilename,self.mode,\n  encoding=self.encoding,errors=self.errors)\n  \n def emit(self,record):\n  ''\n\n\n\n\n\n\n\n  \n  if self.stream is None:\n   if self.mode !='w'or not self._closed:\n    self.stream=self._open()\n  if self.stream:\n   StreamHandler.emit(self,record)\n   \n def __repr__(self):\n  level=getLevelName(self.level)\n  return '<%s %s (%s)>'%(self.__class__.__name__,self.baseFilename,level)\n  \n  \nclass _StderrHandler(StreamHandler):\n ''\n\n\n\n \n def __init__(self,level=NOTSET):\n  ''\n\n  \n  Handler.__init__(self,level)\n  \n @property\n def stream(self):\n  return sys.stderr\n  \n  \n_defaultLastResort=_StderrHandler(WARNING)\nlastResort=_defaultLastResort\n\n\n\n\n\nclass PlaceHolder(object):\n ''\n\n\n\n \n def __init__(self,alogger):\n  ''\n\n  \n  self.loggerMap={alogger:None}\n  \n def append(self,alogger):\n  ''\n\n  \n  if alogger not in self.loggerMap:\n   self.loggerMap[alogger]=None\n   \n   \n   \n   \n   \ndef setLoggerClass(klass):\n ''\n\n\n\n \n if klass !=Logger:\n  if not issubclass(klass,Logger):\n   raise TypeError(\"logger not derived from logging.Logger: \"\n   +klass.__name__)\n global _loggerClass\n _loggerClass=klass\n \ndef getLoggerClass():\n ''\n\n \n return _loggerClass\n \nclass Manager(object):\n ''\n\n\n \n def __init__(self,rootnode):\n  ''\n\n  \n  self.root=rootnode\n  self.disable=0\n  self.emittedNoHandlerWarning=False\n  self.loggerDict={}\n  self.loggerClass=None\n  self.logRecordFactory=None\n  \n @property\n def disable(self):\n  return self._disable\n  \n @disable.setter\n def disable(self,value):\n  self._disable=_checkLevel(value)\n  \n def getLogger(self,name):\n  ''\n\n\n\n\n\n\n\n\n  \n  rv=None\n  if not isinstance(name,str):\n   raise TypeError('A logger name must be a string')\n  with _lock:\n   if name in self.loggerDict:\n    rv=self.loggerDict[name]\n    if isinstance(rv,PlaceHolder):\n     ph=rv\n     rv=(self.loggerClass or _loggerClass)(name)\n     rv.manager=self\n     self.loggerDict[name]=rv\n     self._fixupChildren(ph,rv)\n     self._fixupParents(rv)\n   else:\n    rv=(self.loggerClass or _loggerClass)(name)\n    rv.manager=self\n    self.loggerDict[name]=rv\n    self._fixupParents(rv)\n  return rv\n  \n def setLoggerClass(self,klass):\n  ''\n\n  \n  if klass !=Logger:\n   if not issubclass(klass,Logger):\n    raise TypeError(\"logger not derived from logging.Logger: \"\n    +klass.__name__)\n  self.loggerClass=klass\n  \n def setLogRecordFactory(self,factory):\n  ''\n\n\n  \n  self.logRecordFactory=factory\n  \n def _fixupParents(self,alogger):\n  ''\n\n\n  \n  name=alogger.name\n  i=name.rfind(\".\")\n  rv=None\n  while(i >0)and not rv:\n   substr=name[:i]\n   if substr not in self.loggerDict:\n    self.loggerDict[substr]=PlaceHolder(alogger)\n   else:\n    obj=self.loggerDict[substr]\n    if isinstance(obj,Logger):\n     rv=obj\n    else:\n     assert isinstance(obj,PlaceHolder)\n     obj.append(alogger)\n   i=name.rfind(\".\",0,i -1)\n  if not rv:\n   rv=self.root\n  alogger.parent=rv\n  \n def _fixupChildren(self,ph,alogger):\n  ''\n\n\n  \n  name=alogger.name\n  namelen=len(name)\n  for c in ph.loggerMap.keys():\n  \n   if c.parent.name[:namelen]!=name:\n    alogger.parent=c.parent\n    c.parent=alogger\n    \n def _clear_cache(self):\n  ''\n\n\n  \n  \n  with _lock:\n   for logger in self.loggerDict.values():\n    if isinstance(logger,Logger):\n     logger._cache.clear()\n   self.root._cache.clear()\n   \n   \n   \n   \n   \nclass Logger(Filterer):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n \n def __init__(self,name,level=NOTSET):\n  ''\n\n  \n  Filterer.__init__(self)\n  self.name=name\n  self.level=_checkLevel(level)\n  self.parent=None\n  self.propagate=True\n  self.handlers=[]\n  self.disabled=False\n  self._cache={}\n  \n def setLevel(self,level):\n  ''\n\n  \n  self.level=_checkLevel(level)\n  self.manager._clear_cache()\n  \n def debug(self,msg,*args,**kwargs):\n  ''\n\n\n\n\n\n\n  \n  if self.isEnabledFor(DEBUG):\n   self._log(DEBUG,msg,args,**kwargs)\n   \n def info(self,msg,*args,**kwargs):\n  ''\n\n\n\n\n\n\n  \n  if self.isEnabledFor(INFO):\n   self._log(INFO,msg,args,**kwargs)\n   \n def warning(self,msg,*args,**kwargs):\n  ''\n\n\n\n\n\n\n  \n  if self.isEnabledFor(WARNING):\n   self._log(WARNING,msg,args,**kwargs)\n   \n def error(self,msg,*args,**kwargs):\n  ''\n\n\n\n\n\n\n  \n  if self.isEnabledFor(ERROR):\n   self._log(ERROR,msg,args,**kwargs)\n   \n def exception(self,msg,*args,exc_info=True,**kwargs):\n  ''\n\n  \n  self.error(msg,*args,exc_info=exc_info,**kwargs)\n  \n def critical(self,msg,*args,**kwargs):\n  ''\n\n\n\n\n\n\n  \n  if self.isEnabledFor(CRITICAL):\n   self._log(CRITICAL,msg,args,**kwargs)\n   \n def fatal(self,msg,*args,**kwargs):\n  ''\n\n  \n  self.critical(msg,*args,**kwargs)\n  \n def log(self,level,msg,*args,**kwargs):\n  ''\n\n\n\n\n\n\n  \n  if not isinstance(level,int):\n   if raiseExceptions:\n    raise TypeError(\"level must be an integer\")\n   else:\n    return\n  if self.isEnabledFor(level):\n   self._log(level,msg,args,**kwargs)\n   \n def findCaller(self,stack_info=False,stacklevel=1):\n  ''\n\n\n  \n  f=currentframe()\n  \n  \n  if f is None:\n   return \"(unknown file)\",0,\"(unknown function)\",None\n  while stacklevel >0:\n   next_f=f.f_back\n   if next_f is None:\n   \n   \n    break\n    \n    \n    \n    \n   f=next_f\n   if not _is_internal_frame(f):\n    stacklevel -=1\n  co=f.f_code\n  sinfo=None\n  if stack_info:\n   with io.StringIO()as sio:\n    sio.write(\"Stack (most recent call last):\\n\")\n    traceback.print_stack(f,file=sio)\n    sinfo=sio.getvalue()\n    if sinfo[-1]=='\\n':\n     sinfo=sinfo[:-1]\n  return co.co_filename,f.f_lineno,co.co_name,sinfo\n  \n def makeRecord(self,name,level,fn,lno,msg,args,exc_info,\n func=None,extra=None,sinfo=None):\n  ''\n\n\n  \n  rv=_logRecordFactory(name,level,fn,lno,msg,args,exc_info,func,\n  sinfo)\n  if extra is not None:\n   for key in extra:\n    if(key in[\"message\",\"asctime\"])or(key in rv.__dict__):\n     raise KeyError(\"Attempt to overwrite %r in LogRecord\"%key)\n    rv.__dict__[key]=extra[key]\n  return rv\n  \n def _log(self,level,msg,args,exc_info=None,extra=None,stack_info=False,\n stacklevel=1):\n  ''\n\n\n  \n  sinfo=None\n  if _srcfile:\n  \n  \n  \n   try:\n    fn,lno,func,sinfo=self.findCaller(stack_info,stacklevel)\n   except ValueError:\n    fn,lno,func=\"(unknown file)\",0,\"(unknown function)\"\n  else:\n   fn,lno,func=\"(unknown file)\",0,\"(unknown function)\"\n  if exc_info:\n   if isinstance(exc_info,BaseException):\n    exc_info=(type(exc_info),exc_info,exc_info.__traceback__)\n   elif not isinstance(exc_info,tuple):\n    exc_info=sys.exc_info()\n  record=self.makeRecord(self.name,level,fn,lno,msg,args,\n  exc_info,func,extra,sinfo)\n  self.handle(record)\n  \n def handle(self,record):\n  ''\n\n\n\n\n  \n  if self.disabled:\n   return\n  maybe_record=self.filter(record)\n  if not maybe_record:\n   return\n  if isinstance(maybe_record,LogRecord):\n   record=maybe_record\n  self.callHandlers(record)\n  \n def addHandler(self,hdlr):\n  ''\n\n  \n  with _lock:\n   if not(hdlr in self.handlers):\n    self.handlers.append(hdlr)\n    \n def removeHandler(self,hdlr):\n  ''\n\n  \n  with _lock:\n   if hdlr in self.handlers:\n    self.handlers.remove(hdlr)\n    \n def hasHandlers(self):\n  ''\n\n\n\n\n\n\n\n  \n  c=self\n  rv=False\n  while c:\n   if c.handlers:\n    rv=True\n    break\n   if not c.propagate:\n    break\n   else:\n    c=c.parent\n  return rv\n  \n def callHandlers(self,record):\n  ''\n\n\n\n\n\n\n\n  \n  c=self\n  found=0\n  while c:\n   for hdlr in c.handlers:\n    found=found+1\n    if record.levelno >=hdlr.level:\n     hdlr.handle(record)\n   if not c.propagate:\n    c=None\n   else:\n    c=c.parent\n  if(found ==0):\n   if lastResort:\n    if record.levelno >=lastResort.level:\n     lastResort.handle(record)\n   elif raiseExceptions and not self.manager.emittedNoHandlerWarning:\n    sys.stderr.write(\"No handlers could be found for logger\"\n    \" \\\"%s\\\"\\n\"%self.name)\n    self.manager.emittedNoHandlerWarning=True\n    \n def getEffectiveLevel(self):\n  ''\n\n\n\n\n  \n  logger=self\n  while logger:\n   if logger.level:\n    return logger.level\n   logger=logger.parent\n  return NOTSET\n  \n def isEnabledFor(self,level):\n  ''\n\n  \n  if self.disabled:\n   return False\n   \n  try:\n   return self._cache[level]\n  except KeyError:\n   with _lock:\n    if self.manager.disable >=level:\n     is_enabled=self._cache[level]=False\n    else:\n     is_enabled=self._cache[level]=(\n     level >=self.getEffectiveLevel()\n     )\n   return is_enabled\n   \n def getChild(self,suffix):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  if self.root is not self:\n   suffix='.'.join((self.name,suffix))\n  return self.manager.getLogger(suffix)\n  \n def getChildren(self):\n \n  def _hierlevel(logger):\n   if logger is logger.manager.root:\n    return 0\n   return 1+logger.name.count('.')\n   \n  d=self.manager.loggerDict\n  with _lock:\n  \n  \n  \n   return set(item for item in d.values()\n   if isinstance(item,Logger)and item.parent is self and\n   _hierlevel(item)==1+_hierlevel(item.parent))\n   \n def __repr__(self):\n  level=getLevelName(self.getEffectiveLevel())\n  return '<%s %s (%s)>'%(self.__class__.__name__,self.name,level)\n  \n def __reduce__(self):\n  if getLogger(self.name)is not self:\n   import pickle\n   raise pickle.PicklingError('logger cannot be pickled')\n  return getLogger,(self.name,)\n  \n  \nclass RootLogger(Logger):\n ''\n\n\n\n \n def __init__(self,level):\n  ''\n\n  \n  Logger.__init__(self,\"root\",level)\n  \n def __reduce__(self):\n  return getLogger,()\n  \n_loggerClass=Logger\n\nclass LoggerAdapter(object):\n ''\n\n\n \n \n def __init__(self,logger,extra=None,merge_extra=False):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  self.logger=logger\n  self.extra=extra\n  self.merge_extra=merge_extra\n  \n def process(self,msg,kwargs):\n  ''\n\n\n\n\n\n\n\n  \n  if self.merge_extra and \"extra\"in kwargs:\n   kwargs[\"extra\"]={**self.extra,**kwargs[\"extra\"]}\n  else:\n   kwargs[\"extra\"]=self.extra\n  return msg,kwargs\n  \n  \n  \n  \n def debug(self,msg,*args,**kwargs):\n  ''\n\n  \n  self.log(DEBUG,msg,*args,**kwargs)\n  \n def info(self,msg,*args,**kwargs):\n  ''\n\n  \n  self.log(INFO,msg,*args,**kwargs)\n  \n def warning(self,msg,*args,**kwargs):\n  ''\n\n  \n  self.log(WARNING,msg,*args,**kwargs)\n  \n def error(self,msg,*args,**kwargs):\n  ''\n\n  \n  self.log(ERROR,msg,*args,**kwargs)\n  \n def exception(self,msg,*args,exc_info=True,**kwargs):\n  ''\n\n  \n  self.log(ERROR,msg,*args,exc_info=exc_info,**kwargs)\n  \n def critical(self,msg,*args,**kwargs):\n  ''\n\n  \n  self.log(CRITICAL,msg,*args,**kwargs)\n  \n def log(self,level,msg,*args,**kwargs):\n  ''\n\n\n  \n  if self.isEnabledFor(level):\n   msg,kwargs=self.process(msg,kwargs)\n   self.logger.log(level,msg,*args,**kwargs)\n   \n def isEnabledFor(self,level):\n  ''\n\n  \n  return self.logger.isEnabledFor(level)\n  \n def setLevel(self,level):\n  ''\n\n  \n  self.logger.setLevel(level)\n  \n def getEffectiveLevel(self):\n  ''\n\n  \n  return self.logger.getEffectiveLevel()\n  \n def hasHandlers(self):\n  ''\n\n  \n  return self.logger.hasHandlers()\n  \n def _log(self,level,msg,args,**kwargs):\n  ''\n\n  \n  return self.logger._log(level,msg,args,**kwargs)\n  \n @property\n def manager(self):\n  return self.logger.manager\n  \n @manager.setter\n def manager(self,value):\n  self.logger.manager=value\n  \n @property\n def name(self):\n  return self.logger.name\n  \n def __repr__(self):\n  logger=self.logger\n  level=getLevelName(logger.getEffectiveLevel())\n  return '<%s %s (%s)>'%(self.__class__.__name__,logger.name,level)\n  \n __class_getitem__=classmethod(GenericAlias)\n \nroot=RootLogger(WARNING)\nLogger.root=root\nLogger.manager=Manager(Logger.root)\n\n\n\n\n\ndef basicConfig(**kwargs):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n with _lock:\n  force=kwargs.pop('force',False)\n  encoding=kwargs.pop('encoding',None)\n  errors=kwargs.pop('errors','backslashreplace')\n  if force:\n   for h in root.handlers[:]:\n    root.removeHandler(h)\n    h.close()\n  if len(root.handlers)==0:\n   handlers=kwargs.pop(\"handlers\",None)\n   if handlers is None:\n    if \"stream\"in kwargs and \"filename\"in kwargs:\n     raise ValueError(\"'stream' and 'filename' should not be \"\n     \"specified together\")\n   else:\n    if \"stream\"in kwargs or \"filename\"in kwargs:\n     raise ValueError(\"'stream' or 'filename' should not be \"\n     \"specified together with 'handlers'\")\n   if handlers is None:\n    filename=kwargs.pop(\"filename\",None)\n    mode=kwargs.pop(\"filemode\",'a')\n    if filename:\n     if 'b'in mode:\n      errors=None\n     else:\n      encoding=io.text_encoding(encoding)\n     h=FileHandler(filename,mode,\n     encoding=encoding,errors=errors)\n    else:\n     stream=kwargs.pop(\"stream\",None)\n     h=StreamHandler(stream)\n    handlers=[h]\n   dfs=kwargs.pop(\"datefmt\",None)\n   style=kwargs.pop(\"style\",'%')\n   if style not in _STYLES:\n    raise ValueError('Style must be one of: %s'%','.join(\n    _STYLES.keys()))\n   fs=kwargs.pop(\"format\",_STYLES[style][1])\n   fmt=Formatter(fs,dfs,style)\n   for h in handlers:\n    if h.formatter is None:\n     h.setFormatter(fmt)\n    root.addHandler(h)\n   level=kwargs.pop(\"level\",None)\n   if level is not None:\n    root.setLevel(level)\n   if kwargs:\n    keys=', '.join(kwargs.keys())\n    raise ValueError('Unrecognised argument(s): %s'%keys)\n    \n    \n    \n    \n    \n    \ndef getLogger(name=None):\n ''\n\n\n\n \n if not name or isinstance(name,str)and name ==root.name:\n  return root\n return Logger.manager.getLogger(name)\n \ndef critical(msg,*args,**kwargs):\n ''\n\n\n\n \n if len(root.handlers)==0:\n  basicConfig()\n root.critical(msg,*args,**kwargs)\n \ndef fatal(msg,*args,**kwargs):\n ''\n\n \n critical(msg,*args,**kwargs)\n \ndef error(msg,*args,**kwargs):\n ''\n\n\n\n \n if len(root.handlers)==0:\n  basicConfig()\n root.error(msg,*args,**kwargs)\n \ndef exception(msg,*args,exc_info=True,**kwargs):\n ''\n\n\n\n \n error(msg,*args,exc_info=exc_info,**kwargs)\n \ndef warning(msg,*args,**kwargs):\n ''\n\n\n\n \n if len(root.handlers)==0:\n  basicConfig()\n root.warning(msg,*args,**kwargs)\n \ndef info(msg,*args,**kwargs):\n ''\n\n\n\n \n if len(root.handlers)==0:\n  basicConfig()\n root.info(msg,*args,**kwargs)\n \ndef debug(msg,*args,**kwargs):\n ''\n\n\n\n \n if len(root.handlers)==0:\n  basicConfig()\n root.debug(msg,*args,**kwargs)\n \ndef log(level,msg,*args,**kwargs):\n ''\n\n\n\n \n if len(root.handlers)==0:\n  basicConfig()\n root.log(level,msg,*args,**kwargs)\n \ndef disable(level=CRITICAL):\n ''\n\n \n root.manager.disable=level\n root.manager._clear_cache()\n \ndef shutdown(handlerList=_handlerList):\n ''\n\n\n\n\n \n for wr in reversed(handlerList[:]):\n \n \n  try:\n   h=wr()\n   if h:\n    try:\n     h.acquire()\n     \n     \n     \n     if getattr(h,'flushOnClose',True):\n      h.flush()\n     h.close()\n    except(OSError,ValueError):\n    \n    \n    \n    \n     pass\n    finally:\n     h.release()\n  except:\n   if raiseExceptions:\n    raise\n    \n    \n    \nimport atexit\natexit.register(shutdown)\n\n\n\nclass NullHandler(Handler):\n ''\n\n\n\n\n\n\n\n \n def handle(self,record):\n  ''\n  \n def emit(self,record):\n  ''\n  \n def createLock(self):\n  self.lock=None\n  \n def _at_fork_reinit(self):\n  pass\n  \n  \n  \n_warnings_showwarning=None\n\ndef _showwarning(message,category,filename,lineno,file=None,line=None):\n ''\n\n\n\n\n\n \n if file is not None:\n  if _warnings_showwarning is not None:\n   _warnings_showwarning(message,category,filename,lineno,file,line)\n else:\n  s=warnings.formatwarning(message,category,filename,lineno,line)\n  logger=getLogger(\"py.warnings\")\n  if not logger.handlers:\n   logger.addHandler(NullHandler())\n   \n   \n  logger.warning(str(s))\n  \ndef captureWarnings(capture):\n ''\n\n\n\n \n global _warnings_showwarning\n if capture:\n  if _warnings_showwarning is None:\n   _warnings_showwarning=warnings.showwarning\n   warnings.showwarning=_showwarning\n else:\n  if _warnings_showwarning is not None:\n   warnings.showwarning=_warnings_showwarning\n   _warnings_showwarning=None\n", ["atexit", "collections.abc", "io", "os", "pickle", "re", "string", "sys", "threading", "time", "traceback", "types", "warnings", "weakref"], 1], "multiprocessing.util": [".py", "\n\n\n\n\n\n\n\n\nimport sys\nimport functools\nimport os\nimport itertools\nimport weakref\nimport atexit\nimport threading\n\nfrom subprocess import _args_from_interpreter_flags\n\nfrom multiprocessing.process import current_process,active_children\n\n__all__=[\n'sub_debug','debug','info','sub_warning','get_logger',\n'log_to_stderr','get_temp_dir','register_after_fork',\n'is_exiting','Finalize','ForkAwareThreadLock','ForkAwareLocal',\n'SUBDEBUG','SUBWARNING',\n]\n\n\n\n\n\nNOTSET=0\nSUBDEBUG=5\nDEBUG=10\nINFO=20\nSUBWARNING=25\n\nLOGGER_NAME='multiprocessing'\nDEFAULT_LOGGING_FORMAT='[%(levelname)s/%(processName)s] %(message)s'\n\n_logger=None\n_log_to_stderr=False\n\ndef sub_debug(msg,*args):\n if _logger:\n  _logger.log(SUBDEBUG,msg,*args)\n  \ndef debug(msg,*args):\n if _logger:\n  _logger.log(DEBUG,msg,*args)\n  \ndef info(msg,*args):\n if _logger:\n  _logger.log(INFO,msg,*args)\n  \ndef sub_warning(msg,*args):\n if _logger:\n  _logger.log(SUBWARNING,msg,*args)\n  \ndef get_logger():\n ''\n\n \n global _logger\n import logging\n \n logging._acquireLock()\n try:\n  if not _logger:\n  \n   _logger=logging.getLogger(LOGGER_NAME)\n   _logger.propagate=0\n   logging.addLevelName(SUBDEBUG,'SUBDEBUG')\n   logging.addLevelName(SUBWARNING,'SUBWARNING')\n   \n   \n   if hasattr(atexit,'unregister'):\n    atexit.unregister(_exit_function)\n    atexit.register(_exit_function)\n   else:\n    atexit._exithandlers.remove((_exit_function,(),{}))\n    atexit._exithandlers.append((_exit_function,(),{}))\n    \n finally:\n  logging._releaseLock()\n  \n return _logger\n \ndef log_to_stderr(level=None):\n ''\n\n \n global _log_to_stderr\n import logging\n \n logger=get_logger()\n formatter=logging.Formatter(DEFAULT_LOGGING_FORMAT)\n handler=logging.StreamHandler()\n handler.setFormatter(formatter)\n logger.addHandler(handler)\n \n if level:\n  logger.setLevel(level)\n _log_to_stderr=True\n return _logger\n \n \n \n \n \ndef get_temp_dir():\n\n if current_process()._tempdir is None:\n  import shutil,tempfile\n  tempdir=tempfile.mkdtemp(prefix='pymp-')\n  info('created temp directory %s',tempdir)\n  Finalize(None,shutil.rmtree,args=[tempdir],exitpriority=-100)\n  current_process()._tempdir=tempdir\n return current_process()._tempdir\n \n \n \n \n \n_afterfork_registry=weakref.WeakValueDictionary()\n_afterfork_counter=itertools.count()\n\ndef _run_after_forkers():\n items=list(_afterfork_registry.items())\n items.sort()\n for(index,ident,func),obj in items:\n  try:\n   func(obj)\n  except Exception as e:\n   info('after forker raised exception %s',e)\n   \ndef register_after_fork(obj,func):\n _afterfork_registry[(next(_afterfork_counter),id(obj),func)]=obj\n \n \n \n \n \n_finalizer_registry={}\n_finalizer_counter=itertools.count()\n\n\nclass Finalize(object):\n ''\n\n \n def __init__(self,obj,callback,args=(),kwargs=None,exitpriority=None):\n  assert exitpriority is None or type(exitpriority)is int\n  \n  if obj is not None:\n   self._weakref=weakref.ref(obj,self)\n  else:\n   assert exitpriority is not None\n   \n  self._callback=callback\n  self._args=args\n  self._kwargs=kwargs or{}\n  self._key=(exitpriority,next(_finalizer_counter))\n  self._pid=os.getpid()\n  \n  _finalizer_registry[self._key]=self\n  \n def __call__(self,wr=None,\n \n \n _finalizer_registry=_finalizer_registry,\n sub_debug=sub_debug,getpid=os.getpid):\n  ''\n\n  \n  try:\n   del _finalizer_registry[self._key]\n  except KeyError:\n   sub_debug('finalizer no longer registered')\n  else:\n   if self._pid !=getpid():\n    sub_debug('finalizer ignored because different process')\n    res=None\n   else:\n    sub_debug('finalizer calling %s with args %s and kwargs %s',\n    self._callback,self._args,self._kwargs)\n    res=self._callback(*self._args,**self._kwargs)\n   self._weakref=self._callback=self._args=\\\n   self._kwargs=self._key=None\n   return res\n   \n def cancel(self):\n  ''\n\n  \n  try:\n   del _finalizer_registry[self._key]\n  except KeyError:\n   pass\n  else:\n   self._weakref=self._callback=self._args=\\\n   self._kwargs=self._key=None\n   \n def still_active(self):\n  ''\n\n  \n  return self._key in _finalizer_registry\n  \n def __repr__(self):\n  try:\n   obj=self._weakref()\n  except(AttributeError,TypeError):\n   obj=None\n   \n  if obj is None:\n   return '<Finalize object, dead>'\n   \n  x='<Finalize object, callback=%s'%\\\n  getattr(self._callback,'__name__',self._callback)\n  if self._args:\n   x +=', args='+str(self._args)\n  if self._kwargs:\n   x +=', kwargs='+str(self._kwargs)\n  if self._key[0]is not None:\n   x +=', exitprority='+str(self._key[0])\n  return x+'>'\n  \n  \ndef _run_finalizers(minpriority=None):\n ''\n\n\n\n\n \n if _finalizer_registry is None:\n \n \n \n  return\n  \n if minpriority is None:\n  f=lambda p:p[0][0]is not None\n else:\n  f=lambda p:p[0][0]is not None and p[0][0]>=minpriority\n  \n items=[x for x in list(_finalizer_registry.items())if f(x)]\n items.sort(reverse=True)\n \n for key,finalizer in items:\n  sub_debug('calling %s',finalizer)\n  try:\n   finalizer()\n  except Exception:\n   import traceback\n   traceback.print_exc()\n   \n if minpriority is None:\n  _finalizer_registry.clear()\n  \n  \n  \n  \n  \ndef is_exiting():\n ''\n\n \n return _exiting or _exiting is None\n \n_exiting=False\n\ndef _exit_function(info=info,debug=debug,_run_finalizers=_run_finalizers,\nactive_children=active_children,\ncurrent_process=current_process):\n\n\n\n\n global _exiting\n \n if not _exiting:\n  _exiting=True\n  \n  info('process shutting down')\n  debug('running all \"atexit\" finalizers with priority >= 0')\n  _run_finalizers(0)\n  \n  if current_process()is not None:\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n   for p in active_children():\n    if p._daemonic:\n     info('calling terminate() for daemon %s',p.name)\n     p._popen.terminate()\n     \n   for p in active_children():\n    info('calling join() for process %s',p.name)\n    p.join()\n    \n  debug('running the remaining \"atexit\" finalizers')\n  _run_finalizers()\n  \natexit.register(_exit_function)\n\n\n\n\n\nclass ForkAwareThreadLock(object):\n def __init__(self):\n  self._reset()\n  register_after_fork(self,ForkAwareThreadLock._reset)\n  \n def _reset(self):\n  self._lock=threading.Lock()\n  self.acquire=self._lock.acquire\n  self.release=self._lock.release\n  \nclass ForkAwareLocal(threading.local):\n def __init__(self):\n  register_after_fork(self,lambda obj:obj.__dict__.clear())\n def __reduce__(self):\n  return type(self),()\n", ["atexit", "functools", "itertools", "logging", "multiprocessing.process", "os", "shutil", "subprocess", "sys", "tempfile", "threading", "traceback", "weakref"]], "multiprocessing": [".py", "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n__version__='0.70a1'\n\n__all__=[\n'Process','current_process','active_children','freeze_support',\n'Manager','Pipe','cpu_count','log_to_stderr','get_logger',\n'allow_connection_pickling','BufferTooShort','TimeoutError',\n'Lock','RLock','Semaphore','BoundedSemaphore','Condition',\n'Event','Barrier','Queue','SimpleQueue','JoinableQueue','Pool',\n'Value','Array','RawValue','RawArray','SUBDEBUG','SUBWARNING',\n]\n\n__author__='R. Oudkerk (r.m.oudkerk@gmail.com)'\n\n\n\n\n\nimport os\nimport sys\n\nfrom multiprocessing.process import Process,current_process,active_children\nfrom multiprocessing.util import SUBDEBUG,SUBWARNING\n\n\n\n\n\nclass ProcessError(Exception):\n pass\n \nclass BufferTooShort(ProcessError):\n pass\n \nclass TimeoutError(ProcessError):\n pass\n \nclass AuthenticationError(ProcessError):\n pass\n \nimport _multiprocessing\n\n\n\n\n\ndef Manager():\n ''\n\n\n\n\n \n from multiprocessing.managers import SyncManager\n m=SyncManager()\n m.start()\n return m\n \n \n \n \n \n \n \n \n \ndef cpu_count():\n ''\n\n \n if sys.platform =='win32':\n  try:\n   num=int(os.environ['NUMBER_OF_PROCESSORS'])\n  except(ValueError,KeyError):\n   num=0\n elif 'bsd'in sys.platform or sys.platform =='darwin':\n  comm='/sbin/sysctl -n hw.ncpu'\n  if sys.platform =='darwin':\n   comm='/usr'+comm\n  try:\n   with os.popen(comm)as p:\n    num=int(p.read())\n  except ValueError:\n   num=0\n else:\n  try:\n   num=os.sysconf('SC_NPROCESSORS_ONLN')\n  except(ValueError,OSError,AttributeError):\n   num=0\n   \n if num >=1:\n  return num\n else:\n  raise NotImplementedError('cannot determine number of cpus')\n  \ndef freeze_support():\n ''\n\n\n \n if sys.platform =='win32'and getattr(sys,'frozen',False):\n  from multiprocessing.forking import freeze_support\n  freeze_support()\n  \ndef get_logger():\n ''\n\n \n from multiprocessing.util import get_logger\n return get_logger()\n \ndef log_to_stderr(level=None):\n ''\n\n \n from multiprocessing.util import log_to_stderr\n return log_to_stderr(level)\n \n \n \n \n \n \n \n \n \n \n \n \n \n \ndef Lock():\n ''\n\n \n from multiprocessing.synchronize import Lock\n return Lock()\n \ndef RLock():\n ''\n\n \n from multiprocessing.synchronize import RLock\n return RLock()\n \ndef Condition(lock=None):\n ''\n\n \n from multiprocessing.synchronize import Condition\n return Condition(lock)\n \ndef Semaphore(value=1):\n ''\n\n \n from multiprocessing.synchronize import Semaphore\n return Semaphore(value)\n \ndef BoundedSemaphore(value=1):\n ''\n\n \n from multiprocessing.synchronize import BoundedSemaphore\n return BoundedSemaphore(value)\n \ndef Event():\n ''\n\n \n from multiprocessing.synchronize import Event\n return Event()\n \ndef Barrier(parties,action=None,timeout=None):\n ''\n\n \n from multiprocessing.synchronize import Barrier\n return Barrier(parties,action,timeout)\n \ndef Queue(maxsize=0):\n ''\n\n \n from multiprocessing.queues import Queue\n return Queue(maxsize)\n \ndef JoinableQueue(maxsize=0):\n ''\n\n \n from multiprocessing.queues import JoinableQueue\n return JoinableQueue(maxsize)\n \ndef SimpleQueue():\n ''\n\n \n from multiprocessing.queues import SimpleQueue\n return SimpleQueue()\n \ndef Pool(processes=None,initializer=None,initargs=(),maxtasksperchild=None):\n ''\n\n \n from multiprocessing.pool import Pool\n return Pool(processes,initializer,initargs,maxtasksperchild)\n \ndef RawValue(typecode_or_type,*args):\n ''\n\n \n from multiprocessing.sharedctypes import RawValue\n return RawValue(typecode_or_type,*args)\n \ndef RawArray(typecode_or_type,size_or_initializer):\n ''\n\n \n from multiprocessing.sharedctypes import RawArray\n return RawArray(typecode_or_type,size_or_initializer)\n \ndef Value(typecode_or_type,*args,lock=True):\n ''\n\n \n from multiprocessing.sharedctypes import Value\n return Value(typecode_or_type,*args,lock=lock)\n \ndef Array(typecode_or_type,size_or_initializer,*,lock=True):\n ''\n\n \n from multiprocessing.sharedctypes import Array\n return Array(typecode_or_type,size_or_initializer,lock=lock)\n \n \n \n \n \nif sys.platform =='win32':\n\n def set_executable(executable):\n  ''\n\n\n\n  \n  from multiprocessing.forking import set_executable\n  set_executable(executable)\n  \n __all__ +=['set_executable']\n", ["_multiprocessing", "multiprocessing.forking", "multiprocessing.managers", "multiprocessing.pool", "multiprocessing.process", "multiprocessing.queues", "multiprocessing.sharedctypes", "multiprocessing.synchronize", "multiprocessing.util", "os", "sys"], 1], "multiprocessing.dummy": [".py", "\n\n\n\n\n\n\n\n\n__all__=[\n'Process','current_process','active_children','freeze_support',\n'Lock','RLock','Semaphore','BoundedSemaphore','Condition',\n'Event','Barrier','Queue','Manager','Pipe','Pool','JoinableQueue'\n]\n\n\n\n\n\nimport threading\nimport sys\nimport weakref\nimport array\n\nfrom.connection import Pipe\nfrom threading import Lock,RLock,Semaphore,BoundedSemaphore\nfrom threading import Event,Condition,Barrier\nfrom queue import Queue\n\n\n\n\n\nclass DummyProcess(threading.Thread):\n\n def __init__(self,group=None,target=None,name=None,args=(),kwargs={}):\n  threading.Thread.__init__(self,group,target,name,args,kwargs)\n  self._pid=None\n  self._children=weakref.WeakKeyDictionary()\n  self._start_called=False\n  self._parent=current_process()\n  \n def start(self):\n  if self._parent is not current_process():\n   raise RuntimeError(\n   \"Parent is {0!r} but current_process is {1!r}\".format(\n   self._parent,current_process()))\n  self._start_called=True\n  if hasattr(self._parent,'_children'):\n   self._parent._children[self]=None\n  threading.Thread.start(self)\n  \n @property\n def exitcode(self):\n  if self._start_called and not self.is_alive():\n   return 0\n  else:\n   return None\n   \n   \n   \n   \n   \nProcess=DummyProcess\ncurrent_process=threading.current_thread\ncurrent_process()._children=weakref.WeakKeyDictionary()\n\ndef active_children():\n children=current_process()._children\n for p in list(children):\n  if not p.is_alive():\n   children.pop(p,None)\n return list(children)\n \ndef freeze_support():\n pass\n \n \n \n \n \nclass Namespace(object):\n def __init__(self,/,**kwds):\n  self.__dict__.update(kwds)\n def __repr__(self):\n  items=list(self.__dict__.items())\n  temp=[]\n  for name,value in items:\n   if not name.startswith('_'):\n    temp.append('%s=%r'%(name,value))\n  temp.sort()\n  return '%s(%s)'%(self.__class__.__name__,', '.join(temp))\n  \ndict=dict\nlist=list\n\ndef Array(typecode,sequence,lock=True):\n return array.array(typecode,sequence)\n \nclass Value(object):\n def __init__(self,typecode,value,lock=True):\n  self._typecode=typecode\n  self._value=value\n  \n @property\n def value(self):\n  return self._value\n  \n @value.setter\n def value(self,value):\n  self._value=value\n  \n def __repr__(self):\n  return '<%s(%r, %r)>'%(type(self).__name__,self._typecode,self._value)\n  \ndef Manager():\n return sys.modules[__name__]\n \ndef shutdown():\n pass\n \ndef Pool(processes=None,initializer=None,initargs=()):\n from..pool import ThreadPool\n return ThreadPool(processes,initializer,initargs)\n \nJoinableQueue=Queue\n", ["array", "multiprocessing.dummy.connection", "multiprocessing.pool", "queue", "sys", "threading", "weakref"], 1], "unittest.suite": [".py", "''\n\nimport sys\n\nfrom. import case\nfrom. import util\n\n__unittest=True\n\n\ndef _call_if_exists(parent,attr):\n func=getattr(parent,attr,lambda:None)\n func()\n \n \nclass BaseTestSuite(object):\n ''\n \n _cleanup=True\n \n def __init__(self,tests=()):\n  self._tests=[]\n  self._removed_tests=0\n  self.addTests(tests)\n  \n def __repr__(self):\n  return \"<%s tests=%s>\"%(util.strclass(self.__class__),list(self))\n  \n def __eq__(self,other):\n  if not isinstance(other,self.__class__):\n   return NotImplemented\n  return list(self)==list(other)\n  \n def __iter__(self):\n  return iter(self._tests)\n  \n def countTestCases(self):\n  cases=self._removed_tests\n  for test in self:\n   if test:\n    cases +=test.countTestCases()\n  return cases\n  \n def addTest(self,test):\n \n  if not callable(test):\n   raise TypeError(\"{} is not callable\".format(repr(test)))\n  if isinstance(test,type)and issubclass(test,\n  (case.TestCase,TestSuite)):\n   raise TypeError(\"TestCases and TestSuites must be instantiated \"\n   \"before passing them to addTest()\")\n  self._tests.append(test)\n  \n def addTests(self,tests):\n  if isinstance(tests,str):\n   raise TypeError(\"tests must be an iterable of tests, not a string\")\n  for test in tests:\n   self.addTest(test)\n   \n def run(self,result):\n  for index,test in enumerate(self):\n   if result.shouldStop:\n    break\n   test(result)\n   if self._cleanup:\n    self._removeTestAtIndex(index)\n  return result\n  \n def _removeTestAtIndex(self,index):\n  ''\n  try:\n   test=self._tests[index]\n  except TypeError:\n  \n   pass\n  else:\n  \n  \n   if hasattr(test,'countTestCases'):\n    self._removed_tests +=test.countTestCases()\n   self._tests[index]=None\n   \n def __call__(self,*args,**kwds):\n  return self.run(*args,**kwds)\n  \n def debug(self):\n  ''\n  for test in self:\n   test.debug()\n   \n   \nclass TestSuite(BaseTestSuite):\n ''\n\n\n\n\n\n\n \n \n def run(self,result,debug=False):\n  topLevel=False\n  if getattr(result,'_testRunEntered',False)is False:\n   result._testRunEntered=topLevel=True\n   \n  for index,test in enumerate(self):\n   if result.shouldStop:\n    break\n    \n   if _isnotsuite(test):\n    self._tearDownPreviousClass(test,result)\n    self._handleModuleFixture(test,result)\n    self._handleClassSetUp(test,result)\n    result._previousTestClass=test.__class__\n    \n    if(getattr(test.__class__,'_classSetupFailed',False)or\n    getattr(result,'_moduleSetUpFailed',False)):\n     continue\n     \n   if not debug:\n    test(result)\n   else:\n    test.debug()\n    \n   if self._cleanup:\n    self._removeTestAtIndex(index)\n    \n  if topLevel:\n   self._tearDownPreviousClass(None,result)\n   self._handleModuleTearDown(result)\n   result._testRunEntered=False\n  return result\n  \n def debug(self):\n  ''\n  debug=_DebugResult()\n  self.run(debug,True)\n  \n  \n  \n def _handleClassSetUp(self,test,result):\n  previousClass=getattr(result,'_previousTestClass',None)\n  currentClass=test.__class__\n  if currentClass ==previousClass:\n   return\n  if result._moduleSetUpFailed:\n   return\n  if getattr(currentClass,\"__unittest_skip__\",False):\n   return\n   \n  failed=False\n  try:\n   currentClass._classSetupFailed=False\n  except TypeError:\n  \n  \n   pass\n   \n  setUpClass=getattr(currentClass,'setUpClass',None)\n  doClassCleanups=getattr(currentClass,'doClassCleanups',None)\n  if setUpClass is not None:\n   _call_if_exists(result,'_setupStdout')\n   try:\n    try:\n     setUpClass()\n    except Exception as e:\n     if isinstance(result,_DebugResult):\n      raise\n     failed=True\n     try:\n      currentClass._classSetupFailed=True\n     except TypeError:\n      pass\n     className=util.strclass(currentClass)\n     self._createClassOrModuleLevelException(result,e,\n     'setUpClass',\n     className)\n    if failed and doClassCleanups is not None:\n     doClassCleanups()\n     for exc_info in currentClass.tearDown_exceptions:\n      self._createClassOrModuleLevelException(\n      result,exc_info[1],'setUpClass',className,\n      info=exc_info)\n   finally:\n    _call_if_exists(result,'_restoreStdout')\n    \n def _get_previous_module(self,result):\n  previousModule=None\n  previousClass=getattr(result,'_previousTestClass',None)\n  if previousClass is not None:\n   previousModule=previousClass.__module__\n  return previousModule\n  \n  \n def _handleModuleFixture(self,test,result):\n  previousModule=self._get_previous_module(result)\n  currentModule=test.__class__.__module__\n  if currentModule ==previousModule:\n   return\n   \n  self._handleModuleTearDown(result)\n  \n  \n  result._moduleSetUpFailed=False\n  try:\n   module=sys.modules[currentModule]\n  except KeyError:\n   return\n  setUpModule=getattr(module,'setUpModule',None)\n  if setUpModule is not None:\n   _call_if_exists(result,'_setupStdout')\n   try:\n    try:\n     setUpModule()\n    except Exception as e:\n     if isinstance(result,_DebugResult):\n      raise\n     result._moduleSetUpFailed=True\n     self._createClassOrModuleLevelException(result,e,\n     'setUpModule',\n     currentModule)\n    if result._moduleSetUpFailed:\n     try:\n      case.doModuleCleanups()\n     except Exception as e:\n      self._createClassOrModuleLevelException(result,e,\n      'setUpModule',\n      currentModule)\n   finally:\n    _call_if_exists(result,'_restoreStdout')\n    \n def _createClassOrModuleLevelException(self,result,exc,method_name,\n parent,info=None):\n  errorName=f'{method_name} ({parent})'\n  self._addClassOrModuleLevelException(result,exc,errorName,info)\n  \n def _addClassOrModuleLevelException(self,result,exception,errorName,\n info=None):\n  error=_ErrorHolder(errorName)\n  addSkip=getattr(result,'addSkip',None)\n  if addSkip is not None and isinstance(exception,case.SkipTest):\n   addSkip(error,str(exception))\n  else:\n   if not info:\n    result.addError(error,sys.exc_info())\n   else:\n    result.addError(error,info)\n    \n def _handleModuleTearDown(self,result):\n  previousModule=self._get_previous_module(result)\n  if previousModule is None:\n   return\n  if result._moduleSetUpFailed:\n   return\n   \n  try:\n   module=sys.modules[previousModule]\n  except KeyError:\n   return\n   \n  _call_if_exists(result,'_setupStdout')\n  try:\n   tearDownModule=getattr(module,'tearDownModule',None)\n   if tearDownModule is not None:\n    try:\n     tearDownModule()\n    except Exception as e:\n     if isinstance(result,_DebugResult):\n      raise\n     self._createClassOrModuleLevelException(result,e,\n     'tearDownModule',\n     previousModule)\n   try:\n    case.doModuleCleanups()\n   except Exception as e:\n    if isinstance(result,_DebugResult):\n     raise\n    self._createClassOrModuleLevelException(result,e,\n    'tearDownModule',\n    previousModule)\n  finally:\n   _call_if_exists(result,'_restoreStdout')\n   \n def _tearDownPreviousClass(self,test,result):\n  previousClass=getattr(result,'_previousTestClass',None)\n  currentClass=test.__class__\n  if currentClass ==previousClass or previousClass is None:\n   return\n  if getattr(previousClass,'_classSetupFailed',False):\n   return\n  if getattr(result,'_moduleSetUpFailed',False):\n   return\n  if getattr(previousClass,\"__unittest_skip__\",False):\n   return\n   \n  tearDownClass=getattr(previousClass,'tearDownClass',None)\n  doClassCleanups=getattr(previousClass,'doClassCleanups',None)\n  if tearDownClass is None and doClassCleanups is None:\n   return\n   \n  _call_if_exists(result,'_setupStdout')\n  try:\n   if tearDownClass is not None:\n    try:\n     tearDownClass()\n    except Exception as e:\n     if isinstance(result,_DebugResult):\n      raise\n     className=util.strclass(previousClass)\n     self._createClassOrModuleLevelException(result,e,\n     'tearDownClass',\n     className)\n   if doClassCleanups is not None:\n    doClassCleanups()\n    for exc_info in previousClass.tearDown_exceptions:\n     if isinstance(result,_DebugResult):\n      raise exc_info[1]\n     className=util.strclass(previousClass)\n     self._createClassOrModuleLevelException(result,exc_info[1],\n     'tearDownClass',\n     className,\n     info=exc_info)\n  finally:\n   _call_if_exists(result,'_restoreStdout')\n   \n   \nclass _ErrorHolder(object):\n ''\n\n\n\n \n \n \n \n \n failureException=None\n \n def __init__(self,description):\n  self.description=description\n  \n def id(self):\n  return self.description\n  \n def shortDescription(self):\n  return None\n  \n def __repr__(self):\n  return \"<ErrorHolder description=%r>\"%(self.description,)\n  \n def __str__(self):\n  return self.id()\n  \n def run(self,result):\n \n \n  pass\n  \n def __call__(self,result):\n  return self.run(result)\n  \n def countTestCases(self):\n  return 0\n  \ndef _isnotsuite(test):\n ''\n try:\n  iter(test)\n except TypeError:\n  return True\n return False\n \n \nclass _DebugResult(object):\n ''\n _previousTestClass=None\n _moduleSetUpFailed=False\n shouldStop=False\n", ["sys", "unittest", "unittest.case", "unittest.util"]], "unittest.util": [".py", "''\n\nfrom collections import namedtuple,Counter\nfrom os.path import commonprefix\n\n__unittest=True\n\n_MAX_LENGTH=80\n_PLACEHOLDER_LEN=12\n_MIN_BEGIN_LEN=5\n_MIN_END_LEN=5\n_MIN_COMMON_LEN=5\n_MIN_DIFF_LEN=_MAX_LENGTH -\\\n(_MIN_BEGIN_LEN+_PLACEHOLDER_LEN+_MIN_COMMON_LEN+\n_PLACEHOLDER_LEN+_MIN_END_LEN)\nassert _MIN_DIFF_LEN >=0\n\ndef _shorten(s,prefixlen,suffixlen):\n skip=len(s)-prefixlen -suffixlen\n if skip >_PLACEHOLDER_LEN:\n  s='%s[%d chars]%s'%(s[:prefixlen],skip,s[len(s)-suffixlen:])\n return s\n \ndef _common_shorten_repr(*args):\n args=tuple(map(safe_repr,args))\n maxlen=max(map(len,args))\n if maxlen <=_MAX_LENGTH:\n  return args\n  \n prefix=commonprefix(args)\n prefixlen=len(prefix)\n \n common_len=_MAX_LENGTH -\\\n (maxlen -prefixlen+_MIN_BEGIN_LEN+_PLACEHOLDER_LEN)\n if common_len >_MIN_COMMON_LEN:\n  assert _MIN_BEGIN_LEN+_PLACEHOLDER_LEN+_MIN_COMMON_LEN+\\\n  (maxlen -prefixlen)<_MAX_LENGTH\n  prefix=_shorten(prefix,_MIN_BEGIN_LEN,common_len)\n  return tuple(prefix+s[prefixlen:]for s in args)\n  \n prefix=_shorten(prefix,_MIN_BEGIN_LEN,_MIN_COMMON_LEN)\n return tuple(prefix+_shorten(s[prefixlen:],_MIN_DIFF_LEN,_MIN_END_LEN)\n for s in args)\n \ndef safe_repr(obj,short=False):\n try:\n  result=repr(obj)\n except Exception:\n  result=object.__repr__(obj)\n if not short or len(result)<_MAX_LENGTH:\n  return result\n return result[:_MAX_LENGTH]+' [truncated]...'\n \ndef strclass(cls):\n return \"%s.%s\"%(cls.__module__,cls.__qualname__)\n \ndef sorted_list_difference(expected,actual):\n ''\n\n\n\n\n\n \n i=j=0\n missing=[]\n unexpected=[]\n while True:\n  try:\n   e=expected[i]\n   a=actual[j]\n   if e <a:\n    missing.append(e)\n    i +=1\n    while expected[i]==e:\n     i +=1\n   elif e >a:\n    unexpected.append(a)\n    j +=1\n    while actual[j]==a:\n     j +=1\n   else:\n    i +=1\n    try:\n     while expected[i]==e:\n      i +=1\n    finally:\n     j +=1\n     while actual[j]==a:\n      j +=1\n  except IndexError:\n   missing.extend(expected[i:])\n   unexpected.extend(actual[j:])\n   break\n return missing,unexpected\n \n \ndef unorderable_list_difference(expected,actual):\n ''\n\n\n\n \n missing=[]\n while expected:\n  item=expected.pop()\n  try:\n   actual.remove(item)\n  except ValueError:\n   missing.append(item)\n   \n   \n return missing,actual\n \ndef three_way_cmp(x,y):\n ''\n return(x >y)-(x <y)\n \n_Mismatch=namedtuple('Mismatch','actual expected value')\n\ndef _count_diff_all_purpose(actual,expected):\n ''\n \n s,t=list(actual),list(expected)\n m,n=len(s),len(t)\n NULL=object()\n result=[]\n for i,elem in enumerate(s):\n  if elem is NULL:\n   continue\n  cnt_s=cnt_t=0\n  for j in range(i,m):\n   if s[j]==elem:\n    cnt_s +=1\n    s[j]=NULL\n  for j,other_elem in enumerate(t):\n   if other_elem ==elem:\n    cnt_t +=1\n    t[j]=NULL\n  if cnt_s !=cnt_t:\n   diff=_Mismatch(cnt_s,cnt_t,elem)\n   result.append(diff)\n   \n for i,elem in enumerate(t):\n  if elem is NULL:\n   continue\n  cnt_t=0\n  for j in range(i,n):\n   if t[j]==elem:\n    cnt_t +=1\n    t[j]=NULL\n  diff=_Mismatch(0,cnt_t,elem)\n  result.append(diff)\n return result\n \ndef _count_diff_hashable(actual,expected):\n ''\n \n s,t=Counter(actual),Counter(expected)\n result=[]\n for elem,cnt_s in s.items():\n  cnt_t=t.get(elem,0)\n  if cnt_s !=cnt_t:\n   diff=_Mismatch(cnt_s,cnt_t,elem)\n   result.append(diff)\n for elem,cnt_t in t.items():\n  if elem not in s:\n   diff=_Mismatch(0,cnt_t,elem)\n   result.append(diff)\n return result\n", ["collections", "os.path"]], "unittest": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n__all__=['TestResult','TestCase','IsolatedAsyncioTestCase','TestSuite',\n'TextTestRunner','TestLoader','FunctionTestCase','main',\n'defaultTestLoader','SkipTest','skip','skipIf','skipUnless',\n'expectedFailure','TextTestResult','installHandler',\n'registerResult','removeResult','removeHandler',\n'addModuleCleanup','doModuleCleanups','enterModuleContext']\n\n__unittest=True\n\nfrom.result import TestResult\nfrom.case import(addModuleCleanup,TestCase,FunctionTestCase,SkipTest,skip,\nskipIf,skipUnless,expectedFailure,doModuleCleanups,\nenterModuleContext)\nfrom.suite import BaseTestSuite,TestSuite\nfrom.loader import TestLoader,defaultTestLoader\nfrom.main import TestProgram,main\nfrom.runner import TextTestRunner,TextTestResult\nfrom.signals import installHandler,registerResult,removeResult,removeHandler\n\n\n\n\n\n\n\ndef __dir__():\n return globals().keys()|{'IsolatedAsyncioTestCase'}\n \ndef __getattr__(name):\n if name =='IsolatedAsyncioTestCase':\n  global IsolatedAsyncioTestCase\n  from.async_case import IsolatedAsyncioTestCase\n  return IsolatedAsyncioTestCase\n raise AttributeError(f\"module {__name__ !r} has no attribute {name !r}\")\n", ["unittest.async_case", "unittest.case", "unittest.loader", "unittest.main", "unittest.result", "unittest.runner", "unittest.signals", "unittest.suite"], 1], "unittest.__main__": [".py", "''\n\nimport sys\nif sys.argv[0].endswith(\"__main__.py\"):\n import os.path\n \n \n \n \n executable=os.path.basename(sys.executable)\n sys.argv[0]=executable+\" -m unittest\"\n del os\n \n__unittest=True\n\nfrom.main import main\n\nmain(module=None)\n", ["os.path", "sys", "unittest.main"]], "urllib.error": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\nimport io\nimport urllib.response\n\n__all__=['URLError','HTTPError','ContentTooShortError']\n\n\nclass URLError(OSError):\n\n\n\n\n\n def __init__(self,reason,filename=None):\n  self.args=reason,\n  self.reason=reason\n  if filename is not None:\n   self.filename=filename\n   \n def __str__(self):\n  return '<urlopen error %s>'%self.reason\n  \n  \nclass HTTPError(URLError,urllib.response.addinfourl):\n ''\n __super_init=urllib.response.addinfourl.__init__\n \n def __init__(self,url,code,msg,hdrs,fp):\n  self.code=code\n  self.msg=msg\n  self.hdrs=hdrs\n  self.fp=fp\n  self.filename=url\n  if fp is None:\n   fp=io.BytesIO()\n  self.__super_init(fp,hdrs,url,code)\n  \n def __str__(self):\n  return 'HTTP Error %s: %s'%(self.code,self.msg)\n  \n def __repr__(self):\n  return '<HTTPError %s: %r>'%(self.code,self.msg)\n  \n  \n  \n @property\n def reason(self):\n  return self.msg\n  \n @property\n def headers(self):\n  return self.hdrs\n  \n @headers.setter\n def headers(self,headers):\n  self.hdrs=headers\n  \n  \nclass ContentTooShortError(URLError):\n ''\n def __init__(self,message,content):\n  URLError.__init__(self,message)\n  self.content=content\n", ["io", "urllib.response"]], "urllib.parse": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfrom collections import namedtuple\nimport functools\nimport math\nimport re\nimport types\nimport warnings\nimport ipaddress\n\n__all__=[\"urlparse\",\"urlunparse\",\"urljoin\",\"urldefrag\",\n\"urlsplit\",\"urlunsplit\",\"urlencode\",\"parse_qs\",\n\"parse_qsl\",\"quote\",\"quote_plus\",\"quote_from_bytes\",\n\"unquote\",\"unquote_plus\",\"unquote_to_bytes\",\n\"DefragResult\",\"ParseResult\",\"SplitResult\",\n\"DefragResultBytes\",\"ParseResultBytes\",\"SplitResultBytes\"]\n\n\n\n\n\nuses_relative=['','ftp','http','gopher','nntp','imap',\n'wais','file','https','shttp','mms',\n'prospero','rtsp','rtsps','rtspu','sftp',\n'svn','svn+ssh','ws','wss']\n\nuses_netloc=['','ftp','http','gopher','nntp','telnet',\n'imap','wais','file','mms','https','shttp',\n'snews','prospero','rtsp','rtsps','rtspu','rsync',\n'svn','svn+ssh','sftp','nfs','git','git+ssh',\n'ws','wss','itms-services']\n\nuses_params=['','ftp','hdl','prospero','http','imap',\n'https','shttp','rtsp','rtsps','rtspu','sip',\n'sips','mms','sftp','tel']\n\n\n\n\nnon_hierarchical=['gopher','hdl','mailto','news',\n'telnet','wais','imap','snews','sip','sips']\n\nuses_query=['','http','wais','imap','https','shttp','mms',\n'gopher','rtsp','rtsps','rtspu','sip','sips']\n\nuses_fragment=['','ftp','hdl','http','gopher','news',\n'nntp','wais','https','shttp','snews',\n'file','prospero']\n\n\nscheme_chars=('abcdefghijklmnopqrstuvwxyz'\n'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n'0123456789'\n'+-.')\n\n\n\n_WHATWG_C0_CONTROL_OR_SPACE='\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\t\\n\\x0b\\x0c\\r\\x0e\\x0f\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f '\n\n\n_UNSAFE_URL_BYTES_TO_REMOVE=['\\t','\\r','\\n']\n\ndef clear_cache():\n ''\n urlsplit.cache_clear()\n _byte_quoter_factory.cache_clear()\n \n \n \n \n \n \n \n_implicit_encoding='ascii'\n_implicit_errors='strict'\n\ndef _noop(obj):\n return obj\n \ndef _encode_result(obj,encoding=_implicit_encoding,\nerrors=_implicit_errors):\n return obj.encode(encoding,errors)\n \ndef _decode_args(args,encoding=_implicit_encoding,\nerrors=_implicit_errors):\n return tuple(x.decode(encoding,errors)if x else ''for x in args)\n \ndef _coerce_args(*args):\n\n\n\n\n\n str_input=isinstance(args[0],str)\n for arg in args[1:]:\n \n \n  if arg and isinstance(arg,str)!=str_input:\n   raise TypeError(\"Cannot mix str and non-str arguments\")\n if str_input:\n  return args+(_noop,)\n return _decode_args(args)+(_encode_result,)\n \n \nclass _ResultMixinStr(object):\n ''\n __slots__=()\n \n def encode(self,encoding='ascii',errors='strict'):\n  return self._encoded_counterpart(*(x.encode(encoding,errors)for x in self))\n  \n  \nclass _ResultMixinBytes(object):\n ''\n __slots__=()\n \n def decode(self,encoding='ascii',errors='strict'):\n  return self._decoded_counterpart(*(x.decode(encoding,errors)for x in self))\n  \n  \nclass _NetlocResultMixinBase(object):\n ''\n __slots__=()\n \n @property\n def username(self):\n  return self._userinfo[0]\n  \n @property\n def password(self):\n  return self._userinfo[1]\n  \n @property\n def hostname(self):\n  hostname=self._hostinfo[0]\n  if not hostname:\n   return None\n   \n   \n  separator='%'if isinstance(hostname,str)else b'%'\n  hostname,percent,zone=hostname.partition(separator)\n  return hostname.lower()+percent+zone\n  \n @property\n def port(self):\n  port=self._hostinfo[1]\n  if port is not None:\n   if port.isdigit()and port.isascii():\n    port=int(port)\n   else:\n    raise ValueError(f\"Port could not be cast to integer value as {port !r}\")\n   if not(0 <=port <=65535):\n    raise ValueError(\"Port out of range 0-65535\")\n  return port\n  \n __class_getitem__=classmethod(types.GenericAlias)\n \n \nclass _NetlocResultMixinStr(_NetlocResultMixinBase,_ResultMixinStr):\n __slots__=()\n \n @property\n def _userinfo(self):\n  netloc=self.netloc\n  userinfo,have_info,hostinfo=netloc.rpartition('@')\n  if have_info:\n   username,have_password,password=userinfo.partition(':')\n   if not have_password:\n    password=None\n  else:\n   username=password=None\n  return username,password\n  \n @property\n def _hostinfo(self):\n  netloc=self.netloc\n  _,_,hostinfo=netloc.rpartition('@')\n  _,have_open_br,bracketed=hostinfo.partition('[')\n  if have_open_br:\n   hostname,_,port=bracketed.partition(']')\n   _,_,port=port.partition(':')\n  else:\n   hostname,_,port=hostinfo.partition(':')\n  if not port:\n   port=None\n  return hostname,port\n  \n  \nclass _NetlocResultMixinBytes(_NetlocResultMixinBase,_ResultMixinBytes):\n __slots__=()\n \n @property\n def _userinfo(self):\n  netloc=self.netloc\n  userinfo,have_info,hostinfo=netloc.rpartition(b'@')\n  if have_info:\n   username,have_password,password=userinfo.partition(b':')\n   if not have_password:\n    password=None\n  else:\n   username=password=None\n  return username,password\n  \n @property\n def _hostinfo(self):\n  netloc=self.netloc\n  _,_,hostinfo=netloc.rpartition(b'@')\n  _,have_open_br,bracketed=hostinfo.partition(b'[')\n  if have_open_br:\n   hostname,_,port=bracketed.partition(b']')\n   _,_,port=port.partition(b':')\n  else:\n   hostname,_,port=hostinfo.partition(b':')\n  if not port:\n   port=None\n  return hostname,port\n  \n  \n_DefragResultBase=namedtuple('DefragResult','url fragment')\n_SplitResultBase=namedtuple(\n'SplitResult','scheme netloc path query fragment')\n_ParseResultBase=namedtuple(\n'ParseResult','scheme netloc path params query fragment')\n\n_DefragResultBase.__doc__=\"\"\"\nDefragResult(url, fragment)\n\nA 2-tuple that contains the url without fragment identifier and the fragment\nidentifier as a separate argument.\n\"\"\"\n\n_DefragResultBase.url.__doc__=\"\"\"The URL with no fragment identifier.\"\"\"\n\n_DefragResultBase.fragment.__doc__=\"\"\"\nFragment identifier separated from URL, that allows indirect identification of a\nsecondary resource by reference to a primary resource and additional identifying\ninformation.\n\"\"\"\n\n_SplitResultBase.__doc__=\"\"\"\nSplitResult(scheme, netloc, path, query, fragment)\n\nA 5-tuple that contains the different components of a URL. Similar to\nParseResult, but does not split params.\n\"\"\"\n\n_SplitResultBase.scheme.__doc__=\"\"\"Specifies URL scheme for the request.\"\"\"\n\n_SplitResultBase.netloc.__doc__=\"\"\"\nNetwork location where the request is made to.\n\"\"\"\n\n_SplitResultBase.path.__doc__=\"\"\"\nThe hierarchical path, such as the path to a file to download.\n\"\"\"\n\n_SplitResultBase.query.__doc__=\"\"\"\nThe query component, that contains non-hierarchical data, that along with data\nin path component, identifies a resource in the scope of URI's scheme and\nnetwork location.\n\"\"\"\n\n_SplitResultBase.fragment.__doc__=\"\"\"\nFragment identifier, that allows indirect identification of a secondary resource\nby reference to a primary resource and additional identifying information.\n\"\"\"\n\n_ParseResultBase.__doc__=\"\"\"\nParseResult(scheme, netloc, path, params, query, fragment)\n\nA 6-tuple that contains components of a parsed URL.\n\"\"\"\n\n_ParseResultBase.scheme.__doc__=_SplitResultBase.scheme.__doc__\n_ParseResultBase.netloc.__doc__=_SplitResultBase.netloc.__doc__\n_ParseResultBase.path.__doc__=_SplitResultBase.path.__doc__\n_ParseResultBase.params.__doc__=\"\"\"\nParameters for last path element used to dereference the URI in order to provide\naccess to perform some operation on the resource.\n\"\"\"\n\n_ParseResultBase.query.__doc__=_SplitResultBase.query.__doc__\n_ParseResultBase.fragment.__doc__=_SplitResultBase.fragment.__doc__\n\n\n\n\n\nResultBase=_NetlocResultMixinStr\n\n\nclass DefragResult(_DefragResultBase,_ResultMixinStr):\n __slots__=()\n def geturl(self):\n  if self.fragment:\n   return self.url+'#'+self.fragment\n  else:\n   return self.url\n   \nclass SplitResult(_SplitResultBase,_NetlocResultMixinStr):\n __slots__=()\n def geturl(self):\n  return urlunsplit(self)\n  \nclass ParseResult(_ParseResultBase,_NetlocResultMixinStr):\n __slots__=()\n def geturl(self):\n  return urlunparse(self)\n  \n  \nclass DefragResultBytes(_DefragResultBase,_ResultMixinBytes):\n __slots__=()\n def geturl(self):\n  if self.fragment:\n   return self.url+b'#'+self.fragment\n  else:\n   return self.url\n   \nclass SplitResultBytes(_SplitResultBase,_NetlocResultMixinBytes):\n __slots__=()\n def geturl(self):\n  return urlunsplit(self)\n  \nclass ParseResultBytes(_ParseResultBase,_NetlocResultMixinBytes):\n __slots__=()\n def geturl(self):\n  return urlunparse(self)\n  \n  \ndef _fix_result_transcoding():\n _result_pairs=(\n (DefragResult,DefragResultBytes),\n (SplitResult,SplitResultBytes),\n (ParseResult,ParseResultBytes),\n )\n for _decoded,_encoded in _result_pairs:\n  _decoded._encoded_counterpart=_encoded\n  _encoded._decoded_counterpart=_decoded\n  \n_fix_result_transcoding()\ndel _fix_result_transcoding\n\ndef urlparse(url,scheme='',allow_fragments=True):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n url,scheme,_coerce_result=_coerce_args(url,scheme)\n splitresult=urlsplit(url,scheme,allow_fragments)\n scheme,netloc,url,query,fragment=splitresult\n if scheme in uses_params and ';'in url:\n  url,params=_splitparams(url)\n else:\n  params=''\n result=ParseResult(scheme,netloc,url,params,query,fragment)\n return _coerce_result(result)\n \ndef _splitparams(url):\n if '/'in url:\n  i=url.find(';',url.rfind('/'))\n  if i <0:\n   return url,''\n else:\n  i=url.find(';')\n return url[:i],url[i+1:]\n \ndef _splitnetloc(url,start=0):\n delim=len(url)\n for c in '/?#':\n  wdelim=url.find(c,start)\n  if wdelim >=0:\n   delim=min(delim,wdelim)\n return url[start:delim],url[delim:]\n \ndef _checknetloc(netloc):\n if not netloc or netloc.isascii():\n  return\n  \n  \n import unicodedata\n n=netloc.replace('@','')\n n=n.replace(':','')\n n=n.replace('#','')\n n=n.replace('?','')\n netloc2=unicodedata.normalize('NFKC',n)\n if n ==netloc2:\n  return\n for c in '/?#@:':\n  if c in netloc2:\n   raise ValueError(\"netloc '\"+netloc+\"' contains invalid \"+\n   \"characters under NFKC normalization\")\n   \n   \n   \ndef _check_bracketed_host(hostname):\n if hostname.startswith('v'):\n  if not re.match(r\"\\Av[a-fA-F0-9]+\\..+\\Z\",hostname):\n   raise ValueError(f\"IPvFuture address is invalid\")\n else:\n  ip=ipaddress.ip_address(hostname)\n  if isinstance(ip,ipaddress.IPv4Address):\n   raise ValueError(f\"An IPv4 address cannot be in brackets\")\n   \n   \n   \n@functools.lru_cache(typed=True)\ndef urlsplit(url,scheme='',allow_fragments=True):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n url,scheme,_coerce_result=_coerce_args(url,scheme)\n \n \n url=url.lstrip(_WHATWG_C0_CONTROL_OR_SPACE)\n scheme=scheme.strip(_WHATWG_C0_CONTROL_OR_SPACE)\n \n for b in _UNSAFE_URL_BYTES_TO_REMOVE:\n  url=url.replace(b,\"\")\n  scheme=scheme.replace(b,\"\")\n  \n allow_fragments=bool(allow_fragments)\n netloc=query=fragment=''\n i=url.find(':')\n if i >0 and url[0].isascii()and url[0].isalpha():\n  for c in url[:i]:\n   if c not in scheme_chars:\n    break\n  else:\n   scheme,url=url[:i].lower(),url[i+1:]\n if url[:2]=='//':\n  netloc,url=_splitnetloc(url,2)\n  if(('['in netloc and ']'not in netloc)or\n  (']'in netloc and '['not in netloc)):\n   raise ValueError(\"Invalid IPv6 URL\")\n  if '['in netloc and ']'in netloc:\n   bracketed_host=netloc.partition('[')[2].partition(']')[0]\n   _check_bracketed_host(bracketed_host)\n if allow_fragments and '#'in url:\n  url,fragment=url.split('#',1)\n if '?'in url:\n  url,query=url.split('?',1)\n _checknetloc(netloc)\n v=SplitResult(scheme,netloc,url,query,fragment)\n return _coerce_result(v)\n \ndef urlunparse(components):\n ''\n\n\n \n scheme,netloc,url,params,query,fragment,_coerce_result=(\n _coerce_args(*components))\n if params:\n  url=\"%s;%s\"%(url,params)\n return _coerce_result(urlunsplit((scheme,netloc,url,query,fragment)))\n \ndef urlunsplit(components):\n ''\n\n\n\n \n scheme,netloc,url,query,fragment,_coerce_result=(\n _coerce_args(*components))\n if netloc or(scheme and scheme in uses_netloc and url[:2]!='//'):\n  if url and url[:1]!='/':url='/'+url\n  url='//'+(netloc or '')+url\n if scheme:\n  url=scheme+':'+url\n if query:\n  url=url+'?'+query\n if fragment:\n  url=url+'#'+fragment\n return _coerce_result(url)\n \ndef urljoin(base,url,allow_fragments=True):\n ''\n \n if not base:\n  return url\n if not url:\n  return base\n  \n base,url,_coerce_result=_coerce_args(base,url)\n bscheme,bnetloc,bpath,bparams,bquery,bfragment=\\\n urlparse(base,'',allow_fragments)\n scheme,netloc,path,params,query,fragment=\\\n urlparse(url,bscheme,allow_fragments)\n \n if scheme !=bscheme or scheme not in uses_relative:\n  return _coerce_result(url)\n if scheme in uses_netloc:\n  if netloc:\n   return _coerce_result(urlunparse((scheme,netloc,path,\n   params,query,fragment)))\n  netloc=bnetloc\n  \n if not path and not params:\n  path=bpath\n  params=bparams\n  if not query:\n   query=bquery\n  return _coerce_result(urlunparse((scheme,netloc,path,\n  params,query,fragment)))\n  \n base_parts=bpath.split('/')\n if base_parts[-1]!='':\n \n \n  del base_parts[-1]\n  \n  \n if path[:1]=='/':\n  segments=path.split('/')\n else:\n  segments=base_parts+path.split('/')\n  \n  \n  segments[1:-1]=filter(None,segments[1:-1])\n  \n resolved_path=[]\n \n for seg in segments:\n  if seg =='..':\n   try:\n    resolved_path.pop()\n   except IndexError:\n   \n   \n    pass\n  elif seg =='.':\n   continue\n  else:\n   resolved_path.append(seg)\n   \n if segments[-1]in('.','..'):\n \n \n  resolved_path.append('')\n  \n return _coerce_result(urlunparse((scheme,netloc,'/'.join(\n resolved_path)or '/',params,query,fragment)))\n \n \ndef urldefrag(url):\n ''\n\n\n\n\n \n url,_coerce_result=_coerce_args(url)\n if '#'in url:\n  s,n,p,a,q,frag=urlparse(url)\n  defrag=urlunparse((s,n,p,a,q,''))\n else:\n  frag=''\n  defrag=url\n return _coerce_result(DefragResult(defrag,frag))\n \n_hexdig='0123456789ABCDEFabcdef'\n_hextobyte=None\n\ndef unquote_to_bytes(string):\n ''\n return bytes(_unquote_impl(string))\n \ndef _unquote_impl(string:bytes |bytearray |str)->bytes |bytearray:\n\n\n if not string:\n \n  string.split\n  return b''\n if isinstance(string,str):\n  string=string.encode('utf-8')\n bits=string.split(b'%')\n if len(bits)==1:\n  return string\n res=bytearray(bits[0])\n append=res.extend\n \n \n global _hextobyte\n if _hextobyte is None:\n  _hextobyte={(a+b).encode():bytes.fromhex(a+b)\n  for a in _hexdig for b in _hexdig}\n for item in bits[1:]:\n  try:\n   append(_hextobyte[item[:2]])\n   append(item[2:])\n  except KeyError:\n   append(b'%')\n   append(item)\n return res\n \n_asciire=re.compile('([\\x00-\\x7f]+)')\n\ndef _generate_unquoted_parts(string,encoding,errors):\n previous_match_end=0\n for ascii_match in _asciire.finditer(string):\n  start,end=ascii_match.span()\n  yield string[previous_match_end:start]\n  \n  yield _unquote_impl(ascii_match[1]).decode(encoding,errors)\n  previous_match_end=end\n yield string[previous_match_end:]\n \ndef unquote(string,encoding='utf-8',errors='replace'):\n ''\n\n\n\n\n\n\n\n \n if isinstance(string,bytes):\n  return _unquote_impl(string).decode(encoding,errors)\n if '%'not in string:\n \n  string.split\n  return string\n if encoding is None:\n  encoding='utf-8'\n if errors is None:\n  errors='replace'\n return ''.join(_generate_unquoted_parts(string,encoding,errors))\n \n \ndef parse_qs(qs,keep_blank_values=False,strict_parsing=False,\nencoding='utf-8',errors='replace',max_num_fields=None,separator='&'):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n parsed_result={}\n pairs=parse_qsl(qs,keep_blank_values,strict_parsing,\n encoding=encoding,errors=errors,\n max_num_fields=max_num_fields,separator=separator)\n for name,value in pairs:\n  if name in parsed_result:\n   parsed_result[name].append(value)\n  else:\n   parsed_result[name]=[value]\n return parsed_result\n \n \ndef parse_qsl(qs,keep_blank_values=False,strict_parsing=False,\nencoding='utf-8',errors='replace',max_num_fields=None,separator='&'):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n if not separator or not isinstance(separator,(str,bytes)):\n  raise ValueError(\"Separator must be of type string or bytes.\")\n if isinstance(qs,str):\n  if not isinstance(separator,str):\n   separator=str(separator,'ascii')\n  eq='='\n  def _unquote(s):\n   return unquote_plus(s,encoding=encoding,errors=errors)\n else:\n  if not qs:\n   return[]\n   \n   \n  qs=bytes(memoryview(qs))\n  if isinstance(separator,str):\n   separator=bytes(separator,'ascii')\n  eq=b'='\n  def _unquote(s):\n   return unquote_to_bytes(s.replace(b'+',b' '))\n   \n if not qs:\n  return[]\n  \n  \n  \n  \n if max_num_fields is not None:\n  num_fields=1+qs.count(separator)\n  if max_num_fields <num_fields:\n   raise ValueError('Max number of fields exceeded')\n   \n r=[]\n for name_value in qs.split(separator):\n  if name_value or strict_parsing:\n   name,has_eq,value=name_value.partition(eq)\n   if not has_eq and strict_parsing:\n    raise ValueError(\"bad query field: %r\"%(name_value,))\n   if value or keep_blank_values:\n    name=_unquote(name)\n    value=_unquote(value)\n    r.append((name,value))\n return r\n \ndef unquote_plus(string,encoding='utf-8',errors='replace'):\n ''\n\n\n\n \n string=string.replace('+',' ')\n return unquote(string,encoding,errors)\n \n_ALWAYS_SAFE=frozenset(b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\nb'abcdefghijklmnopqrstuvwxyz'\nb'0123456789'\nb'_.-~')\n_ALWAYS_SAFE_BYTES=bytes(_ALWAYS_SAFE)\n\ndef __getattr__(name):\n if name =='Quoter':\n  warnings.warn('Deprecated in 3.11. '\n  'urllib.parse.Quoter will be removed in Python 3.14. '\n  'It was not intended to be a public API.',\n  DeprecationWarning,stacklevel=2)\n  return _Quoter\n raise AttributeError(f'module {__name__ !r} has no attribute {name !r}')\n \nclass _Quoter(dict):\n ''\n\n\n\n \n \n \n def __init__(self,safe):\n  ''\n  self.safe=_ALWAYS_SAFE.union(safe)\n  \n def __repr__(self):\n  return f\"<Quoter {dict(self)!r}>\"\n  \n def __missing__(self,b):\n \n  res=chr(b)if b in self.safe else '%{:02X}'.format(b)\n  self[b]=res\n  return res\n  \ndef quote(string,safe='/',encoding=None,errors=None):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n if isinstance(string,str):\n  if not string:\n   return string\n  if encoding is None:\n   encoding='utf-8'\n  if errors is None:\n   errors='strict'\n  string=string.encode(encoding,errors)\n else:\n  if encoding is not None:\n   raise TypeError(\"quote() doesn't support 'encoding' for bytes\")\n  if errors is not None:\n   raise TypeError(\"quote() doesn't support 'errors' for bytes\")\n return quote_from_bytes(string,safe)\n \ndef quote_plus(string,safe='',encoding=None,errors=None):\n ''\n\n\n \n \n \n if((isinstance(string,str)and ' 'not in string)or\n (isinstance(string,bytes)and b' 'not in string)):\n  return quote(string,safe,encoding,errors)\n if isinstance(safe,str):\n  space=' '\n else:\n  space=b' '\n string=quote(string,safe+space,encoding,errors)\n return string.replace(' ','+')\n \n \n@functools.lru_cache\ndef _byte_quoter_factory(safe):\n return _Quoter(safe).__getitem__\n \ndef quote_from_bytes(bs,safe='/'):\n ''\n\n\n \n if not isinstance(bs,(bytes,bytearray)):\n  raise TypeError(\"quote_from_bytes() expected bytes\")\n if not bs:\n  return ''\n if isinstance(safe,str):\n \n  safe=safe.encode('ascii','ignore')\n else:\n \n  safe=bytes([c for c in safe if c <128])\n if not bs.rstrip(_ALWAYS_SAFE_BYTES+safe):\n  return bs.decode()\n quoter=_byte_quoter_factory(safe)\n if(bs_len :=len(bs))<200_000:\n  return ''.join(map(quoter,bs))\n else:\n \n  chunk_size=math.isqrt(bs_len)\n  chunks=[''.join(map(quoter,bs[i:i+chunk_size]))\n  for i in range(0,bs_len,chunk_size)]\n  return ''.join(chunks)\n  \ndef urlencode(query,doseq=False,safe='',encoding=None,errors=None,\nquote_via=quote_plus):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n if hasattr(query,\"items\"):\n  query=query.items()\n else:\n \n \n  try:\n  \n  \n   if len(query)and not isinstance(query[0],tuple):\n    raise TypeError\n    \n    \n    \n    \n  except TypeError as err:\n   raise TypeError(\"not a valid non-string sequence \"\n   \"or mapping object\")from err\n   \n l=[]\n if not doseq:\n  for k,v in query:\n   if isinstance(k,bytes):\n    k=quote_via(k,safe)\n   else:\n    k=quote_via(str(k),safe,encoding,errors)\n    \n   if isinstance(v,bytes):\n    v=quote_via(v,safe)\n   else:\n    v=quote_via(str(v),safe,encoding,errors)\n   l.append(k+'='+v)\n else:\n  for k,v in query:\n   if isinstance(k,bytes):\n    k=quote_via(k,safe)\n   else:\n    k=quote_via(str(k),safe,encoding,errors)\n    \n   if isinstance(v,bytes):\n    v=quote_via(v,safe)\n    l.append(k+'='+v)\n   elif isinstance(v,str):\n    v=quote_via(v,safe,encoding,errors)\n    l.append(k+'='+v)\n   else:\n    try:\n    \n     x=len(v)\n    except TypeError:\n    \n     v=quote_via(str(v),safe,encoding,errors)\n     l.append(k+'='+v)\n    else:\n    \n     for elt in v:\n      if isinstance(elt,bytes):\n       elt=quote_via(elt,safe)\n      else:\n       elt=quote_via(str(elt),safe,encoding,errors)\n      l.append(k+'='+elt)\n return '&'.join(l)\n \n \ndef to_bytes(url):\n warnings.warn(\"urllib.parse.to_bytes() is deprecated as of 3.8\",\n DeprecationWarning,stacklevel=2)\n return _to_bytes(url)\n \n \ndef _to_bytes(url):\n ''\n \n \n \n if isinstance(url,str):\n  try:\n   url=url.encode(\"ASCII\").decode()\n  except UnicodeError:\n   raise UnicodeError(\"URL \"+repr(url)+\n   \" contains non-ASCII characters\")\n return url\n \n \ndef unwrap(url):\n ''\n\n\n \n url=str(url).strip()\n if url[:1]=='<'and url[-1:]=='>':\n  url=url[1:-1].strip()\n if url[:4]=='URL:':\n  url=url[4:].strip()\n return url\n \n \ndef splittype(url):\n warnings.warn(\"urllib.parse.splittype() is deprecated as of 3.8, \"\n \"use urllib.parse.urlparse() instead\",\n DeprecationWarning,stacklevel=2)\n return _splittype(url)\n \n \n_typeprog=None\ndef _splittype(url):\n ''\n global _typeprog\n if _typeprog is None:\n  _typeprog=re.compile('([^/:]+):(.*)',re.DOTALL)\n  \n match=_typeprog.match(url)\n if match:\n  scheme,data=match.groups()\n  return scheme.lower(),data\n return None,url\n \n \ndef splithost(url):\n warnings.warn(\"urllib.parse.splithost() is deprecated as of 3.8, \"\n \"use urllib.parse.urlparse() instead\",\n DeprecationWarning,stacklevel=2)\n return _splithost(url)\n \n \n_hostprog=None\ndef _splithost(url):\n ''\n global _hostprog\n if _hostprog is None:\n  _hostprog=re.compile('//([^/#?]*)(.*)',re.DOTALL)\n  \n match=_hostprog.match(url)\n if match:\n  host_port,path=match.groups()\n  if path and path[0]!='/':\n   path='/'+path\n  return host_port,path\n return None,url\n \n \ndef splituser(host):\n warnings.warn(\"urllib.parse.splituser() is deprecated as of 3.8, \"\n \"use urllib.parse.urlparse() instead\",\n DeprecationWarning,stacklevel=2)\n return _splituser(host)\n \n \ndef _splituser(host):\n ''\n user,delim,host=host.rpartition('@')\n return(user if delim else None),host\n \n \ndef splitpasswd(user):\n warnings.warn(\"urllib.parse.splitpasswd() is deprecated as of 3.8, \"\n \"use urllib.parse.urlparse() instead\",\n DeprecationWarning,stacklevel=2)\n return _splitpasswd(user)\n \n \ndef _splitpasswd(user):\n ''\n user,delim,passwd=user.partition(':')\n return user,(passwd if delim else None)\n \n \ndef splitport(host):\n warnings.warn(\"urllib.parse.splitport() is deprecated as of 3.8, \"\n \"use urllib.parse.urlparse() instead\",\n DeprecationWarning,stacklevel=2)\n return _splitport(host)\n \n \n \n_portprog=None\ndef _splitport(host):\n ''\n global _portprog\n if _portprog is None:\n  _portprog=re.compile('(.*):([0-9]*)',re.DOTALL)\n  \n match=_portprog.fullmatch(host)\n if match:\n  host,port=match.groups()\n  if port:\n   return host,port\n return host,None\n \n \ndef splitnport(host,defport=-1):\n warnings.warn(\"urllib.parse.splitnport() is deprecated as of 3.8, \"\n \"use urllib.parse.urlparse() instead\",\n DeprecationWarning,stacklevel=2)\n return _splitnport(host,defport)\n \n \ndef _splitnport(host,defport=-1):\n ''\n\n\n \n host,delim,port=host.rpartition(':')\n if not delim:\n  host=port\n elif port:\n  if port.isdigit()and port.isascii():\n   nport=int(port)\n  else:\n   nport=None\n  return host,nport\n return host,defport\n \n \ndef splitquery(url):\n warnings.warn(\"urllib.parse.splitquery() is deprecated as of 3.8, \"\n \"use urllib.parse.urlparse() instead\",\n DeprecationWarning,stacklevel=2)\n return _splitquery(url)\n \n \ndef _splitquery(url):\n ''\n path,delim,query=url.rpartition('?')\n if delim:\n  return path,query\n return url,None\n \n \ndef splittag(url):\n warnings.warn(\"urllib.parse.splittag() is deprecated as of 3.8, \"\n \"use urllib.parse.urlparse() instead\",\n DeprecationWarning,stacklevel=2)\n return _splittag(url)\n \n \ndef _splittag(url):\n ''\n path,delim,tag=url.rpartition('#')\n if delim:\n  return path,tag\n return url,None\n \n \ndef splitattr(url):\n warnings.warn(\"urllib.parse.splitattr() is deprecated as of 3.8, \"\n \"use urllib.parse.urlparse() instead\",\n DeprecationWarning,stacklevel=2)\n return _splitattr(url)\n \n \ndef _splitattr(url):\n ''\n \n words=url.split(';')\n return words[0],words[1:]\n \n \ndef splitvalue(attr):\n warnings.warn(\"urllib.parse.splitvalue() is deprecated as of 3.8, \"\n \"use urllib.parse.parse_qsl() instead\",\n DeprecationWarning,stacklevel=2)\n return _splitvalue(attr)\n \n \ndef _splitvalue(attr):\n ''\n attr,delim,value=attr.partition('=')\n return attr,(value if delim else None)\n", ["collections", "functools", "ipaddress", "math", "re", "types", "unicodedata", "warnings"]], "urllib": [".py", "", [], 1]}
__BRYTHON__.update_VFS(scripts)
